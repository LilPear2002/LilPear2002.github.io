<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件测试基础功能测试小案例</title>
    <link href="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
    <url>/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>前台地址： <a href="https://hmshop-test.itheima.net/">https://hmshop-test.itheima.net/</a></p><p>后台地址： <a href="https://hmshop-test.itheima.net/admin">https://hmshop-test.itheima.net/admin</a></p><p>本次目标： 1. 核心业务：下单业务 2. 核心模块：选择商品、购物车、注册登录、下单、支付</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image1.png" class="" title="测试流程"><h1 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h1><p>首先熟悉需求-流程：选择商品-&gt;立即购买-&gt;登录成功-&gt;提交订单成功-&gt;支付成功</p><p>并对下单业务绘制流程图</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image2.png" class="" title="流程图"><p><strong>分析出测试点：</strong></p><ul><li><strong>下单成功</strong></li><li><strong>下单失败（购物车添加失败）</strong></li><li><strong>下单失败（登录失败）</strong></li><li><strong>下单失败（提交订单失败）</strong></li><li><strong>下单失败（支付失败）</strong></li></ul><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">order_001</td><td align="center">下单成功（购物车）</td><td align="center">下单业务</td><td align="center">P0</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息</td><td align="center">1、选择商品           2、添加购物车       3、登录成功           4、提交订单成功     5、支付</td><td align="center">商品：001        商品购买数量：1            支付方式：货到付款</td><td align="center">下单成功，订单状态为待发货。     商品001库存数量减少1</td><td align="center">不通过，原因：下单成功后库存数量未减少</td></tr><tr><td align="center">order_002</td><td align="center">下单失败（添加购物车失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品002已上架且库存0</td><td align="center">1、选择商品     2、添加购物车</td><td align="center">商品：002</td><td align="center">下单失败，添加购物车按钮置灰不可点。</td><td align="center">通过</td></tr><tr><td align="center">order_003</td><td align="center">下单失败（登录失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品003已上架且库存200</td><td align="center">1、选择商品     2、添加购物车     3、登录操作</td><td align="center">商品：003     商品购买数量：1     登录操作：不登录</td><td align="center">下单失败，跳转到登录页面。</td><td align="center">通过</td></tr><tr><td align="center">order_004</td><td align="center">下单失败（提交订单失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、未添加收货人信息</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单操作</td><td align="center">商品：001     商品购买数量：1     提交订单：未选择收货人信息</td><td align="center">下单失败，提示：请填写收货人信息</td><td align="center">不通过，原因：未选择收货人信息，下单成功。</td></tr><tr><td align="center">order_005</td><td align="center">下单失败（支付失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息     4、微信余额为0     5、商品001售价大于0</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单成功     5、支付</td><td align="center">商品：001     商品购买数量：1     支付方式：微信</td><td align="center">下单失败，提示：余额不足，请更换其他支付方式。</td><td align="center">不通过，原因：返回错误信息不友好（{“return_code”:”FAIL”,”return_msg”:”mch_id参数格式错误”}）</td></tr></tbody></table><p>为这三个bug写报告：</p><hr><h3 id="🐛-Bug-报告-1：严重的数据逻辑错误"><a href="#🐛-Bug-报告-1：严重的数据逻辑错误" class="headerlink" title="🐛 Bug 报告 1：严重的数据逻辑错误"></a>🐛 Bug 报告 1：严重的数据逻辑错误</h3><p>问题来源： 用例 order_001</p><p>缺陷类型： 数据一致性 (严重程度高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 用户下单支付成功后，后台商品库存数量未自动扣减</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (严重)</strong> - <em>涉及核心库存数据，会导致超卖，属于重大事故。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 库存管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001已上架，后台库存显示为 200。 2. 用户账号已注册并登录，且已添加收货地址。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入商品详情页，选择商品001，数量为 1。 2. 点击“加入购物车”并进入结算页。 3. 点击“提交订单”并完成支付（货到付款）。 4. 登录后台管理系统，查看商品001的剩余库存。</td></tr><tr><td><strong>预期结果</strong></td><td>前台提示下单成功；<strong>后台商品001的库存数量应减少1（变为199）。</strong></td></tr><tr><td><strong>实际结果</strong></td><td>前台提示下单成功；<strong>但后台商品001的库存数量仍显示为 200（未扣减）。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：校验逻辑缺失"><a href="#🐛-Bug-报告-2：校验逻辑缺失" class="headerlink" title="🐛 Bug 报告 2：校验逻辑缺失"></a>🐛 Bug 报告 2：校验逻辑缺失</h3><p>问题来源： 用例 order_004</p><p>缺陷类型： 功能逻辑错误 (严重程度中等偏高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 结算页未选择&#x2F;未填写收货人信息，仍能成功提交订单</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (重要)</strong> - <em>导致产生无效订单，后续无法发货。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 订单提交</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001库存充足。 2. 用户已注册账号，<strong>但账号下未添加任何收货人信息</strong>。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 登录该无收货信息的账号。 2. 将商品001加入购物车。 3. 进入结算页面（此时收货人信息栏为空）。 4. 直接点击“提交订单”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td>订单提交失败，页面应弹出提示框：<strong>“请填写收货人信息”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行拦截，直接提示“下单成功”，生成了无地址的异常订单。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露"><a href="#🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露" class="headerlink" title="🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)"></a>🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)</h3><p>问题来源： 用例 order_005</p><p>缺陷类型： 用户体验 (UI&#x2F;UX)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 余额不足导致支付失败时，页面直接展示原始代码报错信息</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S3 (一般)</strong> - <em>功能逻辑是正确的（拦截了），但体验很差。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P2 (中)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 支付接口</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已下单待支付。 2. 选择“微信支付”，且模拟微信余额为 0。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 在支付页面选择“微信支付”。 2. 点击“确认支付”。 3. 观察页面返回的错误提示。</td></tr><tr><td><strong>预期结果</strong></td><td>页面应弹出友好提示：<strong>“余额不足，请更换其他支付方式”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td>页面弹窗显示后端原始 JSON 代码：<code>&#123;“return_code”:“FAIL”, “return_msg”:“mch_id参数格式错误”&#125;</code>，用户无法理解。</td></tr></tbody></table><hr><h1 id="单模块测试"><a href="#单模块测试" class="headerlink" title="单模块测试"></a>单模块测试</h1><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image3.png" class="" title="登录功能"><table><thead><tr><th align="center"><strong>输入项</strong></th><th align="center"><strong>有效等价类 (合法 - 预期成功)</strong></th><th align="center"><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td align="center">1.用户名</td><td align="center">手机号已注册</td><td align="center">用户名为空</td></tr><tr><td align="center"></td><td align="center">邮箱已注册</td><td align="center">格式错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">未注册</td></tr><tr><td align="center">2.密码</td><td align="center">密码正确</td><td align="center">密码为空</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">密码错误</td></tr><tr><td align="center">3.验证码</td><td align="center">完全匹配</td><td align="center">为空</td></tr><tr><td align="center"></td><td align="center">不限制大小写</td><td align="center">验证码错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">已失效或过期的验证码</td></tr></tbody></table><p>设计测试用例：</p><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">shop_login_001</td><td align="center">手机号登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册手机号 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.手机号：已注册的手机号 2.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_002</td><td align="center">邮箱登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册邮箱 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.验证码打乱大小写 4.点击登录</td><td align="center">1.邮箱：已注册的邮箱 2.验证码：大小写打乱 3.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_003</td><td align="center">用户名为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名为空 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名为空 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_004</td><td align="center">用户名格式错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名格式错误 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名格式错误 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号格式不匹配！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_005</td><td align="center">用户名未注册登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.未注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：未注册的用户名 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不存在！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_006</td><td align="center">密码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：错误密码 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_007</td><td align="center">密码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入验证码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：空 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_008</td><td align="center">验证码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：空</td><td align="center">登陆失败，弹窗提示：“验证码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_009</td><td align="center">验证码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：错误的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_0010</td><td align="center">验证码过期登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：过期的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr></tbody></table><hr><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image4.png" class="" title="购物车1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image5.png" class="" title="购物车2"><p>重点分析 <strong>“购物车添加商品数量”</strong> 和 <strong>“商品种类限制”</strong> 这两个核心规则。</p><h3 id="1-核心分析对象：商品数量-添加-修改"><a href="#1-核心分析对象：商品数量-添加-修改" class="headerlink" title="1. 核心分析对象：商品数量 (添加&#x2F;修改)"></a>1. 核心分析对象：商品数量 (添加&#x2F;修改)</h3><p>需求明确指出：</p><ul><li><strong>库存充足 (&gt;&#x3D;200) 时：</strong> 数量取值为 <code>[1, 200]</code>。</li><li><strong>库存不足 (&lt;200) 时：</strong> 数量取值为 <code>[1, 库存量]</code>。</li></ul><p>这意味着需要设计 <strong>两套</strong> 边界值方案。</p><h4 id="📊-分析表：商品数量输入框"><a href="#📊-分析表：商品数量输入框" class="headerlink" title="📊 分析表：商品数量输入框"></a>📊 分析表：商品数量输入框</h4><p>假设现在有一款商品 A。</p><table><thead><tr><th><strong>测试场景</strong></th><th><strong>前置条件 (环境)</strong></th><th><strong>有效等价类 (合法)</strong></th><th><strong>边界值 (BVA) - 重点！</strong></th><th><strong>无效等价类 (非法)</strong></th></tr></thead><tbody><tr><td><strong>场景 A：库存充足</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>500</strong></td><td>1 ~ 200 之间的整数</td><td><strong>上点 (有效):</strong> 1, 200 <strong>离点 (无效):</strong> 0, 201</td><td>1. 大于 200 的数 (如 201) 2. 小于 1 的数 (如 0, -1) 3. 非整数 (如 1.5) 4. 非数字 (如 abc)</td></tr><tr><td><strong>场景 B：库存紧张</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>5</strong></td><td>1 ~ 5 之间的整数</td><td><strong>上点 (有效):</strong> 1, 5 <strong>离点 (无效):</strong> 0, 6</td><td>1. 大于 5 的数 (如 6) 2. 小于 1 的数 (如 0) … (同上)</td></tr></tbody></table><h3 id="2-核心分析对象：商品种类限制"><a href="#2-核心分析对象：商品种类限制" class="headerlink" title="2. 核心分析对象：商品种类限制"></a>2. 核心分析对象：商品种类限制</h3><p>需求指出：“商品种类不能大于 20 种”。</p><p>(注意：是“种类”，不是“总数量”。买了 100 个苹果 + 1 个梨，这是 2 种)。</p><h4 id="📊-分析表：购物车种类上限"><a href="#📊-分析表：购物车种类上限" class="headerlink" title="📊 分析表：购物车种类上限"></a>📊 分析表：购物车种类上限</h4><table><thead><tr><th><strong>规则</strong></th><th><strong>有效等价类</strong></th><th><strong>边界值 (BVA)</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td><strong>种类 &lt;&#x3D; 20</strong></td><td>购物车内已有 1~19 种商品</td><td><strong>上点 (能加):</strong> 已有 19 种，再加第 20 种 -&gt; <strong>成功</strong> <strong>离点 (报错):</strong> 已有 20 种，再加第 21 种 -&gt; <strong>失败&#x2F;提示</strong></td><td>已有 20 种以上 (如数据库脏数据导致有25种)，再操作添加</td></tr></tbody></table><hr><h3 id="3-核心分析对象：修改方式-号与输入框"><a href="#3-核心分析对象：修改方式-号与输入框" class="headerlink" title="3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)"></a>3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)</h3><p>需求提到可以使用 <strong>【+】</strong> 和 <strong>【-】</strong> 调节，也可以 <strong>直接修改数字</strong>。</p><p>这里主要用 <strong>等价类划分</strong> 来覆盖交互逻辑：</p><table><thead><tr><th><strong>输入方式</strong></th><th><strong>正常类 (Happy Path)</strong></th><th><strong>异常类 (Exception)</strong></th></tr></thead><tbody><tr><td><strong>点击【+】号</strong></td><td>当前数量 &lt; 最大限制 (如库存或200)，点击后数量+1</td><td>当前数量 &#x3D; 最大限制，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (UI测试点)</td></tr><tr><td><strong>点击【-】号</strong></td><td>当前数量 &gt; 1，点击后数量-1</td><td>当前数量 &#x3D; 1，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (有些设计是弹出删除提示，需确认需求)</td></tr><tr><td><strong>直接输入框</strong></td><td>输入正常整数</td><td>输入 <strong>空格</strong>、<strong>中文</strong>、<strong>特殊符号</strong>、<strong>超长数字</strong>、<strong>负数</strong></td></tr></tbody></table><hr><h3 id="🛒-购物车功能测试用例"><a href="#🛒-购物车功能测试用例" class="headerlink" title="🛒 购物车功能测试用例"></a>🛒 购物车功能测试用例</h3><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>CART_001</strong></td><td><strong>添加商品-库存充足边界值 (Max)</strong></td><td><strong>P0</strong></td><td>1. 商品A库存为 <strong>500</strong> 2. 购物车无该商品</td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>200</strong></td><td>添加成功，购物车中显示商品A数量为 200</td></tr><tr><td><strong>CART_002</strong></td><td><strong>添加商品-超过最大购买限制</strong></td><td>P1</td><td>1. 商品A库存为 <strong>500</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>201</strong></td><td>添加失败，提示“最多只能购买200件”或自动变为200</td></tr><tr><td><strong>CART_003</strong></td><td><strong>添加商品-动态库存边界 (全部库存)</strong></td><td><strong>P0</strong></td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>5</strong></td><td>添加成功，购物车中显示商品B数量为 5</td></tr><tr><td><strong>CART_004</strong></td><td><strong>添加商品-超过动态库存</strong></td><td>P1</td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>6</strong></td><td>添加失败，提示“库存不足”或自动修正为5</td></tr><tr><td><strong>CART_005</strong></td><td><strong>修改数量-最小边界值 (Min)</strong></td><td>P1</td><td>1. 购物车中有 2 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td>数量变为 <strong>1</strong>，且【-】号按钮变灰或不可点击</td></tr><tr><td><strong>CART_006</strong></td><td><strong>修改数量-下限溢出保护</strong></td><td>P2</td><td>1. 购物车中有 1 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td><strong>数量保持为 1</strong> (或弹出删除确认框，视具体交互而定)，不能变为 0 或负数</td></tr><tr><td><strong>CART_007</strong></td><td><strong>直接输入非法字符</strong></td><td>P2</td><td>1. 购物车中有商品A</td><td>1. 点击数量输入框 2. 输入非法字符</td><td>数量: <code>abc</code> 或 <code>1.5</code></td><td>输入框不接受非法字符，或自动恢复为修改前的数字</td></tr><tr><td><strong>CART_008</strong></td><td><strong>商品种类上限-有效边界</strong></td><td>P1</td><td>1. 购物车已添加 <strong>19</strong> 种不同商品</td><td>1. 去添加第 <strong>20</strong> 种新商品</td><td>商品T (新种类)</td><td>添加成功，购物车内显示 20 种商品</td></tr><tr><td><strong>CART_009</strong></td><td><strong>商品种类上限-无效边界</strong></td><td>P2</td><td>1. 购物车已添加 <strong>20</strong> 种不同商品</td><td>1. 去添加第 <strong>21</strong> 种新商品</td><td>商品U (新种类)</td><td>添加失败，提示“购物车商品种类已达上限(20种)”</td></tr><tr><td><strong>CART_010</strong></td><td><strong>删除功能-批量删除</strong></td><td>P1</td><td>1. 购物车有商品A, B, C</td><td>1. 勾选商品A和B 2. 点击【删除选中商品】</td><td>&#x2F;</td><td>商品A和B消失，商品C保留，总价自动重新计算</td></tr><tr><td><strong>CART_011</strong></td><td><strong>空状态显示 (已登录)</strong></td><td>P2</td><td>1. 用户已登录 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车空空的哦<del>，去看看心仪的商品吧</del>”</td></tr><tr><td><strong>CART_012</strong></td><td><strong>空状态显示 (未登录)</strong></td><td>P2</td><td>1. 用户<strong>未登录</strong> 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车内暂时没有商品，登录后将显示您之前加入的商品”</td></tr></tbody></table><hr><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image6.png" class="" title="支付1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image7.png" class="" title="支付2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>PAY_001</strong></td><td><strong>最小金额支付 (边界值)</strong></td><td><strong>P0</strong></td><td>订单金额为 <strong>0.01</strong> 元</td><td>选择支付方式，点击确认支付</td><td>金额: 0.01</td><td>成功发起支付，跳转第三方或显示支付成功</td></tr><tr><td><strong>PAY_002</strong></td><td><strong>零金额支付限制 (边界值)</strong></td><td>P1</td><td>订单金额为 <strong>0.00</strong> 元 (需后台造数据)</td><td>尝试点击确认支付</td><td>金额: 0.00</td><td><strong>支付按钮置灰</strong> 或 提示“支付金额不能为0”</td></tr><tr><td><strong>PAY_003</strong></td><td><strong>支付倒计时有效性</strong></td><td>P1</td><td>订单已生成 <strong>29分50秒</strong></td><td>等待至 30分01秒，刷新页面或点击支付</td><td>&#x2F;</td><td>提示“订单已超时&#x2F;已关闭”，无法继续支付</td></tr><tr><td><strong>PAY_004</strong></td><td><strong>支付方式互斥性 (UI)</strong></td><td>P2</td><td>&#x2F;</td><td>1. 默认“货到付款”被选中 2. 点击“支付宝”</td><td>&#x2F;</td><td>“货到付款”自动取消选中，“支付宝”变为选中状态</td></tr><tr><td><strong>PAY_005</strong></td><td><strong>余额不足支付失败</strong></td><td>P1</td><td>选择微信支付</td><td>1. 扫码 2. 使用余额为0的微信账号支付</td><td>&#x2F;</td><td>微信端提示余额不足，商城页面保持在“待支付”状态</td></tr><tr><td><strong>PAY_006</strong></td><td><strong>重复支付拦截 (幂等性)</strong></td><td><strong>P0</strong></td><td>订单已在另一个窗口支付成功</td><td>1. 在当前窗口（旧状态）再次点击“支付”</td><td>&#x2F;</td><td>系统拦截，提示“该订单已支付”，并自动刷新状态为已支付</td></tr><tr><td><strong>PAY_007</strong></td><td><strong>支付时价格变动 (高风险)</strong></td><td><strong>P1</strong></td><td>1. 下单时商品 100元 2. <strong>后台将商品改价为 200元</strong></td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td><strong>页面刷新显示最新价格 200元</strong>，并提示“商品价格已变动，请重新确认”</td></tr><tr><td><strong>PAY_008</strong></td><td><strong>密码错误重试</strong></td><td>P2</td><td>选择银行卡支付</td><td>1. 输错密码 2. 再次输入正确密码</td><td>&#x2F;</td><td>第一次提示错误，第二次支付成功</td></tr><tr><td><strong>PAY_009</strong></td><td><strong>合并支付</strong></td><td>P2</td><td>购物车有商品A和商品B</td><td>1. 勾选A和B 2. 提交订单并支付</td><td>&#x2F;</td><td>支付金额为 A+B 的总和，支付一次即可</td></tr></tbody></table><p>太棒了！我们就挑选支付模块中**“含金量”最高**（也是面试官最爱听）的两个场景来写 Bug 报告。</p><p>这两个 Bug 分别对应了 <strong>严重的功能逻辑漏洞（让公司亏钱）</strong> 和 <strong>边界值校验缺失</strong>。</p><p>请按照下面的格式，直接把这两个单子录入到你的缺陷管理系统里。</p><hr><h3 id="🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）"><a href="#🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）" class="headerlink" title="🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）"></a>🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）</h3><p>这个 Bug 非常经典，直接违反了需求文档中“支付时刻会获取当前订单的最新价格进行显示支付” 这一条风控规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单生成后后台修改商品价格，前台支付时未同步最新价格，导致用户可低价购买</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (致命)</strong> - <em>直接导致资金损失，属于核心业务逻辑错误。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心 &#x2F; 订单管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已登录，且购物车中有商品A（单价 100元）。 2. 拥有后台管理系统权限的账号已登录。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户在前台提交包含商品A的订单，订单金额显示 100元，状态为“待支付”。 2. <strong>(关键步骤)</strong> 管理员在后台将商品A的单价修改为 <strong>200元</strong>。 3. 用户在支付页面（不刷新）或订单列表点击“去支付”。 4. 观察支付网关显示的应付金额。</td></tr><tr><td><strong>预期结果</strong></td><td>系统应拦截旧价格支付，提示**“商品价格已变动，请重新确认”**，并刷新支付金额为 <strong>200元</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行价格二次校验，支付网关仍显示应付金额 100元，用户成功以旧价格完成支付。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：零金额支付漏洞（边界值校验）"><a href="#🐛-Bug-报告-2：零金额支付漏洞（边界值校验）" class="headerlink" title="🐛 Bug 报告 2：零金额支付漏洞（边界值校验）"></a>🐛 Bug 报告 2：零金额支付漏洞（边界值校验）</h3><p>这个 Bug 对应需求文档中“待支付的订单金额为0.00时，无法进行确认支付” 这一条规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单金额为 0.00 元时，未限制“确认支付”操作，可直接发起支付</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (严重)</strong> - <em>虽然不涉及亏钱，但违反了明确的业务规则，可能导致下游财务系统账单异常。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 后台创建一个价格为 0.00 元的测试商品（或使用优惠券抵扣至0元）。 2. 用户下单该商品，生成金额为 0.00 的待支付订单。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入该订单的支付页面。 2. 保持默认支付方式（如货到付款或在线支付）。 3. 点击“确认支付”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td><strong>“确认支付”按钮应置灰不可点击</strong>，或点击后弹出提示“订单金额为0，无法进行支付”。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>按钮可点击，系统提示“支付成功”或跳转到了第三方支付页面（报错参数错误），未能正确拦截。</strong></td></tr></tbody></table><hr><h3 id="💡-为什么选这两个写报告？"><a href="#💡-为什么选这两个写报告？" class="headerlink" title="💡 为什么选这两个写报告？"></a>💡 为什么选这两个写报告？</h3><p>问：“在项目中发现过什么印象深刻的 Bug？”</p><blockquote><p>“我在测试支付模块时，发现了一个 <strong>数据一致性</strong> 的严重 Bug。需求要求支付时必须获取最新价格，但我模拟了‘下单后后台改价’的场景，发现前端传给支付接口的还是旧价格。这会导致用户能‘薅羊毛’，造成公司资损。后来我提了 P0 级的 Bug，开发加了支付前的二次校验逻辑才修复。”</p></blockquote><hr><h1 id="非功能性测试"><a href="#非功能性测试" class="headerlink" title="非功能性测试"></a>非功能性测试</h1><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目&#x2F;模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>tpshop_not_function_001</td><td>项目所有功能显示和操作正常（谷歌）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新谷歌浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_002</td><td>项目所有功能显示和操作正常（火狐）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新火狐浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_003</td><td>项目所有功能显示和操作正常（Edge）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新Edge浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_004</td><td>项目所有功能显示和操作正常（苹果）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新苹果浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_005</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr><tr><td>tpshop_not_function_006</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_PERF_001</strong></td><td><strong>提交订单接口响应时间测试</strong></td><td><strong>P1</strong></td><td>1. 模拟 50 个用户并发在线 2. 数据库中有充足库存</td><td>1. 使用 JMeter 或 LoadRunner 模拟并发点击“提交订单”</td><td>并发数: 50</td><td>1. 平均响应时间 &lt; <strong>3秒</strong> 2. 成功率 100% 3. 服务器 CPU&#x2F;内存占用率 &lt; 80%</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_SEC_001</strong></td><td><strong>商品搜索框 SQL 注入漏洞测试</strong></td><td><strong>P0</strong></td><td>打开商城首页</td><td>1. 在搜索框输入 SQL 注入脚本 2. 点击搜索</td><td><code>&#39; OR 1=1 --</code></td><td>系统拦截特殊字符或提示“未找到商品”，<strong>严禁</strong> 显示数据库报错信息或列出所有商品数据</td></tr><tr><td><strong>NON_FUNC_SEC_002</strong></td><td><strong>XSS 跨站脚本攻击 (评论区)</strong></td><td>P1</td><td>用户已登录</td><td>1. 在商品评价输入框填入 JS 脚本 2. 提交评价 3. 换个账号查看该评价</td><td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td><td>脚本被转义显示为普通文本，<strong>不会</strong> 弹出浏览器弹窗 (Alert)</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_NET_001</strong></td><td><strong>弱网环境支付测试 (丢包&#x2F;延迟)</strong></td><td>P2</td><td>1. 使用 Fiddler&#x2F;Charles 开启弱网模拟 (上行 2kb&#x2F;s) 2. 处于支付确认页</td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td>1. 页面出现 Loading 动画，而不是假死 2. 若超时，提示“网络不给力，请重试” 3. <strong>不会</strong> 出现崩溃或白屏</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试基础</tag>
      
      <tag>功能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Playwright学习</title>
    <link href="/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><p>在 Playwright 中，定位元素主要分为<strong>两派</strong>：</p><ol><li><strong>传统派（兼容 Selenium 思维）</strong>：使用 CSS 和 XPath。</li><li><strong>新潮派（官方推荐）</strong>：使用“用户看到什么就找什么”的方式。</li></ol><hr><h3 id="第一步：传统派-——-page-locator"><a href="#第一步：传统派-——-page-locator" class="headerlink" title="第一步：传统派 —— page.locator()"></a>第一步：传统派 —— <code>page.locator()</code></h3><p>在 Playwright 里，不需要像 Selenium 那样记 By.ID, By.XPATH, By.CSS_SELECTOR 这么多分类。</p><p>你只需要记住一个万能方法：page.locator(“写在这里”)。</p><p>它会自动识别你写的是 CSS 还是 XPath。</p><h4 id="1-ID-定位"><a href="#1-ID-定位" class="headerlink" title="1. ID 定位"></a>1. ID 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.ID, &quot;kw&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>#</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Class-定位"><a href="#2-Class-定位" class="headerlink" title="2. Class 定位"></a>2. Class 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CLASS_NAME, &quot;s_ipt&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>.</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;.s_ipt&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-XPath-定位"><a href="#3-XPath-定位" class="headerlink" title="3. XPath 定位"></a>3. XPath 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.XPATH, &quot;//input[@id=&#39;kw&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>: 直接写 XPath 字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-CSS-选择器-最常用"><a href="#4-CSS-选择器-最常用" class="headerlink" title="4. CSS 选择器 (最常用)"></a>4. CSS 选择器 (最常用)</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CSS_SELECTOR, &quot;input[name=&#39;wd&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;input[name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>🟢 总结：</strong> 只要会写 CSS 或 XPath，直接往 <code>page.locator()</code> 里塞就行了，不需要指定类型。</p></blockquote><hr><h3 id="第二步：新潮派-——-官方推荐的“语义化定位”"><a href="#第二步：新潮派-——-官方推荐的“语义化定位”" class="headerlink" title="第二步：新潮派 —— 官方推荐的“语义化定位”"></a>第二步：新潮派 —— 官方推荐的“语义化定位”</h3><p>Playwright 认为：CSS 和 XPath 是给程序员看的，不是给用户看的。</p><p>如果程序员改了代码（比如把 id&#x3D;”submit-btn” 改成了 id&#x3D;”login-btn”），CSS 定位就挂了。但**按钮上的文字“登录”**通常不会变。</p><p>所以，Playwright 推出了一套<strong>根据页面内容</strong>定位的方法。</p><h4 id="1-找文字-——-get-by-text"><a href="#1-找文字-——-get-by-text" class="headerlink" title="1. 找文字 —— get_by_text()"></a>1. 找文字 —— <code>get_by_text()</code></h4><p>对应 Selenium 的 <code>By.LINK_TEXT</code> 或 XPath 的 <code>text()=</code>。</p><ul><li><p><strong>场景</strong>：页面上有个 <code>&lt;span&gt;欢迎回来&lt;/span&gt;</code> 或 <code>&lt;a&gt;新闻&lt;/a&gt;</code>。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模糊匹配（包含即可）</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎&quot;</span>) <br><br><span class="hljs-comment"># 精确匹配</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎回来&quot;</span>, exact=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-找表单输入框-——-get-by-placeholder"><a href="#2-找表单输入框-——-get-by-placeholder" class="headerlink" title="2. 找表单输入框 —— get_by_placeholder()"></a>2. 找表单输入框 —— <code>get_by_placeholder()</code></h4><ul><li><p><strong>场景</strong>：输入框里灰色的提示字（Placeholder）。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要输入框里写着 &quot;请输入密码&quot;，就能找到</span><br>page.get_by_placeholder(<span class="hljs-string">&quot;请输入密码&quot;</span>).fill(<span class="hljs-string">&quot;123456&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-找角色（按钮-链接-标题）——-get-by-role-最核心"><a href="#3-找角色（按钮-链接-标题）——-get-by-role-最核心" class="headerlink" title="3. 找角色（按钮&#x2F;链接&#x2F;标题）—— get_by_role() (最核心)"></a>3. 找角色（按钮&#x2F;链接&#x2F;标题）—— <code>get_by_role()</code> <strong>(最核心)</strong></h4><p>这是 Playwright 最强大的地方，它通过 HTML 的<strong>语义</strong>来找。</p><ul><li><p><strong>找按钮</strong> (<code>&lt;button&gt;</code> 或 <code>input type=&quot;submit&quot;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;登录&quot; 的按钮</span><br>page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;登录&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找链接</strong> (<code>&lt;a&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;首页&quot; 的链接</span><br>page.get_by_role(<span class="hljs-string">&quot;link&quot;</span>, name=<span class="hljs-string">&quot;首页&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找标题</strong> (<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找内容是 &quot;用户注册&quot; 的一级标题</span><br>page.get_by_role(<span class="hljs-string">&quot;heading&quot;</span>, name=<span class="hljs-string">&quot;用户注册&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="第三步：实战练习（通过高亮来验证）"><a href="#第三步：实战练习（通过高亮来验证）" class="headerlink" title="第三步：实战练习（通过高亮来验证）"></a>第三步：实战练习（通过高亮来验证）</h3><p>为了让你直观地看到定位对不对，我们不执行点击，而是用 <strong><code>.highlight()</code></strong> 方法。这会在浏览器里给元素画个红框，非常适合学习！</p><p>我们以 <strong>百度 (baidu.com)</strong> 为例。</p><p>请新建一个 <code>demo_locator.py</code>，把下面的代码复制进去运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># --- 练习 1: 使用 CSS ID 定位搜索框 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在高亮搜索框 (CSS ID)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.ID &quot;kw&quot;</span><br>    page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿 2 秒让你看清楚红框</span><br><br>    <span class="hljs-comment"># --- 练习 2: 使用 XPath 定位“百度一下”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2. 正在高亮按钮 (XPath)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.XPATH</span><br>    page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;su&#x27;]&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 3: 使用新潮的 get_by_text 定位右上角的“新闻” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3. 正在高亮链接 (Text)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.LINK_TEXT &quot;新闻&quot;</span><br>    page.get_by_text(<span class="hljs-string">&quot;新闻&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 4: 使用新潮的 get_by_role 定位“百度一下”按钮 ---</span><br>    <span class="hljs-comment"># 注意：百度的按钮有时候识别有点怪，这里作为进阶尝试</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;4. 尝试用 Role 定位按钮...&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;百度一下&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h1><p>Playwright 的操作逻辑更简洁，而且解决了一个 Selenium 的大痛点：<strong>它会自动等待元素准备好</strong>。</p><hr><h3 id="1-导航操作-Browser-Actions"><a href="#1-导航操作-Browser-Actions" class="headerlink" title="1. 导航操作 (Browser Actions)"></a>1. 导航操作 (Browser Actions)</h3><p>Playwright 的导航方法和 Selenium 非常像，只是名字稍微变了一点点。</p><table><thead><tr><th><strong>操作</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>打开网页</td><td><code>driver.get(url)</code></td><td><code>page.goto(url)</code></td><td>Playwright 默认会等待页面加载完成(load状态)</td></tr><tr><td>后退</td><td><code>driver.back()</code></td><td><code>page.go_back()</code></td><td>-</td></tr><tr><td>前进</td><td><code>driver.forward()</code></td><td><code>page.go_forward()</code></td><td>-</td></tr><tr><td>刷新</td><td><code>driver.refresh()</code></td><td><code>page.reload()</code></td><td>-</td></tr><tr><td>获取标题</td><td><code>driver.title</code> (属性)</td><td><code>page.title()</code> (方法)</td><td>注意 Playwright 是方法，要加括号 <code>()</code></td></tr><tr><td>获取URL</td><td><code>driver.current_url</code></td><td><code>page.url</code> (属性)</td><td>这个是属性，<strong>不加</strong>括号</td></tr></tbody></table><hr><h3 id="2-元素核心操作-Interaction"><a href="#2-元素核心操作-Interaction" class="headerlink" title="2. 元素核心操作 (Interaction)"></a>2. 元素核心操作 (Interaction)</h3><p>这是自动化测试最高频的操作：输入和点击。</p><h4 id="A-输入框：fill-vs-send-keys"><a href="#A-输入框：fill-vs-send-keys" class="headerlink" title="A. 输入框：fill vs send_keys"></a>A. 输入框：<code>fill</code> vs <code>send_keys</code></h4><ul><li><p>Selenium:</p><p>你需要先 clear() 清空，再 send_keys()。</p></li><li><p>Playwright:</p><p>只有一个神器 fill(“内容”)。它会自动先清空输入框，再输入内容。一步到位。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Selenium</span><br>ele.clear()<br>ele.send_keys(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (推荐)</span><br>page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (如果你想模拟逐个按键，比如测试搜索联想)</span><br>page.locator(<span class="hljs-string">&quot;#search&quot;</span>).press_sequentially(<span class="hljs-string">&quot;test&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h4 id="B-点击：click"><a href="#B-点击：click" class="headerlink" title="B. 点击：click"></a>B. 点击：<code>click</code></h4><ul><li><p>Playwright: page.locator(“…”).click()。</p><p>最大优势：它自带智能等待。它会检查元素是否可见、是否停止移动、是否被遮挡。如果被遮挡，它会等待遮挡物消失再点。</p></li></ul><hr><h3 id="3-获取元素信息-Get-Info"><a href="#3-获取元素信息-Get-Info" class="headerlink" title="3. 获取元素信息 (Get Info)"></a>3. 获取元素信息 (Get Info)</h3><p>用于做断言（Assert），验证测试结果。</p><table><thead><tr><th><strong>获取内容</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>获取文本</strong></td><td><code>ele.text</code></td><td><code>locator.inner_text()</code> (可见文本) <code>locator.text_content()</code> (包含隐藏文本)</td></tr><tr><td><strong>获取属性</strong></td><td><code>ele.get_attribute(&quot;type&quot;)</code></td><td><code>locator.get_attribute(&quot;type&quot;)</code></td></tr><tr><td><strong>是否可见</strong></td><td><code>ele.is_displayed()</code></td><td><code>locator.is_visible()</code></td></tr><tr><td><strong>是否可用</strong></td><td><code>ele.is_enabled()</code></td><td><code>locator.is_enabled()</code></td></tr></tbody></table><hr><h3 id="💻-实战演练"><a href="#💻-实战演练" class="headerlink" title="💻 实战演练"></a>💻 实战演练</h3><p>场景：网站 the-internet.herokuapp.com。</p><ol><li>打开登录页。</li><li>输入用户名和密码（使用 <code>fill</code>）。</li><li>点击登录。</li><li>获取提示文字（使用 <code>inner_text</code>）。</li><li>刷新页面。</li></ol><p>新建文件 <code>demo_action.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">1000</span>) <span class="hljs-comment"># slow_mo 让你看清操作</span><br>    page = browser.new_page()<br><br>    <span class="hljs-comment"># 2. 导航</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在打开网页...&quot;</span>)<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span>)<br>    <br>    <span class="hljs-comment"># 打印当前标题</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 3. 元素操作：输入 (使用 fill，自动清空 + 输入)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在输入账号密码...&quot;</span>)<br>    <span class="hljs-comment"># 这里演示用 CSS 选择器定位</span><br>    page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br>    page.locator(<span class="hljs-string">&quot;#password&quot;</span>).fill(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br>    <span class="hljs-comment"># 4. 元素操作：点击</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 点击登录按钮...&quot;</span>)<br>    <span class="hljs-comment"># 使用语义化定位：找一个 type=&quot;submit&quot; 的按钮 (或者用 class=&quot;radius&quot;)</span><br>    page.locator(<span class="hljs-string">&quot;button[type=&#x27;submit&#x27;]&quot;</span>).click()<br><br>    <span class="hljs-comment"># 5. 获取信息：断言</span><br>    <span class="hljs-comment"># 登录成功后会出现一个 id=&quot;flash&quot; 的提示条</span><br>    flash_message = page.locator(<span class="hljs-string">&quot;#flash&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 获取到的提示信息: \n<span class="hljs-subst">&#123;flash_message&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 简单断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> flash_message:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 测试通过：登录成功！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 测试失败&quot;</span>)<br><br>    <span class="hljs-comment"># 6. 额外操作：刷新</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 刷新页面...&quot;</span>)<br>    page.reload()<br><br>    <span class="hljs-comment"># 截图留念 (Selenium 是 get_screenshot_as_file)</span><br>    page.screenshot(path=<span class="hljs-string">&quot;login_result.png&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已截图保存为 login_result.png&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h1><p>这部分是 Playwright 对比 Selenium <strong>最爽</strong>的改进之一！🤯</p><p>在你的 Selenium 笔记中，处理新窗口（Tab）非常痛苦：</p><ol><li>先获取 <code>window_handles</code>（一堆看不懂的字符串 ID）。</li><li>必须写个循环判断哪个是新窗口。</li><li><strong>核心痛点</strong>：Driver 是“单线程”的，必须 <code>switch_to</code> 过去才能操作新窗口，操作完还得 <code>switch_to</code> 回来。一旦忘了切回来，代码立马报错。</li></ol><h3 id="Playwright-的逻辑：多线操作"><a href="#Playwright-的逻辑：多线操作" class="headerlink" title="Playwright 的逻辑：多线操作"></a>Playwright 的逻辑：多线操作</h3><p>Playwright 不需要切换句柄（Switch）。</p><p>它把每一个标签页都看作一个独立的对象 (Page Object)。</p><ul><li>主窗口是 <code>page1</code>。</li><li>新窗口是 <code>page2</code>。</li><li>手里拿着两个遥控器，<strong>同时</strong>控制两个窗口，完全不需要切来切去！</li></ul><hr><h3 id="1-捕获新窗口"><a href="#1-捕获新窗口" class="headerlink" title="1. 捕获新窗口"></a>1. 捕获新窗口</h3><p>在 Selenium 里是“点击 -&gt; 然后找窗口”。</p><p>在 Playwright 里是“设置陷阱 (监听器) -&gt; 点击 -&gt; 捕获窗口”。</p><p>我们使用 Python 的 <code>with</code> 语法来捕获弹出的新页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置监听器：当有新页面弹出(popup)时，把信息存到 popup_info 里</span><br><span class="hljs-keyword">with</span> page.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>    page.get_by_text(<span class="hljs-string">&quot;打开新窗口&quot;</span>).click()<br><br><span class="hljs-comment"># 拿到新窗口对象，命名为 page2</span><br>page2 = popup_info.value<br></code></pre></td></tr></table></figure><p>现在，<code>page</code> 变量控制老窗口，<code>page2</code> 变量控制新窗口。就这么简单。</p><hr><h3 id="💻-实战演示"><a href="#💻-实战演示" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h3><p>我们继续使用你笔记里的 <strong>The Internet</strong> 靶场 进行演示。</p><p>新建文件 <code>demo_window.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    context = browser.new_context()<br>    <br>    <span class="hljs-comment"># page1 代表主窗口 (老家)</span><br>    page1 = context.new_page()<br>    page1.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;page1.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：点击链接并捕获新窗口 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 准备点击链接...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 语法含义：在这个代码块执行期间，如果弹出了新窗口，就抓给我！</span><br>    <span class="hljs-keyword">with</span> page1.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>        page1.get_by_text(<span class="hljs-string">&quot;Click Here&quot;</span>).click()<br>    <br>    <span class="hljs-comment"># 获取新窗口对象，这才是我们要操作的新页面</span><br>    page2 = popup_info.value<br>    <br>    <span class="hljs-comment"># 等待新页面加载完成 (Playwright 自动处理，但显式等一下更稳)</span><br>    page2.wait_for_load_state()<br><br>    <span class="hljs-comment"># --- 3. 同时操作两个窗口 (无需 Switch!) ---</span><br>    <br>    <span class="hljs-comment"># 操作新窗口</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口标题: <span class="hljs-subst">&#123;page2.title()&#125;</span>&quot;</span>)<br>    heading_text = page2.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口内容: <span class="hljs-subst">&#123;heading_text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 操作老窗口 (直接用 page1 即可，完全不用切回去)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回去操作老窗口 (没切句柄哦)...&quot;</span>)<br>    original_heading = page1.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;老窗口内容: <span class="hljs-subst">&#123;original_heading&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 4. 关闭 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭新窗口&quot;</span>)<br>    page2.close()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭主窗口&quot;</span>)<br>    page1.close()<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="2-Iframe"><a href="#2-Iframe" class="headerlink" title="2. Iframe"></a>2. Iframe</h3><p>你笔记里也提到了 <strong>Iframe</strong> 的痛点：需要 <code>switch_to.frame()</code> 进去，操作完必须 <code>switch_to.default_content()</code> 出来。</p><p>Playwright 同样不需要切进切出！它引入了一个 frame_locator 的概念。</p><p>你就把它当成是“路径”的一部分，一层层点下去就行。</p><p><strong>语法对比：</strong></p><ul><li><p><strong>Selenium (切进切出):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;frame_id&quot;</span>)<br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br>driver.switch_to.default_content() <span class="hljs-comment"># 必须记得出来！</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Playwright (直接钻取):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 意思是：找到 id 为 frame_id 的框，再在里面找 id 为 btn 的按钮，点击。</span><br>page.frame_locator(<span class="hljs-string">&quot;#frame_id&quot;</span>).locator(<span class="hljs-string">&quot;#btn&quot;</span>).click()<br></code></pre></td></tr></table></figure><p><em>它只是定位链条变长了，不需要改变上下文状态。</em></p></li></ul><hr><h1 id="等待机制"><a href="#等待机制" class="headerlink" title="等待机制"></a>等待机制</h1><p>这是 Playwright 对比 Selenium <strong>降维打击</strong>最狠的地方。</p><hr><h3 id="1-强制等待-Forced-Wait"><a href="#1-强制等待-Forced-Wait" class="headerlink" title="1. 强制等待 (Forced Wait)"></a>1. 强制等待 (Forced Wait)</h3><ul><li><strong>Selenium</strong>: <code>time.sleep(3)</code> (单位：秒)</li><li><strong>Playwright</strong>: <code>page.wait_for_timeout(3000)</code> (单位：<strong>毫秒</strong>)<ul><li><strong>注意</strong>: 和 Selenium 一样，官方<strong>强烈不推荐</strong>在生产代码里用。它只适合在调试时想让浏览器停下看一眼。</li></ul></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait"><a href="#2-隐式等待-Implicit-Wait" class="headerlink" title="2. 隐式等待 (Implicit Wait)"></a>2. 隐式等待 (Implicit Wait)</h3><ul><li><strong>Selenium</strong>: <code>driver.implicitly_wait(10)</code><ul><li>设置一个全局查找超时时间。</li></ul></li><li><strong>Playwright</strong>: <strong>全局超时 (Global Timeout)</strong><ul><li>Playwright 默认就有 <strong>30秒</strong> 的超时时间。</li><li>不需要像 Selenium 那样手动写一行代码去开启它。</li><li>如果想改，可以用 <code>page.set_default_timeout(5000)</code>。</li></ul></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-核心区别！"><a href="#3-显式等待-Explicit-Wait-——-核心区别！" class="headerlink" title="3. 显式等待 (Explicit Wait) —— 核心区别！"></a>3. 显式等待 (Explicit Wait) —— 核心区别！</h3><p>这是重点。在 Selenium 里，必须手动写 <code>WebDriverWait</code> + <code>EC.element_to_be_clickable</code>。</p><p><strong>在 Playwright 中，显式等待融入到了每一个操作里。</strong></p><h4 id="A-动作自动等待-Auto-Wait-for-Actions"><a href="#A-动作自动等待-Auto-Wait-for-Actions" class="headerlink" title="A. 动作自动等待 (Auto-Wait for Actions)"></a>A. 动作自动等待 (Auto-Wait for Actions)</h4><p>当你执行 <code>.click()</code>, <code>.fill()</code>, <code>.check()</code> 等操作时，Playwright 会<strong>自动</strong>执行一系列检查（相当于内置了最严格的显式等待）：</p><ol><li><strong>Attached</strong>: 元素是否已经连接到 DOM？</li><li><strong>Visible</strong>: 元素是否可见（没有 <code>display: none</code>）？</li><li><strong>Stable</strong>: 元素是否停止了动画（位置不再飘移）？</li><li><strong>Receives Events</strong>: 元素是否被其他层（比如遮罩）挡住了？</li><li><strong>Enabled</strong>: 元素是否可用（没有 <code>disabled</code> 属性）？</li></ol><p><strong>结论：</strong> 再也不用写 <code>wait_until_clickable</code> 了。直接 <code>click()</code>，如果不满足条件，它自己会等。</p><h4 id="B-断言自动等待-Web-First-Assertions"><a href="#B-断言自动等待-Web-First-Assertions" class="headerlink" title="B. 断言自动等待 (Web-First Assertions)"></a>B. 断言自动等待 (Web-First Assertions)</h4><p>对应 Selenium 的 WebDriverWait(driver).until(EC.visibility_of(…))。</p><p>Playwright 使用 expect 断言库来实现智能等待。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这一行代码会自动重试（默认 5 秒），直到文字变成 &quot;Success&quot;</span><br><span class="hljs-comment"># 如果 5 秒后还不是这个字，才会报错</span><br>expect(page.locator(<span class="hljs-string">&quot;#status&quot;</span>)).to_have_text(<span class="hljs-string">&quot;Success&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚔️-实战：动态加载页面-VS-Selenium"><a href="#⚔️-实战：动态加载页面-VS-Selenium" class="headerlink" title="⚔️ 实战：动态加载页面 (VS Selenium)"></a>⚔️ 实战：动态加载页面 (VS Selenium)</h3><p>The Internet - Dynamic Loading。</p><p>场景：点击 “Start” 按钮，等 5 秒 loading 条消失，出现 “Hello World!”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    <br>    <span class="hljs-comment"># 1. 打开动态加载页面</span><br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 点击 Start</span><br>    <span class="hljs-comment"># Playwright 会自动等待按钮准备好再点</span><br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Start&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已点击 Start，正在等待 Hello World 出现...&quot;</span>)<br>    <br>    <span class="hljs-comment"># --- 核心对比 ---</span><br>    <br>    <span class="hljs-comment"># Selenium 需要写: </span><br>    <span class="hljs-comment"># WebDriverWait(driver, 10).until(EC.visibility_of_element_located(...))</span><br>    <br>    <span class="hljs-comment"># Playwright 只需要写断言:</span><br>    <span class="hljs-comment"># expect 会自动等待(默认5秒)直到元素可见。</span><br>    <span class="hljs-comment"># 注意：这个网页加载特别慢(超5秒)，我们可以单独给这一步加长超时时间</span><br>    target_text = page.get_by_text(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    expect(target_text).to_be_visible(timeout=<span class="hljs-number">10000</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 成功！文字出现了。&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_text.inner_text()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><h3 id="🧠-如果非要等呢？"><a href="#🧠-如果非要等呢？" class="headerlink" title="🧠 如果非要等呢？"></a>🧠 如果非要等呢？</h3><p>虽然 <code>expect</code> 和 <code>auto-wait</code> 覆盖了 99% 的场景，但有时候你就是想单纯地“等某个元素出现，但不操作它，也不断言它”。</p><p>Playwright 提供了类似 Selenium <code>EC</code> 的手动等待方法：</p><table><thead><tr><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><code>wait.until(EC.visibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;visible&quot;)</code></td></tr><tr><td><code>wait.until(EC.invisibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;hidden&quot;)</code></td></tr><tr><td><code>wait.until(EC.presence_of(...))</code></td><td><code>locator.wait_for(state=&quot;attached&quot;)</code></td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 等待 loading 条消失 (detached / hidden)</span><br>page.locator(<span class="hljs-string">&quot;#loading&quot;</span>).wait_for(state=<span class="hljs-string">&quot;hidden&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><p>下拉框被分为了“标准”和“非标准”两类。Playwright 对这两类的处理方式和 Selenium 逻辑一致，但在 API 上做到了<strong>极简</strong>。</p><hr><h3 id="第一类：标准下拉框-标签"><a href="#第一类：标准下拉框-标签" class="headerlink" title="第一类：标准下拉框 (&lt;select&gt; 标签)"></a>第一类：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>在 Selenium 中，必须引入 <code>Select</code> 类，实例化它，然后调用 <code>select_by_visible_text</code> 等方法。</p><p>Playwright 不需要引入额外的类。它直接在 locator 上提供了一个 select_option() 方法，把 Selenium 的三种选择方式合三为一了。</p><h4 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 通过 value 属性选 (对应 select_by_value)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(value=<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-comment"># 2. 通过可见文本选 (对应 select_by_visible_text) —— 最常用</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br><br><span class="hljs-comment"># 3. 通过索引选 (对应 select_by_index)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(index=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="💻-实战演示-1"><a href="#💻-实战演示-1" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h4><p><code>the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># 定位到 select 元素</span><br>    dropdown = page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方式 1: 通过 Label (文本) 选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 1 (by Label)...&quot;</span>)<br>    <span class="hljs-comment"># 这相当于 Selenium 的 select_by_visible_text(&quot;Option 1&quot;)</span><br>    dropdown.select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># --- 方式 2: 通过 Value 属性选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 2 (by Value)...&quot;</span>)<br>    <span class="hljs-comment"># HTML: &lt;option value=&quot;2&quot;&gt;Option 2&lt;/option&gt;</span><br>    dropdown.select_option(value=<span class="hljs-string">&quot;2&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># --- 验证结果 ---</span><br>    <span class="hljs-comment"># 怎么获取当前选中的值？</span><br>    <span class="hljs-comment"># 在 Playwright 中，直接看 value 属性即可</span><br>    current_value = dropdown.input_value()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中的 value 是: <span class="hljs-subst">&#123;current_value&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="第二类：非标准下拉框-Div-Ul-模拟"><a href="#第二类：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二类：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二类：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>这是现在前端框架（React, Vue）最喜欢的写法。它们看起来像下拉框，但 HTML 里根本没有 <code>&lt;select&gt;</code> 标签，全是一堆 <code>&lt;div&gt;</code> 和 <code>&lt;li&gt;</code>。</p><p>Playwright 的处理逻辑：把它当成普通的点击操作。</p><p>假设有一个用 Div 做的下拉框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 点击下拉框，让它展开</span><br>page.locator(<span class="hljs-string">&quot;#custom-dropdown-trigger&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 点击里面的选项</span><br><span class="hljs-comment"># Playwright 会自动等待 &quot;高级教程&quot; 这个选项出现在屏幕上再点击</span><br>page.get_by_text(<span class="hljs-string">&quot;高级教程&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="💡-模糊匹配选项"><a href="#💡-模糊匹配选项" class="headerlink" title="💡 模糊匹配选项"></a>💡 模糊匹配选项</h3><p>有时候下拉框里的字很长，或者有空格，比如 “ Option 1 “。</p><p>在 Selenium 里如果你用 select_by_visible_text，差一个空格都会报错。</p><p>在 Playwright 中，可以结合 <code>match</code> 参数（支持正则）或 <code>contains</code> 逻辑来选：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要包含 &quot;Option 1&quot; 就能选中，不用管有没有空格</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>) <br></code></pre></td></tr></table></figure><hr><h1 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h1><h3 id="核心区别：监听器-Event-Listener"><a href="#核心区别：监听器-Event-Listener" class="headerlink" title="核心区别：监听器 (Event Listener)"></a>核心区别：监听器 (Event Listener)</h3><ul><li><strong>Selenium</strong>: “出了事再处理”。（必须等弹窗出来，脚本才能去切换、操作）。</li><li><strong>Playwright</strong>: “先立好规矩”。（在点击按钮<strong>之前</strong>，先告诉浏览器：“待会儿如果有弹窗出来，你就帮我点确定”）。</li></ul><blockquote><p><strong>⚠️ 默认行为：</strong> 如果你不写任何监听代码，Playwright 会<strong>自动关闭 (Dismiss)</strong> 所有弹出的 Dialog，防止脚本卡死。这虽然安全，但如果你想测试“点击确定后的效果”，就必须手动设置监听器。</p></blockquote><hr><h3 id="1-怎么写监听器？"><a href="#1-怎么写监听器？" class="headerlink" title="1. 怎么写监听器？"></a>1. 怎么写监听器？</h3><p>需要使用 <strong><code>page.on(&quot;dialog&quot;, 处理函数)</code></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个处理函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_dialog</span>(<span class="hljs-params">dialog</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;弹窗内容: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>    dialog.accept() <span class="hljs-comment"># 点击确定</span><br><br><span class="hljs-comment"># 1. 先注册监听器 (埋伏好)</span><br>page.on(<span class="hljs-string">&quot;dialog&quot;</span>, handle_dialog)<br><br><span class="hljs-comment"># 2. 再触发弹窗 (踩雷)</span><br>page.get_by_text(<span class="hljs-string">&quot;点击弹出Alert&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="2-实战演练：Alert-Confirm-Prompt"><a href="#2-实战演练：Alert-Confirm-Prompt" class="headerlink" title="2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt"></a>2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt</h3><p>the-internet.herokuapp.com&#x2F;javascript_alerts。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>        browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>        page = browser.new_page()<br>        page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 1: Alert (只有确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 1. 测试 JS Alert&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这里的 lambda d: d.accept() 意思是：只要有弹窗，就点确定</span><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, <span class="hljs-keyword">lambda</span> d: d.accept()) <br>        <br>        <span class="hljs-comment"># 步骤 B: 点击按钮触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Alert&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证结果</span><br>        result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 应该是 You successfully clicked an alert</span><br><br>        <span class="hljs-comment"># --- 场景 2: Confirm (确定/取消) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 2. 测试 JS Confirm (点击取消)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这次我们定义稍微复杂点的逻辑：打印内容并点击取消</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_confirm</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到弹窗: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.dismiss() <span class="hljs-comment"># 点击取消 (Selenium 的 dismiss)</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_confirm)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Confirm&quot;</span>).click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;page.locator(<span class="hljs-string">&#x27;#result&#x27;</span>).inner_text()&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 3: Prompt (输入 + 确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 3. 测试 JS Prompt (输入内容)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 在 Playwright 中，accept() 可以直接传参数用来输入！</span><br>        <span class="hljs-comment"># Selenium 需要先 send_keys 再 accept，Playwright 合二为一了</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_prompt</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到 Prompt: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.accept(<span class="hljs-string">&quot;Playwright 练习生&quot;</span>) <span class="hljs-comment"># 输入并确定</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_prompt)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Prompt&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证</span><br>        final_result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终结果: <span class="hljs-subst">&#123;final_result&#125;</span>&quot;</span>)<br>        <br>        time.sleep(<span class="hljs-number">2</span>)<br>        browser.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run()<br></code></pre></td></tr></table></figure><h3 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3. 代码解析"></a>3. 代码解析</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>切换</strong></td><td><code>driver.switch_to.alert</code></td><td><code>page.on(&quot;dialog&quot;, handler)</code></td></tr><tr><td><strong>点确定</strong></td><td><code>alert.accept()</code></td><td><code>dialog.accept()</code></td></tr><tr><td><strong>点取消</strong></td><td><code>alert.dismiss()</code></td><td><code>dialog.dismiss()</code></td></tr><tr><td><strong>输入</strong></td><td><code>alert.send_keys(&quot;abc&quot;)</code></td><td><code>dialog.accept(&quot;abc&quot;)</code> <strong>(注意区别)</strong></td></tr><tr><td><strong>获取文字</strong></td><td><code>alert.text</code></td><td><code>dialog.message</code></td></tr></tbody></table><blockquote><ul><li><code>page.on</code>: <strong>永久</strong>监听。只要有弹窗，一直用这个逻辑处理。</li><li><code>page.once</code>: <strong>一次性</strong>监听。处理完这一个弹窗后，监听器就失效了。</li><li>在测试中，通常用 <code>once</code>，因为每个测试用例对弹窗的处理要求可能不一样（有的要点确定，有的要点取消）。</li></ul></blockquote><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><h3 id="1-鼠标操作-Mouse"><a href="#1-鼠标操作-Mouse" class="headerlink" title="1. 鼠标操作 (Mouse)"></a>1. 鼠标操作 (Mouse)</h3><p>不需要初始化 <code>ActionChains</code>，直接调用方法即可。</p><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium (ActionChains)</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>悬停 (Hover)</strong></td><td><code>.move_to_element(ele).perform()</code></td><td><strong><code>locator.hover()</code></strong></td></tr><tr><td><strong>双击</strong></td><td><code>.double_click(ele).perform()</code></td><td><strong><code>locator.dblclick()</code></strong></td></tr><tr><td><strong>右键</strong></td><td><code>.context_click(ele).perform()</code></td><td><strong><code>locator.click(button=&quot;right&quot;)</code></strong></td></tr><tr><td><strong>拖拽</strong></td><td><code>.drag_and_drop(src, dst).perform()</code></td><td><strong><code>page.drag_and_drop(src, dst)</code></strong></td></tr></tbody></table><h4 id="💻-实战-A：鼠标悬停-Baidu-Settings"><a href="#💻-实战-A：鼠标悬停-Baidu-Settings" class="headerlink" title="💻 实战 A：鼠标悬停 (Baidu Settings)"></a>💻 实战 A：鼠标悬停 (Baidu Settings)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 定位“设置”</span><br>    settings_btn = page.locator(<span class="hljs-string">&quot;#s-usersetting-top&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 鼠标悬停 (Selenium 需要 ActionChains，这里直接 hover)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在悬停鼠标...&quot;</span>)<br>    settings_btn.hover()<br>    <br>    <span class="hljs-comment"># 3. 悬停后，菜单浮现，点击“高级搜索”</span><br>    <span class="hljs-comment"># 注意：Playwright 会自动等待菜单变成可见状态再点击</span><br>    page.get_by_text(<span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已点击高级搜索&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><h4 id="💻-实战-B：拖拽-Drag-and-Drop"><a href="#💻-实战-B：拖拽-Drag-and-Drop" class="headerlink" title="💻 实战 B：拖拽 (Drag and Drop)"></a>💻 实战 B：拖拽 (Drag and Drop)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># page.drag_and_drop(源元素选择器, 目标元素选择器)</span><br>page.drag_and_drop(<span class="hljs-string">&quot;#column-a&quot;</span>, <span class="hljs-string">&quot;#column-b&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-键盘操作-Keyboard"><a href="#2-键盘操作-Keyboard" class="headerlink" title="2. 键盘操作 (Keyboard)"></a>2. 键盘操作 (Keyboard)</h3><p>在 Selenium 中，你需要 Keys 类 (Keys.ENTER, Keys.CONTROL)。Playwright 用字符串来表示按键，更加直观。</p><h4 id="核心方法：press-按键名"><a href="#核心方法：press-按键名" class="headerlink" title="核心方法：press(&quot;按键名&quot;)"></a>核心方法：<code>press(&quot;按键名&quot;)</code></h4><ul><li><strong>单键</strong>：<code>press(&quot;Enter&quot;)</code>, <code>press(&quot;ArrowDown&quot;)</code>, <code>press(&quot;Backspace&quot;)</code></li><li><strong>组合键</strong>：用 <code>+</code> 连接。<ul><li><code>press(&quot;Control+A&quot;)</code> (全选)</li><li><code>press(&quot;Control+C&quot;)</code> (复制)</li><li><code>press(&quot;Shift+ArrowLeft&quot;)</code> (选中左边文字)</li></ul></li></ul><h4 id="💻-实战-C：键盘组合键-Baidu-Search"><a href="#💻-实战-C：键盘组合键-Baidu-Search" class="headerlink" title="💻 实战 C：键盘组合键 (Baidu Search)"></a>💻 实战 C：键盘组合键 (Baidu Search)</h4><p><strong>百度搜索组合键</strong> 案例：输入 -&gt; 全选 -&gt; 剪切 -&gt; 粘贴 -&gt; 回车。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">500</span>) <span class="hljs-comment"># 慢放动作</span><br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    search_input = page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 输入内容</span><br>    search_input.fill(<span class="hljs-string">&quot;Playwright&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 模拟全选 (Ctrl+A / Mac上是 Meta+A)</span><br>    <span class="hljs-comment"># Playwright 智能之处：它知道你是什么系统，可以用 &quot;Control+A&quot; 通杀</span><br>    <span class="hljs-comment"># 或者显式写 &quot;Meta+A&quot; (Mac Command键)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 全选...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+A&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 模拟剪切 (Ctrl+X)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 剪切...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+X&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 模拟粘贴 (Ctrl+V)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 粘贴...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+V&quot;</span>)<br>    <br>    <span class="hljs-comment"># 5. 模拟回车 (Enter) 提交搜索</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回车搜索...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Enter&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证是否跳转</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="3-特殊：逐字输入-模拟人工打字"><a href="#3-特殊：逐字输入-模拟人工打字" class="headerlink" title="3. 特殊：逐字输入 (模拟人工打字)"></a>3. 特殊：逐字输入 (模拟人工打字)</h3><p>自动化测试有时候输入太快，触发不了页面上的联想搜索（Suggest）。</p><p>Playwright 提供了一个神器：press_sequentially (旧版本叫 type)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每个字符间隔 100 毫秒，模拟真人打字</span><br>page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).press_sequentially(<span class="hljs-string">&quot;Selenium&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这对应 Selenium 里 <strong>联想输入框</strong> 的难点。</p><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="1-标准上传"><a href="#1-标准上传" class="headerlink" title="1. 标准上传"></a>1. 标准上传</h3><p>如果页面上有一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签（哪怕它是隐藏的），可以直接把文件路径“填”进去。</p><ul><li><strong>Selenium</strong>: <code>ele.send_keys(&quot;路径&quot;)</code></li><li><strong>Playwright</strong>: <strong><code>locator.set_input_files(&quot;路径&quot;)</code></strong></li></ul><h4 id="💻-实战代码"><a href="#💻-实战代码" class="headerlink" title="💻 实战代码"></a>💻 实战代码</h4><p><code>the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 准备一个测试文件 (在当前目录下创建 test.txt)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;Hello Playwright Upload!&quot;</span>)<br><br><span class="hljs-comment"># 获取绝对路径 (和 Selenium 笔记里一样，推荐用绝对路径)</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 准备上传文件: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方法 1: 直接设置文件 (最稳) ---</span><br>    <span class="hljs-comment"># 找到 input 标签，直接塞入文件</span><br>    <span class="hljs-comment"># 注意：不要点击那个 &quot;Choose File&quot; 按钮，直接操作 input</span><br>    page.locator(<span class="hljs-string">&quot;#file-upload&quot;</span>).set_input_files(file_path)<br><br>    <span class="hljs-comment"># 点击上传按钮</span><br>    page.locator(<span class="hljs-string">&quot;#file-submit&quot;</span>).click()<br><br>    <span class="hljs-comment"># 断言结果</span><br>    expect(page.locator(<span class="hljs-string">&quot;#uploaded-files&quot;</span>)).to_have_text(<span class="hljs-string">&quot;test.txt&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 标准上传成功！&quot;</span>)<br><br>    page.wait_for_timeout(<span class="hljs-number">2000</span>)<br>    browser.close()<br><br><span class="hljs-comment"># 清理测试文件</span><br>os.remove(<span class="hljs-string">&quot;test.txt&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-高级上传-拦截文件选择器"><a href="#2-高级上传-拦截文件选择器" class="headerlink" title="2. 高级上传 (拦截文件选择器)"></a>2. 高级上传 (拦截文件选择器)</h3><p>这是 Playwright 的<strong>杀手锏</strong>。在 Selenium 中，如果必须点击按钮才能上传（比如 input 标签被复杂的 JS 逻辑移除了），你会遇到系统弹窗，Selenium 就束手无策了。Playwright 的逻辑：它不管系统弹窗（它是“无头”的思维），它拦截的是**“浏览器请求选择文件”**这个事件。</p><p><strong>步骤：</strong></p><ol><li>设置监听器：<code>expect_file_chooser()</code> (这就好比刚才学的监听弹窗 <code>expect_popup</code>)。</li><li>点击按钮：触发事件。</li><li>在拦截到的“选择器对象”中设置文件。</li></ol><h4 id="💻-实战演示-即使是标准按钮也能用这招"><a href="#💻-实战演示-即使是标准按钮也能用这招" class="headerlink" title="💻 实战演示 (即使是标准按钮也能用这招)"></a>💻 实战演示 (即使是标准按钮也能用这招)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面代码一样 ...</span><br><br><span class="hljs-comment"># --- 方法 2: 点击按钮触发上传 (Selenium 做不到，Playwright 能做) ---</span><br><br><span class="hljs-comment"># 1. 设置监听器 (当文件选择器弹出时...)</span><br><span class="hljs-keyword">with</span> page.expect_file_chooser() <span class="hljs-keyword">as</span> fc_info:<br>    <span class="hljs-comment"># 2. 点击那个会触发弹窗的按钮 (甚至是普通的 div 或 span)</span><br>    page.locator(<span class="hljs-string">&quot;#drag-drop-upload&quot;</span>).click() <span class="hljs-comment"># 这里假设有个点击上传区域</span><br><br><span class="hljs-comment"># 3. 拿到拦截到的选择器</span><br>file_chooser = fc_info.value<br><br><span class="hljs-comment"># 4. 设置文件</span><br>file_chooser.set_files(file_path)<br><br><span class="hljs-comment"># ... 后面一样 ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th><strong>场景</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>标准 Input</strong></td><td><code>send_keys(&quot;path&quot;)</code></td><td><code>locator.set_input_files(&quot;path&quot;)</code></td></tr><tr><td><strong>清除文件</strong></td><td><code>clear</code></td><td><code>locator.set_input_files([])</code> (传空列表)</td></tr><tr><td><strong>多文件上传</strong></td><td><code>send_keys(&quot;a.txt \n b.txt&quot;)</code> (看浏览器)</td><td><code>set_input_files([&quot;a.txt&quot;, &quot;b.txt&quot;])</code> (原生支持列表)</td></tr><tr><td><strong>非标准&#x2F;必须点击</strong></td><td><strong>PyAutoGUI &#x2F; AutoIt</strong></td><td><strong><code>expect_file_chooser()</code></strong> (原生支持，无需外挂)</td></tr></tbody></table><hr><h1 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h1><p><strong>页面（Page）与测试（Test）分离</strong>。</p><hr><h3 id="1-核心区别：BasePage-还需要吗？"><a href="#1-核心区别：BasePage-还需要吗？" class="headerlink" title="1. 核心区别：BasePage 还需要吗？"></a>1. 核心区别：BasePage 还需要吗？</h3><p>在Selenium 笔记中，<code>BasePage</code> 非常重要，因为你需要封装 <code>find_element</code> 来实现显式等待，防止报错。</p><p>但在 Playwright 中：由于它自带自动等待（Auto-wait），不需要再封装一个复杂的 find() 方法去写 WebDriverWait。</p><ul><li><strong>Selenium BasePage</strong>: 必须有。用来“保命”（防报错）。</li><li><strong>Playwright BasePage</strong>: 可选。主要用来存放公共业务逻辑（比如“回到首页”、“截图”、“处理通用弹窗”），而不是为了封装底层 API。</li></ul><hr><h3 id="2-项目结构搭建"><a href="#2-项目结构搭建" class="headerlink" title="2. 项目结构搭建"></a>2. 项目结构搭建</h3><p>按照标准的 Python 工程结构来建立文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Playwright_PO/<br>├── pages/              # 【菜单】存放页面对象<br>│   ├── base_page.py    # 父类 (通用方法)<br>│   └── login_page.py   # 登录页<br>├── tests/              # 【顾客】存放测试用例<br>│   └── test_login.py   <br>├── conftest.py         # 【厨房管家】Pytest 的配置文件 (核心！)<br>└── main.py             # 运行入口<br></code></pre></td></tr></table></figure><hr><h3 id="3-第一步：编写-BasePage-父类"><a href="#3-第一步：编写-BasePage-父类" class="headerlink" title="3. 第一步：编写 BasePage (父类)"></a>3. 第一步：编写 BasePage (父类)</h3><p>虽然 Playwright 不需要封装等待，但为了代码规范，还是写一个轻量级的父类。</p><p>新建 <code>pages/base_page.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page: Page</span>):<br>        <span class="hljs-variable language_">self</span>.page = page<br><br>    <span class="hljs-comment"># 封装一个通用的打开网址方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-variable language_">self</span>.page.goto(url)<br><br>    <span class="hljs-comment"># 封装通用的获取标题</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_title</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.page.title()<br>        <br>    <span class="hljs-comment"># 如果有通用的弹窗处理、Cookie保存，都可以写在这里</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-第二步：编写-LoginPage-页面层"><a href="#4-第二步：编写-LoginPage-页面层" class="headerlink" title="4. 第二步：编写 LoginPage (页面层)"></a>4. 第二步：编写 LoginPage (页面层)</h3><p>注意变化： 在 <strong>init</strong> 里直接定义好 Locator，动作方法里直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pages.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 定义 Locator (写在构造函数里，清晰明了) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br>        <span class="hljs-variable language_">self</span>.url = <span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span><br>        <span class="hljs-comment"># 这里的 locator 只是定义，不会立即查找，所以不用担心页面没加载</span><br>        <span class="hljs-variable language_">self</span>.username_input = page.locator(<span class="hljs-string">&quot;#user-name&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.password_input = page.locator(<span class="hljs-string">&quot;#password&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.login_btn = page.locator(<span class="hljs-string">&quot;#login-button&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.error_msg = page.locator(<span class="hljs-string">&quot;[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 定义动作 (Action) ---</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">navigate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username, password</span>):<br>        <span class="hljs-comment"># Playwright 的 fill 和 click 自带等待，直接写逻辑，极其干净</span><br>        <span class="hljs-variable language_">self</span>.username_input.fill(username)<br>        <span class="hljs-variable language_">self</span>.password_input.fill(password)<br>        <span class="hljs-variable language_">self</span>.login_btn.click()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_text</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.error_msg.inner_text()<br></code></pre></td></tr></table></figure><hr><h3 id="5-第三步：编写测试用例-结合-Pytest"><a href="#5-第三步：编写测试用例-结合-Pytest" class="headerlink" title="5. 第三步：编写测试用例 (结合 Pytest)"></a>5. 第三步：编写测试用例 (结合 Pytest)</h3><p>这里是 Playwright 最舒服的地方。使用 pytest-playwright 插件。不需要手动创建 browser 和 page，Pytest 会自动生成一个 page 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page, expect<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># Pytest 会自动把 page 夹具注入进来，不需要我们自己 launch browser</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">page: Page</span>):<br>    <span class="hljs-comment"># 1. 实例化页面对象</span><br>    login_page = LoginPage(page)<br>    <br>    <span class="hljs-comment"># 2. 调用页面方法 (业务逻辑)</span><br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 断言 (Test层负责断言，Page层不要有 expect)</span><br>    expect(page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_failed</span>(<span class="hljs-params">page: Page</span>):<br>    login_page = LoginPage(page)<br>    <br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_pwd&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证错误提示</span><br>    error_text = login_page.get_error_text()<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text<br></code></pre></td></tr></table></figure><hr><h3 id="6-进阶优化：使用-conftest-py-管理对象"><a href="#6-进阶优化：使用-conftest-py-管理对象" class="headerlink" title="6. 进阶优化：使用 conftest.py 管理对象"></a>6. 进阶优化：使用 <code>conftest.py</code> 管理对象</h3><p>上面的测试代码里，每个用例都要写一句 login_page &#x3D; LoginPage(page)，有点啰嗦。可以用 Pytest 的 fixture 把页面对象的初始化也提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 定义一个 fixture，名字就叫 login</span><br><span class="hljs-comment"># 只要测试用例参数里写了 login，就会自动执行这个函数</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">page</span>):<br>    <span class="hljs-keyword">return</span> LoginPage(page)<br></code></pre></td></tr></table></figure><p><strong>优化后的测试用例 (<code>tests/test_login.py</code>)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> expect<br><br><span class="hljs-comment"># 注意参数变成了 login (对应上面的 fixture)，page 都不用传了</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">login</span>): <br>    <span class="hljs-comment"># login 已经是实例化好的 LoginPage 对象了</span><br>    login.navigate()<br>    login.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 这里的 login.page 是我们在 BasePage 里存的 self.page</span><br>    expect(login.page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="7-怎么运行？"><a href="#7-怎么运行？" class="headerlink" title="7. 怎么运行？"></a>7. 怎么运行？</h3><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行所有测试</span><br>pytest<br><br><span class="hljs-comment"># 运行特定文件并显示浏览器 (headed) 和慢放 (slowmo)</span><br>pytest tests/test_login.py --headed --slowmo 1000<br></code></pre></td></tr></table></figure><hr><h3 id="总结：Selenium-PO-vs-Playwright-PO"><a href="#总结：Selenium-PO-vs-Playwright-PO" class="headerlink" title="总结：Selenium PO vs Playwright PO"></a>总结：Selenium PO vs Playwright PO</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Selenium PO</strong></th><th><strong>Playwright PO</strong></th></tr></thead><tbody><tr><td><strong>BasePage</strong></td><td><strong>必须且厚重</strong> (封装 WebDriverWait)</td><td><strong>可选且轻量</strong> (仅存公共逻辑)</td></tr><tr><td><strong>Locator 定义</strong></td><td><code>(By.ID, &quot;val&quot;)</code> 元组</td><td><code>page.locator(&quot;#val&quot;)</code> 对象</td></tr><tr><td><strong>操作方法</strong></td><td><code>find(*loc).click()</code></td><td><code>self.btn.click()</code></td></tr><tr><td><strong>Driver 传递</strong></td><td>手动初始化 Driver 并传递</td><td>Pytest <code>page</code> fixture 自动注入</td></tr><tr><td><strong>代码量</strong></td><td>多，容易出错</td><td>少，逻辑清晰</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web自动化测试</tag>
      
      <tag>playwright</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium学习</title>
    <link href="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Selenium特点"><a href="#Selenium特点" class="headerlink" title="Selenium特点"></a>Selenium特点</h1><ul><li><strong>跨浏览器支持</strong>：Selenium 支持多种主流浏览器，如 Chrome、Firefox、Safari、Internet Explorer 等，可以在不同浏览器中执行相同的测试脚本。</li><li><strong>多语言支持</strong>：Selenium 支持多种编程语言，开发者可以用自己熟悉的语言来编写测试脚本。</li><li><strong>灵活性</strong>：Selenium 可以与各种测试框架结合使用，如 TestNG、JUnit、PyTest 等，提供了丰富的测试功能。</li><li><strong>与 CI&#x2F;CD 集成</strong>：Selenium 可以与 Jenkins 等持续集成工具集成，帮助实现自动化测试和持续交付。</li><li><strong>自动化Web交互</strong>：Selenium 可以模拟真实用户的操作，如点击、滚动、键盘输入等</li></ul><hr><h1 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h1><p>Selenium WebDriver 是 Selenium 的核心组件，它提供了与浏览器交互的 API，允许开发者通过编程语言控制浏览器并执行各种操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所需模块</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br><span class="hljs-comment"># 使用 get() 方法打开指定的 URL</span><br>driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>)<br><br><span class="hljs-comment"># 最大化窗口</span><br>driver.maximize_window()<br><br><span class="hljs-comment"># 获取页面标题和 URL</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;页面标题:&quot;</span>, driver.title)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前 URL:&quot;</span>, driver.current_url)<br><br><span class="hljs-comment"># 导航到另一个页面</span><br>driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>)<br><br><span class="hljs-comment"># 返回上一个页面</span><br>driver.back()<br><br><span class="hljs-comment"># 刷新页面</span><br>driver.refresh()<br><br><span class="hljs-comment"># 关闭浏览器</span><br>driver.quit()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openqa.selenium.WebDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeleniumExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置 ChromeDriver 路径（方式1：通过系统属性）</span><br>        System.setProperty(<span class="hljs-string">&quot;webdriver.chrome.driver&quot;</span>, <span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>);<br>        <br>        <span class="hljs-comment">// 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>        <span class="hljs-type">ChromeOptions</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeOptions</span>();<br>        <br>        <span class="hljs-comment">// 创建 ChromeDriver 对象，启动 Chrome 浏览器</span><br>        <span class="hljs-type">WebDriver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeDriver</span>(options);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用 get() 方法打开指定的 URL</span><br>            driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 最大化窗口</span><br>            driver.manage().window().maximize();<br>            <br>            <span class="hljs-comment">// 获取页面标题和 URL</span><br>            System.out.println(<span class="hljs-string">&quot;页面标题: &quot;</span> + driver.getTitle());<br>            System.out.println(<span class="hljs-string">&quot;当前 URL: &quot;</span> + driver.getCurrentUrl());<br>            <br>            <span class="hljs-comment">// 导航到另一个页面</span><br>            driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 返回上一个页面</span><br>            driver.navigate().back();<br>            <br>            <span class="hljs-comment">// 刷新页面</span><br>            driver.navigate().refresh();<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭浏览器</span><br>            driver.quit();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><h2 id="1-ID定位"><a href="#1-ID定位" class="headerlink" title="1.ID定位"></a>1.ID定位</h2><p>id是标签的唯一属性,可以通过id属性来唯一定位一个元素(唯一且最快，如果有ID先用ID)</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image1.png" class="" title="ID定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.ID,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.id(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="2-name定位"><a href="#2-name定位" class="headerlink" title="2.name定位"></a>2.name定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image2.png" class="" title="name定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.Name,<span class="hljs-string">&quot; &quot;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.name(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="3-ClassName定位"><a href="#3-ClassName定位" class="headerlink" title="3.ClassName定位"></a>3.ClassName定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image3.png" class="" title="ClassName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.CLASS_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.className(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><p>坑：如果 HTML 是 <button class="btn btn-primary">，你不能直接写 “btn btn-primary”。因为中间有空格，Selenium 会认为这是两个类名，会报错。所以只取其中一个唯一的类名，或者改用 CSS Selector。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ❌ 错误写法</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn btn-primary&quot;</span>)<br><br><span class="hljs-comment"># ✅ 正确写法 (只取其中一段)</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn-primary&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-tagName定位"><a href="#4-tagName定位" class="headerlink" title="4.tagName定位"></a>4.<strong>tagName</strong>定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image4.png" class="" title="tagName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.TAG_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.tagName(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="5-cssSelector定位"><a href="#5-cssSelector定位" class="headerlink" title="5.cssSelector定位"></a>5.<strong>cssSelector</strong>定位</h2><p>语法简洁，渲染速度比 XPath 快，适合没有 ID 但有特定属性的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.CSS_SELECTOR,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.cssSelector(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）id选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#kw&quot;</span>)<br><br><span class="hljs-comment"># 2）类选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;.s_ipt&quot;</span>)<br><br><span class="hljs-comment"># 3）标签选择器</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;input&quot;</span>)  <span class="hljs-comment"># 查找第一个&lt;input&gt;标签</span><br></code></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）单个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 2）多个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[rows=&#x27;1&#x27;][autocomplete=&#x27;off&#x27;][id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 3）标签名+属性选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 4）通过标签名+ID选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea#chat-textarea&quot;</span>)<br><br><span class="hljs-comment"># 5）通过标签名+类选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea.chat-input-textarea&quot;</span>)<br><br><span class="hljs-comment"># 6）通过标签层级定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;form&gt;span&gt;input&quot;</span>)<br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;div&gt;div:nth-child(2)&gt;div:nth-child(2)&gt;a:nth-child(3)&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-link-text定位"><a href="#6-link-text定位" class="headerlink" title="6.link_text定位"></a>6.<strong>link_text</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image5.png" class="" title="link_text定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.linkText(<span class="hljs-string">&quot;地图&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="7-partialLinkText定位"><a href="#7-partialLinkText定位" class="headerlink" title="7.partialLinkText定位"></a>7.<strong>partialLinkText</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image6.png" class="" title="partialLinkText定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.PARTIAL_LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.partialLinkText(<span class="hljs-string">&quot;更&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="8-Xpath定位"><a href="#8-Xpath定位" class="headerlink" title="8.Xpath定位"></a>8.Xpath定位</h2><p><strong>功能最强（能通过文本定位、能找父节点），但速度稍慢，语法啰嗦</strong>。但Xpath是万能的</p><h3 id="绝对路径定位"><a href="#绝对路径定位" class="headerlink" title="绝对路径定位"></a>绝对路径定位</h3><p><strong>特点：</strong> 从 HTML 根节点一层层往下找，极其脆弱。前端稍微加个 <code>div</code> 你的代码就挂了。 <strong>语法：</strong> 单斜杠 <code>/</code> 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非常不建议用</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;/html/body/div[1]/div[2]/div/div[1]/input&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="相对路径定位"><a href="#相对路径定位" class="headerlink" title="相对路径定位"></a>相对路径定位</h3><p><strong>特点：</strong> 忽略层级，在整个页面中查找。 <strong>语法：</strong> 双斜杠 <code>//</code> 开头 + 标签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在整个页面找 input 标签（如果有很多 input，默认返回第一个）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input&quot;</span>) <br><br><span class="hljs-comment"># 找页面所有的 div 下面的 form 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div//form&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="元素属性定位"><a href="#元素属性定位" class="headerlink" title="元素属性定位"></a>元素属性定位</h3><p><strong>特点：</strong> 结合 <code>@属性名</code> 精准定位。 <strong>语法：</strong> <code>//标签名[@属性=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过 id 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 name 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 class 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 结合标签层级：找到 form 标签下的 input 标签，且该 input 有 id=&#x27;kw&#x27;</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//form//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="逻辑运算符定位"><a href="#逻辑运算符定位" class="headerlink" title="逻辑运算符定位"></a>逻辑运算符定位</h3><p><strong>特点：</strong> 当一个属性无法唯一定位时，用 <code>and</code> 或 <code>or</code> 组合多个属性。 <strong>语法：</strong> <code>[@属性1=&#39;值&#39; and @属性2=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同时满足 name=&#x27;wd&#x27; 且 class=&#x27;s_ipt&#x27; 的 input 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27; and @class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 只要满足 id=&#x27;kw&#x27; 或者 name=&#x27;wd&#x27; 任意一个即可</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27; or @name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="文本内容定位"><a href="#文本内容定位" class="headerlink" title="文本内容定位"></a>文本内容定位</h3><p><strong>特点：</strong> 很多链接（<code>&lt;a&gt;</code>）或按钮（<code>&lt;button&gt;</code>）没有 ID，只有文字。 <strong>语法：</strong> <code>text()=&#39;完整文字&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定位文本完全等于 &quot;新闻&quot; 的 a 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[text()=&#x27;新闻&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 定位文本完全等于 &quot;登录&quot; 的 button 按钮</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;登录&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="部分文本-属性定位-模糊匹配"><a href="#部分文本-属性定位-模糊匹配" class="headerlink" title="部分文本&#x2F;属性定位-模糊匹配"></a>部分文本&#x2F;属性定位-模糊匹配</h3><p><strong>特点：</strong> 处理动态变化的元素（例如：<code>id=&quot;user_123&quot;</code>, <code>id=&quot;user_456&quot;</code>）或长文本。 <strong>语法：</strong> <code>contains(@属性或text(), &#39;部分值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文本包含 &quot;百度&quot; 的所有链接（能匹配 &quot;百度一下&quot;、&quot;关于百度&quot; 等）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[contains(text(), &#x27;百度&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># id 属性中包含 &quot;user_name&quot; 的 input (能匹配 id=&quot;my_user_name_input&quot;)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[contains(@id, &#x27;user_name&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用函数定位"><a href="#使用函数定位" class="headerlink" title="使用函数定位"></a>使用函数定位</h3><p><strong>特点：</strong> 匹配以特定字符开头的内容。 <strong>语法：</strong> <code>starts-with(@属性, &#39;开头值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配 id 以 &quot;ctrl_7&quot; 开头的 input 元素 (常用于 ExtJS 等自动生成 ID 的框架)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[starts-with(@id, &#x27;ctrl_7&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># 匹配文本以 &quot;欢迎&quot; 开头的 div</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[starts-with(text(), &#x27;欢迎&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><p>问：遇到一个非常难定位的元素，你会怎么写 XPath？</p><p>如果是静态属性，我优先用 <strong>属性定位</strong> (<code>//tag[@id=&#39;...&#39;]</code>)；如果是链接或按钮，我会用 <strong>文本定位</strong> (<code>//a[text()=&#39;...&#39;]</code>)；如果是动态 ID 或复杂场景，我会用 <strong>contains 模糊匹配</strong> (<code>//div[contains(@class, &#39;...&#39;)]</code>)，或者结合 <strong>父子层级关系</strong> 来写</p><h2 id="基础定位练习-SauceDemo"><a href="#基础定位练习-SauceDemo" class="headerlink" title="基础定位练习-SauceDemo"></a>基础定位练习-<strong>SauceDemo</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;D:\\develop\\chromedriver-win64\\chromedriver.exe&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>driver.maximize_window()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>user_input = driver.find_element(By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>user_input.send_keys(<span class="hljs-string">&quot;standard_user&quot;</span>)<br>password_input = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;password&#x27;]&quot;</span>)<br>password_input.send_keys(<span class="hljs-string">&quot;secret_sauce&quot;</span>)<br><br><span class="hljs-comment"># login_btn = driver.find_element(By.CSS_SELECTOR, &quot;input.btn_action&quot;)</span><br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#login-button&quot;</span>)<br>login_btn.click()<br><br><span class="hljs-comment"># 断言是否登录成功</span><br><span class="hljs-comment"># time.sleep(2)</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url<br><span class="hljs-comment"># 判断Swag Labs是否预期</span><br>page_title = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[@class=&#x27;app_logo&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> page_title == <span class="hljs-string">&quot;Swag Labs&quot;</span><br><br><span class="hljs-comment"># time.sleep(1)</span><br><br><span class="hljs-comment"># add_to_cart_btn = driver.find_element(By.XPATH, &quot;//button[text()=&#x27;Add to cart&#x27;]&quot;)</span><br>add_to_cart_btn = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[contains(text(),&#x27;Add to cart&#x27;)]&quot;</span>)<br>add_to_cart_btn.click()<br><br><span class="hljs-comment"># time.sleep(1)</span><br><span class="hljs-comment"># 验证购物车图标上的数量是否为1</span><br>cart_badge = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//span[@class=&#x27;shopping_cart_badge&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> cart_badge == <span class="hljs-string">&quot;1&quot;</span><br><br><span class="hljs-comment"># driver.close()</span><br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素定位不到"><a href="#元素定位不到" class="headerlink" title="元素定位不到"></a>元素定位不到</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image7.png" class="" title="元素定位不到"><hr><h1 id="WebDriver常用方法"><a href="#WebDriver常用方法" class="headerlink" title="WebDriver常用方法"></a>WebDriver常用方法</h1><h2 id="导航方法"><a href="#导航方法" class="headerlink" title="导航方法"></a>导航方法</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image8.png" class="" title="导航方法"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 加上隐式等待</span><br><br><span class="hljs-comment"># --- 动作 1: 打开第一个网页 (百度) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在打开百度...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 强制等待是为了看清效果 实际最好别用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前URL: <span class="hljs-subst">&#123;driver.current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 2: 打开第二个网页 (B站) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 正在跳转到 Bilibili...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 3: 后退 (Back) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 执行后退操作 (回到百度)...&quot;</span>)<br>driver.back()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 验证一下是不是回到了百度</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 后退成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 4: 前进 (Forward) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n4. 执行前进操作 (回到 Bilibili)...&quot;</span>)<br>driver.forward()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;哔哩哔哩&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 前进成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 5: 刷新 (Refresh) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n5. 执行刷新当前页面...&quot;</span>)<br>driver.refresh()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 页面刷新完毕&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image9.png" class="" title="元素操作"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>) <span class="hljs-comment"># 全局隐式等待</span><br><br><span class="hljs-comment"># 2. 打开练习靶场</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在打开: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>driver.get(url)<br><br><span class="hljs-comment"># --- 定位元素 ---</span><br>username_input = driver.find_element(By.ID, <span class="hljs-string">&quot;username&quot;</span>)<br>password_input = driver.find_element(By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;button.radius&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 1: 状态判断 (is_displayed) ---</span><br><span class="hljs-keyword">if</span> username_input.is_displayed():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用户名输入框可见，准备操作...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找不到输入框！&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 2: 输入与清空 (send_keys + clear) ---</span><br><span class="hljs-comment"># 模拟手误：输入了错误的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;wrong_user_123&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到输入了错误的内容</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入错误用户名&quot;</span>)<br><br><span class="hljs-comment"># 发现错了，清空！</span><br>username_input.clear()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到清空的效果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已清空输入框&quot;</span>)<br><br><span class="hljs-comment"># 输入正确的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入正确用户名: tomsmith&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 3: 获取属性 (get_attribute) —— 安全测试常用 ---</span><br><br><span class="hljs-comment"># 面试题：你怎么验证密码框里的密码是掩码显示的（即显示为圆点或星号）？</span><br><span class="hljs-comment"># 答案：获取它的 type 属性，看是不是等于 &quot;password&quot;</span><br><span class="hljs-comment"># type_attr = password_input.get_attribute(&quot;type&quot;)</span><br>type_attr = password_input.get_dom_attribute(<span class="hljs-string">&quot;type&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;密码框的 type 属性是: <span class="hljs-subst">&#123;type_attr&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> type_attr == <span class="hljs-string">&quot;password&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 安全检查通过：密码框是加密显示的&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 安全漏洞：密码框是明文显示的！&quot;</span>)<br><br><span class="hljs-comment"># 输入密码</span><br>password_input.send_keys(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 4: 点击登录 (click) ---</span><br>login_btn.click()<br><br><span class="hljs-comment"># --- 验证结果 ---</span><br><span class="hljs-comment"># 登录成功后，页面会出现一个绿色的提示条</span><br>success_msg = driver.find_element(By.ID, <span class="hljs-string">&quot;flash&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面提示信息: <span class="hljs-subst">&#123;success_msg&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 断言：验证提示信息里包含 &#x27;You logged into a secure area&#x27;</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> success_msg<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🎉 测试通过！成功登录。&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的URL</span><br>current_url = driver.current_url<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面URL: <span class="hljs-subst">&#123;current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的标题</span><br>current_title = driver.title<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面标题: <span class="hljs-subst">&#123;current_title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的HTML源代码</span><br>page_source = driver.page_source<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面HTML源代码长度: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(page_source)&#125;</span> 字符&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><ul><li><strong>get_dom_attribute(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>HTML 源代码里写死的属性</strong>。</li><li><strong>场景</strong>：获取 id、name、type、href、class。</li><li><strong>例子</strong>：<input value="123"> -&gt; 永远返回 “123”。</li></ul></li><li><strong>get_property(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>浏览器运行时产生的属性</strong>（即用户操作后的状态）。</li><li><strong>场景</strong>：获取用户<strong>输入框里敲进去的字</strong> (value)、复选框是否被勾选 (checked)。</li><li><strong>例子</strong>：<input value="123">，用户删掉 123 输入了 abc -&gt; get_property(‘value’) 返回 “abc”。</li></ul></li></ul><h2 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image10.png" class="" title="窗口和标签页操作"><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>把句柄想象成<strong>窗口的身份证号</strong>。</p><ul><li>每个标签页（Tab）或窗口都有一个唯一的字符串 ID。</li><li>Selenium 通过这个 ID 来决定控制哪个窗口。</li></ul><p><strong>核心方法 ：</strong></p><ol><li>driver.current_window_handle: 获取<strong>当前</strong>窗口的句柄。</li><li>driver.window_handles: 获取浏览器里<strong>所有</strong>窗口的句柄（返回一个列表 List）。</li><li>driver.switch_to.window(handle): 切换到指定句柄的窗口。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开主页面</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span><br>driver.get(url)<br><br><span class="hljs-comment"># 获取当前主窗口的句柄 (相当于记下：这是&quot;老家&quot;)</span><br>original_window = driver.current_window_handle<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口句柄: <span class="hljs-subst">&#123;original_window&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 点击链接，打开新窗口</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;Click Here&quot;</span>).click()<br><br><span class="hljs-comment"># --- 关键时刻：切换窗口 ---</span><br><br><span class="hljs-comment"># 此时虽然新窗口弹出来了，但 driver 还在老窗口</span><br><span class="hljs-comment"># 我们获取所有窗口的句柄列表</span><br>all_handles = driver.window_handles<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前所有句柄: <span class="hljs-subst">&#123;all_handles&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 遍历列表，找到那个“不是老家”的句柄，就是新窗口</span><br><span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> all_handles:<br>    <span class="hljs-keyword">if</span> handle != original_window:<br>        <span class="hljs-comment"># 找到了新窗口，切换过去！</span><br>        driver.switch_to.window(handle)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🔀 已切换到新窗口！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># --- 3. 在新窗口操作 ---</span><br><span class="hljs-comment"># 只有切换成功了，这行代码才能找到元素，否则会报错</span><br>new_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口里的文字是: <span class="hljs-subst">&#123;new_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> new_text == <span class="hljs-string">&quot;New Window&quot;</span><br><br><span class="hljs-comment"># --- 4. 关闭新窗口，切回主窗口 ---</span><br><span class="hljs-comment"># close() 只关闭当前标签页</span><br>driver.close() <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭新窗口&quot;</span>)<br><br><span class="hljs-comment"># ⚠️ 注意：关掉新窗口后，driver 此时处于“失重”状态，谁也没控制</span><br><span class="hljs-comment"># 必须立刻切回主窗口，否则后续操作会报错</span><br>driver.switch_to.window(original_window)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔀 已切回主窗口: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 验证一下是不是真的回来了</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;The Internet&quot;</span> <span class="hljs-keyword">in</span> driver.title<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><h4 id="1-什么是-Iframe？"><a href="#1-什么是-Iframe？" class="headerlink" title="1. 什么是 Iframe？"></a>1. 什么是 Iframe？</h4><p>简单来说，就是<strong>网页里套网页</strong>。<br>想象一下，走进一个大房子（主页面），墙上挂着一台电视机（Iframe）。电视机里在播放另一个画面。</p><ul><li>Selenium 默认只能操作“大房子”里的东西。</li><li>如果你想操作“电视机”里的菜单，你必须先<strong>把遥控器对准电视机</strong>（切换进去）。</li><li>操作完后，必须<strong>把视线移回大房子</strong>（切换出来），否则找不到房子里的其他家具。</li></ul><p><strong>症状</strong>：<br>在开发者工具（F12）里明明能看到这个元素，XPath 写得也对，但代码运行就是报 NoSuchElementException。这时候，<strong>99% 是因为元素在 Iframe 里</strong>。</p><hr><h4 id="2-怎么识别-Iframe？"><a href="#2-怎么识别-Iframe？" class="headerlink" title="2. 怎么识别 Iframe？"></a>2. 怎么识别 Iframe？</h4><p>在 F12 开发者工具里，如果你看到元素的父级标签有 <iframe> 或 <frame>，那就是它了。</p><hr><h4 id="3-核心操作方法"><a href="#3-核心操作方法" class="headerlink" title="3. 核心操作方法"></a>3. 核心操作方法</h4><h5 id="A-切换进去-switch-to-frame"><a href="#A-切换进去-switch-to-frame" class="headerlink" title="A. 切换进去 (switch_to.frame)"></a>A. 切换进去 (switch_to.frame)</h5><p>有 3 种方式可以切换进去：</p><ol><li><p><strong>通过 ID 或 Name (最简单)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;iframe_id&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;iframe_name&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过 WebElement 对象 (最稳，推荐)</strong>：<br>如果 Iframe 没有 ID，或者 ID 是动态的。你可以先用 find_element 找到这个 iframe 标签，再切进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">iframe_element = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//iframe[@class=&#x27;...&#x27;]&quot;</span>)<br>driver.switch_to.frame(iframe_element)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过索引 (Index)</strong>：<br>driver.switch_to.frame(0) (切到第1个 iframe)。<em>不推荐，因为页面变动容易挂。</em></p></li></ol><h4 id="B-切换出来-switch-to-default-content"><a href="#B-切换出来-switch-to-default-content" class="headerlink" title="B. 切换出来 (switch_to.default_content)"></a>B. 切换出来 (switch_to.default_content)</h4><p>操作完 Iframe 里的东西，<strong>一定要切回来！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回到最外层的主页面</span><br>driver.switch_to.default_content()<br><span class="hljs-comment"># (选学) 如果是嵌套 Iframe (A套B，B套C)，想从 C 回到 B：</span><br>driver.switch_to.parent_frame()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开页面</span><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/iframe&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换进 Iframe ---</span><br><span class="hljs-comment"># 这里的 iframe 有个 id 叫 &#x27;mce_0_ifr&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在切换进 Iframe...&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;mce_0_ifr&quot;</span>)<br><br><span class="hljs-comment"># --- 2. 在 Iframe 内部操作 ---</span><br><span class="hljs-comment"># 注意：切进来后，我们找的是 iframe 里面的 body 标签</span><br>editor_body = driver.find_element(By.ID, <span class="hljs-string">&quot;tinymce&quot;</span>)<br><br><span class="hljs-comment"># 清空原有内容</span><br>editor_body.clear()<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 输入新内容</span><br>editor_body.send_keys(<span class="hljs-string">&quot;你好，我是 Selenium 练习生！&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已在编辑器中输入内容&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换回主页面 ---</span><br><span class="hljs-comment"># 如果不写这句，下面找标题会报错，因为标题在 iframe 外面</span><br>driver.switch_to.default_content()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已切回主页面&quot;</span>)<br><br><span class="hljs-comment"># --- 3. 在主页面操作 ---</span><br><span class="hljs-comment"># 获取页面上方的大标题</span><br>h3_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主页面标题: <span class="hljs-subst">&#123;h3_text&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">assert</span> h3_text == <span class="hljs-string">&quot;An iFrame containing the TinyMCE WYSIWYG Editor&quot;</span><br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="浏览器管理与执行JS"><a href="#浏览器管理与执行JS" class="headerlink" title="浏览器管理与执行JS"></a>浏览器管理与执行JS</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image11.png" class="" title="浏览器管理"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image12.png" class="" title="执行JS"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 打开京东</span><br>driver.get(<span class="hljs-string">&quot;https://www.jd.com&quot;</span>)<br><br><span class="hljs-comment"># --- 浏览器管理演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在最大化窗口...&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># --- JS 执行演示：滚动条 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备滚动到底部...&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿一下让你看清</span><br><br><span class="hljs-comment"># 执行 JS 滚动到底部</span><br><span class="hljs-comment"># document.body.scrollHeight 是获取页面总高度</span><br>driver.execute_script(<span class="hljs-string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已滚动到底部，等待图片懒加载...&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等待页面加载更多内容</span><br><br><span class="hljs-comment"># --- 截图演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在截图...&quot;</span>)<br><span class="hljs-comment"># 截图会保存在当前代码的目录下</span><br>driver.get_screenshot_as_file(<span class="hljs-string">&quot;jd_bottom.png&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 截图已保存为 jd_bottom.png&quot;</span>)<br><br><span class="hljs-comment"># --- Cookie 演示 ---</span><br>cookies = driver.get_cookies()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前获取到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(cookies)&#125;</span> 个 Cookie&quot;</span>)<br><span class="hljs-comment"># 随便打印第一个看看长什么样</span><br><span class="hljs-keyword">if</span> cookies:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一个 Cookie: <span class="hljs-subst">&#123;cookies[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- JS 进阶：修改页面标题 (好玩的操作) ---</span><br><span class="hljs-comment"># 你甚至可以用 JS 修改网页显示的内容</span><br>driver.execute_script(<span class="hljs-string">&quot;document.title = &#x27;这是我用 Selenium 改的标题！&#x27;;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;修改后的标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><p><strong>Q1: 自动化测试中，如何处理页面滚动？</strong></p><blockquote><p><strong>答</strong>：Selenium 原生没有滚动方法，我通常使用 execute_script 执行 JavaScript。<br>比如 window.scrollTo(0, document.body.scrollHeight) 滚动到底部，或者使用 arguments[0].scrollIntoView() 滚动到特定元素。</p></blockquote><p><strong>Q2: 遇到一个日期控件，无法直接输入，怎么处理？</strong></p><blockquote><p><strong>答</strong>：通常是因为 input 标签有 readonly 属性。我会先用 JS 移除这个属性 (removeAttribute(‘readonly’))，然后就可以直接用 send_keys 输入日期了，这样比通过 UI 选日历更稳定。</p></blockquote><p><strong>Q3: 自动化测试执行失败了，怎么排查？</strong></p><blockquote><p><strong>答</strong>：我会配置测试框架，在用例失败（Fail）或报错（Error）时，自动调用 driver.get_screenshot_as_file 进行截图，并把截图嵌入到测试报告（如 Allure）中，方便后续分析。</p></blockquote><hr><h1 id="三大等待"><a href="#三大等待" class="headerlink" title="三大等待"></a>三大等待</h1><hr><h3 id="1-强制等待-Forced-Wait-——-time-sleep"><a href="#1-强制等待-Forced-Wait-——-time-sleep" class="headerlink" title="1. 强制等待 (Forced Wait) —— time.sleep()"></a>1. 强制等待 (Forced Wait) —— <code>time.sleep()</code></h3><p>这是 Python 自带的库，不是 Selenium 的功能。</p><ul><li><strong>原理</strong>：不管网页加载完没，不管元素出来没，我就死等指定的秒数。</li><li><strong>代码</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.sleep(<span class="hljs-number">5</span>) <span class="hljs-comment"># 睡 5 秒</span><br></code></pre></td></tr></table></figure></li><li><strong>优点</strong>：简单，粗暴，调试（Debug）时最好用。</li><li><strong>缺点</strong>：<ul><li><strong>浪费时间</strong>：网页 1秒加载完，你睡 5秒，浪费 4秒。</li><li><strong>不稳定</strong>：网页 6秒加载完，你睡 5秒，脚本报错。</li></ul></li><li><strong>结论</strong>：<strong>写作业、调试可以用，但上线运行的代码里尽量别用。</strong></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait-——-driver-implicitly-wait"><a href="#2-隐式等待-Implicit-Wait-——-driver-implicitly-wait" class="headerlink" title="2. 隐式等待 (Implicit Wait) —— driver.implicitly_wait()"></a>2. 隐式等待 (Implicit Wait) —— <code>driver.implicitly_wait()</code></h3><p>这是 Selenium 的全局设置。</p><ul><li><strong>原理</strong>：设置一个<strong>最长等待时间</strong>。在找元素（<code>find_element</code>）时，如果元素没立刻出现，Selenium 会不断轮询（每隔 0.5秒看一眼），直到元素出现<strong>或者</strong>超时报错。</li><li><strong>代码</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只需要在启动浏览器后写一次，全局生效</span><br>driver.implicitly_wait(<span class="hljs-number">10</span>) <br></code></pre></td></tr></table></figure></li><li><strong>优点</strong>：写一行代码，管所有元素，省事。</li><li><strong>缺点 (面试考点)</strong>：<ul><li>它只能判断元素<strong>是否在 HTML (DOM) 里</strong>。</li><li><strong>致命伤</strong>：如果元素在 HTML 里了，但是是<strong>不可见</strong>的（比如 loading 遮罩层还没消失），或者<strong>不可点击</strong>的，隐式等待会认为“找到了”，立刻去点，结果报错 <code>ElementNotInteractableException</code>。</li></ul></li><li><strong>结论</strong>：<strong>作为保底手段，每个脚本都加上，但不能完全依赖它。</strong></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-WebDriverWait"><a href="#3-显式等待-Explicit-Wait-——-WebDriverWait" class="headerlink" title="3. 显式等待 (Explicit Wait) —— WebDriverWait"></a>3. 显式等待 (Explicit Wait) —— <code>WebDriverWait</code></h3><p>这是<strong>最智能、最推荐</strong>的等待方式。</p><ul><li><strong>原理</strong>：专门等待<strong>某个条件</strong>成立（比如：等这个按钮变成“可点击”状态，或者等这段文字“可见”）。</li><li><strong>代码结构</strong>：<br>需要引入三个模块：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br></code></pre></td></tr></table></figure></li><li><strong>语法</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># WebDriverWait(driver, 超时时间, 轮询频率).until(等待条件)</span><br>element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.element_to_be_clickable((By.ID, <span class="hljs-string">&quot;login_btn&quot;</span>))<br>)<br>element.click()<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="⚔️-核心实战：常用-EC-Expected-Conditions-条件"><a href="#⚔️-核心实战：常用-EC-Expected-Conditions-条件" class="headerlink" title="⚔️ 核心实战：常用 EC (Expected Conditions) 条件"></a>⚔️ 核心实战：常用 EC (Expected Conditions) 条件</h3><p><code>expected_conditions</code> (简称 EC) 提供了很多判断标准，面试和工作中<strong>最常用</strong>的是这三个：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>presence_of_element_located</code></strong></td><td align="left">元素存在于 HTML 中</td><td align="left">等同于隐式等待，只要代码里有这个标签就行，不管你看没看见。</td></tr><tr><td align="left"><strong><code>visibility_of_element_located</code></strong></td><td align="left"><strong>元素可见</strong></td><td align="left"><strong>最常用！</strong> 元素不仅在 HTML 里，而且长宽大于 0，肉眼能看见。</td></tr><tr><td align="left"><strong><code>element_to_be_clickable</code></strong></td><td align="left"><strong>元素可点击</strong></td><td align="left"><strong>最稳！</strong> 元素可见且可用（没有 disable）。点按钮前必用这个。</td></tr></tbody></table><hr><h3 id="💻-代码实战：显式等待演示"><a href="#💻-代码实战：显式等待演示" class="headerlink" title="💻 代码实战：显式等待演示"></a>💻 代码实战：显式等待演示</h3><p>去<strong>The Internet</strong> 的动态加载页面。<br><strong>场景</strong>：点击 “Start” 按钮，页面会出现一个 loading 条，过 5 秒后才会出现 “Hello World!” 文字。</p><ul><li>如果用隐式等待，可能会因为 loading 条还在就去抓文字，导致失败。</li><li>我们要用显式等待，直到文字<strong>可见</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br><span class="hljs-comment"># 虽然有显式等待，加个隐式等待做保底也是好习惯</span><br>driver.implicitly_wait(<span class="hljs-number">5</span>) <br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br><br><span class="hljs-comment"># 1. 点击 Start 按钮</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;button&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 等待结果</span><br><span class="hljs-comment"># 此时页面上有一个 loading 进度条，&quot;Hello World&quot; 其实已经在 HTML 里了(hidden)，但不可见。</span><br><span class="hljs-comment"># 如果直接 find_element，隐式等待会立刻找到它（因为在 HTML 里），然后去获取 text，</span><br><span class="hljs-comment"># 结果获取到的是空字符串（因为没显示出来），导致断言失败。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待 Hello World 出现...&quot;</span>)<br><br><span class="hljs-comment"># --- 使用显式等待 ---</span><br><span class="hljs-comment"># 意思：最多等 10 秒，直到 ID 为 &#x27;finish&#x27; 的元素变成【可见】状态</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.visibility_of_element_located((By.ID, <span class="hljs-string">&quot;finish&quot;</span>))<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_element.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> target_element.text == <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试通过！&quot;</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问</strong>：我既设置了 <code>implicitly_wait(10)</code>，又在代码里写了 <code>WebDriverWait(driver, 10)</code>，会有什么问题？</p><p><strong>答</strong>：</p><blockquote><p><strong>尽量不要混用，或者要非常小心。</strong><br>因为 Selenium 的机制原因，当两者混用时，超时时间可能会出现<strong>不可预测的叠加</strong>。<br>比如你本意是等 10 秒，结果它俩互相影响，可能导致脚本卡死 20 秒甚至更久才报错。<br><strong>最佳实践</strong>：设置一个较短的全局隐式等待（如 5秒），关键步骤（如点击、断言）使用显式等待。</p></blockquote><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a>🚀 总结</h3><ol><li><strong><code>time.sleep</code></strong>：调试用，死等。</li><li><strong><code>implicitly_wait</code></strong>：全局设置，只管元素在不在 HTML 里，不管能不能点。</li><li><strong><code>WebDriverWait</code></strong>：<strong>王牌</strong>。精准等待元素可见、可点击。</li></ol><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image13.png" class="" title="下拉框"><ol><li><strong>标准下拉框</strong>：HTML 标签是 <code>&lt;select&gt;</code> + <code>&lt;option&gt;</code>。Selenium 提供了专门的 <code>Select</code> 类来处理，非常简单。</li><li><strong>非标准下拉框</strong>：HTML 标签是 <code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code> 模拟的（现在的前端框架如 Vue&#x2F;React 常用这种）。这种<strong>不能</strong>用 <code>Select</code> 类，必须把它当成普通的元素，用“点击 -&gt; 等待 -&gt; 点击”的方式处理。</li></ol><hr><h3 id="第一种：标准下拉框-标签"><a href="#第一种：标准下拉框-标签" class="headerlink" title="第一种：标准下拉框 (&lt;select&gt; 标签)"></a>第一种：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>Selenium 专门提供了一个 <code>Select</code> 类，专门治这种元素。</p><p><strong>核心步骤</strong>：</p><ol><li>引入：<code>from selenium.webdriver.support.ui import Select</code></li><li>定位：先找到那个 <code>&lt;select&gt;</code> 元素。</li><li>初始化：<code>select = Select(元素对象)</code></li><li>选择：使用三大方法选你想要的。</li></ol><p>**三大选择方法 ：</p><ul><li><code>select_by_visible_text(&quot;文字&quot;)</code>：<strong>最常用</strong>。根据用户看到的文字选，比如 “Option 1”。</li><li><code>select_by_value(&quot;值&quot;)</code>：根据 HTML 里的 <code>value</code> 属性选，比如 <code>value=&quot;1&quot;</code>。</li><li><code>select_by_index(索引)</code>：根据顺序选，从 0 开始。<strong>不推荐</strong>，因为选项顺序容易变。</li></ul><h4 id="💻-代码实战：标准下拉框"><a href="#💻-代码实战：标准下拉框" class="headerlink" title="💻 代码实战：标准下拉框"></a>💻 代码实战：标准下拉框</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-comment"># 1. 引入 Select 类</span><br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> Select<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br><span class="hljs-comment"># 2. 先定位到 select 标签本身</span><br>dropdown_element = driver.find_element(By.ID, <span class="hljs-string">&quot;dropdown&quot;</span>)<br><br><span class="hljs-comment"># 3. 初始化 Select 对象</span><br>select = Select(dropdown_element)<br><br><span class="hljs-comment"># --- 方法 A: 通过可见文本选择 (最推荐) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 1...&quot;</span>)<br>select.select_by_visible_text(<span class="hljs-string">&quot;Option 1&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 验证一下选上了没 (获取当前选中的选项)</span><br><span class="hljs-comment"># first_selected_option 是获取当前显示的那个元素</span><br>current_val = select.first_selected_option.text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中: <span class="hljs-subst">&#123;current_val&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> current_val == <span class="hljs-string">&quot;Option 1&quot;</span><br><br><span class="hljs-comment"># --- 方法 B: 通过 value 属性选择 ---</span><br><span class="hljs-comment"># HTML 长这样: &lt;option value=&quot;2&quot;&gt;Option 2&lt;/option&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 2 (通过 value)...&quot;</span>)<br>select.select_by_value(<span class="hljs-string">&quot;2&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># --- 方法 C: 通过索引选择 (不推荐) ---</span><br><span class="hljs-comment"># 索引 1 对应 Option 1 (因为索引 0 是那个 &quot;Please select an option&quot; 的提示语)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择索引 1...&quot;</span>)<br>select.select_by_index(<span class="hljs-number">1</span>) <br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二种：非标准下拉框-Div-Ul-模拟"><a href="#第二种：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二种：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二种：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>如果对着一个 <code>&lt;div&gt;</code> 标签用 <code>Select()</code> 类，Selenium 会直接报错：<br><code>UnexpectedTagNameException: Select only works on &lt;select&gt; elements</code>。</p><p><strong>处理逻辑</strong>：<br>把它当成普通的点击操作</p><hr><p><strong>问：</strong> “你在自动化测试中遇到过下拉框吗？怎么处理的？”</p><blockquote><p>“遇到过，我通常会先看它的 HTML 标签。</p><ol><li>如果是标准的 <strong><code>&lt;select&gt;</code></strong> 标签，我会直接用 Selenium 的 <strong><code>Select</code> 类</strong>，通过 <code>select_by_visible_text</code> 来选择，这样代码最简洁。</li><li>如果是前端框架（如 Vue&#x2F;React）生成的 <strong><code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code></strong> 模拟的下拉框，<code>Select</code> 类是用不了的。我会把它当成普通元素，<strong>分两步处理</strong>：先点击下拉框弹出列表，再定位并点击具体的选项。为了稳定性，我通常会在第二步加上<strong>显式等待</strong>，确保选项可见后再点击。”</li></ol></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Select 类</strong>：只给 <code>&lt;select&gt;</code> 标签用。</li><li><strong>非 Select</strong>：点击框 -&gt; 等待 -&gt; 点击选项。</li></ul><hr><h1 id="Alert、Prompt、Confirm弹出框"><a href="#Alert、Prompt、Confirm弹出框" class="headerlink" title="Alert、Prompt、Confirm弹出框"></a>Alert、Prompt、Confirm弹出框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image14.png" class="" title="弹框"><h3 id="1-什么是-Alert-Confirm-Prompt？"><a href="#1-什么是-Alert-Confirm-Prompt？" class="headerlink" title="1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？"></a>1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？</h3><p>这些是浏览器<strong>原生</strong>的弹窗（JavaScript 触发的）。</p><ul><li><strong>特点</strong>：它们<strong>不是</strong> HTML 元素！你<strong>无法</strong>用 F12 审查元素，也<strong>无法</strong>用 <code>find_element</code> 定位。</li><li><strong>表现</strong>：弹出来的时候，浏览器会被“冻结”，你必须处理掉它（点确定或取消），才能继续操作页面。</li></ul><h3 id="2-核心操作方法"><a href="#2-核心操作方法" class="headerlink" title="2. 核心操作方法"></a>2. 核心操作方法</h3><p>Selenium 提供了一个 <code>Alert</code> 类来专门处理它们。</p><p><strong>第一步：切换控制权</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alert = driver.switch_to.alert<br></code></pre></td></tr></table></figure><p><strong>第二步：操作弹窗 (4 个方法背下来)</strong></p><ol><li><strong><code>alert.accept()</code></strong>：点击“确定” (OK)。</li><li><strong><code>alert.dismiss()</code></strong>：点击“取消” (Cancel)。</li><li><strong><code>alert.text</code></strong>：获取弹窗里的文字 (用来做断言)。</li><li><strong><code>alert.send_keys(&quot;内容&quot;)</code></strong>：在弹窗里输入文字 (仅针对 Prompt)。</li></ol><hr><h3 id="3-三种弹窗的区别"><a href="#3-三种弹窗的区别" class="headerlink" title="3. 三种弹窗的区别"></a>3. 三种弹窗的区别</h3><ol><li><strong>Alert (警告框)</strong>：只有一个“确定”按钮。</li><li><strong>Confirm (确认框)</strong>：有“确定”和“取消”两个按钮。</li><li><strong>Prompt (提示框)</strong>：有个输入框，加上“确定”和“取消”。</li></ol><hr><h3 id="代码实战：全套演练"><a href="#代码实战：全套演练" class="headerlink" title="代码实战：全套演练"></a>代码实战：全套演练</h3><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/javascript_alerts</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br><span class="hljs-comment"># --- 场景 1: 处理 Alert (只有确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 点击 Alert 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Alert&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿让你看清楚弹窗出来了</span><br><br><span class="hljs-comment"># 切换到弹窗</span><br>alert = driver.switch_to.alert<br><br><span class="hljs-comment"># 获取文字并断言</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Alert 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> alert.text == <span class="hljs-string">&quot;I am a JS Alert&quot;</span><br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Alert 已处理&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 2: 处理 Confirm (确定/取消) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 点击 Confirm 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Confirm&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Confirm 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 这次我们点“取消”试试</span><br>alert.dismiss()<br><br><span class="hljs-comment"># 验证页面结果 (页面会显示 You clicked: Cancel)</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Cancel&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Confirm 已取消&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 3: 处理 Prompt (输入 + 确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 点击 Prompt 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Prompt&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Prompt 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 输入内容</span><br><span class="hljs-comment"># 注意：在 Chrome 中，你可能看不到字打进去的动画，但实际上已经输入了</span><br>alert.send_keys(<span class="hljs-string">&quot;Selenium 练习生&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><br><span class="hljs-comment"># 验证结果</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Selenium 练习生&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Prompt 输入并确认成功&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问：</strong> “页面上弹出了一个框，你用 <code>switch_to.alert</code> 报错说 <code>NoAlertPresentException</code>，为什么？”</p><p><strong>答：</strong></p><blockquote><p>“这说明那个弹窗<strong>不是</strong>浏览器原生的 Alert，而是前端用 HTML&#x2F;CSS（比如 Bootstrap 的 Modal）画出来的<strong>伪弹窗</strong>。</p><p><strong>怎么区分？</strong></p><ul><li><strong>原生 Alert</strong>：右键点击弹窗，<strong>没有</strong>‘检查&#x2F;Inspect’选项，且弹窗出现时浏览器无法操作其他地方。</li><li><strong>HTML 模态框</strong>：右键可以‘检查’，本质上就是个 <code>div</code>。</li></ul><p><strong>处理方法</strong>：</p><ul><li>如果是原生的：用 <code>driver.switch_to.alert</code>。</li><li>如果是 HTML 的：直接用 <code>driver.find_element</code> 定位上面的按钮，然后 <code>click()</code> 即可。”</li></ul></blockquote><hr><h3 id="进阶技巧：显式等待处理-Alert"><a href="#进阶技巧：显式等待处理-Alert" class="headerlink" title="进阶技巧：显式等待处理 Alert"></a>进阶技巧：显式等待处理 Alert</h3><p>有时候点击按钮后，Alert 弹窗不是立刻出来的（比如要请求服务器）。这时候直接 <code>switch_to.alert</code> 会报错。</p><p><strong>解决方案</strong>：使用 <code>EC.alert_is_present()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-comment"># 点击按钮</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br><br><span class="hljs-comment"># 显式等待：直到弹窗出现，并自动切换过去返回 alert 对象</span><br>alert = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.alert_is_present())<br><br><span class="hljs-comment"># 直接操作</span><br>alert.accept()<br></code></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Alert 处理非常简单，记住：</p><ol><li><code>switch_to.alert</code></li><li><code>accept()</code> &#x2F; <code>dismiss()</code></li><li><code>send_keys()</code></li></ol><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image15.png" class="" title="鼠标操作"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image16.png" class="" title="键盘操作"><p>普通的 <code>click()</code> 和 <code>send_keys()</code> 只能处理简单的交互。遇到以下场景，就必须请出 <strong><code>ActionChains</code></strong> 类：</p><ol><li><strong>鼠标悬停 (Hover)</strong>：鼠标移上去才显示下拉菜单（如京东&#x2F;淘宝的商品分类）。</li><li><strong>拖拽 (Drag &amp; Drop)</strong>：滑块验证码、拖动文件上传。</li><li><strong>右键&#x2F;双击</strong>：网页游戏或复杂的后台管理系统。</li><li><strong>键盘组合键</strong>：Ctrl+C, Ctrl+V, 按 Enter 提交。</li></ol><hr><h3 id="核心概念：动作链-Chain"><a href="#核心概念：动作链-Chain" class="headerlink" title="核心概念：动作链 (Chain)"></a>核心概念：动作链 (Chain)</h3><p><code>ActionChains</code> 的工作原理像<strong>录像机</strong>：</p><ol><li>先把一连串的动作（移动、点击、按键）<strong>排队</strong>放进队列里。</li><li>最后必须调用 <strong><code>.perform()</code></strong> 方法，Selenium 才会真正去执行这些动作。</li></ol><hr><h3 id="第一部分：鼠标操作-Mouse-Actions"><a href="#第一部分：鼠标操作-Mouse-Actions" class="headerlink" title="第一部分：鼠标操作 (Mouse Actions)"></a>第一部分：鼠标操作 (Mouse Actions)</h3><h4 id="实战-1：鼠标悬停-Hover-——-百度设置"><a href="#实战-1：鼠标悬停-Hover-——-百度设置" class="headerlink" title="实战 1：鼠标悬停 (Hover) —— 百度设置"></a>实战 1：鼠标悬停 (Hover) —— 百度设置</h4><p><strong>场景</strong>：<br>在百度首页，鼠标如果不移到右上角的“设置”上，下拉菜单是不会出来的，你也点不到里面的“高级搜索”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains <span class="hljs-comment"># 1. 引入 ActionChains</span><br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># 定位“设置”元素</span><br>settings_btn = driver.find_element(By.ID, <span class="hljs-string">&quot;s-usersetting-top&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤 ---</span><br><span class="hljs-comment"># 链式写法：初始化 -&gt; 移动鼠标 -&gt; 执行</span><br><span class="hljs-comment"># 翻译：把鼠标移到 settings_btn 上，然后执行！</span><br>ActionChains(driver).move_to_element(settings_btn).perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;鼠标已悬停，菜单应该出来了&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿一下让你看清楚</span><br><br><span class="hljs-comment"># 现在菜单出来了，可以点击里面的“高级搜索”了</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已点击高级搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h4 id="实战-2：拖拽-Drag-and-Drop"><a href="#实战-2：拖拽-Drag-and-Drop" class="headerlink" title="实战 2：拖拽 (Drag and Drop)"></a>实战 2：拖拽 (Drag and Drop)</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/drag_and_drop</code><br><strong>任务</strong>：把方块 A 拖到 方块 B 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/drag_and_drop&quot;</span>)<br><br><span class="hljs-comment"># 1. 定位源元素 (A) 和 目标元素 (B)</span><br>source_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-a&quot;</span>)<br>target_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-b&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备拖拽 A 到 B...&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 执行拖拽</span><br>actions = ActionChains(driver)<br>actions.drag_and_drop(source_ele, target_ele).perform()<br><br><span class="hljs-comment"># 验证：检查 A 的文字是不是变了（这个网页拖拽成功后 header 会互换）</span><br><span class="hljs-comment"># 注意：DOM 里的 ID 不会变，但里面的 text 会变</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;拖拽完成！&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二部分：键盘操作-Keyboard-Actions"><a href="#第二部分：键盘操作-Keyboard-Actions" class="headerlink" title="第二部分：键盘操作 (Keyboard Actions)"></a>第二部分：键盘操作 (Keyboard Actions)</h3><h4 id="实战-3：组合键操作-Ctrl-A-Ctrl-C"><a href="#实战-3：组合键操作-Ctrl-A-Ctrl-C" class="headerlink" title="实战 3：组合键操作 (Ctrl+A, Ctrl+C)"></a>实战 3：组合键操作 (Ctrl+A, Ctrl+C)</h4><p><strong>场景</strong>：</p><ol><li>在百度搜索框输入 “Python”。</li><li><strong>Ctrl + A</strong> 全选。</li><li><strong>Ctrl + X</strong> 剪切。</li><li><strong>Ctrl + V</strong> 粘贴。</li><li><strong>Enter</strong> 回车搜索（不点按钮）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys <span class="hljs-comment"># 引入 Keys</span><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br><span class="hljs-comment"># 定位搜索框</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br><br><span class="hljs-comment"># 1. 正常输入</span><br>search_input.send_keys(<span class="hljs-string">&quot;Python&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 模拟组合键：Ctrl + A (全选)</span><br><span class="hljs-comment"># key_down(按下) -&gt; send_keys(A) -&gt; key_up(松开)</span><br>ActionChains(driver)\<br>    .key_down(Keys.CONTROL)\<br>    .send_keys(<span class="hljs-string">&quot;a&quot;</span>)\<br>    .key_up(Keys.CONTROL)\<br>    .perform()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已全选&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 模拟组合键：Ctrl + X (剪切)</span><br><span class="hljs-comment"># 其实 send_keys 也可以直接传组合键，不用 ActionChains 也可以，这是简便写法：</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已剪切&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 4. 模拟组合键：Ctrl + V (粘贴)</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;v&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已粘贴&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 5. 模拟回车键 (提交搜索)</span><br><span class="hljs-comment"># 很多时候不用去找“百度一下”按钮，直接回车更稳</span><br>search_input.send_keys(Keys.ENTER)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已回车搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传分为两种情况，处理方式天差地别：</p><ol><li><strong>标准控件 (<code>&lt;input type=&quot;file&quot;&gt;</code>)</strong>：Selenium 可以轻松搞定。</li><li><strong>非标准控件 (Flash&#x2F;JS&#x2F;Div)</strong>：Selenium <strong>无能为力</strong>，必须借助外挂。</li></ol><hr><h3 id="情况一：标准-Input-标签-90-的情况"><a href="#情况一：标准-Input-标签-90-的情况" class="headerlink" title="情况一：标准 Input 标签 (90% 的情况)"></a>情况一：标准 Input 标签 (90% 的情况)</h3><p>如果网页上的上传按钮对应的 HTML 标签是 <code>&lt;input type=&quot;file&quot; ...&gt;</code>，这是最简单的情况。</p><p><strong>核心秘诀：千万不要点击上传按钮！</strong></p><ul><li><strong>错误做法</strong>：你点击按钮 -&gt; 操作系统弹出一个“文件选择框” -&gt; Selenium 傻眼了（因为它控制不了操作系统窗口）。</li><li><strong>正确做法</strong>：直接把<strong>文件路径</strong> <code>send_keys</code> 给那个 input 元素。</li></ul><h4 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br><span class="hljs-comment"># 1. 准备文件路径</span><br><span class="hljs-comment"># 建议使用绝对路径，防止因为运行目录不同找不到文件</span><br><span class="hljs-comment"># 假设当前目录下有一个 test.txt</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;准备上传的文件路径: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 定位上传控件</span><br><span class="hljs-comment"># 注意：我们要找的是那个 input 标签，而不是那个漂亮的“Choose File”按钮</span><br><span class="hljs-comment"># 哪怕 input 是隐藏的，只要能定位到就行</span><br>upload_input = driver.find_element(By.ID, <span class="hljs-string">&quot;file-upload&quot;</span>)<br><br><span class="hljs-comment"># 3. 核心步骤：直接发送路径</span><br><span class="hljs-comment"># 这一步相当于：Selenium 帮你把路径填进去，并自动触发了文件选择</span><br>upload_input.send_keys(file_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已发送文件路径&quot;</span>)<br><br><span class="hljs-comment"># 4. 点击“Upload”按钮 (提交表单)</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;file-submit&quot;</span>).click()<br><br><span class="hljs-comment"># 5. 验证结果</span><br>uploaded_text = driver.find_element(By.ID, <span class="hljs-string">&quot;uploaded-files&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面显示已上传: <span class="hljs-subst">&#123;uploaded_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;test.txt&quot;</span> <span class="hljs-keyword">in</span> uploaded_text<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="情况二：非标准控件-面试难点"><a href="#情况二：非标准控件-面试难点" class="headerlink" title="情况二：非标准控件 (面试难点)"></a>情况二：非标准控件 (面试难点)</h3><p>有些网站（比如花哨的图片上传插件），找不到 <code>&lt;input&gt;</code> 标签，或者那个标签被复杂的 JS 逻辑包裹，<code>send_keys</code> 不生效。必须点击按钮，弹出 Windows&#x2F;Mac 的文件选择框才能上传。</p><p><strong>Selenium 的局限性</strong>：Selenium 只能控制浏览器，<strong>控制不了操作系统的弹窗</strong>。</p><p><strong>解决方案</strong>：<br>需要引入“外援”来控制鼠标和键盘。</p><h4 id="1-PyAutoGUI-Python-库，推荐"><a href="#1-PyAutoGUI-Python-库，推荐" class="headerlink" title="1. PyAutoGUI (Python 库，推荐)"></a>1. PyAutoGUI (Python 库，推荐)</h4><p>这是一个能控制鼠标键盘的 Python 库。</p><ul><li><strong>思路</strong>：Selenium 点击按钮 -&gt; 弹窗出现 -&gt; PyAutoGUI 输入路径 -&gt; PyAutoGUI 按回车。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要先安装: pip install pyautogui</span><br><span class="hljs-keyword">import</span> pyautogui<br><br><span class="hljs-comment"># ... Selenium 点击按钮的代码 ...</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;upload_btn&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等弹窗出来</span><br><br><span class="hljs-comment"># 使用 PyAutoGUI 操作 Windows 弹窗</span><br>pyautogui.write(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>) <span class="hljs-comment"># 输入路径</span><br>pyautogui.press(<span class="hljs-string">&quot;enter&quot;</span>)        <span class="hljs-comment"># 按回车</span><br></code></pre></td></tr></table></figure><ul><li><strong>缺点</strong>：脚本运行时，<strong>鼠标焦点必须在浏览器上</strong>，你不能去干别的事，否则会输错地方。而且在“无头模式”（Headless，后台运行）下无法使用。</li></ul><h4 id="2-AutoIt-Windows-老牌工具"><a href="#2-AutoIt-Windows-老牌工具" class="headerlink" title="2. AutoIt (Windows 老牌工具)"></a>2. AutoIt (Windows 老牌工具)</h4><p>写一个 <code>.exe</code> 脚本来处理弹窗，Python 调用这个 exe。</p><ul><li><strong>缺点</strong>：学习成本高，只能在 Windows 上用，现在用的人越来越少了。</li></ul><hr><p><strong>问：</strong> “如果上传按钮不是 input 标签，或者 input 标签是 hidden（隐藏）的，怎么处理？”</p><p><strong>答：</strong></p><blockquote><p>“如果是 <code>input</code> 标签被 <code>hidden</code> 隐藏了：</p><ol><li>我会先尝试用 JS (<code>execute_script</code>) 把它的 <code>style.display</code> 改为 <code>block</code> 让它显示出来。</li><li>然后直接用 <code>send_keys</code> 上传，这是最稳的。</li></ol><p>如果根本没有 <code>input</code> 标签，必须操作 OS 弹窗：</p><ul><li>我会使用 <strong>PyAutoGUI</strong> 这样的第三方库来模拟键盘输入路径并回车。</li><li>但在 CI&#x2F;CD 流水线（无界面环境）中这会失效，所以我会尽量和开发沟通，让他们提供一个可供自动化调用的上传接口。”</li></ul></blockquote><hr><h1 id="日期选择"><a href="#日期选择" class="headerlink" title="日期选择"></a>日期选择</h1><ol><li><strong>结构复杂</strong>：通常是嵌套了无数层 <code>div</code>、<code>table</code> 的控件。</li><li><strong>只读限制</strong>：很多输入框有 <code>readonly=&quot;readonly&quot;</code> 属性，禁止你直接输入，强制你点日历。</li><li><strong>翻页麻烦</strong>：如果要选“去年”或者“下个月”，你得写循环去点“上一页&#x2F;下一页”，非常容易出错。</li></ol><hr><h3 id="中策：直接输入-send-keys"><a href="#中策：直接输入-send-keys" class="headerlink" title="中策：直接输入 (send_keys)"></a>中策：直接输入 (send_keys)</h3><p>如果开发比较“仁慈”，没有给输入框加 <code>readonly</code> 属性，或者允许键盘输入。</p><ul><li><p><strong>做法</strong>：</p><ol><li><code>clear()</code> 清空（或者 Ctrl+A -&gt; Delete）。</li><li><code>send_keys(&quot;2023-12-12&quot;)</code>。</li><li>按 <code>Keys.TAB</code> 或点击空白处让日历收起来。</li></ol></li><li><p><strong>注意</strong>：要注意日期的格式（是 <code>yyyy-mm-dd</code> 还是 <code>yyyy/mm/dd</code>），输错了网页会报错。</p></li></ul><hr><h3 id="上策：JS-强行祛除“只读”属性-The-Killer-Move"><a href="#上策：JS-强行祛除“只读”属性-The-Killer-Move" class="headerlink" title="上策：JS 强行祛除“只读”属性 (The Killer Move)"></a>上策：JS 强行祛除“只读”属性 (The Killer Move)</h3><p><strong>原理</strong>：<br>既然 Selenium 控制不了日历控件，那我就用 JS 把输入框的 <code>readonly</code> 属性撕掉！把它变成一个普通的输入框，然后直接填值。</p><h4 id="JS-暴力填单"><a href="#JS-暴力填单" class="headerlink" title="JS 暴力填单"></a>JS 暴力填单</h4><p>假设 HTML 长这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有 readonly，不让你直接输 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;train_date&quot;</span> <span class="hljs-attr">readonly</span>=<span class="hljs-string">&quot;readonly&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.12306.cn/index/&quot;</span>) <span class="hljs-comment"># 以 12306 为例</span><br><br><span class="hljs-comment"># 1. 定位日期输入框</span><br><span class="hljs-comment"># 12306 的出发日期 id 是 &#x27;train_date&#x27;</span><br>date_input = driver.find_element(By.ID, <span class="hljs-string">&quot;train_date&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：JS 祛除 readonly ---</span><br><br><span class="hljs-comment"># 这段 JS 的意思是：找到这个元素(arguments[0])，移除它的 readonly 属性</span><br>js_remove_readonly = <span class="hljs-string">&quot;arguments[0].removeAttribute(&#x27;readonly&#x27;);&quot;</span><br>driver.execute_script(js_remove_readonly, date_input)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已移除只读属性&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：清空并输入 ---</span><br><br><span class="hljs-comment"># 2. 清空原有的日期</span><br>date_input.clear()<br><br><span class="hljs-comment"># 3. 输入你想去的日期</span><br><span class="hljs-comment"># 注意：12306 这种网站对格式要求很严，必须是 yyyy-mm-dd</span><br>date_input.send_keys(<span class="hljs-string">&quot;2025-01-01&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入日期: 2025-01-01&quot;</span>)<br><br><span class="hljs-comment"># 4. (可选) 有时候输入完日历还在遮挡视线，可以点一下别的地方</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>).click()<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="进阶坑点：Vue-React-框架的日期控件"><a href="#进阶坑点：Vue-React-框架的日期控件" class="headerlink" title="进阶坑点：Vue&#x2F;React 框架的日期控件"></a>进阶坑点：Vue&#x2F;React 框架的日期控件</h3><p>现在的网站很多是用 Vue 或 React 写的。<br>可能会发现：<strong>用上面的方法 <code>send_keys</code> 填进去了，但一点“查询”，日期又变回去了！</strong></p><p><strong>原因</strong>：<br>这些前端框架是“双向绑定”的。光改了 HTML 里的 value，但没有触发网页的 <code>input</code> 或 <code>change</code> 事件，框架不知道改了值。</p><p><strong>解决方案 (JS 直接赋值)</strong>：<br>不要用 <code>send_keys</code>，直接用 JS 修改 value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 针对 Vue/React 等难搞的控件</span><br><span class="hljs-comment"># 直接把 value 改掉，一步到位</span><br>js_value = <span class="hljs-string">&quot;arguments[0].value = &#x27;2025-01-01&#x27;;&quot;</span><br>driver.execute_script(js_value, date_input)<br></code></pre></td></tr></table></figure><hr><h1 id="联想输入框"><a href="#联想输入框" class="headerlink" title="联想输入框"></a>联想输入框</h1><p>它的难点在于：<strong>选项是动态加载的</strong>。</p><ol><li>输入“电脑”。</li><li>浏览器发送请求给服务器。</li><li>服务器返回数据，前端再渲染出一个下拉列表（通常是 <code>&lt;ul&gt;&lt;li&gt;</code> 或 <code>&lt;div&gt;</code> 结构）。</li><li>这个过程有<strong>延迟</strong>，必须处理好等待。</li></ol><hr><h3 id="方法一：XPath-文本定位"><a href="#方法一：XPath-文本定位" class="headerlink" title="方法一：XPath 文本定位"></a>方法一：XPath 文本定位</h3><p>如果明确知道想选哪一个（比如输入 “selenium”，你想选 “selenium教程”），直接用 XPath 的文本匹配去点。</p><p><strong>核心逻辑</strong>：<br>输入 -&gt; <strong>显式等待</strong>列表出现 -&gt; <strong>XPath 定位包含特定文字的元素</strong> -&gt; 点击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.zhihu.com/&quot;</span>)<br>driver.maximize_window()<br><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 输入关键词</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;Popover1-toggle&quot;</span>).send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br><br><span class="hljs-comment"># 2. 【关键】显式等待联想框出现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待联想选项出现...&quot;</span>)<br><br>target_text = <span class="hljs-string">&quot;selenium被淘汰了吗&quot;</span><br><br><span class="hljs-comment"># XPath 解析：在所有 span 标签中，找到文本包含 &#x27;selenium被淘汰了吗&#x27; 的那个</span><br><span class="hljs-comment"># 注意：联想词通常在 li 标签或者 div 标签或者 span里</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.XPATH, <span class="hljs-string">f&quot;//span[contains(., &#x27;<span class="hljs-subst">&#123;target_text&#125;</span>&#x27;)]&quot;</span>))<br>)<br><br><span class="hljs-comment"># 3. 点击它</span><br>target_element.click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已点击选项: <span class="hljs-subst">&#123;target_text&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="方法二：循环遍历法"><a href="#方法二：循环遍历法" class="headerlink" title="方法二：循环遍历法"></a>方法二：循环遍历法</h3><p>有时候 XPath 文本匹配可能会因为空格、换行符导致定位失败。或者想打印出所有联想词看看。这时候可以用<strong>遍历法</strong>。</p><p><strong>核心逻辑</strong>：</p><ol><li>找到所有的选项元素（返回一个 List）。</li><li>用 <code>for</code> 循环一个一个看。</li><li>如果文字对上了，就点击，然后 <code>break</code> 跳出循环。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面输入代码一样 ...</span><br><br><span class="hljs-comment"># 1. 等待任意一个选项出现，确保列表加载了</span><br>WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>))<br>)<br><br><span class="hljs-comment"># 2. 获取所有选项列表</span><br><span class="hljs-comment"># 百度联想项的 CSS 通常是 .bdsug li (具体要按 F12 确认)</span><br>options = driver.find_elements(By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;一共找到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(options)&#125;</span> 个联想词&quot;</span>)<br><br><span class="hljs-comment"># 3. 循环遍历</span><br>want_to_click = <span class="hljs-string">&quot;selenium安装教程&quot;</span><br><br><span class="hljs-keyword">for</span> option <span class="hljs-keyword">in</span> options:<br>    <span class="hljs-comment"># 获取当前选项的文本</span><br>    text = option.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发现选项: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 模糊匹配：如果我想点的词在选项里</span><br>    <span class="hljs-keyword">if</span> want_to_click <span class="hljs-keyword">in</span> text:<br>        option.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功点击: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找了一圈没找到你要的词&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="方法三：键盘操作法"><a href="#方法三：键盘操作法" class="headerlink" title="方法三：键盘操作法"></a>方法三：键盘操作法</h3><p>如果你不在乎具体选哪个，或者列表结构太复杂（比如嵌套了无数层 div），你可以模拟键盘的 <strong>“向下箭头” + “回车”</strong>。</p><p><strong>场景</strong>：输入后，默认选第一个联想词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<br><br><span class="hljs-comment"># 1. 输入文本</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br>search_input.send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等一下列表出来</span><br><br><span class="hljs-comment"># 2. 模拟按键：向下箭头 -&gt; 向下箭头 -&gt; 回车</span><br><span class="hljs-comment"># 选第二个联想词</span><br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ENTER)<br></code></pre></td></tr></table></figure><hr><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><h2 id="1-基本交互方法"><a href="#1-基本交互方法" class="headerlink" title="1. 基本交互方法"></a>1. <strong>基本交互方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/challenging_dom&quot;</span>) <span class="hljs-comment"># 这里只是举例，找个有 canvas 的网页很难，假设页面有个 id=&#x27;myCanvas&#x27;</span><br><br><span class="hljs-comment"># 1. 定位 Canvas 元素本身</span><br><span class="hljs-comment"># canvas = driver.find_element(By.ID, &quot;myCanvas&quot;) </span><br><span class="hljs-comment"># 为了演示代码不报错，我用 body 代替 canvas 演示动作</span><br>canvas = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义裁剪的动作</span><br><span class="hljs-comment"># 假设：裁剪框的起始点在画布 (100, 100) 的位置</span><br><span class="hljs-comment"># 假设：我们要向右下角拖拽，宽 200，高 150</span><br><br>action = ActionChains(driver)<br><br><span class="hljs-comment"># 步骤分解：</span><br><span class="hljs-comment"># A. 移动鼠标到画布的 (100, 100) 位置</span><br><span class="hljs-comment"># 注意：move_to_element_with_offset 是相对于元素的左上角</span><br>action.move_to_element_with_offset(canvas, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># B. 按下鼠标左键 (不松开)</span><br>action.click_and_hold()<br><br><span class="hljs-comment"># C. 拖拽鼠标 (相对移动)</span><br><span class="hljs-comment"># 向右移动 200px，向下移动 150px</span><br>action.move_by_offset(<span class="hljs-number">200</span>, <span class="hljs-number">150</span>)<br><br><span class="hljs-comment"># D. 松开鼠标</span><br>action.release()<br><br><span class="hljs-comment"># E. 执行！</span><br>action.perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已完成 Canvas 上的拖拽操作&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-JavaScript-执行方法"><a href="#2-JavaScript-执行方法" class="headerlink" title="2. JavaScript 执行方法"></a>2. <strong>JavaScript 执行方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取像素数据</span><br>script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);</span><br><span class="hljs-string">return Array.from(imageData.data);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>pixel_data = driver.execute_script(script, canvas)<br><br><span class="hljs-comment"># 在 Canvas 上绘制</span><br>draw_script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">ctx.fillStyle = &#x27;red&#x27;;</span><br><span class="hljs-string">ctx.fillRect(10, 10, 50, 50);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>driver.execute_script(draw_script, canvas)<br></code></pre></td></tr></table></figure><hr><h1 id="PO模式"><a href="#PO模式" class="headerlink" title="PO模式"></a>PO模式</h1><h3 id="1-什么是-PO-模式？"><a href="#1-什么是-PO-模式？" class="headerlink" title="1. 什么是 PO 模式？"></a>1. 什么是 PO 模式？</h3><p><strong>核心思想</strong>：<strong>页面（Page）与测试逻辑（Test）分离</strong>。</p><ul><li><strong>没有 PO 模式</strong>：想吃宫保鸡丁，直接冲进厨房，自己切鸡肉、自己炒菜、自己吃。（测试脚本里混杂了定位元素、点击操作、断言逻辑）。</li><li><strong>用了 PO 模式</strong>：<ul><li><strong>Page (菜单)</strong>：厨房封装好了“宫保鸡丁”这道菜（封装了定位和操作）。</li><li><strong>Test (顾客)</strong>：只需要对着菜单喊一声“我要一份宫保鸡丁”（调用方法），不需要知道厨房里是怎么切菜的。</li></ul></li></ul><hr><h3 id="2-为什么要用它"><a href="#2-为什么要用它" class="headerlink" title="2. 为什么要用它"></a>2. 为什么要用它</h3><p>假设有 50 条测试用例都涉及“登录”。<br>有一天，前端开发把登录按钮的 <code>id=&quot;login-btn&quot;</code> 改成了 <code>id=&quot;submit-btn&quot;</code>。</p><ul><li><strong>惨状（无 PO）</strong>：需要打开 50 个测试文件，一个一个查找替换。</li><li><strong>优雅（有 PO）</strong>：只需要打开 <code>LoginPage.py</code> 这<strong>一个</strong>文件，修改一行代码。50 条用例自动修复。</li></ul><hr><h3 id="3-PO-模式的三层架构"><a href="#3-PO-模式的三层架构" class="headerlink" title="3. PO 模式的三层架构"></a>3. PO 模式的三层架构</h3><p>把代码拆分成三个文件夹（层级）：</p><ol><li><strong><code>base/</code> (基类层)</strong>：<strong>地基</strong>。封装 Selenium 最底层的 <code>find_element</code>、<code>click</code> 等方法，加上显式等待。</li><li><strong><code>pages/</code> (页面层)</strong>：<strong>菜单</strong>。每个页面写一个类（如 <code>LoginPage</code>），只存放<strong>元素定位</strong>和<strong>页面操作</strong>。</li><li><strong><code>test_cases/</code> (测试层)</strong>：<strong>顾客</strong>。只写<strong>业务逻辑</strong>和<strong>断言</strong>。</li></ol><hr><h3 id="4-手把手代码实战"><a href="#4-手把手代码实战" class="headerlink" title="4. 手把手代码实战"></a>4. 手把手代码实战</h3><p>我们以 <strong>SauceDemo</strong> 登录为例。</p><h4 id="第一步：搭建项目结构"><a href="#第一步：搭建项目结构" class="headerlink" title="第一步：搭建项目结构"></a>第一步：搭建项目结构</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">AutoTestProject/<br>├── base/<br>│   └── base_page.py      # 封装底层 Selenium<br>├── pages/<br>│   └── login_page.py     # 登录页面的元素和操作<br>└── test_cases/<br>    └── test_login.py     # 具体的测试脚本<br></code></pre></td></tr></table></figure><h4 id="第二步：编写基类-base-base-page-py"><a href="#第二步：编写基类-base-base-page-py" class="headerlink" title="第二步：编写基类 (base/base_page.py)"></a>第二步：编写基类 (<code>base/base_page.py</code>)</h4><p>这一层的目的是：<strong>让页面层不需要直接接触 <code>driver</code> 的原生 API，而是用我们封装好的更稳定的方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, driver</span>):<br>        <span class="hljs-variable language_">self</span>.driver = driver<br><br>    <span class="hljs-comment"># 封装 find_element，加入显式等待，从此告别 NoSuchElementException</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-comment"># locator 比如是 (By.ID, &quot;user-name&quot;)</span><br>        <span class="hljs-keyword">return</span> WebDriverWait(<span class="hljs-variable language_">self</span>.driver, <span class="hljs-number">10</span>).until(<br>            EC.visibility_of_element_located(locator)<br>        )<br><br>    <span class="hljs-comment"># 封装输入</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_keys</span>(<span class="hljs-params">self, locator, text</span>):<br>        ele = <span class="hljs-variable language_">self</span>.find(locator)<br>        ele.clear() <span class="hljs-comment"># 输入前先清空，好习惯</span><br>        ele.send_keys(text)<br><br>    <span class="hljs-comment"># 封装点击</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-variable language_">self</span>.find(locator).click()<br>        <br>    <span class="hljs-comment"># 封装获取文本（用于断言）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_text</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.find(locator).text<br></code></pre></td></tr></table></figure><h4 id="第三步：编写页面层-pages-login-page-py"><a href="#第三步：编写页面层-pages-login-page-py" class="headerlink" title="第三步：编写页面层 (pages/login_page.py)"></a>第三步：编写页面层 (<code>pages/login_page.py</code>)</h4><p>这一层<strong>严禁出现断言（assert）</strong>，只负责描述页面长什么样、能干什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> base.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 核心：元素定位 (Locators) ---</span><br>    <span class="hljs-comment"># 把页面上用到的元素 ID 都写在这里，以后改 ID 只要改这里</span><br>    _USERNAME_INPUT = (By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>    _PASSWORD_INPUT = (By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>    _LOGIN_BTN = (By.ID, <span class="hljs-string">&quot;login-button&quot;</span>)<br>    _ERROR_MSG = (By.CSS_SELECTOR, <span class="hljs-string">&quot;h3[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：页面操作 (Actions) ---</span><br>    <br>    <span class="hljs-comment"># 定义一个登录动作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, user, pwd</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在登录账号: <span class="hljs-subst">&#123;user&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 调用父类 BasePage 的方法，而不是直接用 driver</span><br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._USERNAME_INPUT, user)<br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._PASSWORD_INPUT, pwd)<br>        <span class="hljs-variable language_">self</span>.click(<span class="hljs-variable language_">self</span>._LOGIN_BTN)<br><br>    <span class="hljs-comment"># 获取错误提示文字</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_msg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.get_text(<span class="hljs-variable language_">self</span>._ERROR_MSG)<br></code></pre></td></tr></table></figure><h4 id="第四步：编写测试层-test-cases-test-login-py"><a href="#第四步：编写测试层-test-cases-test-login-py" class="headerlink" title="第四步：编写测试层 (test_cases/test_login.py)"></a>第四步：编写测试层 (<code>test_cases/test_login.py</code>)</h4><p>这一层只能调用 Page 对象的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 模拟一个测试用例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_logic</span>():<br>    <span class="hljs-comment"># 1. 启动浏览器 (这一步以后会交给 Pytest fixture 做)</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 初始化页面对象</span><br>    <span class="hljs-comment"># 把 driver 传给 LoginPage，这样 LoginPage 才能操作浏览器</span><br>    login_page = LoginPage(driver)<br><br>    <span class="hljs-comment"># --- 用例 1: 登录成功 ---</span><br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 断言：判断 URL 是否跳转</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例1通过：登录成功&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 用例1失败&quot;</span>)<br><br>    <span class="hljs-comment"># --- 准备测下一个用例，先退出或重启浏览器 ---</span><br>    <span class="hljs-comment"># 这里为了演示简单，我们直接重启</span><br>    driver.quit()<br>    <br>    <span class="hljs-comment"># --- 用例 2: 登录失败 ---</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>    login_page = LoginPage(driver)<br>    <br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_password&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取页面上的错误提示</span><br>    error_text = login_page.get_error_msg()<br>    <br>    <span class="hljs-comment"># 断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例2通过：错误提示正确&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 用例2失败，实际提示: <span class="hljs-subst">&#123;error_text&#125;</span>&quot;</span>)<br>        <br>    driver.quit()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    test_login_logic()<br></code></pre></td></tr></table></figure><hr><h3 id="5-PO-模式的“六大原则”-面试加分项"><a href="#5-PO-模式的“六大原则”-面试加分项" class="headerlink" title="5. PO 模式的“六大原则” (面试加分项)"></a>5. PO 模式的“六大原则” (面试加分项)</h3><p>你在设计 PO 模式时遵循什么原则？</p><ol><li><strong>公共方法封装在 BasePage</strong>：不要在每个 Page 里重复写显式等待。</li><li><strong>页面元素与测试数据分离</strong>：Page 类里不要写死 “standard_user”，数据要从 Test 层传进来。</li><li><strong>Page 层不写断言</strong>：Page 层只负责“做动作”和“返回结果”，断言（判断对错）是 Test 层的事。</li><li><strong>方法名要有业务含义</strong>：用 <code>login()</code> 而不是 <code>type_username_and_click()</code>。</li><li><strong>不要暴露内部元素</strong>：Test 层不应该能访问到 <code>By.ID</code>，只能调用方法。</li><li><strong>返回新页面对象 (进阶)</strong>：点击登录后，<code>login()</code> 方法最好返回一个 <code>InventoryPage</code> 对象（链式调用）。</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web自动化测试</tag>
      
      <tag>python</tag>
      
      <tag>selenium</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/2025/12/10/Python%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/12/10/Python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: 演示定义汽车类 及  使用类中的成员.</span><br><span class="hljs-string"></span><br><span class="hljs-string">面向对象核心概念:</span><br><span class="hljs-string">    类: 抽象的概念, 看不见, 摸不着, 是 属性(名词) 和 行为(动词)的集合.</span><br><span class="hljs-string">    对象: 类的具体体现, 实现.</span><br><span class="hljs-string">    属性(名词): 用来描述事物的外在特征的, 例如: 姓名, 年龄...</span><br><span class="hljs-string">        格式: 和以前定义变量一样.</span><br><span class="hljs-string">    行为(动词): 用来描述事物能够做什么的, 例如: 吃, 喝...</span><br><span class="hljs-string">        格式: 和以前定义函数一样.</span><br><span class="hljs-string"></span><br><span class="hljs-string">定义类的格式:</span><br><span class="hljs-string">    class 类名:</span><br><span class="hljs-string">        # 属性</span><br><span class="hljs-string">        # 行为</span><br><span class="hljs-string"></span><br><span class="hljs-string">如何访问类中的成员?</span><br><span class="hljs-string">    step1: 创建该类的对象.</span><br><span class="hljs-string">        对象名 = 类名()</span><br><span class="hljs-string">    step2: 通过 对象名. 的方式调用.</span><br><span class="hljs-string">        对象性.属性名</span><br><span class="hljs-string">        对象名.行为名()</span><br><span class="hljs-string"></span><br><span class="hljs-string">需求: 定义汽车类, 有跑的行为.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 1.定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:      <span class="hljs-comment"># 类名遵循 大驼峰命名法.</span><br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><br><span class="hljs-comment"># 3. 调用Car类的run()函数, 简写版: 调用Car#run()</span><br>c1.run()<br></code></pre></td></tr></table></figure><hr><h2 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: self关键字介绍.</span><br><span class="hljs-string"></span><br><span class="hljs-string">self介绍:</span><br><span class="hljs-string">    概述:</span><br><span class="hljs-string">        它是Python内置的关键字, 用于表示 本类当前对象的引用.</span><br><span class="hljs-string">    作用:</span><br><span class="hljs-string">        1个类是可以有多个对象的, 这多个对象都可以通过 对象名. 的方式访问类中的行为(函数)</span><br><span class="hljs-string">        函数默认有self属性, 函数通过self来区分到底是哪个对象调用的该函数.</span><br><span class="hljs-string">    大白话:</span><br><span class="hljs-string">        谁调用函数, self就代表哪个对象.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 需求: 定义汽车类, 创建多个该类的对象, 看看打印结果.</span><br><span class="hljs-comment"># 1. 定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为, 跑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是run函数, self的值是: <span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1对象: <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c1.run()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">34</span>)<br><br><span class="hljs-comment"># 3.继续创建汽车类的对象.</span><br>c2 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2对象: <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c2.run()<br></code></pre></td></tr></table></figure><hr><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/self.png" class="" title="self"><p>这张图非常生动地展示了 <strong>Python 面向对象编程（OOP）中的内存管理机制</strong>，特别是<strong>对象（Object）与引用（Reference）的关系，以及实例属性</strong>是如何存储的。</p><p>这张图主要分为三个部分：<strong>代码区（左侧）</strong>、<strong>内存结构示意图（右侧，包含栈、堆、方法区）</strong>。</p><p>我将为你详细拆解这张图背后的逻辑：</p><h3 id="1-核心概念：内存的三大区域"><a href="#1-核心概念：内存的三大区域" class="headerlink" title="1. 核心概念：内存的三大区域"></a>1. 核心概念：内存的三大区域</h3><ul><li><strong>栈 (Stack)</strong>：<ul><li>图中的左侧竖条。</li><li><strong>作用</strong>：存储局部变量（即变量名）。在这里存储的是 <code>c1</code> 和 <code>c2</code>。</li><li><strong>本质</strong>：它们只是**引用（Reference）**或者说是“标签”，它们本身不存数据，而是指向堆内存中的具体地址（如 <code>0x01</code> 和 <code>0x02</code>）。</li></ul></li><li><strong>堆 (Heap)</strong>：<ul><li>图中的右侧蓝色大框。</li><li><strong>作用</strong>：存储真正的<strong>对象实例</strong>。</li><li><strong>内容</strong>：这里有两个 <code>Car()</code> 对象。每个对象都有自己独立的内存空间（地址 <code>0x01</code> 和 <code>0x02</code>）。对象内部存储该对象的具体数据（属性）。</li></ul></li><li><strong>方法区 (Method Area)</strong>：<ul><li>图中的右下角红色框。</li><li><strong>作用</strong>：存储类的定义和方法的代码。</li><li><strong>关键点</strong>：<code>run(self)</code> 这个方法只有一份代码（地址 <code>0x03</code>）。无论你创建多少个 <code>Car</code> 对象，它们调用的 <code>run</code> 方法都是同一个，不需要为每个对象复制一份代码。</li></ul></li></ul><h3 id="2-代码执行流程与内存变化"><a href="#2-代码执行流程与内存变化" class="headerlink" title="2. 代码执行流程与内存变化"></a>2. 代码执行流程与内存变化</h3><p>让我们跟随左侧的代码，看看内存里发生了什么：</p><h4 id="第一步：创建-c1-对象"><a href="#第一步：创建-c1-对象" class="headerlink" title="第一步：创建 c1 对象"></a>第一步：创建 c1 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c1</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块空间（假设地址 <code>0x01</code>）生成一个 <code>Car</code> 对象。</li><li>在<strong>栈</strong>中创建一个变量 <code>c1</code>。</li><li>将 <code>c1</code> 指向 <code>0x01</code>（图中绿色的箭头）。</li></ol></li><li>此时，<code>c1</code> 对象内部包含一个指向方法区的指针 <code>0x03</code>，以便能调用 <code>run()</code> 方法。</li></ul><h4 id="第二步：给-c1-添加属性（动态属性）"><a href="#第二步：给-c1-添加属性（动态属性）" class="headerlink" title="第二步：给 c1 添加属性（动态属性）"></a>第二步：给 c1 添加属性（动态属性）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">c1.color</span> = <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-attr">c1.number</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ul><li>Python 是动态语言，允许在对象创建后随意添加属性。</li><li>图中的 <code>c1</code> 对象（<code>0x01</code> 盒子）里，现在多了两行数据：<code>color=&#39;红色&#39;</code> 和 <code>number=4</code>。</li><li><strong>注意</strong>：这些数据是<strong>独属于</strong> <code>c1</code> 这个对象的。</li></ul></li></ul><h4 id="第三步：创建-c2-对象"><a href="#第三步：创建-c2-对象" class="headerlink" title="第三步：创建 c2 对象"></a>第三步：创建 c2 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c2</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块<strong>新的</strong>空间（地址 <code>0x02</code>）。</li><li>在<strong>栈</strong>中创建变量 <code>c2</code>。</li><li>将 <code>c2</code> 指向 <code>0x02</code>（图中深红色的箭头）。</li></ol></li><li><strong>关键区别</strong>：<code>c2</code> 是一个全新的对象。虽然它也是 <code>Car</code>，但因为它刚出生，还没有人给它赋值 <code>color</code> 和 <code>number</code>，所以图中的 <code>c2</code> 盒子（<code>0x02</code>）里是<strong>空的</strong>（只有指向方法的 <code>0x03</code>）。</li></ul><h4 id="第四步：代码中的注释细节-细节-3"><a href="#第四步：代码中的注释细节-细节-3" class="headerlink" title="第四步：代码中的注释细节 (细节 3)"></a>第四步：代码中的注释细节 (细节 3)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;颜色: &#123;c2.color&#125;...&#x27;</span>)</span><br></code></pre></td></tr></table></figure><ul><li>这行代码被注释掉了，因为如果运行它会<strong>报错</strong>（AttributeError）。</li><li><strong>原因</strong>：看堆内存图就很清楚，<code>c2</code> 指向的 <code>0x02</code> 盒子里并没有 <code>color</code> 和 <code>number</code> 数据。属性不会自动从 <code>c1</code> 传染给 <code>c2</code>。</li></ul><h3 id="3-图解总结-Key-Takeaways"><a href="#3-图解总结-Key-Takeaways" class="headerlink" title="3. 图解总结 (Key Takeaways)"></a>3. 图解总结 (Key Takeaways)</h3><ol><li><strong>同类不同命</strong>：<code>c1</code> 和 <code>c2</code> 虽然都是 <code>Car</code> 类造出来的，但它们是两个独立的个体。修改 <code>c1</code> 的属性不会影响 <code>c2</code>。</li><li><strong>方法共享，数据独享</strong>：<ul><li><strong>数据（属性）</strong>：存在<strong>堆</strong>里各自的对象中（<code>c1</code> 有颜色，<code>c2</code> 没有）。</li><li><strong>行为（方法）</strong>：存在<strong>方法区</strong>里，大家共用同一个（地址 <code>0x03</code>）。</li></ul></li><li><strong>引用传递</strong>：变量名（<code>c1</code>）只是一个遥控器，它通过内存地址控制真正的对象。</li></ol><hr><p>**问：**如果每个对象调用的方法都指向同一个地址，那假如这个方法中有修改对象属性的逻辑，那岂不是一个对象调用之后，别的对象的属性也被修改了？</p><p>答案是：<strong>完全不会。</strong></p><p>其中的关键就在于 Python 方法中的第一个参数 —— <strong><code>self</code></strong>。</p><p>虽然代码（指令）只有一份，存在方法区里（比如地址 <code>0x03</code>），但<strong>执行这份代码时操作的数据对象</strong>是不同的。</p><h3 id="核心机制：self-就是那个“定位器”"><a href="#核心机制：self-就是那个“定位器”" class="headerlink" title="核心机制：self 就是那个“定位器”"></a>核心机制：<code>self</code> 就是那个“定位器”</h3><p>你可以把方法区里的代码看作是一本**“公用操作手册”**。</p><p>假如 <code>run</code> 方法里有一句代码是修改颜色的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 修改属性</span><br></code></pre></td></tr></table></figure><p>当你调用方法时，Python 在后台做了一个**“隐式传递”**的操作：</p><h4 id="1-当-c1-调用时"><a href="#1-当-c1-调用时" class="headerlink" title="1. 当 c1 调用时"></a>1. 当 <code>c1</code> 调用时</h4><p>你写的是：c1.run()</p><p>Python 实际执行的是：Car.run(c1)  &lt;– 看这里！</p><ul><li>它把 <code>c1</code> 的地址（<code>0x01</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c1.color = &#39;黑色&#39;</code>。</li><li>于是，只有 <strong>堆内存中 0x01 号盒子</strong> 里的 <code>color</code> 变成了黑色。</li></ul><h4 id="2-当-c2-调用时"><a href="#2-当-c2-调用时" class="headerlink" title="2. 当 c2 调用时"></a>2. 当 <code>c2</code> 调用时</h4><p>你写的是：c2.run()</p><p>Python 实际执行的是：Car.run(c2)</p><ul><li>这次它把 <code>c2</code> 的地址（<code>0x02</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c2.color = &#39;黑色&#39;</code>。</li><li>于是，是 <strong>堆内存中 0x02 号盒子</strong> 里的数据被修改了。</li></ul><hr><h2 id="魔术方法init"><a href="#魔术方法init" class="headerlink" title="魔术方法init"></a>魔术方法init</h2><p><strong>init</strong>()魔法方法, 在创建对象的时候, 会被自动调用, 一般用于给该类对象 的属性进行初始化.</p><p>无参版 init -&gt;  默认上的有底色, 你需要重新涂色(覆盖底色)<br>有参版 init -&gt;  默认没有涂色的石膏娃娃, 我们根据喜好自由涂色即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时不需要参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br>        <span class="hljs-variable language_">self</span>.number = <span class="hljs-number">3</span>      <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br><br><span class="hljs-comment"># 情况 A：c2 (保留默认)</span><br>c2 = Car()<br><span class="hljs-comment"># 此时内存里是：黑色, 3</span><br><br><span class="hljs-comment"># 情况 B：c1 (后期改装)</span><br>c1 = Car()          <br><span class="hljs-comment"># 1. 此时内存里也是：黑色, 3</span><br>c1.color = <span class="hljs-string">&#x27;红色&#x27;</span>   <br><span class="hljs-comment"># 2. 【覆盖动作】：找到内存里的&#x27;黑色&#x27;，把它擦掉，换成&#x27;红色&#x27;</span><br>c1.number = <span class="hljs-number">6</span>       <br><span class="hljs-comment"># 3. 【覆盖动作】：找到内存里的3，把它擦掉，换成6</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c2: <span class="hljs-subst">&#123;c2.color&#125;</span>, <span class="hljs-subst">&#123;c2.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：黑色, 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：红色, 6</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时，强制要求传入颜色和数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color    <span class="hljs-comment"># 直接赋值为传入的参数</span><br>        <span class="hljs-variable language_">self</span>.number = number<br><br><span class="hljs-comment"># 【内存动作】：</span><br><span class="hljs-comment"># 在堆内存创建对象时，直接写入 &#x27;红色&#x27; 和 6。</span><br><span class="hljs-comment"># 不需要先写入默认值再擦除。</span><br>c1 = Car(<span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-number">6</span>) <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：c1: 红色, 6</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法str"><a href="#魔术方法str" class="headerlink" title="魔术方法str"></a>魔术方法str</h2><p>当用print()函数 打印对象的时候, 会自动调用该对象(所在类)的 str魔法方法.该魔法方法默认打印的是对象的地址值, 无意义, 一般都会重写, 改为打印对象的各个属性值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-comment"># 输出结果类似：&lt;__main__.Car object at 0x000001&gt;  (看不懂，只知道是个Car对象)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br>        <span class="hljs-variable language_">self</span>.number = number<br><br>    <span class="hljs-comment"># 定义对象的字符串表现形式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 必须返回一个字符串！</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;【车辆信息】颜色：<span class="hljs-subst">&#123;self.color&#125;</span>，轮胎数：<span class="hljs-subst">&#123;self.number&#125;</span>&quot;</span><br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 此时 print 内部会自动调用 c1.__str__()</span><br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-comment"># 输出结果：【车辆信息】颜色：红色，轮胎数：4</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法del"><a href="#魔术方法del" class="headerlink" title="魔术方法del"></a>魔术方法del</h2><p>当.py文件执行结束, 或者 手动 del 释放对象资源, 会自动调用该函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【出生】<span class="hljs-subst">&#123;self.name&#125;</span> 被制造出来了！&quot;</span>)<br><br>    <span class="hljs-comment"># 定义对象销毁时要执行的逻辑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【消亡】<span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了，送去回收站。&quot;</span>)<br><br><span class="hljs-comment"># 1. 创建对象</span><br>c1 = Car(<span class="hljs-string">&quot;宝马&quot;</span>)<br><br><span class="hljs-comment"># 2. 模拟一些操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 正在开车中 ---&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 手动删除对象（或者当程序运行结束时，也会自动触发）</span><br><span class="hljs-keyword">del</span> c1 <br><span class="hljs-comment"># 此时，c1 的引用计数变为0，Python 自动调用 __del__ 【消亡】宝马 被销毁了，送去回收站。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="模数方法lt-le-eq"><a href="#模数方法lt-le-eq" class="headerlink" title="模数方法lt&#x2F;le&#x2F;eq"></a>模数方法lt&#x2F;le&#x2F;eq</h2><p>这三个魔术方法让你的对象可以使用 <strong>比较运算符</strong>（<code>&lt;</code>, <code>&lt;=</code>, <code>==</code>）进行 PK。如果不写这些方法，Python 不知道怎么比较两个自定义对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-comment"># __lt__ 对应 &lt; (Less Than)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt; other.score<br><br>    <span class="hljs-comment"># __le__ 对应 &lt;= (Less Than or Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt;= other.score<br><br>    <span class="hljs-comment"># __eq__ 对应 == (Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score == other.score<br><br><span class="hljs-comment"># 创建学生对象</span><br>s1 = Student(<span class="hljs-number">80</span>)<br>s2 = Student(<span class="hljs-number">90</span>)<br>s3 = Student(<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># Python 会自动调用对应的方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt; s2 : <span class="hljs-subst">&#123;s1 &lt; s2&#125;</span>&quot;</span>)   <span class="hljs-comment"># 调用 s1.__lt__(s2)，80 &lt; 90，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt;= s3: <span class="hljs-subst">&#123;s1 &lt;= s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__le__(s3)，80 &lt;= 80，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 == s3: <span class="hljs-subst">&#123;s1 == s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__eq__(s3)，80 == 80，结果 True</span><br><br><span class="hljs-comment"># 甚至可以直接用在列表中排序（主要依赖 __lt__）</span><br>students = [s2, s1]<br>students.sort() <span class="hljs-comment"># 此时 Python 知道按分数排</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一名分数: <span class="hljs-subst">&#123;students[-<span class="hljs-number">1</span>].score&#125;</span>&quot;</span>) <span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure><hr><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>是一种编程思想, 强调的是以 <strong>对象</strong> 为基础完成各种操作，其三大特性：</p><ul><li>封装：大白话：把属性和方法封装在一起，仅提供对外的方法让别人去访问。好处： 简化编程</li><li>继承：大白话：孩子可使用老爹的东西。好处：代码复用</li><li>多态：大白话：同样一个函数（消息）在不同场景下表现出不同形态。 好处：解耦合，可拓展</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装 (Encapsulation)</strong> 的核心思想是：<strong>把重要的数据锁在保险箱里，只留一个小窗口（方法）对外办事。</strong></p><p>这样做可以防止外部随意修改内部数据，保证数据的安全性。在 Python 中，在属性名前加 <strong>两个下划线 <code>__</code></strong>，就可以把它变成**私有（Private）**的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, money</span>):<br>        <span class="hljs-variable language_">self</span>.name = name          <span class="hljs-comment"># 公有属性：大家都能看</span><br>        <span class="hljs-variable language_">self</span>.__balance = money    <span class="hljs-comment"># 私有属性：加了__，只有自己能看/改</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来查看余额 (Getter)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_balance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;用户 <span class="hljs-subst">&#123;self.name&#125;</span> 当前余额：<span class="hljs-subst">&#123;self.__balance&#125;</span> 元&quot;</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来修改余额 (Setter)，可以在这里加安全判断</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_money</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.__balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功存入 <span class="hljs-subst">&#123;amount&#125;</span> 元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存钱金额必须大于0！&quot;</span>)<br><br>acc = Account(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 1. 正常操作：通过方法访问</span><br>acc.save_money(<span class="hljs-number">500</span>)<br><span class="hljs-built_in">print</span>(acc.check_balance())<br><br><span class="hljs-comment"># 2. 违规操作：尝试直接访问私有属性</span><br><span class="hljs-comment"># print(acc.__balance)  </span><br><span class="hljs-comment"># 报错：AttributeError（Python 会假装在这个对象里找不到 __balance）</span><br><br><span class="hljs-comment"># 3. 绕过封装（虽然不推荐，但原理要知道）</span><br><span class="hljs-comment"># Python 实际上是把名字改成了 _类名__属性名</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;强行偷看：<span class="hljs-subst">&#123;acc._Account__balance&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类可以继承父类的属性和行为</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大口干饭...&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义子类，括号里写父类的名字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-comment"># 3. 使用</span><br>wangcai = Dog()<br>wangcai.bark()  <span class="hljs-comment"># 调用自己的方法</span><br>wangcai.eat()   <span class="hljs-comment"># 【关键】调用父类的方法（虽然Dog里没写eat，但它继承下来了）</span><br></code></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会飞高高&quot;</span>)<br><br><span class="hljs-comment"># 父类 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会跑得快&quot;</span>)<br><br><span class="hljs-comment"># 子类：括号里写多个父类，用逗号隔开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Flyer, Mammal):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bite</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我还咬人！&quot;</span>)<br><br><span class="hljs-comment"># 使用</span><br>bianfu = Bat()<br>bianfu.fly()   <span class="hljs-comment"># 继承自 Flyer</span><br>bianfu.run()   <span class="hljs-comment"># 继承自 Mammal</span><br>bianfu.bite()  <span class="hljs-comment"># 自己的</span><br></code></pre></td></tr></table></figure><h3 id="子类重写父类的功能"><a href="#子类重写父类的功能" class="headerlink" title="子类重写父类的功能"></a>子类重写父类的功能</h3><p>有两种常见的重写方式：</p><ol><li><strong>完全覆盖</strong>：彻底抛弃父类的做法，另起炉灶。</li><li><strong>功能扩展</strong>：保留父类的核心逻辑（用 <code>super()</code>），然后增加新功能。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 父类：普通的狗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！(普通叫声)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;也就是个慢跑...&quot;</span>)<br><br><span class="hljs-comment"># 2. 子类A：哈士奇 (完全覆盖)</span><br><span class="hljs-comment"># 哈士奇不想“汪汪汪”，它想“嗷呜”，所以它彻底改写了 bark 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;嗷呜~~~~ (狼嚎)&quot;</span>)<br><br><span class="hljs-comment"># 3. 子类B：警犬 (功能扩展)</span><br><span class="hljs-comment"># 警犬也得先像普通狗一样叫，但叫完之后还得抓坏人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoliceDog</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 【关键步骤】super() 代表父类</span><br>        <span class="hljs-comment"># 先执行父类的 bark (输出“汪汪汪”)</span><br>        <span class="hljs-built_in">super</span>().bark() <br>        <span class="hljs-comment"># 然后再执行自己的特殊逻辑</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 发现坏人，猛扑上去！&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br>h = Husky()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 哈士奇 ---&quot;</span>)<br>h.bark() <br><span class="hljs-comment"># 输出：嗷呜~~~~ (父类的逻辑完全不见了)</span><br><br>p = PoliceDog()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 警犬 ---&quot;</span>)<br>p.bark()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 汪汪汪！(普通叫声)  &lt;-- 来自 super().bark()</span><br><span class="hljs-comment"># &gt;&gt;&gt; 发现坏人，猛扑上去！</span><br></code></pre></td></tr></table></figure><hr><h3 id="子类访问父类功能"><a href="#子类访问父类功能" class="headerlink" title="子类访问父类功能"></a>子类访问父类功能</h3><p>子类重写父类功能后, 继续访问父类功能 </p><ol><li>父类名.父类函数名(self)      精准访问, 想找哪个父类, 就调哪个父类.</li><li>super().父类函数名()        只能访问最近的那个父类, 有就用, 没有就往后继续查找.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👴 父亲的技能：编程 (Python)&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👩 母亲的技能：画画 (Painting)&quot;</span>)<br><br><span class="hljs-comment"># 注意继承顺序：Father 在前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Father, Mother):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是孩子，开始展示技能...&quot;</span>)<br><br>        <span class="hljs-comment"># --- 方式 1: super() (自动挡) ---</span><br>        <span class="hljs-comment"># 规则：只找 MRO 列表里的“下一个”。</span><br>        <span class="hljs-comment"># 因为 class Child(Father, Mother)，Father 排前面，</span><br>        <span class="hljs-comment"># 所以 super() 只能调到 Father，直接忽略了 Mother。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 1: super().skill()】&quot;</span>)<br>        <span class="hljs-built_in">super</span>().skill()<br><br>        <span class="hljs-comment"># --- 方式 2: 类名.方法(self) (手动挡) ---</span><br>        <span class="hljs-comment"># 规则：指哪打哪。</span><br>        <span class="hljs-comment"># 即使 Mother 排在后面，super() 够不着，</span><br>        <span class="hljs-comment"># 我依然可以通过“类名”强行调用她。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 2: Mother.skill(self)】&quot;</span>)<br>        Mother.skill(<span class="hljs-variable language_">self</span>)<br><br><span class="hljs-comment"># 运行测试</span><br>c = Child()<br>c.skill()<br><span class="hljs-comment"># 我是孩子，开始展示技能...</span><br><br><span class="hljs-comment"># 【方式 1: super().skill()】</span><br><span class="hljs-comment"># 👴 父亲的技能：编程 (Python)</span><br><br><span class="hljs-comment"># 【方式 2: Mother.skill(self)】</span><br><span class="hljs-comment"># 👩 母亲的技能：画画 (Painting)</span><br></code></pre></td></tr></table></figure><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个函数, 接收不同的参数, 有不同的效果。即同一个指令，不同的对象去做，会有不同的行为。</p><p>多态的一般前提条件:1.要有继承.2.有方法重写, 不然多态无意义.3.要有父类引用指向子类对象.但在 Python 中，多态更加灵活，归因于Python 动态语言灵活性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 必须有继承 (条件1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Charger</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-comment"># 2. 必须重写 (条件2)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 Type-C 充电...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lightning_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 苹果头 充电...&quot;</span>)<br><br><span class="hljs-comment"># 函数定义必须暗示接收父类类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">charger_obj: Charger</span>): <span class="hljs-comment"># 类型提示只是提示，不强制</span><br>    charger_obj.charge()<br><br><span class="hljs-comment"># 3. 父类引用指向子类 (在Python里变量没有类型，所以这一步是隐式的)</span><br>c1 = TypeC_Charger()<br>power_up(c1)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>:<br>    <span class="hljs-comment"># 没有继承任何父类！</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Type-C 充电中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span>:<br>    <span class="hljs-comment"># 这是一个汉堡，跟充电器没半毛钱关系</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是一个汉堡，但我居然也有 charge 方法！充能中（热量+100）&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-comment"># Python 不管你是什么类，只管你有没有 charge 方法</span><br>    obj.charge() <br><br>t = TypeC_Charger()<br>b = Burger()<br><br>power_up(t) <span class="hljs-comment"># 正常工作</span><br>power_up(b) <span class="hljs-comment"># 居然也正常工作！这就是鸭子类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类解释:<br>        抽象类一般充当父类, 用于指定行业规范, 准则, 具体的实现交由 子类 来完成.</p><h3 id="父类制定标准，子类去实现-思想"><a href="#父类制定标准，子类去实现-思想" class="headerlink" title="父类制定标准，子类去实现(思想)"></a>父类制定标准，子类去实现(思想)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义抽象类, 空调类, 设定: 空调的规则.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC</span>:<br>    <span class="hljs-comment"># 1.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 2. 定义子类(小米空调), 实现父类(空调类)中的所有抽象方法.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-comment"># 2.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制冷技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制热技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米空调 静音左右摆风 技术!&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 4.1 小米空调</span><br>    xm = XiaoMi()<br>    xm.cool_wind()<br>    xm.hot_wind()<br>    xm.swing_l_r()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><h3 id="引入-abc-模块（Abstract-Base-Class）-严谨"><a href="#引入-abc-模块（Abstract-Base-Class）-严谨" class="headerlink" title="引入 abc 模块（Abstract Base Class）(严谨)"></a>引入 <code>abc</code> 模块（Abstract Base Class）(严谨)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 1. 定义抽象类：必须继承 ABC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义抽象方法：加上装饰器 @abstractmethod</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 这里不写具体逻辑，因为不知道怎么付，只占个位</span><br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># ❌ 错误演示：尝试直接创建抽象类对象</span><br><span class="hljs-comment"># p = Payment() </span><br><span class="hljs-comment"># 报错：TypeError: Can&#x27;t instantiate abstract class Payment...</span><br><span class="hljs-comment"># (意思：Payment 是抽象的，是个半成品，不能直接用)</span><br><br><br><span class="hljs-comment"># ✅ 正确演示：子类继承并实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-comment"># 【必须重写】如果不写这个方法，AliPay 也会报错</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;支付宝支付中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;微信支付中...&quot;</span>)<br><br><span class="hljs-comment"># 3. 正常使用</span><br>ali = AliPay()<br>ali.pay()<br></code></pre></td></tr></table></figure><p>在python中，<strong>抽象类（ABC）和接口（Interface）在语法上是同一个东西</strong>。如果你把一个抽象类里的方法全写成空（只有定义没实现），它就是接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 用法 A：当作【接口】用 (全都是抽象方法，没有具体实现)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USBInterface</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 用法 B：当作【抽象类】用 (有一部分共用的代码)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭眼睡觉...&quot;</span>)  <span class="hljs-comment"># 这是一个具体功能</span><br>    <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><hr><h2 id="类属性和对象属性"><a href="#类属性和对象属性" class="headerlink" title="类属性和对象属性"></a>类属性和对象属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># --- 这里是【类属性】 ---</span><br>    <span class="hljs-comment"># 定义在方法外面，这是大家共享的</span><br>    school = <span class="hljs-string">&quot;霍格沃茨魔法学校&quot;</span><br>    count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用来记录一共招生了多少人</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># --- 这里是【实例属性】 ---</span><br>        <span class="hljs-comment"># 定义在 __init__ 里，绑定在 self 上，是个人的</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <br>        <span class="hljs-comment"># 每创建一个学生，班级总人数就 +1</span><br>        <span class="hljs-comment"># 注意：要修改类属性，最好用 类名.属性</span><br>        Student.count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 1. 创建两个学生</span><br>s1 = Student(<span class="hljs-string">&quot;哈利波特&quot;</span>, <span class="hljs-number">11</span>)<br>s2 = Student(<span class="hljs-string">&quot;罗恩&quot;</span>, <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 2. 访问实例属性 (每个人不一样) 只能通过对象访问</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的名字: <span class="hljs-subst">&#123;s1.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 哈利波特</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的名字: <span class="hljs-subst">&#123;s2.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 罗恩</span><br><br><span class="hljs-comment"># 3. 访问类属性 (大家都一样)</span><br><span class="hljs-comment"># 可以通过对象访问，也可以通过类名访问(推荐)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的学校: <span class="hljs-subst">&#123;s1.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的学校: <span class="hljs-subst">&#123;s2.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目前招生人数: <span class="hljs-subst">&#123;Student.count&#125;</span>&quot;</span>) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><hr><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>    属于类的方法, 可以通过类名. 还可以通过对象名. 的方式来调用.<br>    定义类方法的时候, 必须使用装饰器 @classmethod, 且第1个参数必须表示类对象.</p><p>静态方法:<br>    属于该类下所有对象所共享的方法, 可以通过类名. 还可以通过 对象名.的方式来调用.<br>    定义静态方法的时候, 必须使用装饰器 @staticmethod, 且参数传不传都可以.</p><p>区别:<br>       1. 类方法的第1个参数必须是类对象, 静态方法无参数的特殊要求<br>       2. 你可以理解为: 如果函数中要用类对象, 就定义成类方法, 否则定义成静态方法, 除此外并无任何区别.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义学生类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># 2. 定义类属性.</span><br>    school = <span class="hljs-string">&#x27;黑马程序员&#x27;</span><br><br>    <span class="hljs-comment"># 3. 定义类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show1</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cls: <span class="hljs-subst">&#123;cls&#125;</span>&#x27;</span>)        <span class="hljs-comment"># &lt;class &#x27;__main__.Student&#x27;&gt;</span><br>        <span class="hljs-built_in">print</span>(cls.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是类方法&#x27;</span>)<br><br>    <span class="hljs-comment"># 4. 定义静态方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show2</span>():<br>        <span class="hljs-built_in">print</span>(Student.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是静态方法&#x27;</span>)<br><br><span class="hljs-comment"># 5. 测试.</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s1 = Student()<br>    s1.show1()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br>    s1.show2()<br></code></pre></td></tr></table></figure><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包入门"><a href="#闭包入门" class="headerlink" title="闭包入门"></a>闭包入门</h2><p>通常情况下，函数内部的变量是“临时工”，函数执行完，变量就被销毁（内存释放）了。</p><p>但是<strong>闭包</strong>不同，它可以让一个函数<strong>把外部的变量“打包带走”</strong>。即使外部函数已经执行完了，内部函数依然能访问并使用那个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 外部函数 (工厂)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">config_greeting</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-comment"># msg 是外部函数的变量 (零件)</span><br>    <br>    <span class="hljs-comment"># 2. 内部函数 (工人)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-comment"># 3. 内部使用了外部变量 msg</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;msg&#125;</span>, <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 返回内部函数 (工人背着零件走了)</span><br>    <span class="hljs-keyword">return</span> printer<br><br><span class="hljs-comment"># --- 关键看这里 ---</span><br><br><span class="hljs-comment"># 创建一个闭包实例：配置为 &quot;Hello&quot;</span><br>say_hello = config_greeting(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-comment"># 此时，config_greeting 函数其实已经运行结束了！</span><br><span class="hljs-comment"># 按理说变量 &quot;Hello&quot; 应该从内存消失，但它被 printer 抓住了。</span><br><br><span class="hljs-comment"># 创建另一个闭包实例：配置为 &quot;你好&quot;</span><br>say_nihao = config_greeting(<span class="hljs-string">&quot;你好&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br>say_hello(<span class="hljs-string">&quot;张三&quot;</span>)  <span class="hljs-comment"># 输出：Hello, 张三</span><br>say_nihao(<span class="hljs-string">&quot;李四&quot;</span>)  <span class="hljs-comment"># 输出：你好, 李四</span><br></code></pre></td></tr></table></figure><h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><p><code>nonlocal</code> 的作用是：<strong>允许内部函数修改外部函数（闭包）中的变量</strong>。</p><p>Python 有一个保护机制：如果你在函数内部给一个变量赋值（比如 <code>a = 10</code>），Python 默认会认为这只是一个<strong>全新的局部变量</strong>，跟外面的那个 <code>a</code> 没关系。</p><p>这就导致了一个问题：如果想<strong>修改</strong>外面的变量，而不是<strong>新建</strong>一个，程序会报错或者不符合预期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>        <span class="hljs-comment"># 【关键】声明：我要修改外面的那个 count！</span><br>        <span class="hljs-keyword">nonlocal</span> count <br>        <br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前计数: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>        <br>    <span class="hljs-keyword">return</span> adder<br><br>c = make_counter()<br>c()  <span class="hljs-comment"># 输出：当前计数: 1</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 2</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 3</span><br></code></pre></td></tr></table></figure><p>问：<code>nonlocal</code> vs <code>global</code> 的区别？</p><p><strong><code>global</code></strong>：</p><ul><li>用于修改<strong>全局变量</strong>（整个模块级别的）。</li><li>它是去<strong>最外层</strong>找变量。</li></ul><p><strong><code>nonlocal</code></strong>：</p><ul><li>用于修改<strong>嵌套函数中的变量</strong>（闭包里的）。</li><li>它是去<strong>上一层（或上上层）函数找变量，但绝不</strong>去全局找。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全局变量</span><br>score = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_score</span>():<br>    <span class="hljs-comment"># 【声明】：我要用的这个 score 是全局那个！不是新建的！</span><br>    <span class="hljs-keyword">global</span> score<br>    <br>    score += <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;游戏得分！&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 0</span><br><br>add_score()<br>add_score()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 200 (真的被改掉了)</span><br></code></pre></td></tr></table></figure><hr><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><p><strong>装饰器本质上就是一个闭包，它的作用是在不修改原函数代码的前提下，给原函数“增加新功能”</strong></p><p><strong>核心原则：开放封闭原则 (Open-Closed Principle)</strong></p><ul><li><strong>封闭</strong>：对修改源代码封闭（不要动原来的代码）</li><li><strong>开放</strong>：对扩展功能开放（想加日志、想加权限验证，随便加）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 接收一个函数作为参数 (外部函数)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_gift</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义内部函数 (包装纸)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 🎁 正在包装礼物...&quot;</span>)<br>        <span class="hljs-comment"># 3. 调用原函数 (放入礼物)</span><br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; ✅ 礼物已发出！&quot;</span>)<br>        <br>    <span class="hljs-comment"># 4. 返回内部函数</span><br>    <span class="hljs-keyword">return</span> wrapper<br>    <br>    <br><span class="hljs-comment"># 写法 A：原函数</span><br><span class="hljs-meta">@add_gift  </span><span class="hljs-comment"># &lt;--- 这就是装饰器语法，相当于给 buy_shoe 穿了层衣服</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_shoe</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一双球鞋&quot;</span>)<br><br><span class="hljs-meta">@add_gift</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_phone</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一台手机&quot;</span>)<br><br><span class="hljs-comment"># --- 运行测试 ---</span><br><br><span class="hljs-comment"># 当你调用 buy_shoe 时，其实你运行的是 wrapper！</span><br>buy_shoe()<br></code></pre></td></tr></table></figure><h2 id="带参数和返回值"><a href="#带参数和返回值" class="headerlink" title="带参数和返回值"></a>带参数和返回值</h2><p>例子虽然简单，但有两个致命的缺陷：</p><ol><li><strong>传参限制</strong>：如果原函数需要参数（比如 <code>buy_shoe(&quot;耐克&quot;)</code>），之前的 <code>wrapper()</code> 没定义参数，一调就报错。</li><li><strong>吞噬返回值</strong>：如果原函数有 <code>return</code>，之前的 <code>wrapper()</code> 没有把结果返回出来，导致外界拿到的是 <code>None</code>。</li></ol><p><strong>装饰器的内部函数格式要和被装饰的原函数 保持一致,即: 原函数是无参无返回的, 则装饰器的内部函数也必须是无参无返回的.原函数有参有返回的, 则装饰器的内部函数也必须是有参有返回的.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-comment"># 1. 【万能参数】：*args, **kwargs</span><br>    <span class="hljs-comment"># 不管原函数传什么参数（一个、两个、关键字参数），我全都能接住</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 正在进行权限核对...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 2. 【调用原函数】并【接收返回值】</span><br>        <span class="hljs-comment"># 把刚才接住的参数，原封不动地传给原函数</span><br>        result = func(*args, **kwargs)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 核对完毕，放行。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 3. 【返回结果】</span><br>        <span class="hljs-comment"># 这一步如果不写，外界拿到的就是 None</span><br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 A：有参数，无返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">food, drink</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在吃<span class="hljs-subst">&#123;food&#125;</span>，喝<span class="hljs-subst">&#123;drink&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 场景 B：有参数，有返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_sum</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在努力计算中...&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 测试 eat (两个参数)</span><br>eat(<span class="hljs-string">&quot;火锅&quot;</span>, <span class="hljs-string">&quot;可乐&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在吃火锅，喝可乐</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 2. 测试 calculate_sum (有返回值)</span><br>res = calculate_sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在努力计算中...</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><span class="hljs-comment"># 计算结果是: 30  &lt;-- 如果 wrapper 没写 return，这里就是 None</span><br></code></pre></td></tr></table></figure><p><strong>args和kwargs<code>就像是一个弹性收纳袋，无论扔进来多少个参数，wrapper 都能收下，然后再原封不动地传递给</code>func</strong></p><p>万能公式 &#x3D; 闭包 + <code>*args/**kwargs</code> + <code>return</code></p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>要在装饰器里传参数，需要在原本的装饰器外面，<strong>再包一层函数</strong>。</p><ul><li><strong>第一层 (最外面)</strong>：负责接收<strong>装饰器的参数</strong>（比如 “ERROR”）。管它叫“装饰器工厂”。</li><li><strong>第二层 (中间层)</strong>：负责接收<strong>被修饰的函数</strong>（<code>func</code>）。这才是真正的装饰器。</li><li><strong>第三层 (最里面)</strong>：负责接收<strong>函数的参数</strong>（<code>*args</code>）。这是具体的干活逻辑（Wrapper）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># --- 第一层：工厂层 (负责接收 level 参数) ---</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">level</span>):<br>    <br>    <span class="hljs-comment"># --- 第二层：装饰器层 (负责接收 func) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <br>        <span class="hljs-comment"># --- 第三层：Wrapper层 (负责接收 func 的参数) ---</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 正在启动功能...&quot;</span>) <span class="hljs-comment"># 这里用到了第一层的变量</span><br>            <br>            <span class="hljs-comment"># 调用原函数</span><br>            result = func(*args, **kwargs)<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 执行结束。&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <br>        <span class="hljs-keyword">return</span> wrapper <span class="hljs-comment"># 返回第三层</span><br>    <br>    <span class="hljs-keyword">return</span> decorator <span class="hljs-comment"># 返回第二层</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 1：普通操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;INFO&quot;</span></span>) </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_page</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打开网页...&quot;</span>)<br><br><span class="hljs-comment"># 场景 2：危险操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;DANGER&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删库跑路...&quot;</span>)<br><br><span class="hljs-comment"># --- 运行 ---</span><br>open_page()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [INFO] 正在启动功能...</span><br><span class="hljs-comment"># 打开网页...</span><br><br>delete_db()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [DANGER] 正在启动功能...</span><br><span class="hljs-comment"># 删库跑路...</span><br></code></pre></td></tr></table></figure><p><strong>FastAPI</strong> 和 <strong>Django</strong> 中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)  </span><span class="hljs-comment"># 传了参数 &quot;/users&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(): ...<br></code></pre></td></tr></table></figure><p>这里 <code>@app.get</code> 就是一个带参数的装饰器，它记录了 URL 路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@permission_required(<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span></span>) </span><span class="hljs-comment"># 传了参数 &quot;admin&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(): ...<br></code></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>用了装饰器后，原函数的名字（<code>__name__</code>）会变成 <code>wrapper</code>，这在调试时很不方便</p><p>先看没有 <code>wraps</code> 时会发生什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 见证“身份被窃” ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 函数的名字是: wrapper   &lt;-- 糟糕！原本叫 login，现在变成 wrapper 了</span><br><span class="hljs-comment"># 函数的说明是: None      &lt;-- 糟糕！原本写的注释说明也没了</span><br></code></pre></td></tr></table></figure><p><strong>为什么会这样？</strong> 因为 <code>login = my_decorator(login)</code>，现在的 <code>login</code> 变量实际上指向的是那个内部函数 <code>wrapper</code>。所以你打印的自然是 <code>wrapper</code> 的名字。</p><p>Python 标准库提供了一个神器 <code>@functools.wraps</code>。它的作用是：<strong>自动把原函数（func）的元数据（名字、注释文档等）拷贝给 wrapper。</strong></p><p>这就是所谓的“伪装”：让 wrapper 看起来跟原函数一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools  <span class="hljs-comment"># 1. 导入模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 【关键】在定义 wrapper 之前，加上这行代码</span><br>    <span class="hljs-comment"># 意思是：把 func 的身份证信息贴到 wrapper 脑门上</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>) </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 再次查验身份 ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 函数的名字是: login</span><br><span class="hljs-comment"># 函数的说明是: 这是登录系统的核心函数</span><br></code></pre></td></tr></table></figure><p>为什么这很关键？</p><p>在简单的脚本里确实没关系，但在<strong>框架开发</strong>中这是致命的：</p><ol><li><strong>FastAPI &#x2F; Django 生成文档</strong>：<ul><li>FastAPI 会自动读取函数名和 docstring 来生成 Swagger 接口文档。</li><li>如果你用了装饰器但没加 <code>wraps</code>，FastAPI 看到的函数全叫 <code>wrapper</code>，文档里的接口说明也会全都变成空白。API 文档瞬间就废了。</li></ul></li><li><strong>自动化测试框架</strong>：<ul><li>在 Pytest 或 Unittest 中，测试报告通常会显示“正在执行 xxxx 用例”。</li><li>如果不加 <code>wraps</code>，测试报告里可能会显示“正在执行 wrapper”，根本不知道崩的是哪个用例。</li></ul></li></ol><hr><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h2><p>赋值操作（<code>=</code>）永远只是复制了对象的引用（内存地址），而没有复制对象本身,即仅仅是多了一个指向同一个内存地址的指针</p><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image2.png" class="" title="普通赋值"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="浅拷贝可变类型"><a href="#浅拷贝可变类型" class="headerlink" title="浅拷贝可变类型"></a>浅拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image3.png" class="" title="浅拷贝可变类型"><p>可以清晰地看出，浅拷贝拷贝可变类型，只拷贝第一层</p><h3 id="浅拷贝不可变类型"><a href="#浅拷贝不可变类型" class="headerlink" title="浅拷贝不可变类型"></a>浅拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image4.png" class="" title="浅拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），浅拷贝（copy）等同于赋值（&#x3D;），根本不会创建新对象！</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="深拷贝可变类型"><a href="#深拷贝可变类型" class="headerlink" title="深拷贝可变类型"></a>深拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image5.png" class="" title="深拷贝可变类型"><p>深拷贝拷贝可变类型，则会拷贝所有可变类型的层。</p><h3 id="深拷贝不可变类型"><a href="#深拷贝不可变类型" class="headerlink" title="深拷贝不可变类型"></a>深拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image6.png" class="" title="深拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），深拷贝（deepcopy）等同于赋值（&#x3D;），根本不会创建新对象！</p><hr><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>简单来说，网络编程就是让<strong>两台计算机（或者同一台电脑上的两个程序）互相说话</strong>。网络编程其实就是：<strong>IP 定位电脑 + Port 定位程序 + TCP&#x2F;UDP 定位规则</strong>。</p><p>为了实现“说话”，必须解决三个核心问题：</p><ol><li><strong>找人</strong>：去哪里找对方？（IP 地址）</li><li><strong>找门</strong>：找到电脑后，跟哪个软件说话？（端口号 Port）</li><li><strong>怎么说</strong>：用什么规则交流？（协议 Protocol）</li></ol><hr><h3 id="1-找人：IP-地址-IP-Address"><a href="#1-找人：IP-地址-IP-Address" class="headerlink" title="1. 找人：IP 地址 (IP Address)"></a>1. 找人：IP 地址 (IP Address)</h3><p>IP 地址就是计算机在网络世界的**“门牌号”**。</p><ul><li><strong>公网 IP</strong>：比如百度的 IP，全世界都能访问。</li><li><strong>局域网 IP</strong>：比如 <code>192.168.1.5</code>，只有你家路由器下面的设备能互访。</li><li><strong>本机 IP</strong>：<code>127.0.0.1</code>（有个别名叫 <code>localhost</code>），特指“我自己”。做测试开发时先在本地部署服务，用的就是这个 IP。</li></ul><hr><h3 id="2-找门：端口号-Port"><a href="#2-找门：端口号-Port" class="headerlink" title="2. 找门：端口号 (Port)"></a>2. 找门：端口号 (Port)</h3><p>找到电脑（IP）后，电脑里运行着几十个程序（微信、QQ、浏览器、你的测试脚本）。消息发给谁呢？</p><p>这就需要端口号。它就像是这栋大楼里的**“房间号”**。</p><ul><li><strong>端口范围</strong>：0 - 65535。</li><li><strong>知名端口</strong>（不要去占用）：<ul><li><code>80</code>: 网页浏览 (HTTP)</li><li><code>443</code>: 加密网页 (HTTPS)</li><li><code>3306</code>: MySQL 数据库</li></ul></li><li><strong>动态端口</strong>：我们写程序时，一般使用 1024 之后的端口（比如 8000, 8080, 9999），避免和系统冲突。</li></ul><hr><h3 id="3-怎么说：通信协议-Protocol"><a href="#3-怎么说：通信协议-Protocol" class="headerlink" title="3. 怎么说：通信协议 (Protocol)"></a>3. 怎么说：通信协议 (Protocol)</h3><p>找到了人，也敲开了门，接下来怎么交流？</p><p>在传输层（Transport Layer），最著名的两位“大佬”是 TCP 和 UDP。它们的性格截然不同：</p><h4 id="A-TCP-协议-Transmission-Control-Protocol-——-“打电话”"><a href="#A-TCP-协议-Transmission-Control-Protocol-——-“打电话”" class="headerlink" title="A. TCP 协议 (Transmission Control Protocol) —— “打电话”"></a>A. TCP 协议 (Transmission Control Protocol) —— “打电话”</h4><ul><li><strong>性格</strong>：严谨、靠谱、慢热。</li><li><strong>特点</strong>：<strong>面向连接</strong>。<ul><li>在发数据前，必须先建立连接（著名的<strong>三次握手</strong>）。</li><li>发出去的数据，对方必须确认收到（ACK）。如果没收到，我会重发。</li><li>保证数据顺序不错乱。</li></ul></li><li><strong>应用</strong>：网页访问 (HTTP)、文件传输、邮件、接口自动化（绝大多数接口测试测的都是基于 TCP 的 HTTP）。</li></ul><h4 id="B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”"><a href="#B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”" class="headerlink" title="B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”"></a>B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”</h4><ul><li><strong>性格</strong>：豪爽、快、不负责任。</li><li><strong>特点</strong>：<strong>无连接</strong>。<ul><li>想发就发，不需要建立连接。</li><li>发出去就不管了，对方收没收到我不知道，也不重发。</li><li>可能会丢包，顺序可能会乱。</li></ul></li><li><strong>应用</strong>：视频会议、在线直播、王者荣耀（卡顿一下没关系，只要实时性高就行）。</li></ul><hr><h3 id="4-Python-的工具：socket"><a href="#4-Python-的工具：socket" class="headerlink" title="4. Python 的工具：socket"></a>4. Python 的工具：socket</h3><p>在 Python 中，实现网络编程主要靠 socket (套接字) 模块。</p><p>把 socket 想象成是一个**“电话机”**。</p><ul><li><strong>服务端 (Server)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>插上电话线，绑定号码 (bind IP &amp; Port)。</li><li>守在电话旁等铃声 (listen)。</li><li>接电话 (accept)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li><li><strong>客户端 (Client)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>拨号 (connect IP &amp; Port)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li></ul><hr><h2 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image7.png" class="" title="网络编程"><p>这张图是 <strong>TCP 网络编程中最经典、最标准的核心流程图</strong>。</p><hr><h3 id="1-右侧：TCP-服务器-Server-——-“客服中心”"><a href="#1-右侧：TCP-服务器-Server-——-“客服中心”" class="headerlink" title="1. 右侧：TCP 服务器 (Server) —— “客服中心”"></a>1. 右侧：TCP 服务器 (Server) —— “客服中心”</h3><p>服务器必须先启动，坐在那儿等着被撩。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>首先需要有一个通信工具。在代码中就是创建一个套接字对象。</li></ul></li><li><strong>插卡&#x2F;定号码 (<code>bind(IP, 端口号)</code>)</strong><ul><li>手机买好了，你得告诉大家你的号码是多少（IP），以及大家打进来找哪个部门（端口号，比如 8080）。</li><li>如果不绑定，别人根本找不到你。</li></ul></li><li><strong>开机&#x2F;设置排队 (<code>listen(最大监听数)</code>)</strong><ul><li><strong>开机</strong>：让端口处于“监听状态”，准备接客。</li><li><strong>最大监听数</strong>：相当于客服系统的“排队上限”。如果同时有 100 个人打进来，但我设了 5，那第 6 个人就会听到“正在通话中”。</li></ul></li><li><strong>等待接听 (<code>accept()</code>) —— 关键步骤！</strong><ul><li>图中有个蓝字解释非常重要：<strong>“等待监听，会返回 1 个元组 (负责和客户端交互的 socket, 客户端信息)”</strong>。</li><li><strong>阻塞 (Blocking)</strong>：代码运行到这儿会<strong>停住</strong>（卡住），直到有电话打进来。</li><li><strong>分身术</strong>：这是新手最容易晕的地方。<code>accept</code> 收到请求后，会<strong>专门分配一个新的分身 socket</strong> 去跟这个客户一对一聊天。原来的主 socket 继续回到 <code>listen</code> 状态等下一个电话。</li></ul></li><li><strong>收发数据 (<code>recv() / send()</code>)</strong><ul><li>图中的箭头展示了数据的流向：服务器先接收请求，处理完后，再发送响应。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>聊完了，释放资源。</li></ul></li></ol><hr><h3 id="2-左侧：TCP-客户端-Client-——-“打电话的人”"><a href="#2-左侧：TCP-客户端-Client-——-“打电话的人”" class="headerlink" title="2. 左侧：TCP 客户端 (Client) —— “打电话的人”"></a>2. 左侧：TCP 客户端 (Client) —— “打电话的人”</h3><p>客户端就比较主动了。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>同样先创建一个 socket 对象。</li></ul></li><li><strong>拨号 (<code>connect(IP, 端口号)</code>)</strong><ul><li><strong>三次握手</strong>：也就是图中间写的“连接建立”。</li><li>这一步如果成功，就说明电话通了；如果失败（比如服务器没开），程序就会直接报错 <code>ConnectionRefusedError</code>。</li></ul></li><li><strong>发收数据 (<code>send() / recv()</code>)</strong><ul><li>注意箭头方向：客户端通常是<strong>先说话</strong>（发送请求 <code>send</code>），然后<strong>等着听</strong>（接收响应 <code>recv</code>）。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>打完收工。</li></ul></li></ol><hr><h3 id="3-图中的三个“隐藏细节”"><a href="#3-图中的三个“隐藏细节”" class="headerlink" title="3. 图中的三个“隐藏细节”"></a>3. 图中的三个“隐藏细节”</h3><p>这张图里有几行不起眼的小字，但这恰恰是写代码时最容易踩坑的地方：</p><ol><li><strong>“二进制传输” (绿色字)</strong><ul><li>网络不认识中文，也不认识字符串。</li><li><strong>潜台词</strong>：你在 Python 里 <code>send(&quot;你好&quot;)</code> 是会报错的！必须 <code>send(&quot;你好&quot;.encode(&quot;utf-8&quot;))</code>，把它变成 <code>bytes</code> 类型才能传。</li></ul></li><li><strong>“一直阻塞到客户连接到达”</strong><ul><li>这就是 <code>accept()</code> 的特性。如果没人连你，你的程序就会像死机一样停在那一行不动。</li></ul></li><li><strong>交互逻辑 (<code>send</code> 对 <code>recv</code>)</strong><ul><li>看图中间的横向箭头：<ul><li>客户端的 <code>send()</code> 数据流向 -&gt; 服务器的 <code>recv()</code>。</li><li>服务器的 <code>send()</code> 数据流向 -&gt; 客户端的 <code>recv()</code>。</li></ul></li><li>如果两边同时写 <code>recv()</code>，就会发生<strong>死锁</strong>（俩人都在等对方先说话，结果谁也不理谁）。</li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这张图就是 TCP 代码的<strong>骨架</strong>。</p><ul><li><strong>Server</strong>: <code>socket</code> -&gt; <code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code> (循环) -&gt; <code>recv/send</code> -&gt; <code>close</code></li><li><strong>Client</strong>: <code>socket</code> -&gt; <code>connect</code> -&gt; <code>send/recv</code> -&gt; <code>close</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机 (创建 socket 对象)</span><br><span class="hljs-comment"># AF_INET: 使用 IPv4</span><br><span class="hljs-comment"># SOCK_STREAM: 使用 TCP 协议</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 插卡 (绑定 IP 和 端口)</span><br><span class="hljs-comment"># &#x27;127.0.0.1&#x27; 代表本机</span><br>server_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 开机 (监听)</span><br>server_socket.listen(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 客服中心已启动，正在等待客户电话...&quot;</span>)<br><br><span class="hljs-comment"># 4. 等待接听 (accept) -- 程序会卡在这里直到有人连接</span><br><span class="hljs-comment"># client_sock: 专门负责跟这个客户聊天的分身 socket</span><br><span class="hljs-comment"># addr: 客户的 IP 地址</span><br>client_sock, addr = server_socket.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 电话通了！客户地址: <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 接收消息 (recv) -- 对应图中的第一对 send/recv</span><br><span class="hljs-comment"># 注意：网络传输必须用 bytes，所以要 decode 解码</span><br>data = client_sock.recv(<span class="hljs-number">1024</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客户消息: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 6. 发送回复 (send) -- 对应图中的第二对 send/recv</span><br>msg = <span class="hljs-string">&quot;你好，我是客服小冰，很高兴为您服务！&quot;</span><br>client_sock.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 必须 encode 转成二进制</span><br><br><span class="hljs-comment"># 7. 挂断</span><br>client_sock.close()<br>server_socket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 拨号 (连接服务器)</span><br><span class="hljs-comment"># 必须和服务器的 IP、端口一致</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 先说话 (send)</span><br>msg = <span class="hljs-string">&quot;你好，我要查余额&quot;</span><br>client_socket.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 4. 等回复 (recv)</span><br>data = client_socket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客服回复: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 挂断</span><br>client_socket.close()<br></code></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="1-核心概念：进程-vs-线程"><a href="#1-核心概念：进程-vs-线程" class="headerlink" title="1. 核心概念：进程 vs 线程"></a>1. 核心概念：进程 vs 线程</h3><ul><li><strong>进程 (Process)</strong>：<ul><li><strong>定义</strong>：资源分配的最小单位。</li><li><strong>比喻</strong>：一个独立运行的 <code>.exe</code> 程序，比如 QQ</li><li><strong>特点</strong>：每个进程都有自己独立的内存空间，互不干扰。QQ 崩了，不会影响微信。</li><li><strong>开销</strong>：创建和销毁都很慢，像盖工厂一样费劲。</li></ul></li><li><strong>线程 (Thread)</strong>：<ul><li><strong>定义</strong>：CPU 调度的最小单位。</li><li><strong>比喻</strong>：<strong>工厂里的工人</strong>。</li><li><strong>特点</strong>：<ul><li>一个进程（工厂）里至少有一个线程（老板自己干活），也可以有多个线程（雇了 10 个工人）。</li><li><strong>共享资源</strong>：所有线程都在同一个工厂里，共用同一个食堂、同一个厕所（共享内存）。这就带来了“争抢资源”的问题</li></ul></li><li><strong>开销</strong>：创建非常快，像招个临时工一样简单。</li></ul></li></ul><hr><h3 id="2-串行、并发、并行"><a href="#2-串行、并发、并行" class="headerlink" title="2. 串行、并发、并行"></a>2. 串行、并发、并行</h3><ul><li><strong>串行 (Serial)</strong>：<ul><li><strong>模式</strong>：一个一个来。</li><li><strong>例子</strong>：你去排队打饭，前一个人没打完，你只能干等。</li></ul></li><li><strong>并发 (Concurrency) —— Python 多线程主要属于这种</strong>：<ul><li><strong>模式</strong>：<strong>假装</strong>同时在做。其实是 CPU 切换得太快了，让你产生了错觉。</li><li><strong>例子</strong>：你一边吃饭一边回微信。其实你不能同时把饭送进嘴里又同时打字。你是“吃一口饭 -&gt; 放下筷子回两句 -&gt; 再吃一口”。因为切换速度极快，看起来像是同时进行的。</li></ul></li><li><strong>并行 (Parallelism)</strong>：<ul><li><strong>模式</strong>：<strong>真正</strong>同时在做。</li><li><strong>例子</strong>：你用左手拿勺子喝汤，你朋友坐在对面用右手拿筷子吃面。你俩互不干扰，真正的同时进行（这通常需要多核 CPU 支持）。</li></ul></li></ul><hr><h3 id="3-Python-多线程的“阿喀琉斯之踵”：GIL-锁"><a href="#3-Python-多线程的“阿喀琉斯之踵”：GIL-锁" class="headerlink" title="3. Python 多线程的“阿喀琉斯之踵”：GIL 锁"></a>3. Python 多线程的“阿喀琉斯之踵”：GIL 锁</h3><p>在 Python 中谈多线程，必须得提 <strong>GIL (Global Interpreter Lock，全局解释器锁)</strong>。</p><ul><li><strong>现象</strong>：因为有 GIL 的存在，Python 的多线程在<strong>同一时刻，只能有一个线程在 CPU 上运行</strong>。</li><li><strong>后果</strong>：<ul><li>Python 的多线程是 <strong>“伪多线程”</strong>（针对 CPU 密集型任务）。哪怕你是 8 核 CPU，Python 多线程也只能用 1 个核。</li></ul></li><li><strong>那多线程还有用吗？</strong><ul><li><strong>非常有用！</strong> 但要分场景：</li><li><strong>计算密集型（CPU Bound）</strong>：比如视频解码、科学计算。<strong>（Python 多线程没用，反而更慢，因为要频繁切换）</strong>。</li><li><strong>IO 密集型（IO Bound）</strong>：比如 <strong>爬虫、接口请求、读写文件</strong>。<strong>（Python 多线程神器！）</strong><ul><li><strong>原因</strong>：当线程 A 去请求网络（IO 操作）时，它处于“等待”状态（不占 CPU），Python 会立刻释放 GIL 锁，让线程 B 赶紧去干活。这样就利用了等待的时间。</li></ul></li></ul></li></ul><hr><h2 id="多线程示例"><a href="#多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image8.png" class="" title="多线程"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟网络延迟，耗时1秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_single</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 依次调用 5 次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        download(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>)<br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[单线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_single()<br>    <br>    <br><span class="hljs-comment"># 开始下载: 图片_1.jpg</span><br><span class="hljs-comment"># ... (等1秒)</span><br><span class="hljs-comment"># 下载完成: 图片_1.jpg</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># [单线程] 总耗时: 5.02 秒</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_multi</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 用来存放所有线程对象的列表</span><br>    threads = []<br>    <br>    <span class="hljs-comment"># 1. 创建并启动线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># target: 指定要干什么活 (函数名)</span><br>        <span class="hljs-comment"># args: 指定参数 (注意必须是元组，如果是1个参数后面要加逗号)</span><br>        t = threading.Thread(target=download, args=(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>,))<br>        <br>        <span class="hljs-comment"># 启动线程！(相当于告诉工人：开始干活！)</span><br>        t.start()<br>        <br>        <span class="hljs-comment"># 把工人的名字记下来</span><br>        threads.append(t)<br>        <br>    <span class="hljs-comment"># 2. 等待所有线程结束 (这一步至关重要！)</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join() <br>        <span class="hljs-comment"># join的意思是：主程序(老板)在这里等着，直到这个线程(工人)干完活才能往下走</span><br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[多线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_multi()<br>    <br><span class="hljs-string">&quot;&quot;&quot;   </span><br><span class="hljs-string">开始下载: 图片_1.jpg</span><br><span class="hljs-string">开始下载: 图片_2.jpg</span><br><span class="hljs-string"><span class="hljs-meta">... </span>(几乎同时打印)</span><br><span class="hljs-string">下载完成: 图片_1.jpg</span><br><span class="hljs-string">...</span><br><span class="hljs-string">[多线程] 总耗时: 1.01 秒</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="A-t-start-vs-t-run"><a href="#A-t-start-vs-t-run" class="headerlink" title="A. t.start() vs t.run()"></a>A. <code>t.start()</code> vs <code>t.run()</code></h4><ul><li><strong><code>start()</code></strong>: <strong>正确写法</strong>。它会向操作系统申请一个新的线程，并在新线程里执行代码（真正的并发）。</li><li><strong><code>run()</code></strong>: <strong>错误写法</strong>。它只是把函数当普通函数调用了一遍，还在主线程里跑，根本没有多线程效果。</li></ul><h4 id="B-t-join-为什么要写？"><a href="#B-t-join-为什么要写？" class="headerlink" title="B. t.join() 为什么要写？"></a>B. <code>t.join()</code> 为什么要写？</h4><p>如果把 <code>join</code> 那段循环删掉，会发现程序会在 <strong>0.00秒</strong> 就打印“总耗时”，然后才慢慢打印“下载完成”。</p><ul><li><strong>原因</strong>：Python 的主线程（老板）启动完子线程（工人）后，默认是<strong>不等的</strong>。工人还在下载，老板已经把最后一句 <code>print(总耗时)</code> 执行完了。</li><li><strong>作用</strong>：<code>join()</code> 就像是设了一个<strong>关卡</strong>：“所有人都得在这儿集合！谁没干完，主程序就不准结束！”</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>使用原始的 <code>threading</code> 模块有两个大麻烦：</p><ol><li><strong>管理麻烦</strong>：如果有 1000 个任务，你不能真的启动 1000 个线程（CPU 切换会累死，内存会爆）。你需要控制<strong>最大并发数</strong>（比如只允许同时有 5 个人干活，后面的人排队）。</li><li><strong>拿结果麻烦</strong>：<code>threading.Thread</code> 很难获取函数的<strong>返回值</strong>。你不知道工人干得怎么样，只能靠改全局变量或用队列，很丑陋。</li></ol><p><strong>线程池完美解决了这两个问题。 核心模块：<code>concurrent.futures</code></strong></p><h4 id="实战代码-1：最常用的-submit-方式（灵活控制）"><a href="#实战代码-1：最常用的-submit-方式（灵活控制）" class="headerlink" title="实战代码 1：最常用的 submit 方式（灵活控制）"></a>实战代码 1：最常用的 <code>submit</code> 方式（灵活控制）</h4><p>这种方式适合：任务参数各不相同，或者你需要实时处理每个完成的任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 模拟一个有返回值的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">name, seconds</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔴 [开始] <span class="hljs-subst">&#123;name&#125;</span> 需要 <span class="hljs-subst">&#123;seconds&#125;</span>秒&quot;</span>)<br>    time.sleep(seconds)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;name&#125;</span> 下载成功！&quot;</span>  <span class="hljs-comment"># 这里有返回值！</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># max_workers=3: 也就是虽然我有 5 个任务，但公司只有 3 个工位</span><br>    <span class="hljs-comment"># 剩下 2 个任务得在外面排队，等有人干完了才能进</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 1. 提交任务 (submit)</span><br>        <span class="hljs-comment"># 这里的 task1, task2 是 &quot;未来对象&quot; (Future)，代表一个将来的结果</span><br>        all_tasks = [<br>            pool.submit(download, <span class="hljs-string">&quot;电影A&quot;</span>, <span class="hljs-number">2</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;图片B&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;小说C&quot;</span>, <span class="hljs-number">3</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;音乐D&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;文件E&quot;</span>, <span class="hljs-number">2</span>)<br>        ]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 任务已全部提交，正在排队执行中...\n&quot;</span>)<br><br>        <span class="hljs-comment"># 2. 获取结果 (as_completed)</span><br>        <span class="hljs-comment"># 谁先干完，谁先返回。不用傻傻地按顺序等。</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(all_tasks):<br>            result = future.result() <span class="hljs-comment"># 【关键】获取函数的返回值</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="实战代码-2：极简的-map-方式（批量处理）"><a href="#实战代码-2：极简的-map-方式（批量处理）" class="headerlink" title="实战代码 2：极简的 map 方式（批量处理）"></a>实战代码 2：极简的 <code>map</code> 方式（批量处理）</h4><p>这种方式适合：任务逻辑完全一样，只是参数不同（比如给 100 个 URL 列表发请求）。它的写法跟 Python 自带的 <code>map</code> 一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_url</span>(<span class="hljs-params">url</span>):<br>    time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 模拟请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;url&#125;</span>] 状态码: 200&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_map</span>():<br>    urls = [<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-string">&quot;www.google.com&quot;</span>, <span class="hljs-string">&quot;www.python.org&quot;</span>]<br>    <br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 一行代码搞定批量提交 + 结果按顺序返回</span><br>        <span class="hljs-comment"># 注意：这里的结果是严格按照 urls 列表的顺序返回的</span><br>        results = pool.<span class="hljs-built_in">map</span>(check_url, urls)<br>        <br>        <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> results:<br>            <span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_map()<br></code></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul><li><strong>可迭代对象 (Iterable)</strong>：<ul><li><strong>含义</strong>：具有“被遍历能力”的数据。</li><li><strong>例子</strong>：<code>list</code>, <code>tuple</code>, <code>str</code>, <code>dict</code>。</li><li><strong>特征</strong>：内部实现了 <code>__iter__</code> 方法。它本身不记录位置，需要转化成迭代器才能用 <code>next()</code>。</li></ul></li><li><strong>迭代器 (Iterator)</strong>：<ul><li><strong>含义</strong>：正在执行遍历动作的那个“指针”。</li><li><strong>例子</strong>：<code>iter(list)</code> 后的结果。</li><li><strong>特征</strong>：同时实现了 <code>__iter__</code> 和 <strong><code>__next__</code></strong> 方法。</li></ul></li></ul><p><code>for x in [1, 2, 3]</code>，其实 Python 偷偷做了三件事：</p><ol><li>调用 <code>iter()</code> 把列表变成迭代器。</li><li>不断调用 <code>next()</code> 获取下一个值。</li><li>遇到 <code>StopIteration</code> 异常时，停止循环。</li></ol><p>手动模拟一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 这是一个可迭代对象 (Iterable)</span><br>my_list = [<span class="hljs-string">&quot;接口A&quot;</span>, <span class="hljs-string">&quot;接口B&quot;</span>, <span class="hljs-string">&quot;接口C&quot;</span>]<br><br><span class="hljs-comment"># ❌ 直接 next(my_list) 会报错，因为它还不是迭代器</span><br><br><span class="hljs-comment"># 2. 变成迭代器 (Iterator)</span><br><span class="hljs-comment"># 这一步相当于给薯片筒装上了弹簧，可以往外弹了</span><br>my_iterator = <span class="hljs-built_in">iter</span>(my_list)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;迭代器长这样: <span class="hljs-subst">&#123;my_iterator&#125;</span>&quot;</span>) <br><span class="hljs-comment"># &lt;list_iterator object at 0x...&gt;</span><br><br><span class="hljs-comment"># 3. 手动调用 next()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口A</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口B</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口C</span><br><br><span class="hljs-comment"># 4. 再拿一次？</span><br><span class="hljs-comment"># print(next(my_iterator)) </span><br><span class="hljs-comment"># 报错！StopIteration (薯片吃完了)</span><br></code></pre></td></tr></table></figure><p>要在 Python 中创建一个自定义的迭代器类，需要实现两个魔术方法：</p><ul><li><code>__iter__(self)</code>: 返回自己。</li><li><code>__next__(self)</code>: 返回下一个数据，或者抛出 <code>StopIteration</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_num</span>):<br>        <span class="hljs-variable language_">self</span>.max_num = max_num<br>        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 1. 必须有这个，表明我是可迭代的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-comment"># 2. 必须有这个，定义“下一次”返回什么</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 只要没超标，就返回新账号</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current &lt;= <span class="hljs-variable language_">self</span>.max_num:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;User_<span class="hljs-subst">&#123;self.current&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 超标了，通知 for 循环停下来</span><br>            <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># --- 使用 ---</span><br><br><span class="hljs-comment"># 创建一个能生成 3 个账号的迭代器</span><br>users = UserGenerator(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 像用列表一样用它</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users:<br>    <span class="hljs-built_in">print</span>(u)<br><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># User_1</span><br><span class="hljs-comment"># User_2</span><br><span class="hljs-comment"># User_3</span><br></code></pre></td></tr></table></figure><p>假设有一个 1GB 的 CSV 文件，里面存了 <strong>100 万条</strong> 真实的交易数据，你要用这些数据来跑测试。</p><ul><li><strong>如果不通过迭代器（用 List）</strong>： <code>data = open(&quot;big_data.csv&quot;).readlines()</code> 这会瞬间把 100 万行数据全部加载到内存里，电脑可能会卡死（MemoryError）。</li><li><strong>如果使用迭代器</strong>： 写一个迭代器，每次只从文件里<strong>读取一行</strong>，测试完这一行，扔掉，再读下一行。 <strong>结果</strong>：不管文件有几百 GB，程序只占几 KB 的内存。这叫 <strong>“惰性求值” (Lazy Evaluation)</strong>。</li></ul><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器 <strong>本质上就是一个迭代器</strong>。 但不需要写复杂的类，只需要写一个<strong>函数</strong>。</p><ul><li><strong>普通函数</strong>：用 <code>return</code> 返回结果。一旦 <code>return</code>，函数就结束了，内存也就释放了。</li><li><strong>生成器函数</strong>：用 <strong><code>yield</code></strong> 返回结果。<ul><li><strong>暂停</strong>：函数执行到 <code>yield</code> 时，会把结果交出去，然后<strong>暂停</strong>在这一行（像按了暂停键）。</li><li><strong>保留现场</strong>：函数内的变量、状态全都保留着，没死。</li><li><strong>恢复</strong>：下次你再调用 <code>next()</code> 时，它从刚才暂停的地方<strong>继续往下执行</strong>。</li></ul></li></ul><p>普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_list</span>():<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        result.append(<span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 必须全部做完才能返回</span><br><br><span class="hljs-comment"># 调用</span><br>plate = make_dumplings_list()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;端上来：<span class="hljs-subst">&#123;plate&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成器函数 (<code>yield</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        <span class="hljs-comment"># 【关键】把饺子交出去，然后在这个位置暂停！</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   (第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子被取走了...继续干活)&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br><span class="hljs-comment"># 注意：这一步并没有执行函数代码！只是创建了一个生成器对象</span><br>gen = make_dumplings_gen()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成器对象: <span class="hljs-subst">&#123;gen&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 开始吃 (手动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 我要吃第一个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师包第1个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 我要吃第二个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师从暂停处恢复 -&gt; 包第2个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-comment"># --- 或者直接用 for 循环 (自动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 剩下的我全包了&quot;</span>)<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(d)<br>    <br><span class="hljs-string">&quot;&quot;&quot;    </span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第一个</span><br><span class="hljs-string">👨‍🍳 正在包第 1 个饺子...</span><br><span class="hljs-string">饺子_1</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第二个</span><br><span class="hljs-string">   (第 1 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 2 个饺子...</span><br><span class="hljs-string">饺子_2</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>剩下的我全包了</span><br><span class="hljs-string">   (第 2 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 3 个饺子...</span><br><span class="hljs-string">饺子_3</span><br><span class="hljs-string">   (第 3 个饺子被取走了...继续干活)</span><br></code></pre></td></tr></table></figure><p>写法2-生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 列表推导式 (耗内存)</span><br>list_data = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(list_data) <br><span class="hljs-comment"># 输出: [0, 1, 4, 9, ..., 81] (内存里真的有10个数)</span><br><br><span class="hljs-comment"># 2. 生成器表达式 (省内存)</span><br>gen_data = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(gen_data)<br><span class="hljs-comment"># 输出: &lt;generator object ...&gt; (内存里只有一个公式，还没算呢)</span><br><br><span class="hljs-comment"># 想用的时候再算</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><hr><h1 id="Property属性"><a href="#Property属性" class="headerlink" title="Property属性"></a>Property属性</h1><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, birth_year</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.birth_year = birth_year<br><br>    <span class="hljs-comment"># 【关键】加上 @property</span><br>    <span class="hljs-comment"># 把这个方法变成一个 &quot;只读属性&quot;</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        current_year = datetime.datetime.now().year<br>        <span class="hljs-keyword">return</span> current_year - <span class="hljs-variable language_">self</span>.birth_year<br><br>s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment"># 1. 像访问变量一样访问 age（注意：后面没有括号！）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;今年年龄: <span class="hljs-subst">&#123;s1.age&#125;</span>&quot;</span>) <br><br><span class="hljs-comment"># 2. 尝试修改它（会报错）</span><br><span class="hljs-comment"># s1.age = 18 </span><br><span class="hljs-comment"># 报错：AttributeError: can&#x27;t set attribute (因为我们只定义了 getter，没定义 setter)</span><br></code></pre></td></tr></table></figure><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这是一个私有变量，不对外公开</span><br>        <span class="hljs-variable language_">self</span>._score = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># --- 1. 定义 Getter (读) ---</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._score<br><br>    <span class="hljs-comment"># --- 2. 定义 Setter (写) ---</span><br>    <span class="hljs-comment"># 语法规则：@函数名.setter</span><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 错误：分数必须是整数！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 错误：分数 <span class="hljs-subst">&#123;value&#125;</span> 超出范围 (0-100)！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>            <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 分数 <span class="hljs-subst">&#123;value&#125;</span> 设置成功&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._score = value<br><br><span class="hljs-comment"># --- 测试 ---</span><br>s = Student()<br><br><span class="hljs-comment"># 正常赋值</span><br>s.score = <span class="hljs-number">90</span>  <span class="hljs-comment"># 自动触发 @score.setter 下的函数</span><br><span class="hljs-built_in">print</span>(s.score) <span class="hljs-comment"># 自动触发 @property 下的函数</span><br><br><span class="hljs-comment"># 异常赋值（会被 setter 里的逻辑拦截）</span><br>s.score = <span class="hljs-number">999</span> <br>s.score = <span class="hljs-string">&quot;不及格&quot;</span><br><br><span class="hljs-comment"># 再次查看，还是原来的 90，没被污染</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前真实分数: <span class="hljs-subst">&#123;s.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="基础语法速查表"><a href="#基础语法速查表" class="headerlink" title="基础语法速查表"></a>基础语法速查表</h3><p>认识几个“特殊符号”（元字符）：</p><h4 id="A-代表“字符”的符号"><a href="#A-代表“字符”的符号" class="headerlink" title="A. 代表“字符”的符号"></a>A. 代表“字符”的符号</h4><ul><li><strong><code>.</code> (点)</strong>：万能符。代表<strong>除了换行符以外的任意一个字符</strong>。</li><li><strong><code>\d</code></strong>：数字 (Digit)。等价于 <code>[0-9]</code>。</li><li><strong><code>\w</code></strong>：单词字符 (Word)。代表 <strong>数字、字母、下划线、中文</strong>（Python 3 中）。</li><li><strong><code>\s</code></strong>：空白符 (Space)。代表空格、Tab、换行。</li></ul><h4 id="B-代表“数量”的符号"><a href="#B-代表“数量”的符号" class="headerlink" title="B. 代表“数量”的符号"></a>B. 代表“数量”的符号</h4><ul><li><strong><code>*</code></strong>：0 次或多次（有没有都行，越多越好）。</li><li><strong><code>+</code></strong>：1 次或多次（至少得有一个）。</li><li><strong><code>?</code></strong>：0 次或 1 次（要么没有，要么有一个）。</li><li><strong><code>&#123;n&#125;</code></strong>：恰好 n 次。</li><li><strong><code>&#123;n, m&#125;</code></strong>：n 到 m 次。</li></ul><h4 id="C-代表“位置”的符号"><a href="#C-代表“位置”的符号" class="headerlink" title="C. 代表“位置”的符号"></a>C. 代表“位置”的符号</h4><ul><li><strong><code>^</code></strong>：必须以…开头。</li><li><strong><code>$</code></strong>：必须以…结尾。</li></ul><p>1：<code>re.findall()</code> —— 找到所有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;张三的电话是 13811112222，李四的电话是 15933334444，还有一个座机 010-123456。&quot;</span><br><br><span class="hljs-comment"># 规则：1开头，后面接10个数字</span><br><span class="hljs-comment"># r&#x27;&#x27; 表示原生字符串，防止转义字符捣乱，写正则建议都要加 r</span><br>pattern = <span class="hljs-string">r&quot;1\d&#123;10&#125;&quot;</span><br><br>phones = re.findall(pattern, text)<br><span class="hljs-built_in">print</span>(phones)<br><span class="hljs-comment"># 输出: [&#x27;13811112222&#x27;, &#x27;15933334444&#x27;]</span><br></code></pre></td></tr></table></figure><p>2：<code>re.search()</code> —— 找到第一个就收工 (最常用):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>html = <span class="hljs-string">&quot;&lt;div&gt;订单号: &lt;span id=&#x27;order&#x27;&gt;20231212001&lt;/span&gt;&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 规则：找数字，但我要更精确</span><br><span class="hljs-comment"># 使用括号 () 进行【分组提取】，这是做接口测试提取数据的核心！</span><br><span class="hljs-comment"># r&quot;(\d&#123;11&#125;)&quot; 意思是：找到11个数字，并把这11个数字单独拿出来</span><br>match_obj = re.search(<span class="hljs-string">r&quot;id=&#x27;order&#x27;&gt;(\d+)&lt;&quot;</span>, html)<br><br><span class="hljs-keyword">if</span> match_obj:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;匹配到的整体: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">0</span>)&#125;</span>&quot;</span>) <span class="hljs-comment"># id=&#x27;order&#x27;&gt;20231212001&lt;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取的目标: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)   <span class="hljs-comment"># 20231212001 (我们通常只要这个)</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没找到&quot;</span>)<br></code></pre></td></tr></table></figure><p>3：<code>re.sub()</code> —— 替换 (清洗数据):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;我给你转了￥100元，又转了$50元&quot;</span><br><br><span class="hljs-comment"># 把所有的货币符号去掉，只留数字</span><br><span class="hljs-comment"># [] 表示“其中任意一个”</span><br>new_text = re.sub(<span class="hljs-string">r&quot;[￥$元]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, text)<br><br><span class="hljs-built_in">print</span>(new_text) <br><span class="hljs-comment"># 输出: 我给你转了100，又转了50</span><br></code></pre></td></tr></table></figure><p>4:re.match()–只从字符串的第一个字符开始匹配:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello Python World&quot;</span><br>pattern = <span class="hljs-string">r&quot;Python&quot;</span><br><br><span class="hljs-comment"># --- 1. 使用 match (碰壁) ---</span><br><span class="hljs-comment"># match 看了看第一个单词 &quot;Hello&quot;，发现不是 &quot;Python&quot;，直接报错(返回None)</span><br>res_match = re.<span class="hljs-keyword">match</span>(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 结果: <span class="hljs-subst">&#123;res_match&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Match 结果: None</span><br><br><br><span class="hljs-comment"># --- 2. 使用 search (成功) ---</span><br><span class="hljs-comment"># search 很有耐心，跳过 Hello，在第 6 个位置找到了 Python</span><br>res_search = re.search(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Search 结果: <span class="hljs-subst">&#123;res_search&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Search 结果: &lt;re.Match object; span=(6, 12), match=&#x27;Python&#x27;&gt;</span><br><br><br><span class="hljs-comment"># --- 3. 只有一种情况 match 能成功 ---</span><br><span class="hljs-comment"># 必须让 Python 出现在开头</span><br>text_2 = <span class="hljs-string">&quot;Python is good&quot;</span><br>res_match_2 = re.<span class="hljs-keyword">match</span>(pattern, text_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 成功: <span class="hljs-subst">&#123;res_match_2&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: Match 成功: &lt;re.Match object...&gt;</span><br></code></pre></td></tr></table></figure><p>5:贪婪与非贪婪:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&quot;&lt;div&gt;第一个&lt;/div&gt;&lt;div&gt;第二个&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 1. 贪婪模式 (.*)</span><br><span class="hljs-comment"># 它会从第一个 &lt;div&gt; 一直吃到最后一个 &lt;/div&gt;，中间不管有多少闭合标签全吞了</span><br>res_greedy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;贪婪: <span class="hljs-subst">&#123;res_greedy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&lt;/div&gt;&lt;div&gt;第二个&#x27;]  &lt;-- 翻车了！</span><br><br><span class="hljs-comment"># 2. 非贪婪模式 (.*?)</span><br><span class="hljs-comment"># 遇到第一个 &lt;/div&gt; 它就觉得“够了”，停止匹配</span><br>res_lazy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*?)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;非贪婪: <span class="hljs-subst">&#123;res_lazy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&#x27;, &#x27;第二个&#x27;] &lt;-- 这才是我们要的</span><br></code></pre></td></tr></table></figure><hr><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Python 的 GC 机制是以【引用计数】为主，以【标记-清除】和【分代回收】为辅。</p><h2 id="引用计数-Reference-Counting"><a href="#引用计数-Reference-Counting" class="headerlink" title="引用计数 (Reference Counting)"></a>引用计数 (Reference Counting)</h2><p>这是 Python 内存管理最核心、最基础的机制。它像是一个**“计分器”**。</p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Python 中的每个对象（比如一个列表、一个数字）内部都有一个字段叫 <code>ob_refcnt</code>，记录着**“现在有多少个变量引用着我”**。</p><ul><li><strong>计数 +1 的情况</strong>：<ul><li>对象被创建：<code>a = [1, 2]</code> （计数&#x3D;1）</li><li>被赋值给别人：<code>b = a</code> （计数&#x3D;2）</li><li>作为参数传给函数：<code>func(a)</code> （计数+1，函数结束-1）</li><li>被放进容器里：<code>list_c = [a]</code> （计数+1）</li></ul></li><li><strong>计数 -1 的情况</strong>：<ul><li>变量被显式销毁：<code>del a</code></li><li>变量被赋予了新值：<code>a = &quot;hello&quot;</code> （原来的 <code>[1,2]</code> 计数-1）</li><li>离开作用域（函数运行结束）：局部变量会被自动销毁。</li></ul></li><li><strong>回收时刻</strong>：<ul><li>一旦某个对象的引用计数变成 <strong>0</strong>，Python 里的“收尸队”会<strong>立刻</strong>把它回收，释放内存。这是一种<strong>实时</strong>的回收机制。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 出生了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💀 <span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了 (内存释放)&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 创建对象（计数=1）</span><br>h1 = Hero(<span class="hljs-string">&quot;亚索&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 注意：sys.getrefcount() 会比实际多 1，因为它自己作为参数也引用了一次</span><br><br><span class="hljs-comment"># 2. 增加引用（计数+1）</span><br>h2 = h1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <span class="hljs-comment"># 现在有两个变量指着它</span><br><br><span class="hljs-comment"># 3. 删除其中一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h1...&quot;</span>)<br><span class="hljs-keyword">del</span> h1<br><span class="hljs-comment"># 此时 h2 还在，引用计数没归零，所以亚索还活着，不会打印 &quot;被销毁&quot;</span><br><br><span class="hljs-comment"># 4. 删除最后一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h2...&quot;</span>)<br><span class="hljs-keyword">del</span> h2<br><span class="hljs-comment"># 此时引用计数为 0，系统立刻触发回收，打印 &quot;被销毁&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 程序结束&quot;</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">✅ 亚索 出生了</span><br><span class="hljs-string">引用计数: 2</span><br><span class="hljs-string">引用计数: 3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h1...</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h2...</span><br><span class="hljs-string">💀 亚索 被销毁了 (内存释放)</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>程序结束</span><br></code></pre></td></tr></table></figure><h4 id="致命缺点：循环引用-Circular-Reference"><a href="#致命缺点：循环引用-Circular-Reference" class="headerlink" title="致命缺点：循环引用 (Circular Reference)"></a>致命缺点：循环引用 (Circular Reference)</h4><p>引用计数非常快，但有一个死穴。请看下面这个经典的“互为舔狗”场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>]<br>b = [<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 互相引用</span><br>a.append(b) <span class="hljs-comment"># a 引用 b</span><br>b.append(a) <span class="hljs-comment"># b 引用 a</span><br><br><span class="hljs-comment"># 删除外部引用</span><br><span class="hljs-keyword">del</span> a<br><span class="hljs-keyword">del</span> b<br></code></pre></td></tr></table></figure><p><strong>结果</strong>：</p><ul><li>执行 <code>del a</code> 后，<code>[1]</code> 的计数从 2 减为 1（因为 <code>b</code> 还在引用它）。</li><li>执行 <code>del b</code> 后，<code>[2]</code> 的计数从 2 减为 1（因为 <code>a</code> 还在引用它）。</li><li><strong>死锁</strong>：外界已经谁也找不到这两个列表了，但它俩在内存里互相抓着对方，计数器永远不为 0。这就造成了<strong>内存泄漏</strong>。</li></ul><p><strong>为了解决这个问题，Python 引入了后面两把辅助斧头。</strong></p><hr><h2 id="标记-清除-Mark-and-Sweep"><a href="#标记-清除-Mark-and-Sweep" class="headerlink" title="标记-清除 (Mark and Sweep)"></a>标记-清除 (Mark and Sweep)</h2><p>这把斧头专门用来解决<strong>循环引用</strong>的问题。</p><p>它不再盯着计数器看，而是从更高的视角看**“连通性”**。</p><h4 id="1-原理（图论思想）"><a href="#1-原理（图论思想）" class="headerlink" title="1. 原理（图论思想）"></a>1. 原理（图论思想）</h4><p>Python 会把所有的对象看作图的节点，引用看作边。</p><ul><li><strong>Root (根节点)</strong>：全局变量、调用栈里的变量、寄存器。这些是绝对不能回收的“大人物”。</li></ul><h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h4><ol><li><strong>标记 (Mark)</strong>：GC 算法从“根节点”出发，沿着引用链往下走。凡是能走到的对象，都打上“<strong>存活</strong>”的标签。</li><li><strong>清除 (Sweep)</strong>：遍历所有对象，凡是<strong>没有</strong>被打上“存活”标签的（也就是那些与外界彻底失联的“孤岛”，比如刚才互为舔狗的那俩），统统干掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 准备好了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;♻️ <span class="hljs-subst">&#123;self.name&#125;</span> 被 GC 回收了&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_cycle</span>():<br>    <span class="hljs-comment"># 1. 创建两个对象</span><br>    n1 = Node(<span class="hljs-string">&quot;节点A&quot;</span>)<br>    n2 = Node(<span class="hljs-string">&quot;节点B&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 制造循环引用 (互为舔狗)</span><br>    n1.partner = n2 <span class="hljs-comment"># Python 允许在对象创建后的任何时间，给它身上贴任何新的属性标签。</span><br>    n2.partner = n1<br><br>    <span class="hljs-comment"># 3. 删除外部引用</span><br>    <span class="hljs-comment"># 按理说，函数结束，n1 和 n2 应该被销毁。</span><br>    <span class="hljs-comment"># 但因为它们互相拉着对方，引用计数不为 0，所以默认无法回收！</span><br>    <span class="hljs-keyword">del</span> n1<br>    <span class="hljs-keyword">del</span> n2<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 函数运行结束，外部引用已断开&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 为了演示效果，我们先关闭自动 GC，模拟引用计数解决不了的场景</span><br>gc.disable()<br><br>create_cycle()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 等待片刻 ---&quot;</span>)<br><span class="hljs-comment"># 此时你会发现，并没有打印 &quot;被 GC 回收了&quot;，说明内存泄漏了！</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 手动触发 GC (标记-清除)...&quot;</span>)<br><span class="hljs-comment"># 手动召唤收尸队</span><br>collected_num = gc.collect()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;本次 GC 清理了 <span class="hljs-subst">&#123;collected_num&#125;</span> 个垃圾对象&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序彻底结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="分代回收-Generational-Collection"><a href="#分代回收-Generational-Collection" class="headerlink" title="分代回收 (Generational Collection)"></a>分代回收 (Generational Collection)</h2><p>标记-清除虽然能解决循环引用，但它要把所有对象扫描一遍，<strong>太慢了</strong>！ 为了不拖慢程序运行速度，Python 引入了**“分代回收”**（基于“空间换时间”的思想）。</p><h4 id="1-核心假设"><a href="#1-核心假设" class="headerlink" title="1. 核心假设"></a>1. 核心假设</h4><p><strong>“对象存活越久，它是垃圾的可能性越小。”</strong></p><ul><li>新创建的对象（比如循环里的临时变量）往往死得快。</li><li>老不死的对象（比如全局配置）往往会一直活下去。</li></ul><h4 id="2-三代人-0代-1代-2代"><a href="#2-三代人-0代-1代-2代" class="headerlink" title="2. 三代人 (0代, 1代, 2代)"></a>2. 三代人 (0代, 1代, 2代)</h4><p>Python 将所有的对象分为三代：</p><ul><li><strong>0代 (Generation 0)</strong>：新生代。所有新创建的对象都放这里。</li><li><strong>1代 (Generation 1)</strong>：中生代。</li><li><strong>2代 (Generation 2)</strong>：老年代。</li></ul><h4 id="3-回收逻辑"><a href="#3-回收逻辑" class="headerlink" title="3. 回收逻辑"></a>3. 回收逻辑</h4><ol><li><strong>扫描频率</strong>：0代扫描最勤快，1代次之，2代最懒。</li><li><strong>晋升机制</strong>：<ul><li>当 GC 扫描 0代列表时，发现有些对象居然还活着（没被回收），那就把它们<strong>移入 1代</strong>。</li><li>同理，如果在扫描 1代时对象还没死，就<strong>移入 2代</strong>。</li></ul></li><li><strong>触发阈值</strong>（了解即可）：<ul><li>当 0代对象数量达到一定阈值（默认 700 个），就会触发一次 0代 GC。</li><li>当 0代 GC 触发 10 次，才会触发一次 1代 GC。</li><li>当 1代 GC 触发 10 次，才会触发一次 2代 GC。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><span class="hljs-comment"># 获取当前的分代回收阈值</span><br>threshold = gc.get_threshold()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;700 表示：0代对象超过 700 个触发一次 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：0代 GC 触发 10 次，触发一次 1代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：1代 GC 触发 10 次，触发一次 2代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前阈值: <span class="hljs-subst">&#123;threshold&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前每一代的垃圾数量</span><br><span class="hljs-comment"># 结果类似 (count0, count1, count2)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前各代垃圾数量: <span class="hljs-subst">&#123;gc.get_count()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="数据结构原理"><a href="#数据结构原理" class="headerlink" title="数据结构原理"></a>数据结构原理</h1><h3 id="1-列表-List-vs-元组-Tuple"><a href="#1-列表-List-vs-元组-Tuple" class="headerlink" title="1. 列表 (List) vs 元组 (Tuple)"></a>1. 列表 (List) vs 元组 (Tuple)</h3><p><strong>面试题</strong>：“List 和 Tuple 有什么区别？为什么 Python 要设计两个看似一样的东西？”</p><h4 id="核心区别："><a href="#核心区别：" class="headerlink" title="核心区别："></a>核心区别：</h4><ol><li><strong>可变性 (Mutability)</strong>：<ul><li><strong>List (<code>[]</code>)</strong>：<strong>可变的（Mutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“背包”**。你可以随时往里塞东西、拿东西出来，甚至把里面的苹果换成香蕉。</li></ul></li><li><strong>Tuple (<code>()</code>)</strong>：<strong>不可变的（Immutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“琥珀”<strong>或者</strong>“封死的快递箱”**。一旦出厂（创建），里面的东西就定死了。你想改？只能打碎了重新做一个。</li></ul></li></ul></li><li><strong>性能 (Performance)</strong>：<ul><li><strong>Tuple 比 List 快</strong>。</li><li><strong>原因</strong>：<ul><li>Python 对 Tuple 做了<strong>内存缓存机制</strong>。当你创建一个 tuple 时，Python 知道它不会变，所以可以放心大胆地分配一段固定的内存，不需要像 List 那样预留额外的空间（为了 append）。</li><li>如果你的数据只读不改（比如配置参数、数据库查出来的结果），请无脑用 Tuple。</li></ul></li></ul></li><li><strong>作为字典的 Key</strong>：<ul><li><strong>Tuple 可以</strong>做字典的 Key（只要里面装的也是不可变元素）。</li><li><strong>List 不行</strong>（因为它是可变的，不可哈希）。</li></ul></li></ol><hr><h3 id="2-字典-Dict-的底层原理-——-哈希表-Hash-Table"><a href="#2-字典-Dict-的底层原理-——-哈希表-Hash-Table" class="headerlink" title="2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)"></a>2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)</h3><p><strong>面试题</strong>：“字典为什么查找速度这么快？底层是怎么实现的？”</p><p>这是 Python 面试中<strong>含金量最高</strong>的问题。</p><h4 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h4><p>字典查找是 <strong>O(1)</strong> 的时间复杂度（也就是<strong>秒查</strong>，不管字典里有 1 万个数据还是 1 亿个，查找速度几乎一样快）。</p><p><strong>比喻：超市储物柜</strong></p><ul><li><strong>Hash 函数</strong>：就是<strong>条形码扫描枪</strong>。</li><li><strong>Key</strong>：你手里的<strong>小票</strong>。</li><li><strong>Value</strong>：柜子里的<strong>包</strong>。</li></ul><p>当你想存东西（<code>dict[&quot;name&quot;] = &quot;亚索&quot;</code>）：</p><ol><li>Python 拿着 “name” 这个 Key，通过 <strong>哈希函数 (hash function)</strong> 算出一个数字（比如 10086）。</li><li>这个数字直接对应内存里的<strong>地址索引</strong>。</li><li>Python 直接把 “亚索” 扔进 10086 号柜子。</li></ol><p>当你想取东西（<code>dict[&quot;name&quot;]</code>）：</p><ol><li>Python 拿着 “name” 再算一次哈希值，算出 10086。</li><li>直接去 10086 号柜子拿数据。</li><li><strong>完全不需要遍历！</strong> 不需要一个个柜子打开看。</li></ol><h4 id="追问：哈希冲突-Hash-Collision"><a href="#追问：哈希冲突-Hash-Collision" class="headerlink" title="追问：哈希冲突 (Hash Collision)"></a>追问：哈希冲突 (Hash Collision)</h4><p><strong>面试题</strong>：“如果两个不同的 Key，算出来的哈希值一样（都要抢 10086 号柜子）怎么办？”</p><ul><li><strong>Java (HashMap)</strong>：采用**“链地址法”**。如果你来了发现 10086 有人了，你在 10086 后面挂个钩子，吊在下面（形成链表）。</li><li><strong>Python (Dict)</strong>：采用**“开放寻址法” (Open Addressing)**。<ul><li><strong>逻辑</strong>：如果你来了发现 10086 被占了，Python 会说：“别急，往后看！”</li><li>它会按照某种规则（比如看 10087、10088…）去找<strong>下一个空的柜子</strong>存进去。</li><li><em>注：Python 3.6+ 之后对字典进行了大量优化（变得有序且更省内存），但核心依然是哈希表。</em></li></ul></li></ul><hr><h3 id="3-列表-List-的底层-——-动态数组"><a href="#3-列表-List-的底层-——-动态数组" class="headerlink" title="3. 列表 (List) 的底层 —— 动态数组"></a>3. 列表 (List) 的底层 —— 动态数组</h3><p><strong>面试题</strong>：“List 是怎么实现动态扩容的？为什么 append 很快，insert 很慢？”</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Python 的 List 不是链表，而是<strong>连续的内存空间（数组）</strong>，里面存的是<strong>指针</strong>（指向具体的对象）。</p><ol><li><strong>为什么 append (尾部插入) 快？</strong><ul><li>List 在初始化时，会<strong>偷偷多申请一点内存</strong>。</li><li>比如你存 3 个数，它实际申请了 4 个坑位。当你 <code>append</code> 第 4 个数时，直接放进去就行，不需要找操作系统要内存。</li></ul></li><li><strong>动态扩容 (Resizing)</strong>：<ul><li>如果你 append 第 5 个数，坑位不够了怎么办？</li><li>Python 会直接申请一个<strong>更大的内存条</strong>（通常是原来的 1.125 倍左右），然后把旧数据<strong>统统复制过去</strong>，再把旧内存扔掉。</li><li>这就是为什么偶尔一次 append 会变慢的原因。</li></ul></li><li><strong>为什么 insert (中间插入) 慢？</strong><ul><li>如果你在 index&#x3D;0 的位置插入一个数据。</li><li>Python 必须把后面所有的数据<strong>全体起立，向后挪一个位置</strong>，给新来的腾地儿。</li><li>数据越多，挪动越慢。所以 List 极其不适合做“队列”使用。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python进阶</tag>
      
      <tag>面向对象</tag>
      
      <tag>装饰器</tag>
      
      <tag>拷贝</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2025/12/09/Python%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-1-字面量"><a href="#1-1-字面量" class="headerlink" title="1.1 字面量"></a>1.1 字面量</h2><p>字面量：在代码中，被写下来的的固定的值，称之为字面量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;人生苦短_&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个变量</span><br>money = <span class="hljs-number">50</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br><br>money -= <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br></code></pre></td></tr></table></figure><hr><h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;小黎&quot;</span>)) <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)) <span class="hljs-comment"># &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">13.14</span>)) <span class="hljs-comment"># &lt;class &#x27;float&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int() 转换为整数类型</span><br>a = <span class="hljs-built_in">int</span>(<span class="hljs-number">99.6</span>) <span class="hljs-comment"># 99.6 转换为 99</span><br><span class="hljs-comment"># float() 转换为浮点类型</span><br>b = <span class="hljs-built_in">float</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 99.0</span><br><span class="hljs-comment"># str() 转换为字符串类型</span><br>c = <span class="hljs-built_in">str</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 &quot;99&quot;</span><br><span class="hljs-comment"># bool() 转换为布尔类型</span><br>d = <span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 转换为 True</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-6-字符串拼接"><a href="#1-6-字符串拼接" class="headerlink" title="1.6 字符串拼接"></a>1.6 字符串拼接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-comment"># 用+拼接只适用于字符串 不适用与整数型或浮点型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-7-字符串格式化"><a href="#1-7-字符串格式化" class="headerlink" title="1.7 字符串格式化"></a>1.7 字符串格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;小黎&quot;</span><br>age = <span class="hljs-number">22</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-comment"># %s 即将内容转换为字符串放入占位位置</span><br>message1 = <span class="hljs-string">&quot;我的名字是%s&quot;</span> %name<br>message2 = <span class="hljs-string">&quot;我的名字是%s,年龄是%d&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message1) <span class="hljs-comment"># 我的名字是小黎</span><br><span class="hljs-built_in">print</span>(message2) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-comment"># 数字精度控制 (会做四舍五入)</span><br>message3 = <span class="hljs-string">&quot;我的名字是%s,年龄是%.2f&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message3) <span class="hljs-comment"># 我的名字是小黎,年龄是22.00</span><br><span class="hljs-comment"># 方式二 比较快捷 不关心精度控制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的名字是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是&quot;</span>,name,<span class="hljs-string">&quot;年龄是&quot;</span>,age) <span class="hljs-comment"># 我的名字是 小黎 年龄是 22</span><br>age = <span class="hljs-number">22.0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age)) <span class="hljs-comment"># 我的年龄是22.00</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-8-表达式格式化"><a href="#1-8-表达式格式化" class="headerlink" title="1.8 表达式格式化"></a>1.8 表达式格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是%s&quot;</span> %(<span class="hljs-number">11</span> + <span class="hljs-number">11</span>)) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的年龄是<span class="hljs-subst">&#123;<span class="hljs-number">11</span> + <span class="hljs-number">11</span>&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字符串在python中的数据类型是%s&quot;</span> %(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;字符串&quot;</span>))) <span class="hljs-comment"># 字符串在python中的数据类型是&lt;class &#x27;str&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="2-1-布尔类型"><a href="#2-1-布尔类型" class="headerlink" title="2.1 布尔类型"></a>2.1 布尔类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-literal">True</span><br>b = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;a的内容是<span class="hljs-subst">&#123;a&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(a)&#125;</span>&quot;</span>) <span class="hljs-comment"># a的内容是True,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;b的内容是<span class="hljs-subst">&#123;b&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(b)&#125;</span>&quot;</span>) <span class="hljs-comment"># b的内容是False,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><br>result = <span class="hljs-number">10</span> &gt; <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10 &gt; 5 的结果是<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 10 &gt; 5 的结果是True</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-2-判断语句"><a href="#2-2-判断语句" class="headerlink" title="2.2 判断语句"></a>2.2 判断语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 产生一个1-10之间的随机数字</span><br>num = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(num)</span><br>guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入您猜测的数:&quot;</span>))<br><span class="hljs-keyword">if</span> guess_num == num:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第一次就猜中了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> guess_num &gt; num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>    guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>    <span class="hljs-keyword">if</span> guess_num == num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第二次猜中了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> guess_num &gt; num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>        guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>        <span class="hljs-keyword">if</span> guess_num == num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第三次猜中了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;很遗憾，三次你都没猜中&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="3-1-while循环"><a href="#3-1-while循环" class="headerlink" title="3.1 while循环"></a>3.1 while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">9</span>:<br>    j = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt;= i:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;j&#125;</span> * <span class="hljs-subst">&#123;i&#125;</span> = <span class="hljs-subst">&#123;j * i&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 不换行且对齐</span><br>        j += <span class="hljs-number">1</span><br>    i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 换行</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-2-for循环"><a href="#3-2-for循环" class="headerlink" title="3.2 for循环"></a>3.2 for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 统计字符串中有多少个a</span><br>name = <span class="hljs-string">&quot;xiaoli is a rapper&quot;</span><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> name:<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;a&quot;</span>:<br>        count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(count)<br></code></pre></td></tr></table></figure><hr><h2 id="3-3-range"><a href="#3-3-range" class="headerlink" title="3.3 range"></a>3.3 range</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># range的作用 获得一个数字序列</span><br>num1 = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num1:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="4-1-传参方式"><a href="#4-1-传参方式" class="headerlink" title="4.1 传参方式"></a>4.1 传参方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示多种传参的形式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 位置传参</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是20,性别是男</span><br><br><span class="hljs-comment"># 关键字传参</span><br>user_info(name=<span class="hljs-string">&#x27;小王&#x27;</span>, age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小王,年龄是19,性别是女</span><br>user_info(age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, name=<span class="hljs-string">&#x27;小黎&#x27;</span>)  <span class="hljs-comment"># 位置可随意</span><br><br><span class="hljs-comment"># 缺省参数(默认参数必须写在最后面)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender=<span class="hljs-string">&#x27;男&#x27;</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是男</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是女</span><br><br><span class="hljs-comment"># 位置不定长 不定长定义的形式参数会作为元组存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;args&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(args)&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;小黎&#x27;</span>, <span class="hljs-string">&#x27;男孩&#x27;</span>) <span class="hljs-comment"># args的内容是(1, 2, 3, &#x27;小黎&#x27;, &#x27;男孩&#x27;)，类型是&lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 关键字不定长 不定长定义的形式参数会作为字典存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;kwargs&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(kwargs)&#125;</span>&quot;</span>)<br><br>user_info(name=<span class="hljs-string">&quot;小黎&quot;</span>, age=<span class="hljs-number">22</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># args的内容是&#123;&#x27;name&#x27;: &#x27;小黎&#x27;, &#x27;age&#x27;: 22, &#x27;gender&#x27;: &#x27;男&#x27;&#125;，类型是&lt;class &#x27;dict&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-2-函数作为参数传递"><a href="#4-2-函数作为参数传递" class="headerlink" title="4.2 函数作为参数传递"></a>4.2 函数作为参数传递</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是<span class="hljs-subst">&#123;result&#125;</span>,参数类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(compute)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br>test_func(compute) <span class="hljs-comment"># 计算结果是3,参数类型是&lt;class &#x27;function&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-3-lambda匿名函数"><a href="#4-3-lambda匿名函数" class="headerlink" title="4.3 lambda匿名函数"></a>4.3 lambda匿名函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果是:<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 将匿名函数作为参数传入</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x + y)<br></code></pre></td></tr></table></figure><hr><h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="5-1-列表"><a href="#5-1-列表" class="headerlink" title="5.1 列表"></a>5.1 列表</h2><h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><p>列表可以修改、支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>,<span class="hljs-number">666</span>,<span class="hljs-string">&quot;python&quot;</span>]<br><span class="hljs-comment"># 查找某元素的下标索引 若不存在会报错</span><br><span class="hljs-built_in">print</span>(mylist.index(<span class="hljs-string">&quot;python&quot;</span>))<br><span class="hljs-comment"># 修改目标索引对应元素的值</span><br>mylist[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;小黎&quot;</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在目标索引处插入元素</span><br>mylist.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加元素</span><br>mylist.append(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br>mylist += [<span class="hljs-string">&quot;人生苦短&quot;</span>]<br>mylist *= <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加一个数据容器中的元素</span><br>mylist2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>mylist.extend(mylist2)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除目标索引处的元素 两种方法 第一种方法可以得到返回值</span><br>element = mylist.pop(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-keyword">del</span> mylist[<span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除某元素在列表中的第一个匹配项</span><br>mylist.remove(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 统计某元素的个数</span><br><span class="hljs-built_in">print</span>(mylist.count(<span class="hljs-string">&quot;xiaoli&quot;</span>))<br><span class="hljs-comment"># 统计所有元素的个数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mylist))<br><span class="hljs-comment"># 清空列表</span><br>mylist.clear()<br><span class="hljs-built_in">print</span>(mylist)<br></code></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_while_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(mylist):<br>        <span class="hljs-built_in">print</span>(mylist[index])<br>        index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 使用for循环遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_for_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> mylist:<br>        <span class="hljs-built_in">print</span>(element)<br><br>list_while_func()<br>list_for_func()<br></code></pre></td></tr></table></figure><hr><h2 id="5-2-元组"><a href="#5-2-元组" class="headerlink" title="5.2 元组"></a>5.2 元组</h2><p>元组不可修改，支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义元组</span><br>t1 = (<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义空元祖</span><br>t2 = ()<br>t3 = <span class="hljs-built_in">tuple</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t1的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t1)&#125;</span>,内容是<span class="hljs-subst">&#123;t1&#125;</span>&quot;</span>) <span class="hljs-comment"># t1的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(2, &#x27;Hello&#x27;, True)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t2的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t2)&#125;</span>,内容是<span class="hljs-subst">&#123;t2&#125;</span>&quot;</span>) <span class="hljs-comment"># t2的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t3的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t3)&#125;</span>,内容是<span class="hljs-subst">&#123;t3&#125;</span>&quot;</span>) <span class="hljs-comment"># t3的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-comment"># 定义单个元素的元组</span><br>t4 = (<span class="hljs-string">&quot;hello&quot;</span>)<br>t5 = (<span class="hljs-string">&quot;hello&quot;</span>,)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t4的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t4)&#125;</span>,内容是<span class="hljs-subst">&#123;t4&#125;</span>&quot;</span>) <span class="hljs-comment"># t4的类型是&lt;class &#x27;str&#x27;&gt;,内容是hello</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t5的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t5)&#125;</span>,内容是<span class="hljs-subst">&#123;t5&#125;</span>&quot;</span>) <span class="hljs-comment"># t5的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(&#x27;hello&#x27;,)</span><br><span class="hljs-comment"># 元组的嵌套</span><br>t6 = ((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t6的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t6)&#125;</span>,内容是<span class="hljs-subst">&#123;t6&#125;</span>&quot;</span>) <span class="hljs-comment"># t6的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是((1, 2, 3), (4, 5, 6))</span><br><span class="hljs-comment"># 取目标索引的值</span><br><span class="hljs-built_in">print</span>(t6[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) <span class="hljs-comment"># 6</span><br><span class="hljs-comment"># index</span><br><span class="hljs-built_in">print</span>(t1.index(<span class="hljs-string">&quot;Hello&quot;</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(t1.count(<span class="hljs-literal">True</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(t1)) <span class="hljs-comment"># 3</span><br><span class="hljs-comment"># while遍历</span><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(t1):<br>    <span class="hljs-built_in">print</span>(t1[index])<br>    index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># for遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> t1:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 不可以直接修改元组中的元素 否则会报错</span><br><span class="hljs-comment"># 但是若元组中包含列表 则可以修改该列表中的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-3-集合"><a href="#5-3-集合" class="headerlink" title="5.3 集合"></a>5.3 集合</h2><p>集合中的元素不重复且内容无序 不支持按照索引访问元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;learn&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>&#125;<br>my_set_empty = <span class="hljs-built_in">set</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set_empty)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 添加新元素</span><br>my_set.add(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 移除元素</span><br>my_set.remove(<span class="hljs-string">&quot;learn&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 随机取出一个元素</span><br>element = my_set.pop()<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 统计集合中元素的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_set))<br><span class="hljs-comment"># 遍历 由于不支持索引查找元素 所以不支持while循环遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> my_set:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 清空集合</span><br>my_set.clear()<br><span class="hljs-built_in">print</span>(my_set)<br><br><span class="hljs-comment"># 集合的数学运算</span><br>set1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>set2 = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment"># 并集 &#123;1,2,3,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.union(set2))<br><span class="hljs-built_in">print</span>(set1 | set2)<br><span class="hljs-comment"># 交集 &#123;3&#125;</span><br><span class="hljs-built_in">print</span>(set1.intersection(set2))<br><span class="hljs-built_in">print</span>(set1 &amp; set2)<br><span class="hljs-comment"># 差集 &#123;1,2&#125;</span><br><span class="hljs-built_in">print</span>(set1.difference(set2))<br><span class="hljs-built_in">print</span>(set1 - set2)<br><span class="hljs-comment"># 对称差集 &#123;1,2,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.symmetric_difference(set2))<br><span class="hljs-built_in">print</span>(set1 ^ set2)<br></code></pre></td></tr></table></figure><hr><h2 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h2><p>典存储的元素是键值对 key不允许重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;黎鸿翔&quot;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&quot;xiaoli&quot;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>: <span class="hljs-number">97</span>&#125;<br>my_dict_empty = &#123;&#125;  <span class="hljs-comment"># 空字典</span><br>my_dict_empty2 = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict的内容是<span class="hljs-subst">&#123;my_dict&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty的内容是<span class="hljs-subst">&#123;my_dict_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty2的内容是<span class="hljs-subst">&#123;my_dict_empty2&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty2)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 通过key获取value</span><br>score = my_dict[<span class="hljs-string">&quot;xiaoli&quot;</span>]<br><span class="hljs-built_in">print</span>(score)<br><span class="hljs-comment"># 修改或新增</span><br>my_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>] = <span class="hljs-number">99.5</span>  <span class="hljs-comment"># key存在则修改value</span><br>my_dict[<span class="hljs-string">&quot;孙悟空&quot;</span>] = <span class="hljs-number">99.9</span>  <span class="hljs-comment"># 若key不存在则为新增</span><br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 删除</span><br>value = my_dict.pop(<span class="hljs-string">&quot;孙悟空&quot;</span>)<br><span class="hljs-built_in">print</span>(value)<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 获取全部的key</span><br>keys = my_dict.keys()<br><span class="hljs-built_in">print</span>(keys)<br><span class="hljs-comment"># 遍历字典</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------&#x27;</span>)<br><span class="hljs-comment">#     方式二:</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 方式三: 通过items()方法获取key-value对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取全部的value</span><br>values = my_dict.values()<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><span class="hljs-comment">#     长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_dict))<br><span class="hljs-comment"># 清空</span><br>my_dict.clear()<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 定义嵌套字典</span><br>stu_score_dict = &#123;<br>    <span class="hljs-string">&quot;黎鸿翔&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">97</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">110</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">107</span><br>    &#125;,<br>    <span class="hljs-string">&quot;xiaoli&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">92</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">140</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">137</span><br>    &#125;,<br>    <span class="hljs-string">&quot;Lil Pear&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">90</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">120</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">100</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(stu_score_dict)<br><span class="hljs-comment"># 取value</span><br><span class="hljs-built_in">print</span>(stu_score_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>][<span class="hljs-string">&quot;数学&quot;</span>])<br></code></pre></td></tr></table></figure><hr><h2 id="5-5-字符串"><a href="#5-5-字符串" class="headerlink" title="5.5 字符串"></a>5.5 字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 小黎专属python固定模板</span><br><span class="hljs-comment"># 开发时间：2024/7/5 21:42</span><br><span class="hljs-comment"># 字符串不可修改，支持重复元素且有序</span><br>my_str = <span class="hljs-string">&quot;xiaoli is the best one&quot;</span><br><span class="hljs-built_in">print</span>(my_str)<br><span class="hljs-comment"># 通过索引取值</span><br><span class="hljs-built_in">print</span>(my_str[<span class="hljs-number">2</span>])<br><span class="hljs-comment"># index方法</span><br><span class="hljs-built_in">print</span>(my_str.index(<span class="hljs-string">&quot;is&quot;</span>))<br><span class="hljs-comment"># replace 替换</span><br>my_str2 = my_str.replace(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>)<br><span class="hljs-built_in">print</span>(my_str2)<br><span class="hljs-built_in">print</span>(my_str) <span class="hljs-comment">#不变</span><br><span class="hljs-comment"># split 字符串分割</span><br>mylist = my_str.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 字符串规整</span><br>my_str3 = <span class="hljs-string">&quot;  xiaoli  &quot;</span><br>my_str4 = <span class="hljs-string">&quot;12xiaoli212&quot;</span><br><span class="hljs-built_in">print</span>(my_str3.strip())<br><span class="hljs-built_in">print</span>(my_str4.strip(<span class="hljs-string">&quot;12&quot;</span>))<br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(my_str.count(<span class="hljs-string">&quot;i&quot;</span>))<br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_str))<br></code></pre></td></tr></table></figure><hr><h2 id="5-6-序列切片"><a href="#5-6-序列切片" class="headerlink" title="5.6 序列切片"></a>5.6 序列切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">序列是指：内容连续、有序，可使用下标索引的一类数据容器</span><br><span class="hljs-string">列表、元组、字符串，均可以视为序列</span><br><span class="hljs-string">切片就是从一个序列中取出一个子序列</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>mytuple = (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>mystr = <span class="hljs-string">&quot;0123456&quot;</span><br><span class="hljs-comment"># 对列表进行切片，从1开始，4结束(不含索引4对应的元素)，步长为1(默认为1可不写)</span><br>mylist2 = mylist[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(mylist2)<br><span class="hljs-comment"># 对元组进行切片，从头开始到尾结束，步长为1</span><br>mytuple2 = mytuple[:]<br><span class="hljs-built_in">print</span>(mytuple2)<br><span class="hljs-comment"># 对字符串进行切片，从头开始到尾结束，步长为2</span><br>mystr2 = mystr[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(mystr):<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr2)<br><br><span class="hljs-comment"># 也可以反向取</span><br><span class="hljs-comment"># 对列表进行切片，从头开始到尾结束，步长为-1</span><br>mylist3 = mylist[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mylist3)<br><span class="hljs-comment"># 对元组进行切片，从3开始到1结束，步长为-1</span><br>mytuple3 = mytuple[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mytuple3)<br><span class="hljs-comment"># 对字符串进行切片 从头开始到尾结束步长为-2</span><br>mystr3 = mystr[::-<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr3)<br></code></pre></td></tr></table></figure><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="6-1-文件读取"><a href="#6-1-文件读取" class="headerlink" title="6.1 文件读取"></a>6.1 文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f))<br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-comment"># print(f.read(9))  # 读取9个字节的内容</span><br><span class="hljs-comment"># print(f.read())</span><br><span class="hljs-comment"># io_list = f.readlines()  # 读取文件的全部行并存到列表中</span><br><span class="hljs-comment"># print(io_list)</span><br><br><span class="hljs-comment"># for line in f.readlines():</span><br><span class="hljs-comment">#     print(line)</span><br><br><span class="hljs-comment"># 读取每行数据</span><br><span class="hljs-comment"># line1 = f.readline()</span><br><span class="hljs-comment"># line2 = f.readline()</span><br><span class="hljs-comment"># line3 = f.readline()</span><br><span class="hljs-comment"># print(line1)</span><br><span class="hljs-comment"># print(line2)</span><br><span class="hljs-comment"># print(line3)</span><br><br><span class="hljs-comment"># for循环读取文件行</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>    <span class="hljs-built_in">print</span>(line.split(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-comment"># print(io_list)</span><br><span class="hljs-comment"># 文件的关闭</span><br>f.close()<br></code></pre></td></tr></table></figure><hr><h2 id="6-2-文件写入"><a href="#6-2-文件写入" class="headerlink" title="6.2 文件写入"></a>6.2 文件写入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件不存在时会创建新文件并写入内容 若文件存在则清空原有的内容并写入新内容 若要追加 则调整为a模式</span><br>f1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f1.write(<span class="hljs-string">&quot;你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f2.write(<span class="hljs-string">&quot;\n你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f1.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f2.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><br><span class="hljs-comment"># 捕获指定的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(name)<br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义的异常&quot;</span>)<br><br><span class="hljs-comment"># 捕获多个类型的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># print(name)</span><br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> (NameError,ZeroDivisionError) <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义或者除以0的异常&quot;</span>)<br><br><span class="hljs-comment"># finally 一定会执行的语句</span><br><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment">#     捕获全部异常的第二种写法</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;好高兴，无异常&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一定会执行finally中的语句&quot;</span>)<br>    f.close()<br></code></pre></td></tr></table></figure><hr><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用（导入模块去使用）</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/image1.png" class="" title="模块"><p>常用的组合形式如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 类、变量、方法等<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 别名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能名 <span class="hljs-keyword">as</span> 别名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种写法</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br><br><span class="hljs-comment"># 第二种写法</span><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br></code></pre></td></tr></table></figure><p>自定义模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a + b)<br><br><span class="hljs-comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> my_module1<br><br>my_module1.test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如，在my_module1.py文件中添加测试代码test(1,1).此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>test</code>函数的调用</p><p>注意事项：当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能</p><p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素</p><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>从物理上看，包就是一个文件夹，在该文件夹下包含了一个 <strong>init</strong>.py 文件，该文件夹可用于包含多个模块文件</p><p>从逻辑上看，包的本质依然是模块</p><p>当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/package.png" class="" title="包"><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-keyword">import</span> 包名.模块名</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">包名.模块名.目标</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础</title>
    <link href="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">目标：学会使用注释</span><br><span class="hljs-comment">     这是程序的讲解注释</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoteDemo</span>&#123;<br>    <span class="hljs-comment">//这是程序的主方法，是程序的入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我开始学习Java程序，好嗨皮~~&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        窗前明月光</span><br><span class="hljs-comment">        疑是地上霜</span><br><span class="hljs-comment">        举头望明月</span><br><span class="hljs-comment">        低头思故乡</span><br><span class="hljs-comment">        */</span><br>        System.out.println(<span class="hljs-string">&quot;播仔&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;deli&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-字面量"><a href="#1-2-字面量" class="headerlink" title="1.2 字面量"></a>1.2 字面量</h2><p>字面量其实就是告诉程序员数据在程序中的书写格式。下面是常用的数据在程序中的书写格式</p><img src="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/image1.png" class="" title="字面量"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">目标：需要同学们掌握常见数据在程序中的书写格式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiteralDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.整数</span><br>        System.out.println(<span class="hljs-number">666</span>);<br>        <br>        <span class="hljs-comment">//2.小数</span><br>        System.out.println(<span class="hljs-number">3.66</span>);<br>        <br>        <span class="hljs-comment">//3.字符: 字符必须用单引号引起来</span><br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;中&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//空格也算字符</span><br>        <span class="hljs-comment">//特殊字符：\t表示制表符 \n表示换行</span><br>        System.out.println(<span class="hljs-string">&#x27;\t&#x27;</span>); <span class="hljs-comment">//这相当于一个tab键，专业叫做制表符</span><br>        System.out.println(<span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">//这是换行的意思</span><br>        <br>        <span class="hljs-comment">//4.字符串：字符串是双引号引起来的</span><br>        System.out.println(<span class="hljs-string">&quot;我爱你中国abc&quot;</span>);<br>        <br>        <span class="hljs-comment">//5.布尔值：只有两个值true和false</span><br>        System.out.println(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>变量是用来记录程序中的数据的。其本质上是内存中的一块区域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p>当执行<code>int age = 18;</code> 这句代码时，JVM会在内存中申请一块区域，在这个区域中存储了一个整数18，给这个区域取的名字叫age； 相当于在盒子中存了一个数据18，这个盒子的名字是age，当我们打印age时，就是从盒子中把盒子中的数据取出来再打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>变量定义在哪个&#123;&#125;范围内，就只在哪个大括号内有效。变量的有效范围称之为变量的作用域<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>System.out.println(a); <span class="hljs-comment">//这是是对的</span><br>&#125;<br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">2.</span>在同一个作用域内，不能有两个同名的变量<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">//这里会出错</span><br>&#125;<br><br><span class="hljs-number">3.</span>变量没有初始化只，不能直接使用<br><span class="hljs-type">int</span> a; <span class="hljs-comment">//仅仅定义了变量，但是没有初始值</span><br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">4.</span>变量可以定义在同一行<br>如：<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>; <span class="hljs-comment">//a和b都是int类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-4-关键字"><a href="#1-4-关键字" class="headerlink" title="1.4 关键字"></a>1.4 关键字</h2><p>关键字是java语言中有特殊含义的单词。比如用int表示整数，用double表示小数，等等</p><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><hr><h2 id="1-5-标识符"><a href="#1-5-标识符" class="headerlink" title="1.5 标识符"></a>1.5 标识符</h2><p>标志符其实就是我们自己取的名字。像前面我们取的类名，变量名其实都是标志符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">强制要求：必须遵守，不遵守就会报错<br><span class="hljs-number">1.</span>最好是字母、数字、下划线、$组成<br><span class="hljs-number">2.</span>不能以数字开头<br><span class="hljs-number">3.</span>不能是Java的关键字<br><br>建议遵守：按照下面的方式取名字会显得更加专业<br><span class="hljs-number">1.</span>所有的名字要见名知意，便于自己和别人阅读<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125; <span class="hljs-comment">//一看这个类就知道表示一个学生</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span><span class="hljs-number">10</span>;    <span class="hljs-comment">//一看这个变量就知道表示年龄</span><br><br><span class="hljs-number">2.</span>类名：首字母大写（大驼峰命名）<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br><br><span class="hljs-number">3.</span>变量名：第二个单词开始首字母大写（小驼峰命名）<br>举例： <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.88</span>;  <br>  <span class="hljs-type">double</span> <span class="hljs-variable">applePrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">7.5</span>; <br></code></pre></td></tr></table></figure><hr><h1 id="类型转换、运算符"><a href="#类型转换、运算符" class="headerlink" title="类型转换、运算符"></a>类型转换、运算符</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java SE</tag>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试基础</title>
    <link href="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试理论基础"><a href="#软件测试理论基础" class="headerlink" title="软件测试理论基础"></a>软件测试理论基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>标准定义：</strong> 在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</li><li><strong>核心目的 ：</strong><ol><li><strong>发现缺陷：</strong> 尽可能早地找出软件中的Bug。</li><li><strong>评估质量：</strong> 告诉开发和产品经理，现在的软件能不能上线，风险大不大。</li><li><strong>预防风险：</strong> 通过测试反馈，帮助开发改进流程，预防同类Bug再次出现。</li></ol></li></ul><blockquote><p><strong>💡 测开视角：</strong> 作为测开，目标不仅仅是“点点点”找错，而是要**“保障交付质量”**。有时候需要开发工具来提高测试效率，这也是为了这个目标服务。</p></blockquote><h2 id="测试的“七大原则”-ISTQB-标准"><a href="#测试的“七大原则”-ISTQB-标准" class="headerlink" title="测试的“七大原则” (ISTQB 标准)"></a>测试的“七大原则” (ISTQB 标准)</h2><p>国际软件测试认证委员会 (ISTQB) 总结的原则：</p><ol><li><strong>测试显示缺陷的存在 (Testing shows the presence of defects)：</strong> 测试只能证明软件<strong>有</strong>错，不能证明软件<strong>没</strong>错。</li><li><strong>穷尽测试是不可能的 (Exhaustive testing is impossible)：</strong> 输入组合是无穷无尽的，不可能测完所有情况。所以需要<strong>设计</strong>测试用例。</li><li><strong>测试尽早介入 (Early testing)：</strong> Bug 发现得越早，修复成本越低。</li><li><strong>缺陷集群性 (Defect clustering)：</strong> 80% 的错误通常集中在 20% 的核心模块里。（二八原则，找到一个Bug的地方，通常还有更多Bug）。</li><li><strong>杀虫剂悖论 (Pesticide paradox)：</strong> 同样的测试用例如果重复运行很多次，就找不出新Bug了。需要不断更新用例，或者开发自动化脚本来应对。</li></ol><h2 id="软件开发与测试模型-V模型）"><a href="#软件开发与测试模型-V模型）" class="headerlink" title="软件开发与测试模型 (V模型）"></a>软件开发与测试模型 (V模型）</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image1.jpg" class="" title="V模型"><p><strong>V模型</strong>展示了开发阶段和测试阶段的对应关系：</p><ul><li><strong>左边是开发过程：</strong><ol><li><strong>需求分析</strong> (弄清要做什么)</li><li><strong>概要设计</strong> (系统架构设计)</li><li><strong>详细设计</strong> (具体模块&#x2F;函数设计)</li><li><strong>编码</strong> (写代码)</li></ol></li><li><strong>右边是测试过程：</strong><ol><li><strong>单元测试 (Unit Testing)：</strong> 对应<strong>编码</strong>。测最小的函数或类。通常由开发做，或者测开写单测代码。</li><li><strong>集成测试 (Integration Testing)：</strong> 对应<strong>详细设计</strong>。测模块与模块之间的接口（比如 订单模块 调 支付模块 通不通）。</li><li><strong>系统测试 (System Testing)：</strong> 对应<strong>概要设计</strong>。把软件看成一个整体来测（我们常说的功能测试、性能测试都在这）。</li><li><strong>验收测试 (Acceptance Testing)：</strong> 对应<strong>需求分析</strong>。由用户或产品经理来测，确认是否满足了最初的需求。</li></ol></li></ul><h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><h4 id="A-代码可见度划分"><a href="#A-代码可见度划分" class="headerlink" title="A. 代码可见度划分"></a>A. 代码可见度划分</h4><ul><li><strong>黑盒测试 (Black-box)：</strong> 把软件当成一个黑盒子，不看内部代码，只关心输入变成输出对不对。<ul><li><em>应用：</em> 功能测试、用户体验测试。</li></ul></li><li><strong>白盒测试 (White-box)：</strong> 打开盒子，研究里面的代码逻辑、循环、分支是否正确。<ul><li><em>应用：</em> 单元测试、代码审计。</li></ul></li><li><strong>灰盒测试 (Grey-box)：</strong> 介于两者之间，关注接口的输入输出，也关注部分内部逻辑（如数据库状态）。<ul><li><em>应用：</em> <strong>接口测试</strong></li></ul></li></ul><h4 id="B-按是否运行程序分"><a href="#B-按是否运行程序分" class="headerlink" title="B. 按是否运行程序分"></a>B. 按是否运行程序分</h4><ul><li><strong>静态测试：</strong> 不运行程序。比如：检查文档、Review代码（代码走查）。</li><li><strong>动态测试：</strong> 运行程序，看实际结果。平时做的绝大多数测试都是动态的。</li></ul><h4 id="C-按测试属性分-专项测试"><a href="#C-按测试属性分-专项测试" class="headerlink" title="C. 按测试属性分 (专项测试)"></a>C. 按测试属性分 (专项测试)</h4><ul><li><strong>功能测试：</strong> 点点点，验证功能对不对。</li><li><strong>性能测试：</strong> 测快不快（响应时间）、能不能抗住（并发量）。</li><li><strong>安全测试：</strong> 测有没有漏洞（SQL注入、XSS攻击）。</li><li><strong>兼容性测试：</strong> 安卓&#x2F;iOS能不能用，Chrome&#x2F;Edge能不能用。</li></ul><h2 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image2.png" class="" title="质量模型"><h4 id="1-功能性-Functional-Suitability-——-软件是否具备某方面的能力"><a href="#1-功能性-Functional-Suitability-——-软件是否具备某方面的能力" class="headerlink" title="1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力"></a>1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image3.png" class="" title="功能性"><h4 id="2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）"><a href="#2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）" class="headerlink" title="2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）"></a>2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image4.png" class="" title="性能效率"><h4 id="3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用"><a href="#3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用" class="headerlink" title="3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用"></a>3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image5.png" class="" title="兼容性"><h4 id="4-易用性-Usability-——-易学、易用、用户粘性好"><a href="#4-易用性-Usability-——-易学、易用、用户粘性好" class="headerlink" title="4. 易用性 (Usability) —— 易学、易用、用户粘性好"></a>4. 易用性 (Usability) —— 易学、易用、用户粘性好</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image6.png" class="" title="易容性"><h4 id="5-可靠性-Reliability-——-长时间运行稳定，不出现异常"><a href="#5-可靠性-Reliability-——-长时间运行稳定，不出现异常" class="headerlink" title="5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常"></a>5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image7.png" class="" title="可靠性"><h4 id="6-安全性-Security-——-敏感数据存储-传输安全"><a href="#6-安全性-Security-——-敏感数据存储-传输安全" class="headerlink" title="6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全"></a>6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image8.png" class="" title="安全性"><h4 id="7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便"><a href="#7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便" class="headerlink" title="7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便"></a>7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image9.png" class="" title="可维护性"><h4 id="8-可移植性-Portability-——-应用系统升级-数据迁移方便"><a href="#8-可移植性-Portability-——-应用系统升级-数据迁移方便" class="headerlink" title="8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便"></a>8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image10.png" class="" title="可移植性"><p>以微信为例</p><p>1.功能性：与需求数量一致，功能正确 2. 性能：响应快、占用资源少 3. 兼容性：不同设备平台正常使用 4. 易用性：用户体验好 5. 安全性：敏感信息无泄密存储有保障 6. 可靠性：持久运行无异常 7. 可移植性：升级迁移数据不丢失 8. 可维护性：出现异常恢复简单、可扩展功能、升级更新便捷</p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image11.png" class="" title="测试流程"><hr><h1 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h1><h2 id="1-什么是测试用例-Test-Case-？"><a href="#1-什么是测试用例-Test-Case-？" class="headerlink" title="1. 什么是测试用例 (Test Case)？"></a>1. 什么是测试用例 (Test Case)？</h2><p>测试用例就是一个<strong>文档化的“操作剧本”</strong>。它的核心作用是：让任何一个人拿着这份文档，都能按步骤执行，并判断系统是对是错。</p><h4 id="🧪-一个标准测试用例的解剖图"><a href="#🧪-一个标准测试用例的解剖图" class="headerlink" title="🧪 一个标准测试用例的解剖图"></a>🧪 一个标准测试用例的解剖图</h4><p>不同公司的模板（Excel&#x2F;Jira&#x2F;飞书）长相不同，但核心要素万变不离其宗：</p><ol><li><strong>用例编号 (ID):</strong> 唯一标识 (如 <code>LOGIN_001</code>)。</li><li><strong>用例标题 (Title):</strong> 一句话概括测什么 (如：<code>验证输入正确账号密码能成功登录</code>)。</li><li><strong>项目&#x2F;模块</strong></li><li><strong>预置条件 (Precondition):</strong> 执行前需要满足的环境 (如：<code>已注册账号，且网络正常</code>)。</li><li><strong>测试步骤 (Steps):</strong>  第一步做什么，第二步做什么。</li><li><strong>测试数据</strong></li><li><strong>预期结果 (Expected Result):</strong> 也是判断Bug的标准。必须明确！不能写“登录成功”，要写“跳转至首页，右上角显示用户名”。</li><li><strong>实际结果 (Actual Result):</strong> 执行测试时填写的。</li><li><strong>优先级 (Priority):</strong> P0(冒烟&#x2F;核心) &gt; P1 &gt; P2。</li></ol><blockquote><p>👨‍💻 测开视角 Pro Tip：为什么写好用例对“测开”特别重要？</p><p>因为自动化测试脚本其实就是把这些步骤翻译成代码（Python&#x2F;Java）。如果用例逻辑不通，代码根本写不出来。</p></blockquote><hr><h2 id="2-为什么需要设计方法？"><a href="#2-为什么需要设计方法？" class="headerlink" title="2. 为什么需要设计方法？"></a>2. 为什么需要设计方法？</h2><p>穷尽测试是不可能的。比如一个输入框要求输入 <code>1~100</code> 的整数：</p><ul><li>如果测 1, 2, 3…一直测到 100，那是<strong>蛮力</strong>，效率极低。</li><li>如果只测 50，那是<strong>碰运气</strong>。</li></ul><p>所以需要科学的方法，用<strong>最少的用例，覆盖最多的Bug</strong>。即黑盒测试的<strong>五大核心设计方法</strong>。</p><h3 id="（1）等价类划分法"><a href="#（1）等价类划分法" class="headerlink" title="（1）等价类划分法"></a>（1）等价类划分法</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image12.png" class="" title="等价类划分法"><p>它的逻辑基础是：<strong>如果在这个类别中选取的一个数据通过了测试，那么这个类别中的其他数据也一定能通过</strong></p><p>在划分时，必须把数据分为两类：</p><ol><li><strong>有效等价类 (Valid Equivalence Class):</strong><ul><li>完全符合需求规格说明的数据。</li><li><strong>目的：</strong> 验证软件**“做了它该做的事情”**。</li></ul></li><li><strong>无效等价类 (Invalid Equivalence Class):</strong><ul><li>不符合需求的数据（比如格式错、范围错、类型错）。</li><li><strong>目的：</strong> 验证软件**“有错误处理能力”**（比如提示“输入错误”，而不是直接崩溃或乱码）。找Bug通常是在这里找到的！</li></ul></li></ol><p>三步走：</p><p><strong>分析需求：</strong> 找到输入条件（长度、类型、规则）。</p><p><strong>划分集合：</strong> 针对每个条件，列出“有效”和“无效”的情况。</p><p><strong>设计用例：</strong> 从每个集合中挑选 <strong>1个</strong> 代表性数据作为测试数据。设计无效用例时，每次只能破坏一个规则，保证其他规则是正确的</p><hr><p>案例:某电商网站的“修改密码”功能，新密码长度限制为 <strong>8 到 16 位</strong> 的字符,并且必须包含 <strong>大写字母</strong> + <strong>小写字母</strong> + <strong>数字</strong></p><h4 id="1-划分等价类表"><a href="#1-划分等价类表" class="headerlink" title="1. 划分等价类表"></a>1. 划分等价类表</h4><table><thead><tr><th><strong>输入条件</strong></th><th><strong>有效等价类 (合法 - 预期成功)</strong></th><th><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td><strong>长度 (8~16)</strong></td><td>1. 长度在 8~16 之间   <em>(例如选个中间值：10位)</em></td><td>2. 长度 &lt; 8   *(例如：5位)*   3. 长度 &gt; 16   <em>(例如：20位)</em></td></tr><tr><td><strong>规则 (组合)</strong></td><td>4. 同时包含大写+小写+数字</td><td>5. 缺少大写字母   6. 缺少小写字母   7. 缺少数字   8. 为空   9. 包含非法字符(如汉字&#x2F;空格)</td></tr></tbody></table><h4 id="2-挑选测试用例-Sample"><a href="#2-挑选测试用例-Sample" class="headerlink" title="2. 挑选测试用例 (Sample)"></a>2. 挑选测试用例 (Sample)</h4><p>挑选最具代表性的数据：</p><ul><li><strong>【这条必须过】(有效长度+有效规则):</strong><ul><li><code>Netease163</code> (10位，含大写N、小写、数字) -&gt; <strong>预期：通过</strong></li></ul></li><li><strong>【测长度无效】:</strong><ul><li><code>Test1</code> (5位，长度过短) -&gt; <strong>预期：报错“密码长度不足”</strong></li><li><code>Netease123456789000</code> (20位，长度过长) -&gt; <strong>预期：报错“密码过长”</strong></li></ul></li><li><strong>【测规则无效 - 控制变量法】:</strong><ul><li><code>netease163</code> (缺大写) -&gt; <strong>预期：报错“需包含大写字母”</strong></li><li><code>NETEASE163</code> (缺小写) -&gt; <strong>预期：报错“需包含小写字母”</strong></li><li><code>NeteaseTest</code> (缺数字) -&gt; <strong>预期：报错“需包含数字”</strong></li><li>空字符</li><li>非法字符</li></ul></li></ul><hr><h3 id="（2）边界值分析法"><a href="#（2）边界值分析法" class="headerlink" title="（2）边界值分析法"></a>（2）边界值分析法</h3><p>如果代码不小心写成 <code>if (length &gt; 8 &amp;&amp; length &lt; 16)</code>，那么输入 8 和 16 都会报错，这时候只用等价类划分可能无法发现这个错误</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image13.png" class="" title="边界值分析法"><p><strong>边界值分析法</strong>就是专门针对输入范围的<strong>边缘</strong>进行测试的方法</p><h4 id="关键概念：上点、离点、内点"><a href="#关键概念：上点、离点、内点" class="headerlink" title="关键概念：上点、离点、内点"></a>关键概念：上点、离点、内点</h4><p>假设需求是输入范围：<strong>[1, 100]</strong> （包含1和100）。</p><ol><li><strong>上点 (On Point)：</strong> 边界上的点。<ul><li>也就是 <strong>1</strong> 和 <strong>100</strong>。</li><li><em>(在此例中，它们是<strong>有效</strong>的)</em></li></ul></li><li><strong>离点 (Off Point)：</strong> 离边界最近的那个点。<ul><li>也就是 <strong>0</strong> 和 <strong>101</strong>。</li><li><em>(在此例中，它们是<strong>无效</strong>的)</em></li></ul></li><li><strong>内点 (Interior Point)：</strong> 范围内的任意一点。<ul><li>比如 <strong>50</strong>。</li></ul></li></ol><p><strong>等价类</strong>和<strong>边界值</strong>一般都是<strong>同时使用</strong>的</p><hr><p>以上述的案例为例：</p><p>这种方法在方案一的基础上，对“长度”这个条件进行了<strong>极致的精确打击</strong>。因为程序员最容易把 <code>&gt;8</code> 写成 <code>&gt;=8</code>，或者把 <code>16</code> 写成 <code>15</code>。</p><h4 id="1-确定边界点"><a href="#1-确定边界点" class="headerlink" title="1. 确定边界点"></a>1. 确定边界点</h4><ul><li><strong>有效范围：</strong> [8, 16]</li><li><strong>上点 (有效边界)：</strong> 8, 16</li><li><strong>离点 (无效边界)：</strong> 7, 17</li><li><strong>内点 (有效中间)：</strong> 10 (或任意8-16之间的数)</li></ul><h4 id="2-设计测试用例-高能部分"><a href="#2-设计测试用例-高能部分" class="headerlink" title="2. 设计测试用例 (高能部分)"></a>2. 设计测试用例 (高能部分)</h4><p>在设计边界值用例时，<strong>内容规则必须是正确的（大写+小写+数字）</strong>，这样才能确保报错唯一原因是“长度不对”。</p><p><strong>针对“长度”的边界测试：</strong></p><ol><li><strong>【最小无效边界 - 7位】 (关键):</strong><ul><li>输入：<code>Abcdef1</code></li><li>说明：7位，规则满足。</li><li><strong>预期：失败</strong> (刚好不够长)</li></ul></li><li><strong>【最小有效边界 - 8位】 (关键):</strong><ul><li>输入：<code>Abcdefg1</code></li><li>说明：8位，规则满足。</li><li><strong>预期：成功</strong> (刚好够长，测是否写了<code>&gt;8</code>导致8失败)</li></ul></li><li><strong>【中间任意值】:</strong><ul><li>输入：<code>Abcdefg123</code></li><li>说明：10位。</li><li><strong>预期：成功</strong> (日常功能验证)</li></ul></li><li><strong>【最大有效边界 - 16位】 (关键):</strong><ul><li>输入：<code>Abcdefghij123456</code></li><li>说明：16位，规则满足。</li><li><strong>预期：成功</strong></li></ul></li><li><strong>【最大无效边界 - 17位】 (关键):</strong><ul><li>输入：<code>Abcdefghij1234567</code></li><li>说明：17位，规则满足。</li><li><strong>预期：失败</strong> (刚好溢出)</li></ul></li></ol><p><strong>针对“规则”的等价类测试 (同方案一，补充测试):</strong></p><ol><li><strong>【缺大写】:</strong> <code>abcdefg1</code> (8位，满足长度，破坏规则) -&gt; <strong>失败</strong></li><li><strong>【缺小写】:</strong> <code>ABCDEFG1</code> -&gt; <strong>失败</strong></li><li><strong>【缺数字】:</strong> <code>Abcdefgh</code> -&gt; <strong>失败</strong></li><li><strong>【其他非法】:</strong> 空值、空格、中文等。</li></ol><hr><h3 id="（3）判定表法"><a href="#（3）判定表法" class="headerlink" title="（3）判定表法"></a>（3）判定表法</h3><p>判定表法是专门用来处理<strong>多条件组合逻辑</strong>的工具。它能帮你把所有可能的“条件组合”都列出来，确保每一种逻辑分支（True&#x2F;False 组合）都被测到。</p><ul><li><strong>条件桩 (Condition Stub):</strong> 列出问题的所有<strong>输入条件</strong>（例如：是否VIP、金额是否&gt;100）。</li><li><strong>动作桩 (Action Stub):</strong> 列出可能采取的所有<strong>操作&#x2F;结果</strong>（例如：打8折、不打折、包邮）。</li><li><strong>条件项 (Condition Entry):</strong> 填入真假值（True&#x2F;False 或 Yes&#x2F;No），列出所有可能的<strong>组合</strong>。</li><li><strong>动作项 (Action Entry):</strong> 根据每一列的条件组合，勾选出对应的<strong>结果</strong>。</li></ul><p><strong>需求场景：</strong> 某电商网站规定：如果订单金额 <strong>大于 99 元</strong>，<strong>或者</strong> 用户是 <strong>VIP会员</strong>，则享受 <strong>“免运费”</strong> 服务；否则需要 <strong>“支付运费”</strong>。</p><table><thead><tr><th align="center"><strong>组成部分</strong></th><th align="center"><strong>规则 1</strong></th><th align="center"><strong>规则 2</strong></th><th align="center"><strong>规则 3</strong></th><th align="center"><strong>规则 4</strong></th></tr></thead><tbody><tr><td align="center"><strong>【条件桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">C1: 金额 &gt; 99元</td><td align="center"><strong>Y</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center">C2: 是 VIP</td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center"><strong>【动作桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">A1: 免运费</td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"></td></tr><tr><td align="center">A2: 支付运费</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><strong>✔</strong></td></tr></tbody></table><p>根据上面的表格，直接就能写出 4 条测试用例：</p><ol><li><strong>用例1:</strong> 购买 200元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例2:</strong> 购买 200元，非 VIP -&gt; 预期：免运费。</li><li><strong>用例3:</strong> 购买 50元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例4:</strong> 购买 50元，非 VIP -&gt; 预期：支付运费。</li></ol><h3 id="（4）场景图"><a href="#（4）场景图" class="headerlink" title="（4）场景图"></a>（4）场景图</h3><p>把软件运行想象成用户在走一条路。</p><ul><li><strong>基本流 (Basic Flow):</strong> 也叫“快乐路径” (Happy Path)。一切顺利，没有任何报错，用户最想走的那个流程。</li><li><strong>备选流 (Alternative Flow):</strong> 也就是异常流程。走到半路出了岔子（密码错了、没钱了、网断了），程序怎么处理？</li></ul><p>练习流程图工具：visio、processon</p><h4 id="案例-ATM"><a href="#案例-ATM" class="headerlink" title="案例-ATM"></a>案例-ATM</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image14.png" class="" title="ATM流程图"><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image15.png" class="" title="路径"><h5 id="1-基本流-The-Happy-Path"><a href="#1-基本流-The-Happy-Path" class="headerlink" title="1. 基本流 (The Happy Path)"></a>1. 基本流 (The Happy Path)</h5><p>这是最顺畅的一条路，也就是图中中间那一列直直往下走的路。</p><ul><li><strong>路径：</strong> 插入银行卡 -&gt; 验证成功 -&gt; 输入密码 -&gt; 验证正确 -&gt; 选择取款 -&gt; 验证账户余额(足) -&gt; 验证取款金额(对) -&gt; 验证ATM余额(足) -&gt; 出钞 -&gt; <strong>[结束]</strong>。</li><li><strong>对应图中下方的文字：</strong> <code>6、开始-&gt;验证银行卡成功-&gt;...-&gt;取款成功-&gt;结束</code>。</li><li><strong>意义：</strong> 证明ATM机“能用”。</li></ul><h5 id="2-备选流-The-Sad-Paths"><a href="#2-备选流-The-Sad-Paths" class="headerlink" title="2. 备选流 (The Sad Paths)"></a>2. 备选流 (The Sad Paths)</h5><p>这是你在每一个“菱形判断框”遇到红灯（No&#x2F;False）时拐弯走的路。顺着图一个一个找：</p><ul><li><strong>拐弯点 1 (验证银行卡):</strong> 验证不成功 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>1</code>。</li></ul></li><li><strong>拐弯点 2 (验证密码):</strong> 这是一个特殊的<strong>循环结构</strong>。<ul><li>不正确 -&gt; 提示错误 -&gt; 判断到3次了吗？</li><li><strong>没有到3次</strong> -&gt; 箭头指回“输入密码” (让用户重输)。</li><li><strong>到了3次</strong> -&gt; 吞卡 -&gt; <strong>[结束]</strong>。</li><li>这就是路径 <code>2</code>。</li></ul></li><li><strong>拐弯点 3 (验证账户余额):</strong> 不满足 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>3</code>。</li></ul></li><li><strong>拐弯点 4 (验证取款金额):</strong> 不满足 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>4</code>。</li></ul></li><li><strong>拐弯点 5 (验证ATM余额):</strong> 不够用 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>5</code>。</li></ul></li></ul><p><strong>总结：</strong> 通过对着这张图“顺藤摸瓜”，一共摸出了 <strong>6条</strong> 唯一的路径（1条成功 + 5条失败）。</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image16.png" class="" title="ATM测试用例"><hr><h3 id="（5）错误猜测法"><a href="#（5）错误猜测法" class="headerlink" title="（5）错误猜测法"></a>（5）错误猜测法</h3><p>基于你以前见过的 Bug，去“猜”这个程序哪里可能坏掉。通常作为最后一步的<strong>补充测试</strong></p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image17.png" class="" title="错误猜测法"><hr><p>在实际工作中，不要割裂使用，要像打组合拳一样：</p><ol><li>拿到功能，先用 <strong>场景法</strong> 搞清楚业务流程（基本流+备选流）。</li><li>针对流程中的每一个输入框（比如金额、密码），用 <strong>等价类</strong> + <strong>边界值</strong> 设计具体数据。</li><li>如果有复杂的逻辑判断（比如满减、VIP），用 <strong>判定表</strong> 理清逻辑。</li><li>最后，用 <strong>错误猜测法</strong> 搞点破坏，查漏补缺。</li></ol><hr><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>$$<br>Bug &#x3D; 实际结果 (Actual Result) \neq 预期结果 (Expected Result)<br>$$</p><p>软件中存在的各种问题，都为缺陷，简称bug；</p><h2 id="Bug的生命周期"><a href="#Bug的生命周期" class="headerlink" title="Bug的生命周期"></a>Bug的生命周期</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image18.png" class="" title="Bug的生命周期"><p>Bug 的生命周期，就是**“从被发现，到最终被消灭”<strong>的全过程。这中间会经历不同的</strong>状态 (Status)**。</p><h3 id="🔄-标准流程（Happy-Path）"><a href="#🔄-标准流程（Happy-Path）" class="headerlink" title="🔄 标准流程（Happy Path）"></a>🔄 标准流程（Happy Path）</h3><p>这是最顺利的情况，Bug 被发现并成功修复。</p><ol><li><strong>New (新建):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 你发现了Bug，提交到系统里。</li><li><strong>含义：</strong> “嘿，我发现了个问题，待认领。”</li></ul></li><li><strong>Open (打开&#x2F;确认):</strong><ul><li><strong>谁做：</strong> 开发人员（老王）或 测试组长。</li><li><strong>动作：</strong> 开发看到了单子，确认这确实是个Bug，准备开始修。</li><li><strong>含义：</strong> “收到，确实是问题，我开始干活了。”</li></ul></li><li><strong>Fixed &#x2F; Resolved (已修复&#x2F;已解决):</strong><ul><li><strong>谁做：</strong> 开发人员。</li><li><strong>动作：</strong> 代码改好了，开发在系统上点“已修复”。</li><li><strong>含义：</strong> “我改完了，你（测试）去验证一下吧。”</li></ul></li><li><strong>Verified (已验证):</strong><ul><li><strong>谁做：</strong> 测试人员（你）。</li><li><strong>动作：</strong> 你拿到新版本，重新测了一遍，发现真的修好了。</li><li><strong>含义：</strong> “验货通过，没问题了。”</li><li><em>(注：有的公司会跳过这个状态直接Closed，但在严谨流程中，验证是独立动作)</em></li></ul></li><li><strong>Closed (关闭):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 关闭这个Bug单。</li><li><strong>含义：</strong> “此案终结，归档。”</li></ul></li></ol><hr><h4 id="⚠️-异常流程（扯皮与返工）"><a href="#⚠️-异常流程（扯皮与返工）" class="headerlink" title="⚠️ 异常流程（扯皮与返工）"></a>⚠️ 异常流程（扯皮与返工）</h4><ol><li><strong>Reopen (重新打开):</strong><ul><li><strong>场景：</strong> 开发说“修好了” (Fixed)，结果你去验证 (Verify) 发现<strong>还是没好</strong>，或者<strong>引发了新Bug</strong>。</li><li><strong>动作：</strong> 你把状态从 Fixed 改为 Reopen，打回给开发。</li><li><strong>含义：</strong> “老王，你没修好啊，重来！”</li></ul></li><li><strong>Rejected (拒绝):</strong><ul><li><strong>场景：</strong> 开发觉得这不是Bug（比如是你环境配错了，或者需求理解不一致，或者就是“特性不是Bug”）。</li><li><strong>含义：</strong> “这不是我的锅，驳回。”</li><li><em>应对：这时需要找产品经理（PM）来做裁判。</em></li></ul></li><li><strong>Duplicate (重复):</strong><ul><li><strong>场景：</strong> 你提的Bug，别的测试同事昨天已经提过了。</li><li><strong>含义：</strong> “重复单子，关掉其中一个。”</li></ul></li><li><strong>Deferred &#x2F; Postponed (延期):</strong><ul><li><strong>场景：</strong> Bug确实存在，但上线时间紧，这个Bug影响不大（比如一个像素的偏差），决定放到下一个版本再修。</li><li><strong>含义：</strong> “承认问题，但暂不修复，下期再说。”</li></ul></li></ol><hr><h2 id="Bug的管理"><a href="#Bug的管理" class="headerlink" title="Bug的管理"></a>Bug的管理</h2><h3 id="Bug-的核心要素"><a href="#Bug-的核心要素" class="headerlink" title="Bug 的核心要素"></a>Bug 的核心要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image19.png" class="" title="Bug的核心要素"><h3 id="Bug-的提交要素"><a href="#Bug-的提交要素" class="headerlink" title="Bug 的提交要素"></a>Bug 的提交要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image20.png" class="" title="Bug的提交要素"><h3 id="常用管理工具"><a href="#常用管理工具" class="headerlink" title="常用管理工具"></a>常用管理工具</h3><ul><li><strong>Jira:</strong> 全球最通用的项目管理工具，大厂常用。</li><li><strong>禅道 (ZenTao):</strong> 国内中小厂非常流行，集成了用例管理和Bug管理。</li><li><strong>Tapd:</strong> 腾讯出的，很多互联网公司也在用。</li><li><strong>Excel:</strong> 虽然原始，但有些小项目确实还在用 Excel 记 Bug。</li></ul><h3 id="Bug-的等级：严重程度-vs-优先级"><a href="#Bug-的等级：严重程度-vs-优先级" class="headerlink" title="Bug 的等级：严重程度 vs 优先级"></a>Bug 的等级：严重程度 vs 优先级</h3><p><strong>“严重程度高的Bug，优先级一定高吗？”</strong></p><h4 id="A-严重程度-Severity-——-技术视角"><a href="#A-严重程度-Severity-——-技术视角" class="headerlink" title="A. 严重程度 (Severity) —— 技术视角"></a>A. 严重程度 (Severity) —— 技术视角</h4><p>代表这个 Bug 对软件功能的破坏程度。</p><ul><li><strong>S1 (致命):</strong> 系统崩溃、数据丢失、核心功能瘫痪（如无法支付）。</li><li><strong>S2 (严重):</strong> 主要功能出错（如算错钱、逻辑错误），但系统没崩。</li><li><strong>S3 (一般):</strong> 次要功能错误（如提示语模糊、界面布局微调）。</li><li><strong>S4 (轻微):</strong> 建议性问题（如字体不好看、个别错别字）。</li></ul><h4 id="B-优先级-Priority-——-业务视角"><a href="#B-优先级-Priority-——-业务视角" class="headerlink" title="B. 优先级 (Priority) —— 业务视角"></a>B. 优先级 (Priority) —— 业务视角</h4><p>代表开发需要<strong>多快</strong>去修这个 Bug。</p><ul><li><strong>P0 (立即):</strong> 现在、马上、停下手头所有事去修（通常针对阻碍测试进行的Bug）。</li><li><strong>P1 (高):</strong> 下个版本发布前必须修好。</li><li><strong>P2 (中):</strong> 发布前最好修好，修不完可以延期。</li><li><strong>P3 (低):</strong> 有空再修，或者不修。</li></ul><p><strong>问：</strong> “有没有 <strong>严重程度很高</strong>，但 <strong>优先级很低</strong> 的情况？或者反过来？” <strong>答：</strong> 有！</p><ol><li><strong>高严重 + 低优先级：</strong><ul><li><em>例子：</em> 一个会让APP崩溃的Bug，但它只发生在 <strong>iPhone 6 (很久远的机型)</strong> 上，而公司决定下个月就停止支持 iPhone 6 了。虽然崩溃很严重，但修它的优先级很低。</li></ul></li><li><strong>低严重 + 高优先级：</strong><ul><li><em>例子：</em> 公司首页的 Logo 颜色配错了（甚至带了竞争对手的颜色），或者有一句骂人的文案。</li><li><em>分析：</em> 技术上这只是换张图、改个字，完全不影响功能使用（严重度极低）。但这对公司形象影响巨大，必须立刻、马上修好（优先级极高）。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>软件测试理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/08/hello-world/"/>
    <url>/2025/12/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
