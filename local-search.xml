<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vibe Coding</title>
    <link href="/2025/12/25/Vibe-Coding/"/>
    <url>/2025/12/25/Vibe-Coding/</url>
    
    <content type="html"><![CDATA[<h1 id="Vibe-Coding"><a href="#Vibe-Coding" class="headerlink" title="Vibe Coding"></a>Vibe Coding</h1><p>Vibe Coding 压根就不关心你代码具体怎么实现的，核心关注点是代码生成的结果对不对。至于实现逻辑、底层细节这些繁琐的活，都交给 AI 去搞定。我只需要盯着效果，觉得哪里不对、哪里有问题，就直接改 prompt，重新提需求，AI 会自动帮你调整和优化，直到最后结果完全符合你的预期为止。整个过程你都沉浸在“<strong>说想法—&gt;看结果—&gt;继续调整—&gt;再出结果</strong>”的循环里。</p><h3 id="集成开发环境-IDE-终端"><a href="#集成开发环境-IDE-终端" class="headerlink" title="集成开发环境 (IDE) &amp; 终端"></a>集成开发环境 (IDE) &amp; 终端</h3><ul><li><a href="https://code.visualstudio.com/"><strong>Visual Studio Code</strong></a>: 一款功能强大的集成开发环境，适合代码阅读与手动修改。其 <code>Local History</code> 插件对项目版本管理尤为便捷。</li><li><strong>虚拟环境 (.venv)</strong>: 强烈推荐使用，可实现项目环境的一键配置与隔离，特别适用于 Python 开发。</li><li><a href="https://cursor.com/"><strong>Cursor</strong></a>: 已经占领用户心智高地，人尽皆知。</li><li><a href="https://www.warp.dev/"><strong>Warp</strong></a>: 集成 AI 功能的现代化终端，能有效提升命令行操作和错误排查的效率。</li><li><a href="https://github.com/neovim/neovim"><strong>Neovim (nvim)</strong></a>: 一款高性能的现代化 Vim 编辑器，拥有丰富的插件生态，是键盘流开发者的首选。</li><li><a href="https://github.com/LazyVim/LazyVim"><strong>LazyVim</strong></a>: 基于 Neovim 的配置框架，预置了 LSP、代码补全、调试等全套功能，实现了开箱即用与深度定制的平衡。</li></ul><h3 id="AI-模型-服务"><a href="#AI-模型-服务" class="headerlink" title="AI 模型 &amp; 服务"></a>AI 模型 &amp; 服务</h3><ul><li><a href="https://claude.ai/new"><strong>Claude Opus 4.5</strong></a>: 性能强大的 AI 模型，通过 Claude Code 等平台提供服务，并支持 CLI 和 IDE 插件。</li><li><a href="https://chatgpt.com/codex/"><strong>gpt-5.1-codex.1-codex (xhigh)</strong></a>: 适用于处理大型项目和复杂逻辑的 AI 模型，可通过 Codex CLI 等平台使用。</li><li><a href="https://factory.ai/news/terminal-bench"><strong>Droid</strong></a>: 提供对 Claude Opus 4.5 等多种模型的 CLI 访问。</li><li><a href="https://kiro.dev/"><strong>Kiro</strong></a>: 目前提供免费的 Claude Opus 4.5 模型访问，并提供客户端及 CLI 工具。</li><li><a href="https://geminicli.com/"><strong>Gemini CLI</strong></a>: 提供对 Gemini 模型的免费访问，适合执行脚本、整理文档和探索思路。</li><li><a href="https://antigravity.google/"><strong>antigravity</strong></a>: 目前由 Google 提供的免费 AI 服务，支持使用 Claude Opus 4.5 和 Gemini 3.0 Pro。</li><li><a href="https://aistudio.google.com/prompts/new_chat"><strong>AI Studio</strong></a>: Google 提供的免费服务，支持使用 Gemini 3.0 Pro 和 Nano Banana。</li><li><a href="https://cloud.google.com/gemini-enterprise"><strong>Gemini Enterprise</strong></a>: 面向企业用户的 Google AI 服务，目前可以免费使用。</li><li><a href="https://github.com/copilot"><strong>GitHub Copilot</strong></a>: 由 GitHub 和 OpenAI 联合开发的 AI 代码补全工具。</li><li><a href="https://www.kimi.com/"><strong>Kimi K2</strong></a>: 一款国产 AI 模型，适用于多种常规任务。</li><li><a href="https://bigmodel.cn/"><strong>GLM</strong></a>: 由智谱 AI 开发的国产大语言模型。</li><li><a href="https://qwenlm.github.io/qwen-code-docs/zh/cli/"><strong>Qwen</strong></a>: 由阿里巴巴开发的 AI 模型，其 CLI 工具提供免费使用额度。</li></ul><h3 id="开发与辅助工具"><a href="#开发与辅助工具" class="headerlink" title="开发与辅助工具"></a>开发与辅助工具</h3><ul><li><a href="https://app.augmentcode.com/"><strong>Augment</strong></a>: 提供强大的上下文引擎和提示词优化功能。</li><li><a href="https://windsurf.com/"><strong>Windsurf</strong></a>: 为新用户提供免费额度的 AI 开发工具。</li><li><a href="https://ollama.com/"><strong>Ollama</strong></a>: 本地大模型管理工具，可通过命令行方便地拉取和运行开源模型。</li><li><a href="https://www.mermaidchart.com/"><strong>Mermaid Chart</strong></a>: 用于将文本描述转换为架构图、序列图等可视化图表。</li><li><a href="https://notebooklm.google.com/"><strong>NotebookLM</strong></a>: 一款用于 AI 解读资料、音频和生成思维导图的工具。</li><li><a href="https://zread.ai/"><strong>Zread</strong></a>: AI 驱动的 GitHub 仓库阅读工具，有助于快速理解项目代码。</li><li><a href="https://github.com/tmux/tmux"><strong>tmux</strong></a>: 强大的终端复用工具，支持会话保持、分屏和后台任务，是服务器与多项目开发的理想选择。</li><li><a href="https://dbeaver.io/"><strong>DBeaver</strong></a>: 一款通用数据库管理客户端，支持多种数据库，功能全面。</li></ul><p>国内大厂IDE：Qoder、Trae、CodeBuddy、comate、joyCode、codeFlicker、catpaw……</p><p>GLM4.7  minimax2.1</p><hr><h1 id="Tools-Function-Function-Calling"><a href="#Tools-Function-Function-Calling" class="headerlink" title="Tools Function(Function Calling)"></a>Tools Function(Function Calling)</h1><p>AI擅长的是非结构化数据的分析，如果需求中包含严格的逻辑校验或需要读写数据库，纯Prompt模式就难以实现了</p><p>例如一个业务流程如下：</p><img src="/2025/12/25/Vibe-Coding/image1.png" class="" title="业务流程图"><p>这里就涉及到了很多数据库操作，比如：</p><ul><li>查询课程信息</li><li>查询校区信息</li><li>新增课程试听预约单</li></ul><p>可以看出整个业务流程有一部分任务是负责与用户沟通，获取用户意图的，这些是大模型擅长的事情：</p><ul><li>大模型的任务：<ul><li>了解、分析用户的兴趣、学历等信息</li><li>给用户推荐课程</li><li>引导用户预约试听</li><li>引导学生留下联系方式</li></ul></li></ul><p>还有一些任务是需要操作数据库的，这些任务是java&#x2F;python程序擅长的：</p><ul><li>传统应用需要完成的任务：<ul><li>根据条件查询课程</li><li>查询校区信息</li><li>新增预约单</li></ul></li></ul><p>为了能实现智能客服功能，我们就需要结合两者的能力。Function Calling就是起到这样的作用。</p><p>首先，可以把数据库的操作都定义成Function，或者也可以叫Tool，也就是工具。</p><p>然后，可以在提示词中，告诉大模型，什么情况下需要调用什么工具。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">你是一家名为“黑马程序员”的职业教育公司的智能客服小黑。<br>你的任务给用户提供课程咨询、预约试听服务。<br>1.课程咨询：<br><span class="hljs-bullet">-</span> 提供课程建议前必须从用户那里获得：学习兴趣、学员学历信息<br><span class="hljs-bullet">-</span> 然后基于用户信息，调用工具查询符合用户需求的课程信息,推荐给用户<br><span class="hljs-bullet">-</span> 不要直接告诉用户课程价格，而是想办法让用户预约课程。<br><span class="hljs-bullet">-</span> 与用户确认想要了解的课程后，再进入课程预约环节<br>2.课程预约<br><span class="hljs-bullet">-</span> 在帮助用户预约课程之前，你需要询问学生要去哪个校区试听。<br><span class="hljs-bullet">-</span> 可以通过工具查询校区列表，供用户选择要预约的校区。<br><span class="hljs-bullet">-</span> 你还需要从用户那里获得用户的联系方式、姓名，才能进行课程预约。<br><span class="hljs-bullet">-</span> 收集到预约信息后要跟用户最终确认信息是否正确。<br>-信息无误后，调用工具生成课程预约单。<br><br>查询课程的工具如下：xxx<br>查询校区的工具如下：xxx<br>新增预约单的工具如下：xxx<br></code></pre></td></tr></table></figure><p>也就是说，在提示词中告诉大模型，什么情况下需要调用什么工具，将来用户在与大模型交互的时候，大模型就可以在适当的时候调用工具了。</p><p>流程如下：</p><img src="/2025/12/25/Vibe-Coding/image2.png" class="" title="流程"><p>流程解读：</p><ol><li>提前把这些操作定义为Function，</li><li>然后将Function的名称、作用、需要的参数等信息都封装为Prompt提示词与用户的提问一起发送给大模型</li><li>大模型在与用户交互的过程中，根据用户交流的内容判断是否需要调用Function</li><li>如果需要则返回Function名称、参数等信息</li><li>后端解析结果，判断要执行哪个函数，代码执行Function，把结果再次封装到Prompt中发送给AI</li><li>AI继续与用户交互，直到完成任务</li></ol><hr><h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>大模型存在<strong>知识限制</strong>问题：</p><ul><li>知识数据往往是几个月之前的</li><li>不包含太过<strong>专业领域</strong>或者<strong>企业私有</strong>的数据</li></ul><p>为了解决这些问题，就需要用到RAG了。下面我们简单回顾下RAG原理</p><h3 id="RAG原理"><a href="#RAG原理" class="headerlink" title="RAG原理"></a>RAG原理</h3><p>要解决大模型的知识限制问题，其实并不复杂。解决的思路就是给大模型外挂一个<strong>知识库</strong>，可以是专业领域知识，也可以是企业私有的数据。</p><p>不过，知识库不能简单的直接拼接在提示词中。因为通常知识库数据量都是非常大的，而大模型的上下文是有大小限制的，因此知识库不能直接写在提示词中。</p><p>思路很简单，庞大的知识库中与用户问题相关的其实并不多。所以，需要想办法<strong>从庞大的知识库中找到与用户问题相关的一小部分，组装成提示词</strong>，发送给大模型就可以了。</p><p>全文检索是文字匹配，这里我们要求的是内容上的相似度。而要从内容相似度来判断，这就不得不提到<strong>向量模型</strong>的知识了。</p><h4 id="向量模型"><a href="#向量模型" class="headerlink" title="向量模型"></a>向量模型</h4><p>向量是空间中有方向和长度的量，空间可以是二维，也可以是多维。向量既然是在空间中，两个向量之间就一定能计算距离。</p><p>以二维向量为例，向量之间的距离有两种计算方法：</p><img src="/2025/12/25/Vibe-Coding/image3.png" class="" title="相似度计算"><p>通常，两个向量之间<strong>欧式距离越近</strong>，我们认为两个向量的<strong>相似度越高</strong>。（余弦距离相反，越大相似度越高）</p><p>所以，如果我们能<strong>把文本转为向量</strong>，就可以<strong>通过向量距离来判断文本的相似度</strong>了。</p><p>现在有非常多的文本嵌入模型**，就可以实现将文本向量化。一个好的向量模型，就是要<strong>尽可能让文本含义相似的向量，在空间中距离更近</strong>：</p><img src="/2025/12/25/Vibe-Coding/image4.png" class="" title="嵌入模型"><h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><table><thead><tr><th><strong>数据库</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Milvus &#x2F; Zilliz</strong></td><td><strong>老牌霸主。</strong> 性能极强，支持百亿级数据，由国产团队（Zilliz）主导开源。</td><td><strong>大型企业级应用</strong>。如果你面试的是大厂，聊这个最稳。</td></tr><tr><td><strong>Pinecone</strong></td><td><strong>全托管 Serverless。</strong> 不需要自己运维，按需付费，开发者体验极好。</td><td><strong>初创公司或快速原型</strong>。面试时可以提：“我们为了快速验证 RAG 效果，选用了 Pinecone。”</td></tr><tr><td><strong>Qdrant</strong></td><td><strong>Rust 编写。</strong> 极致的查询效率和内存优化，过滤功能非常强大。</td><td><strong>高性能、低延迟</strong>的检索需求。</td></tr></tbody></table><p>还有像ChromaDB、FAISS、pgvector等等常用的向量数据库</p><h3 id="RAG痛点"><a href="#RAG痛点" class="headerlink" title="RAG痛点"></a>RAG痛点</h3><p><strong>切片（Chunking）策略：</strong> “如果文档切得太碎，上下文会丢失；切得太长，噪声又太多。采用 <strong>Semantic Chunking（语义切片）</strong>。”</p><p><strong>重排序（Rerank）：</strong> “初步搜出来的结果不一定最准，可以加一层 <strong>Rerank 模型</strong>，对搜索结果进行二次精选，确保喂给 AI 的是最高质量的参考资料。”</p><p><strong>多路召回：</strong> “结合传统的关键字搜索（BM25）和向量搜索，防止搜不到专有名词。”</p><p>如果答案分散在 A 文档和 B 文档中，传统 RAG 很难把它们串联起来。传统 RAG 如果有新文档加入，往往需要全量重做 Embedding</p><p>现在很多新型RAG系统出现解决这些问题，例如香港大学黄超老师团队开源的LightRAG</p><hr><h1 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h1><p>Agent 就是给 AI 一个 <strong>“大脑（控制系统）”</strong>，让它能够自主拆解任务、反思错误并闭环解决问题</p><ul><li><strong>大脑（Brain）</strong>：大模型负责推理和决策。</li><li><strong>规划（Planning）</strong>：分解任务为子步骤（如思维链、任务列表）。</li><li><strong>工具使用（Tool Use）</strong>：调用外部工具（搜索、计算、API）。</li><li><strong>记忆（Memory）</strong>：短期记忆（上下文）和长期记忆（向量数据库）。</li><li><strong>行动（Action）</strong>：执行具体操作并观察结果。</li></ul><hr><h1 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h1><p>MCP（Model Context Protocol，模型上下文协议） ，2024年11月底，由  Anthropic 推出的一种开放标准。旨在为大语言模型（LLM）提供统一的、 标准化方式与外部数据源和工具之间进行通信。</p><img src="/2025/12/25/Vibe-Coding/image5.png" class="" title="MCP"><p>传统AI集成的问题：这种为每个数据源构建独立连接的方式，可以被视为一个M*N问题。 问题：架构碎片化，难以扩展，限制了AI获取必要上下文信息的能力 MCP解决方案：提供统一且可靠的方式来访问所需数据，克服了以往集成方法的局限性</p><p>MCP 作为一种标准化协议，极大地简化了大语言模型与外部世界的交互方式，使开发者能够以统一 的方式为 AI 应用添加各种能力</p><img src="/2025/12/25/Vibe-Coding/image6.png" class="" title="MCP2"><img src="/2025/12/25/Vibe-Coding/image7.png" class="" title="MCP3"><img src="/2025/12/25/Vibe-Coding/image8.png" class="" title="MCP4"><img src="/2025/12/25/Vibe-Coding/image9.png" class="" title="MCP5"><img src="/2025/12/25/Vibe-Coding/image10.png" class="" title="MCP6"><img src="/2025/12/25/Vibe-Coding/image11.png" class="" title="MCP7"><img src="/2025/12/25/Vibe-Coding/image12.png" class="" title="MCP8"><img src="/2025/12/25/Vibe-Coding/image13.png" class="" title="MCP9"><hr><h1 id="A2A"><a href="#A2A" class="headerlink" title="A2A"></a>A2A</h1><p>单一的大型 Agent（通常被称为 Monolithic Agent）会面临以下问题：</p><ul><li><strong>上下文过载：</strong> 让一个 AI 同时负责写代码、调接口、查文档、写报告，它的 Prompt 会变得极其臃肿，导致执行成功率下降。</li><li><strong>术业有专攻：</strong> 就像公司里分开发、测试、产品一样，不同的任务需要不同的“性格”和“技能包”。</li></ul><p><strong>A2A 的本质：</strong> 将复杂任务拆分给多个角色，通过它们之间的<strong>对话、博弈、监督</strong>来提高最终结果的质量。</p><p>谷歌，25年4月10日发布开源的、应用层协议 A2A（Agent-to-Agent 协议），即  Agent-to-Agent。其设计目的是使智能体（Agent）间能够以一种自然的模态进行协 作，类似于人与人之间的互动。</p><p>举例：阿里云 &amp; 火山云 阿里云上创建的 AI Agent，通过A2A协议，可以与火山云上创建的 AI  Agent 进行无缝的通信与协作。</p><hr><h1 id="Agentic-Workflow"><a href="#Agentic-Workflow" class="headerlink" title="Agentic Workflow"></a>Agentic Workflow</h1><p><strong>Agentic Workflow</strong>，即 <strong>“智能体工作流”</strong>，是指由<strong>一个或多个AI智能体</strong>按照预设的规划、逻辑和协作方式，自主或半自主地完成一项复杂任务的多步骤过程。它超越了单次问答，强调的是为达成目标而进行的<strong>动态、序列化、可循环</strong>的行动链条。</p><p><strong>工作流就是指将复杂的任务拆解为一系列</strong>确定的步骤。是一个能够自我规划、反思、调用工具的流程</p>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vibe-coding</tag>
      
      <tag>mcp</tag>
      
      <tag>agent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer</title>
    <link href="/2025/12/25/Transformer/"/>
    <url>/2025/12/25/Transformer/</url>
    
    <content type="html"><![CDATA[<img src="/2025/12/25/Transformer/image1.png" class="" title="Transformer架构"><h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><p>Transformer 的本质是一个 <strong>Encoder-Decoder（编码器-解码器）</strong> 架构。想象成一个“翻译官”：编码器负责读懂原文，解码器负责根据理解出的意思写出译文。</p><hr><h3 id="Encoder（左侧：编码器堆栈）"><a href="#Encoder（左侧：编码器堆栈）" class="headerlink" title="Encoder（左侧：编码器堆栈）"></a>Encoder（左侧：编码器堆栈）</h3><p>编码器的任务是提取特征。它由 6 层（原论文参数，可调整）相同的层堆叠而成。每一层都有两个主要的子层：</p><ul><li><strong>Multi-Head Self-Attention（多头自注意力层）：</strong> 帮助模型在对某个词编码时，查看输入序列中的其他单词。</li><li><strong>Feed Forward（前馈神经网络）：</strong> 对每个位置的特征进行独立的处理和非线性变换。</li></ul><h3 id="Decoder（右侧：解码器堆栈）"><a href="#Decoder（右侧：解码器堆栈）" class="headerlink" title="Decoder（右侧：解码器堆栈）"></a><strong>Decoder（右侧：解码器堆栈）</strong></h3><p>解码器的任务是生成输出。它同样由 6 层组成，但比编码器多了一个子层：</p><ul><li><strong>Masked Multi-Head Attention（掩码多头自注意力层）：</strong> 确保在生成当前词时，模型只能看到之前已经生成的词，而不能“偷看”后面的答案。</li><li><strong>Encoder-Decoder Attention（编码器-解码器注意力层）：</strong> 这是两者的桥梁。它让解码器可以重点关注输入序列中与当前生成词相关的部分（比如翻译“苹果”时，注意力会集中在原句中的 “Apple” 上）。</li></ul><hr><p>看一个句子是如何被处理的：</p><ol><li><strong>词嵌入（Input Embedding）：</strong> 单词（如 “Hello”）被转换成高维向量。</li><li><strong>位置编码（Positional Encoding）：</strong> 由于 Transformer 没有顺序感，我们需要给向量加上“位置标签”，告诉模型单词在句子里的顺序。</li><li><strong>进入 Encoder：</strong><ul><li>自注意力机制计算词与词之间的关系。</li><li>通过**残差连接（Residual Connection）<strong>和</strong>层归一化（Layer Norm）**防止训练时的梯度消失。</li></ul></li><li><strong>传递给 Decoder：</strong> Encoder 的输出作为“记忆”传递给 Decoder。</li><li><strong>Decoder 生成：</strong> Decoder 逐个生成单词。生成下一个词时，它会同时参考：<ul><li>已经生成的词。</li><li>Encoder 提供的原文上下文。</li></ul></li><li><strong>线性层与 Softmax：</strong> 最后通过一个全连接层和 Softmax 函数，从词汇表中选出概率最大的那个词。</li></ol><hr><h1 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h1><p>BERT 的全称是 <strong>Bidirectional Encoder Representations from Transformers</strong>。它的核心逻辑是：<strong>“既然 Encoder 能够一眼看全句，那我就让它把全句的上下文信息压榨到极致。”</strong></p><hr><h2 id="1-BERT-的架构：Encoder-Only"><a href="#1-BERT-的架构：Encoder-Only" class="headerlink" title="1. BERT 的架构：Encoder-Only"></a>1. BERT 的架构：Encoder-Only</h2><p>BERT 彻底舍弃了 Transformer 的 Decoder 部分，只保留了 <strong>Encoder</strong> 堆栈。</p><ul><li><strong>双向性 (Bidirectional)</strong>：与传统模型从左到右阅读不同，BERT 在处理每一个词时，都能<strong>同时</strong>看到它左边和右边的所有词。</li><li><strong>目标</strong>：它不是为了“生成”句子（比如翻译或聊天），而是为了“理解”句子。它要把每个词转变成包含极其丰富上下文信息的<strong>特征向量</strong>。</li></ul><hr><h2 id="2-如何训练"><a href="#2-如何训练" class="headerlink" title="2. 如何训练"></a>2. 如何训练</h2><p>既然没有 Decoder 目标序列，BERT 怎么训练呢？Google 提出了两个自监督任务：</p><h3 id="任务-A：掩码语言模型-Masked-LM-MLM"><a href="#任务-A：掩码语言模型-Masked-LM-MLM" class="headerlink" title="任务 A：掩码语言模型 (Masked LM, MLM)"></a><strong>任务 A：掩码语言模型 (Masked LM, MLM)</strong></h3><p>这是 BERT 最著名的“完形填空”训练法：</p><ol><li>输入一句话，比如：“我 [MASK] 猫”。</li><li>模型通过双向 Attention 观察“我”和“猫”，推测出 [MASK] 位置应该是“爱”。</li></ol><ul><li><strong>意义</strong>：这强制模型去理解词与词之间的双向逻辑关系，而不是像 GPT 那样只根据前文猜后文。</li></ul><h3 id="任务-B：下一句预测-Next-Sentence-Prediction-NSP"><a href="#任务-B：下一句预测-Next-Sentence-Prediction-NSP" class="headerlink" title="任务 B：下一句预测 (Next Sentence Prediction, NSP)"></a><strong>任务 B：下一句预测 (Next Sentence Prediction, NSP)</strong></h3><ol><li>给模型两句话：A 和 B。</li><li>让模型判断 B 是不是 A 的下一句话。</li></ol><ul><li><strong>意义</strong>：这让模型学会了理解<strong>句子与句子之间</strong>的层级关系，对问答（QA）任务极其重要。</li></ul><hr><h2 id="3-BERT-的输入表征"><a href="#3-BERT-的输入表征" class="headerlink" title="3. BERT 的输入表征"></a>3. BERT 的输入表征</h2><p>BERT 为了能处理各种下游任务，设计了非常精巧的输入：</p><ul><li><strong>Token Embeddings</strong>：词向量。</li><li><strong>Segment Embeddings</strong>：区分第一句话和第二句话。</li><li><strong>Position Embeddings</strong>：位置编码（BERT 使用的是可学习的向量，而不是正余弦函数）。</li><li><strong>[CLS] 标志</strong>：放在句首，它的输出向量被看作是<strong>整句话的语义总结</strong>，常用于分类任务。</li></ul><hr><h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p>既然我们已经理解了 BERT 这种“双向全能”的 Encoder 架构，现在我们来看看目前大模型（LLM）的主流——<strong>Decoder-only 架构</strong>。以 GPT（Generative Pre-trained Transformer）为例，它的核心逻辑是：<strong>“只看过去，预测未来”</strong>。</p><hr><h2 id="1-架构核心：单向性（Unidirectional）"><a href="#1-架构核心：单向性（Unidirectional）" class="headerlink" title="1. 架构核心：单向性（Unidirectional）"></a>1. 架构核心：单向性（Unidirectional）</h2><p>与 BERT 能同时看到左右两边不同，GPT 的 Decoder 架构在处理信息时是<strong>单向自回归</strong>的。</p><ul><li><strong>受限视野</strong>：在处理第n个词时，模型只能看到前 n-1个词。</li><li><strong>物理实现</strong>：这是通过 <strong>Masked Multi-Head Attention（掩码多头注意力）</strong> 实现的。在训练时，我们会用一个上三角矩阵（Look-ahead Mask）把当前位置之后的词全部遮住。</li><li><strong>为什么这么做？</strong>：为了模拟真实的生成场景。在现实中，我们说话是一个字一个字往外蹦的，你不可能在说第一个字时就“预见”到最后一个字的精确表征。</li></ul><hr><h2 id="2-为什么现在的-LLM-几乎全是-Decoder-only？"><a href="#2-为什么现在的-LLM-几乎全是-Decoder-only？" class="headerlink" title="2. 为什么现在的 LLM 几乎全是 Decoder-only？"></a>2. 为什么现在的 LLM 几乎全是 Decoder-only？</h2><h3 id="1-训练与推理的一致性"><a href="#1-训练与推理的一致性" class="headerlink" title="(1) 训练与推理的一致性"></a><strong>(1) 训练与推理的一致性</strong></h3><ul><li><strong>BERT</strong> 训练时是做完形填空（填中间），但实际使用时往往是生成长文本（往后写）。这种训练和使用的不一致会导致性能损耗。</li><li><strong>GPT</strong> 训练时就是“根据前文猜下一个词”，这和它实际聊天时的逻辑完全一样。</li></ul><h3 id="2-零样本迁移能力（Zero-shot-Learning）"><a href="#2-零样本迁移能力（Zero-shot-Learning）" class="headerlink" title="(2) 零样本迁移能力（Zero-shot Learning）"></a><strong>(2) 零样本迁移能力（Zero-shot Learning）</strong></h3><p>Decoder-only 架构天生适合<strong>指令遵循</strong>。只要你给它一个开头（Prompt），它就能顺着你的意思一直写下去。研究发现，当模型参数规模足够大时，这种单向预测的能力会产生“涌现”现象，展现出极强的通用性。</p><h3 id="3-显存效率"><a href="#3-显存效率" class="headerlink" title="(3) 显存效率"></a><strong>(3) 显存效率</strong></h3><p>在生成长文本时，Decoder 只需要维护一个 <strong>KV Cache</strong>（缓存已经算过的词的 Key 和 Value），每次预测新词只需要计算新词的特征，而不需要像 Encoder 那样重新扫描全句，这在大规模生成时效率更高。</p><hr><h2 id="3-GPT-的训练全过程（Generative-Pre-training）"><a href="#3-GPT-的训练全过程（Generative-Pre-training）" class="headerlink" title="3. GPT 的训练全过程（Generative Pre-training）"></a>3. GPT 的训练全过程（Generative Pre-training）</h2><p>GPT 的训练通常分为两个阶段：</p><h3 id="第一阶段：无监督预训练（Pre-training）"><a href="#第一阶段：无监督预训练（Pre-training）" class="headerlink" title="第一阶段：无监督预训练（Pre-training）"></a><strong>第一阶段：无监督预训练（Pre-training）</strong></h3><p>在海量的互联网文本上进行“接龙游戏”。</p><ul><li><strong>目标函数</strong>：最大化似然概率。</li><li><strong>意义</strong>：这一步是为了让模型学会人类世界的知识、语法、逻辑和常识。</li></ul><h3 id="第二阶段：有监督微调（SFT）与-RLHF"><a href="#第二阶段：有监督微调（SFT）与-RLHF" class="headerlink" title="第二阶段：有监督微调（SFT）与 RLHF"></a><strong>第二阶段：有监督微调（SFT）与 RLHF</strong></h3><p>预训练后的模型是一个“复读机”，它只会顺着话往下说，不一定会听你的指令。</p><ul><li><strong>SFT</strong>：用人工编写的问答对来教它：“当我问你问题时，你要给出答案，而不是重复我的问题。”</li><li><strong>RLHF</strong>：通过人类反馈强化学习，让模型更符合人类的价值观和偏好。</li></ul><hr><h2 id="4-Decoder-only-vs-Encoder-only"><a href="#4-Decoder-only-vs-Encoder-only" class="headerlink" title="4. Decoder-only vs. Encoder-only"></a>4. Decoder-only vs. Encoder-only</h2><table><thead><tr><th><strong>维度</strong></th><th><strong>Encoder-only (如 BERT)</strong></th><th><strong>Decoder-only (如 GPT)</strong></th></tr></thead><tbody><tr><td><strong>注意力机制</strong></td><td>双向（Bidirectional）</td><td>单向（Masked &#x2F; Causal）</td></tr><tr><td><strong>核心任务</strong></td><td>理解、分类、标注</td><td>生成、对话、推理</td></tr><tr><td><strong>预训练目标</strong></td><td>掩码预测（完形填空）</td><td>下一个词预测（文本接龙）</td></tr><tr><td><strong>优势</strong></td><td>对词的表征极其精准</td><td>逻辑推理能力强，适合长文本生成</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
      <tag>NLP</tag>
      
      <tag>大模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requests库基础学习</title>
    <link href="/2025/12/23/requests%E5%BA%93%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/23/requests%E5%BA%93%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>接口测试本质上就是<strong>客户端（你的代码）</strong> 发送请求，<strong>服务器</strong> 处理并返回响应。</p><h2 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h2><p>GET 请求通常用于“获取”数据（比如查询商品列表）。在接口自动化中，<code>GET</code> 请求最常见的场景是：<strong>带参数查询</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 1. 定义目标 URL</span><br>url = <span class="hljs-string">&quot;https://httpbin.org/get&quot;</span><br><br><span class="hljs-comment"># 2. 定义查询参数 (例如：搜索 keyword=&#x27;python&#x27;, page=1)</span><br><span class="hljs-comment"># requests 允许你直接传一个字典，它会自动帮你拼接成 url?key=value 的形式</span><br>payload = &#123;<br>    <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;python&quot;</span>,<br>    <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment"># 3. 发送 GET 请求</span><br><span class="hljs-comment"># 这里的 params 参数就是用来处理 URL 后面跟着的参数的</span><br>response = requests.get(url, params=payload)<br><br><span class="hljs-comment"># 4. 获取结果 (测试人员最关心的部分)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 状态码 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(response.status_code)  <span class="hljs-comment"># 200 表示成功</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 响应的 URL (自动拼接好的) ---&quot;</span>)<br><span class="hljs-built_in">print</span>(response.url) <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 响应文本 (String 格式) ---&quot;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><blockquote><p>httpbin.org 是一个专门用来练习 HTTP 请求的网站，它会把发送给它的东西原样返回，适合用来调试代码。</p></blockquote><hr><h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><p>POST 请求通常用于“提交”数据（比如登录、注册、创建订单）。这是测试中最容易出错的地方，因为<strong>数据格式</strong>必须准确。</p><p>区分两种最常见的数据格式：</p><ol><li><strong>Form 表单 (<code>application/x-www-form-urlencoded</code>)</strong>：传统的网页提交方式。</li><li><strong>JSON (<code>application/json</code>)</strong>：现代前后端分离接口（RESTful API）最常用的方式。****</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br>url = <span class="hljs-string">&quot;https://httpbin.org/post&quot;</span><br><br><span class="hljs-comment"># --- 场景 A: 提交 JSON 数据 (推荐) ---</span><br><span class="hljs-comment"># 现在的后端接口 90% 都是这种格式</span><br>data_json = &#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;tester_01&quot;</span>,<br>    <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;login&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 注意：这里使用 json= 参数</span><br><span class="hljs-comment"># requests 库会自动帮你把字典转成 JSON 字符串，并添加 Content-Type: application/json 头</span><br>response_json = requests.post(url, json=data_json)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- JSON 提交响应 ---&quot;</span>)<br><span class="hljs-comment"># 使用 .json() 方法直接把返回的字符串解析成 Python 字典，方便后续断言</span><br><span class="hljs-built_in">print</span>(response_json.json()) <br><br><br><span class="hljs-comment"># --- 场景 B: 提交表单数据 ---</span><br>data_form = &#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;tester_02&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 注意：这里使用 data= 参数</span><br>response_form = requests.post(url, data=data_form)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 表单提交响应 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(response_form.json())<br></code></pre></td></tr></table></figure><hr><h2 id="解析响应"><a href="#解析响应" class="headerlink" title="解析响应"></a>解析响应</h2><table><thead><tr><th><strong>属性</strong></th><th><strong>说明</strong></th><th><strong>测开用途</strong></th></tr></thead><tbody><tr><td><code>response.status_code</code></td><td>HTTP 状态码</td><td><strong>第一层断言</strong>：先判断是不是 200。</td></tr><tr><td><code>response.json()</code></td><td>解析 JSON 响应</td><td><strong>核心断言</strong>：获取业务字段（如 <code>code</code>, <code>msg</code>, <code>token</code>）。</td></tr><tr><td><code>response.text</code></td><td>原始文本</td><td>当返回不是 JSON（如 HTML 或报错信息）时查看。</td></tr><tr><td><code>response.elapsed</code></td><td>响应耗时</td><td>用于简单的性能监控（如断言响应必须 &lt; 500ms）。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;https://httpbin.org/get&quot;</span><br>resp = requests.get(url)<br><br><span class="hljs-comment"># --- 自动化测试的核心逻辑 ---</span><br><br><span class="hljs-comment"># 1. 断言状态码</span><br><span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 接口连通性测试通过&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 接口报错，状态码: <span class="hljs-subst">&#123;resp.status_code&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 断言业务逻辑 (假设返回的 JSON 中必须包含 headers 字段)</span><br>resp_dict = resp.json() <span class="hljs-comment"># 转成字典</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;headers&quot;</span> <span class="hljs-keyword">in</span> resp_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 业务字段校验通过&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 缺少关键字段&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="身份伪装与会话管理"><a href="#身份伪装与会话管理" class="headerlink" title="身份伪装与会话管理"></a>身份伪装与会话管理</h1><p>在真实的测试场景中，大部分接口不是“裸奔”的。比如：</p><ol><li>有些接口必须<strong>登录</strong>后才能访问（需要 Cookie 或 Token）。</li><li>有些接口限制了<strong>客户端类型</strong>（需要 User-Agent）。</li><li>接口测试通常是<strong>连续</strong>的：先登录 -&gt; 再查询 -&gt; 再下单。</li></ol><p>“<strong>如何让代码像浏览器一样，记住登录状态？</strong>”</p><hr><h2 id="定制请求头-Headers"><a href="#定制请求头-Headers" class="headerlink" title="定制请求头 (Headers)"></a>定制请求头 (Headers)</h2><p>很多时候直接请求接口会返回 403 Forbidden，或者返回的数据不对，大概率是因为缺少了 <code>Headers</code>。</p><p>在自动化框架中，有两个 Header 最常用：</p><ul><li><code>User-Agent</code>: 告诉服务器你是谁（浏览器？手机？还是爬虫脚本）。</li><li><code>Authorization</code> &#x2F; <code>token</code>: 用于鉴权（告诉服务器你登录了）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;https://httpbin.org/headers&quot;</span><br><br><span class="hljs-comment"># 定义 headers 字典</span><br><span class="hljs-comment"># 模拟自己是一个 Chrome 浏览器，或者是你的测试框架专用的 User-Agent</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;MyTestFramework/1.0&quot;</span>,<br>    <span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;a1b2c3d4e5&quot;</span>  <span class="hljs-comment"># 假设这是登录后获取的 token</span><br>&#125;<br><br><span class="hljs-comment"># 发送请求时带上 headers</span><br>response = requests.get(url, headers=headers)<br><br><span class="hljs-built_in">print</span>(response.json())<br></code></pre></td></tr></table></figure><blockquote><p>测试开发视角：在封装框架时，会把 headers 放在公共配置里（比如 config.py），这样不用每个测试用例都手动写一遍 User-Agent。</p></blockquote><hr><h2 id="会话对象-Session"><a href="#会话对象-Session" class="headerlink" title="会话对象 (Session)"></a>会话对象 (Session)</h2><p>问题场景：假设有两个接口：</p><ol><li><code>/login</code> (登录成功后，服务器会给浏览器发一个 Cookie)</li><li><code>/profile</code> (查询个人信息，需要带着刚才那个 Cookie 才能查)</li></ol><p>如果直接用 <code>requests.post</code> 登录，再用 <code>requests.get</code> 查信息，<strong>第二次请求会失败</strong>。因为 <code>requests</code> 是“无状态”的，第二次请求时它已经忘记了第一次请求发生的事。</p><p>解决方案：requests.Session()。Session 对象就像一个浏览器，它会自动帮你保存和携带 Cookie。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 1. 初始化一个 Session 对象（把它想象成打开了一个浏览器窗口）</span><br>s = requests.Session()<br><br><span class="hljs-comment"># 2. 先访问设置 Cookie 的接口（模拟登录）</span><br><span class="hljs-comment"># httpbin/cookies/set 会模拟服务器给客户端种下 cookie</span><br>login_url = <span class="hljs-string">&quot;https://httpbin.org/cookies/set/sessioncookie/123456789&quot;</span><br>s.get(login_url) <br><br><span class="hljs-comment"># 注意：此时 s 这个对象里已经存了 cookie 了</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前会话中的 Cookie:&quot;</span>, s.cookies.get_dict())<br><br><span class="hljs-comment"># 3. 带着状态去访问下一个接口（模拟查询）</span><br><span class="hljs-comment"># httpbin/cookies 会返回当前请求带了哪些 cookie</span><br>profile_url = <span class="hljs-string">&quot;https://httpbin.org/cookies&quot;</span><br><br><span class="hljs-comment"># 注意：这里用 s.get 而不是 requests.get</span><br>resp = s.get(profile_url)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;个人中心接口收到的 Cookie:&quot;</span>, resp.json())<br></code></pre></td></tr></table></figure><blockquote><p>在未来写的自动化框架中，通常会创建一个 BaseApi 类，并在 <strong>init</strong> 方法里实例化 self.session &#x3D; requests.Session()。所有的接口请求都通过 self.session 发送，从而保证全流程登录状态不丢失。</p></blockquote><hr><h2 id="超时处理-Timeout"><a href="#超时处理-Timeout" class="headerlink" title="超时处理 (Timeout)"></a>超时处理 (Timeout)</h2><p>自动化测试要想稳定，必须要有超时控制。如果服务器挂了，脚本不能一直卡在那里等死。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 设为 0.1 秒，连接 github 这种国外网站通常会超时报错</span><br><span class="hljs-keyword">try</span>:<br>    requests.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>, timeout=<span class="hljs-number">0.1</span>)<br><span class="hljs-keyword">except</span> requests.exceptions.Timeout:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 请求超时了！测试用例执行失败，请检查网络或服务器性能。&quot;</span>)<br><span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 发生了其他错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApi</span>:<br>    <span class="hljs-comment"># 类变量：通常放一些固定的配置，比如域名</span><br>    <span class="hljs-comment"># 注意：httpbin.org/cookies/set... 是用来模拟让服务器种 Cookie 的</span><br>    host = <span class="hljs-string">&quot;https://httpbin.org&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 1. 初始化 Session 工具箱</span><br>        <span class="hljs-variable language_">self</span>.session = requests.Session()<br>        <br>        <span class="hljs-comment"># (可选) 如果有些接口一开始就需要 headers，可以在这里统一定义</span><br>        <span class="hljs-variable language_">self</span>.session.headers = &#123;<br>            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;TestDev-Client/1.0&quot;</span><br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;模拟登录：这里演示发送 POST 请求&quot;&quot;&quot;</span><br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.host&#125;</span>/post&quot;</span> <span class="hljs-comment"># 拼接 URL</span><br>        <br>        data_json = &#123;<br>            <span class="hljs-string">&quot;user&quot;</span>: username  <span class="hljs-comment"># 注意：这里使用传入的变量，不要加引号</span><br>        &#125;<br>        <br>        <span class="hljs-comment"># 2. 使用 self.session 发送请求</span><br>        <span class="hljs-comment"># 必须 return 响应对象，否则外面调用的人拿不到结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.session.post(url, json=data_json)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cookie_action</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;模拟一个会产生 Cookie 的操作&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 这个接口访问后，Session 里就会自动存入 cookie</span><br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.host&#125;</span>/cookies/set/my_token/123456&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.session.get(url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;模拟查询：演示携带 Cookie 的 GET 请求&quot;&quot;&quot;</span><br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.host&#125;</span>/cookies&quot;</span> <span class="hljs-comment"># 这个接口会返回当前 Session 里所有的 Cookie</span><br>        <br>        <span class="hljs-comment"># 3. 再次使用 self.session</span><br>        <span class="hljs-comment"># 因为前面如果调用过 set_cookie_action，这里的 session 会自动带上那个 cookie</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.session.get(url, timeout=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># --- 验证代码 (你可以直接复制运行) ---</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 1. 实例化 (相当于打开了一个浏览器)</span><br>    api = DemoApi()<br>    <br>    <span class="hljs-comment"># 2. 模拟登录 (虽然 httpbin 的 post 不会真的种 cookie，但演示了 post 写法)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在登录...&quot;</span>)<br>    resp_login = api.login(<span class="hljs-string">&quot;admin_001&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;登录响应: <span class="hljs-subst">&#123;resp_login.json()[<span class="hljs-string">&#x27;json&#x27;</span>]&#125;</span>&quot;</span>) <span class="hljs-comment"># 打印出来看看 username 对不对</span><br><br>    <span class="hljs-comment"># 3. 模拟一个种 Cookie 的操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 正在获取 Cookie...&quot;</span>)<br>    api.set_cookie_action()<br>    <br>    <span class="hljs-comment"># 4. 查询个人信息 (验证 Cookie 是否被自动带过去了)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 正在查询信息(检查Cookie)...&quot;</span>)<br>    resp_info = api.get_user_info()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;查询结果: <span class="hljs-subst">&#123;resp_info.json()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="分层管理-自动化测试框架雏形"><a href="#分层管理-自动化测试框架雏形" class="headerlink" title="分层管理-自动化测试框架雏形"></a>分层管理-自动化测试框架雏形</h1><p>遵循一个核心原则：<strong>分层设计 (Layered Architecture)</strong>。把“发送请求的代码”和“测试验证的代码”拆分开。</p><h2 id="创建标准目录结构"><a href="#创建标准目录结构" class="headerlink" title="创建标准目录结构"></a>创建标准目录结构</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">ApiTestFramework<span class="hljs-symbol">/</span>  (项目根目录)<br>├── api<span class="hljs-symbol">/</span>             <span class="hljs-comment"># 【API层】只负责发请求，不负责断言</span><br>│   └── user_api.py      <span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span>- 刚才写的 Class 放在这里<br>├── testcases<span class="hljs-symbol">/</span>       <span class="hljs-comment"># 【用例层】调用 API 层，进行断言 (pytest)</span><br>│   └── test_login.py    <span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span>- 真正的测试脚本<br>├── utils<span class="hljs-symbol">/</span>           <span class="hljs-comment"># 【工具层】读取配置、生成日志等</span><br>└── run.py           <span class="hljs-comment"># 【执行入口】一键运行所有测试</span><br></code></pre></td></tr></table></figure><hr><h2 id="拆分代码"><a href="#拆分代码" class="headerlink" title="拆分代码"></a>拆分代码</h2><p>把刚才写的 <code>DemoApi</code> 拆成两部分。</p><h3 id="编写-API-层"><a href="#编写-API-层" class="headerlink" title="编写 API 层"></a>编写 API 层</h3><p>规则：这里只写 requests 相关操作，不要出现 assert（断言），也不要出现测试数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件路径: api/user_api.py</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApi</span>:<br>    host = <span class="hljs-string">&quot;https://httpbin.org&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.session = requests.Session()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;发送登录请求&quot;&quot;&quot;</span><br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.host&#125;</span>/post&quot;</span><br>        data = &#123;<span class="hljs-string">&quot;user&quot;</span>: username&#125;<br>        <span class="hljs-comment"># 只负责返回响应对象，不负责判断对错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.session.post(url, json=data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;发送查询请求&quot;&quot;&quot;</span><br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.host&#125;</span>/get&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.session.get(url)<br></code></pre></td></tr></table></figure><h3 id="编写用例层"><a href="#编写用例层" class="headerlink" title="编写用例层"></a>编写用例层</h3><p>这里引入一个强大的测试运行框架：Pytest。负责<strong>调用 API</strong> 并 <strong>断言 (assert)</strong> 结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件路径: testcases/test_login.py</span><br><br><span class="hljs-comment"># 1. 导入刚才写的 API 类</span><br><span class="hljs-comment"># 注意：如果在 PyCharm 中报红线找不到模块，右键根目录 -&gt; Mark Directory as -&gt; Sources Root</span><br><span class="hljs-keyword">from</span> api.user_api <span class="hljs-keyword">import</span> UserApi<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUserLogin</span>:<br>    <br>    <span class="hljs-comment"># setup_class 是 pytest 的钩子函数：在所有测试开始前只执行一次</span><br>    <span class="hljs-comment"># 适合用来初始化 API 对象</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_class</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.user_api = UserApi()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;测试用例1：正常登录&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 步骤 1: 调用接口</span><br>        res = <span class="hljs-variable language_">self</span>.user_api.login(<span class="hljs-string">&quot;admin_01&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 2: 获取数据</span><br>        res_json = res.json()<br>        <br>        <span class="hljs-comment"># 步骤 3: 断言 (判定测试是通过还是失败)</span><br>        <span class="hljs-comment"># 这里的 assert 是 pytest 的核心</span><br>        <span class="hljs-keyword">assert</span> res.status_code == <span class="hljs-number">200</span><br>        <span class="hljs-keyword">assert</span> res_json[<span class="hljs-string">&#x27;json&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>] == <span class="hljs-string">&quot;admin_01&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 登录测试通过&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_get_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;测试用例2：查询信息&quot;&quot;&quot;</span><br>        res = <span class="hljs-variable language_">self</span>.user_api.get_info()<br>        <span class="hljs-keyword">assert</span> res.status_code == <span class="hljs-number">200</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 查询测试通过&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>现在我们不再右键点击文件运行了，而是使用命令行。打开终端，进入项目根目录 <code>ApiTestFramework</code>，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -vs<br></code></pre></td></tr></table></figure><ul><li><code>-v</code>: 显示详细信息 (verbose)。</li><li><code>-s</code>: 显示代码里的 <code>print</code> 输出 (默认 pytest 会吃掉 print)。</li></ul><p>预期结果：应该会看到绿色的文字，显示 passed，类似这样：</p><p>testcases&#x2F;test_login.py::TestUserLogin::test_login_success PASSED</p><p>testcases&#x2F;test_login.py::TestUserLogin::test_get_info PASSED</p><blockquote><p>“为了解耦和复用。</p><p>如果接口的 URL 或参数变了，只需要去 API 层 修改 1 个地方，而不用去修改几十个 测试用例。</p><p>测试用例只关注业务逻辑（断言），API 层只关注协议细节。”</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口测试</tag>
      
      <tag>requests</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Locust基础学习</title>
    <link href="/2025/12/22/Locust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/Locust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Locust 是非常适合**测试开发（Test Dev）**岗位的工具</p><ol><li><strong>它是 Python 编写的</strong>：完全符合测开对代码能力的要求。</li><li><strong>Code-as-Infrastructure</strong>：测试脚本就是代码，易于维护和版本控制。</li><li><strong>高并发能力</strong>：基于协程（Gevent），单机能模拟极高并发。</li></ol><p> Locust 的三个核心概念：</p><ul><li><strong>User Class (用户类)</strong>：每一个虚拟用户都是这个类的一个实例。</li><li><strong>Task (任务)</strong>：用户具体要做的事（比如：刷首页、下单、搜索），用 <code>@task</code> 装饰器标记。</li><li><strong>Wait Time (等待时间)</strong>：模拟真实人类的操作间隔。</li></ul><p>模拟一个场景：<strong>用户访问百度的首页，并且偶尔访问一下百度的“新闻”页面。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    <span class="hljs-comment"># wait_time 模拟用户思考时间</span><br>    <span class="hljs-comment"># between(1, 3) 表示每个用户做完一个任务后，会随机休息 1 到 3 秒</span><br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment"># host 是被测网站的地址，也可以在命令行里指定</span><br>    <span class="hljs-comment"># 这里我们先不写，一会儿在网页界面里填</span><br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">1</span></span>)  </span><span class="hljs-comment"># 权重为 1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_news</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># client 继承自 requests 库，用法几乎一样</span><br>        <span class="hljs-comment"># 这里模拟搜索</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/s?wd=哈哈&quot;</span>)<br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">3</span></span>)  </span><span class="hljs-comment"># 权重为 3</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_homepage</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 模拟访问根目录</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/&quot;</span>)<br><br><span class="hljs-comment"># 逻辑解释：</span><br><span class="hljs-comment"># 这里的权重(1 和 3)意味着：</span><br><span class="hljs-comment"># 这是一个概率游戏。Locust 每次挑任务时，</span><br><span class="hljs-comment"># 有 3/4 的概率会去访问首页，有 1/4 的概率会去访问新闻页。</span><br><span class="hljs-comment"># 这比单纯的轮询更像真实用户的行为。</span><br></code></pre></td></tr></table></figure><p>启动 Locust-在终端中，进入 locustfile.py 所在的文件夹，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locust<br></code></pre></td></tr></table></figure><p><em>注意：不需要加文件名，因为它默认找 <code>locustfile.py</code>。</em></p><ol><li><p>打开 Web 界面</p><p>看到终端提示：Starting web interface at <a href="http://0.0.0.0:8089。打开浏览器访问">http://0.0.0.0:8089。打开浏览器访问</a></p></li><li><p>配置参数（重点）</p><p>界面上会有三个框，这样填：</p><ul><li><strong>Number of users (Peak Concurrency)</strong>: <code>10</code> (我们要模拟 10 个用户)</li><li><strong>Spawn rate (Users started&#x2F;second)</strong>: <code>1</code> (每秒增加 1 个用户，也就是 10 秒后达到满载)</li><li><strong>Host</strong>: <code>https://www.baidu.com</code> (不要忘了 https)</li></ul></li><li><p><strong>点击 “Start swarming”</strong></p></li></ol><p>跑起来后，会看到几个核心指标：</p><ol><li><strong>RPS (Requests Per Second)</strong>: 吞吐量。每秒服务器处理了多少请求。<em>数值越大，性能越好。</em></li><li><strong>Failures</strong>: 失败率。如果这个不为 0，说明服务器报错了或者网络有问题。</li><li><strong>Average &#x2F; Median &#x2F; 95%ile (ms)</strong>: 响应时间。<ul><li><strong>坑点</strong>：永远不要只看 Average（平均值），因为平均值会掩盖问题。</li><li><strong>要看 95%ile (P95)</strong>：意思是 95% 的请求都在这个时间内完成了。这才是衡量用户体验的真实标准。</li></ul></li></ol><hr><h1 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h1><p>如果 10 个用户都搜同一个词：</p><ul><li><strong>服务器端</strong>：可能有缓存，导致测试结果比实际快，数据<strong>失真</strong>。</li><li><strong>业务逻辑</strong>：无法覆盖数据库查询的多样性。</li></ul><p><strong>解决方法</strong>：建立一个“词库”，让用户每次随机挑一个词去搜。</p><p>另外，如果直接把 URL 写成动态的，比如：</p><ul><li>用户A 访问 <code>/s?wd=apple</code></li><li>用户B 访问 <code>/s?wd=banana</code></li></ul><p>Locust 的报告里会把这两条当成<strong>两个完全不同的接口</strong>来展示。如果有 1000 个搜索词，报告里就会有 1000 行数据，<strong>没法看</strong>。</p><p><strong>需要做的是</strong>：告诉 Locust，“不管后面参数是什么，这些都是‘搜索接口’，请把它们合并成一行统计”。</p><hr><p>修改 <code>locustfile.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># &lt;--- 1. 引入随机库</span><br><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment"># &lt;--- 2. 准备测试数据（真实项目中通常从 CSV 文件读取）</span><br>    search_keywords = [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;locust&quot;</span>, <span class="hljs-string">&quot;测试开发&quot;</span>, <span class="hljs-string">&quot;字节跳动&quot;</span>, <span class="hljs-string">&quot;高并发&quot;</span>]<br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_homepage</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/&quot;</span>)<br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 随机选一个词</span><br>        word = random.choice(<span class="hljs-variable language_">self</span>.search_keywords)<br>        <br>        <span class="hljs-comment"># &lt;--- 3. 核心考点：使用 name 参数</span><br>        <span class="hljs-comment"># 这里的 f&quot;/s?wd=&#123;word&#125;&quot; 是真正发给百度的请求</span><br>        <span class="hljs-comment"># 这里的 name=&quot;/s?wd=[keyword]&quot; 是你在 Locust 网页报告里想看到的名字</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">f&quot;/s?wd=<span class="hljs-subst">&#123;word&#125;</span>&quot;</span>, name=<span class="hljs-string">&quot;/s?wd=[keyword]&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li>保存代码。</li><li>回到终端，<strong>必须</strong>按 <code>Ctrl+C</code> 停止之前的运行，然后重新输入 <code>locust</code> 启动（代码修改后必须重启）。</li><li>回到浏览器 <code>http://localhost:8089</code>，再次启动测试。</li></ol><p>这一次，请盯着 Statistics 列表里的 Name 那一列。</p><ul><li><strong>如果做对了</strong>：不管通过了多少请求，搜索接口那一行永远只显示 <code>GET /s?wd=[keyword]</code>，所有的搜索请求都被合并统计到了这一行里。</li><li><strong>如果做错了</strong>（比如忘了加 <code>name</code> 参数）：你会发现列表越来越长，每一行都是具体的 <code>/s?wd=python</code>, <code>/s?wd=locust</code>…</li></ul><hr><h1 id="模拟登陆"><a href="#模拟登陆" class="headerlink" title="模拟登陆"></a>模拟登陆</h1><blockquote><p><em>如果在每一个任务里都写一遍登录，导致服务器压力爆炸（每秒登录 1000 次），还会被安全系统封号。</em></p></blockquote><p>在 Locust 里，处理登录只需要记住两点：</p><ol><li><strong><code>on_start</code> 方法</strong>：这是一个特殊的方法。Locust 启动每个虚拟用户时，<strong>只运行一次</strong>这个方法。它是放登录代码的最佳位置。</li><li><strong>Session 自动保持</strong>：<code>self.client</code> 继承自 <code>requests.Session</code>。这意味着，只要在 <code>on_start</code> 里登录成功了，后续所有的 task（任务）都会<strong>自动带上 Cookie</strong>，不需要手动传 Cookie。</li></ol><hr><p>使用 <code>httpbin.org</code>（一个专门用于测试 HTTP 请求的工具网站）来模拟登录过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这个方法在每个用户启动时只运行一次。</span><br><span class="hljs-string">        我们在这里进行登录操作。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 1. 准备登录数据 (模拟账号密码)</span><br>        login_data = &#123;<br>            <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;test_admin&quot;</span>,<br>            <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;123456&quot;</span><br>        &#125;<br>        <br>        <span class="hljs-comment"># 2. 发送登录请求 (POST)</span><br>        <span class="hljs-comment"># 我们用 httpbin.org/post 模拟登录接口，它会返回我们需要的数据</span><br>        response = <span class="hljs-variable language_">self</span>.client.post(<span class="hljs-string">&quot;/post&quot;</span>, json=login_data, name=<span class="hljs-string">&quot;Login_Action&quot;</span>)<br>        <br>        <span class="hljs-comment"># 3. 检查是否登录成功 (关键！测开必须有的健壮性思维)</span><br>        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录失败，停止该用户&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.stop() <span class="hljs-comment"># 如果登录失败，直接杀掉这个用户，防止产生错误数据</span><br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">view_profile</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 因为 on_start 已经运行过，这里的请求会自动带上 Cookie</span><br>        <span class="hljs-comment"># 模拟查看个人主页</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/get&quot;</span>, name=<span class="hljs-string">&quot;View_Profile&quot;</span>)<br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">logout</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 模拟注销 (通常注销后我们会停止该用户，或者重新登录)</span><br>        <span class="hljs-comment"># 这里为了演示，我们只是发个请求</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/get?action=logout&quot;</span>, name=<span class="hljs-string">&quot;Logout_Action&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><p>场景：<strong>参数化登录（每个人用不同的账号登录）</strong>。</p><p>这里有两种常用的策略，需要根据业务场景选：</p><ol><li><strong>随机抽取（Random）</strong>：适合搜索词、商品ID。数据可以重复使用。</li><li><strong>独占消耗（Queue）</strong>：适合登录账号。<strong>绝对不能</strong>两个虚拟用户同时用同一个账号登录，否则会被互踢。</li></ol><p><strong>以下用第二种：使用队列（Queue）实现账号的“独占读取”</strong>。</p><hr><p>在脚本同级目录下，新建一个文件叫 <code>users.csv</code>，内容如下（模拟账号和密码）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">user1</span>,<span class="hljs-number">123456</span><br><span class="hljs-attribute">user2</span>,<span class="hljs-number">123456</span><br><span class="hljs-attribute">user3</span>,<span class="hljs-number">123456</span><br><span class="hljs-attribute">user4</span>,<span class="hljs-number">123456</span><br><span class="hljs-attribute">user5</span>,<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>这里有一个<strong>至关重要的性能点</strong>：</p><blockquote><p>文件读取一定要放在 User 类外面（全局）！</p><p>如果写在类里面，Locust 每启动一个虚拟用户就会去读一次文件。如果有 1000 个用户，文件就会被打开 1000 次，内存直接爆炸。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> queue  <span class="hljs-comment"># 引入队列库，用于保证数据先进先出，不重复</span><br><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-comment"># =========================================</span><br><span class="hljs-comment"># 1. 全局数据加载区 (只运行一次)</span><br><span class="hljs-comment"># =========================================</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在加载测试数据...&quot;</span>)<br>user_data_queue = queue.Queue() <span class="hljs-comment"># 创建一个先进先出队列</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;users.csv&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        reader = csv.reader(f)<br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>            <span class="hljs-comment"># row 也是一个列表，比如 [&#x27;user1&#x27;, &#x27;123456&#x27;]</span><br>            user_data_queue.put(row) <br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;错误：找不到 users.csv 文件！&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据加载完成，队列中共有 <span class="hljs-subst">&#123;user_data_queue.qsize()&#125;</span> 条数据&quot;</span>)<br><br><br><span class="hljs-comment"># =========================================</span><br><span class="hljs-comment"># 2. 虚拟用户类</span><br><span class="hljs-comment"># =========================================</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvLoginUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        用户启动时，从队列里领一个账号。</span><br><span class="hljs-string">        如果队列空了，说明账号用完了，这个用户就必须直接退出。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># get(block=False) 表示如果队列空了直接报错，不等待</span><br>            <span class="hljs-comment"># pop 出一条数据，比如 [&#x27;user1&#x27;, &#x27;123456&#x27;]</span><br>            user_info = user_data_queue.get(block=<span class="hljs-literal">False</span>) <br>            <br>            <span class="hljs-variable language_">self</span>.username = user_info[<span class="hljs-number">0</span>]<br>            <span class="hljs-variable language_">self</span>.password = user_info[<span class="hljs-number">1</span>]<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前用户领取账号: <span class="hljs-subst">&#123;self.username&#125;</span>&quot;</span>)<br>            <br>            <span class="hljs-comment"># 这里调用登录逻辑（模拟）</span><br>            <span class="hljs-variable language_">self</span>.login()<br>            <br>        <span class="hljs-keyword">except</span> queue.Empty:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;【悲报】账号不够分了！当前用户无法启动，直接退出。&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.stop()  <span class="hljs-comment"># 关键：停止该用户</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 模拟登录请求</span><br>        <span class="hljs-variable language_">self</span>.client.post(<span class="hljs-string">&quot;/login&quot;</span>, json=&#123;<br>            <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-variable language_">self</span>.username, <br>            <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-variable language_">self</span>.password<br>        &#125;, name=<span class="hljs-string">&quot;Login_Action&quot;</span>)<br><br><span class="hljs-meta">    @task</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_something</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 登录后的业务操作</span><br>        <span class="hljs-variable language_">self</span>.client.get(<span class="hljs-string">&quot;/profile&quot;</span>, name=<span class="hljs-string">&quot;View_Profile&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li><strong>运行脚本</strong></li><li><strong>设置 Web 界面</strong>：<ul><li><strong>Users</strong>: 设置 <strong>6</strong> 个 ( CSV 里只有 <strong>5</strong> 条数据)。</li><li><strong>Spawn rate</strong>: 1</li><li>Host: <code>https://httpbin.org</code></li></ul></li><li><strong>观察终端输出</strong>：<ul><li>看到前 5 个用户打印 <code>当前用户领取账号: userX</code>。</li><li><strong>第 6 个用户</strong>启动时，会触发 <code>【悲报】账号不够分了！</code>，然后自动退出。</li></ul></li></ol><hr><p>问：<em>“直接把数据读到一个 list 列表里，然后用 random.choice 随机选不行吗？”</em></p><blockquote><p>“如果是搜索关键词，可以用 list+random。</p><p>但如果是登录账号，用 random 会导致两个虚拟用户随机到了同一个账号 user1。</p><p>现实中，后登录的 user1 会把先登录的 user1 踢下线（Session 互斥），导致前一个用户的后续请求全部报错。</p><p>所以对于消耗型数据（如账号、优惠券码），必须用 Queue 做到取一个少一个，保证线程安全。”</p></blockquote><hr><h1 id="无界面运行"><a href="#无界面运行" class="headerlink" title="无界面运行"></a>无界面运行</h1><p>在真实的生产环境中（ Linux 服务器），通常是没有图形界面的，往往需要把它集成到 Jenkins 或 GitLab CI 里的自动化流水线中，这时候<strong>必须</strong>使用命令行模式。</p><ul><li><strong>节省资源</strong>：图形界面（Web UI）本身也会消耗电脑资源。当要模拟几万并发时，哪怕一点点资源都很宝贵。</li><li><strong>自动化集成</strong>：CI&#x2F;CD 流水线（比如 Jenkins）只能运行命令，没有人去点网页上的 “Start” 按钮。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locust --headless -u 10 -r 2 -t 30s --html result.html --host https://httpbin.org<br></code></pre></td></tr></table></figure><p><strong>参数详解：</strong></p><ul><li><code>--headless</code>: <strong>核心开关</strong>。告诉 Locust 不要启动网页，直接在后台跑。</li><li><code>-u 10</code> (Users): 启动 <strong>10</strong> 个用户。</li><li><code>-r 2</code> (Rate): 每秒启动 <strong>2</strong> 个用户（5秒后达到满载）。</li><li><code>-t 30s</code> (Time): 运行 <strong>30秒</strong> 后自动停止。</li><li><code>--html result.html</code>: 测试结束后，自动生成一个漂亮的 HTML 报告文件。</li></ul><hr><p>输入命令后，会看到屏幕上只有简单的文字在滚动，不再有网页弹出来。</p><ul><li>它会显示 <code>Ramping to 10 users...</code></li><li>然后每隔几秒打印一次当前的统计数据。</li><li>30秒倒计时结束后，它会自动停止，并显示 <code>Shutting down</code>。</li></ul><p>去文件夹里找一找，多了一个叫 result.html 的文件。打开会看到一个包含图表、统计数据的完整报告。</p><p>“每次自动化压力测试结束后，会配置 Locust 自动导出 HTML 报告，并发送邮件给开发团队，这样大家不用跑脚本也能看到性能趋势。”</p><hr><p>问 <strong>“为什么要用 Locust 而不用 JMeter？”</strong></p><blockquote><p>“JMeter 虽然功能强大，但它是基于线程的，并发很高时非常吃内存。而 Locust 是**基于协程（Gevent）**的，更轻量，单机能支持更高的并发。</p><p>更重要的是，Locust 是 Code-as-Infrastructure（代码即各种配置），更喜欢用 Python 代码来维护复杂的测试逻辑（比如复杂的加密、断言），而不是在 XML 界面里点点点，这样更利于版本控制和团队协作。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能测试</tag>
      
      <tag>压力测试</tag>
      
      <tag>Locust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git基础学习</title>
    <link href="/2025/12/22/git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在测开的实际工作中，Git 不仅仅是用来“存代码”的，还需要用它来管理自动化测试脚本、处理版本回滚、甚至配合 CI&#x2F;CD（持续集成&#x2F;持续部署）流水线。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="三个工作区"><a href="#三个工作区" class="headerlink" title="三个工作区"></a>三个工作区</h2><p>Git 在本地电脑上，其实把文件分成了三个状态（区域）：</p><ol><li><strong>工作区 (Working Directory)：</strong> 平时写代码、能看到文件的地方（比如 VS Code 打开的文件夹）。</li><li><strong>暂存区 (Staging Area&#x2F;Index)：</strong> 一个临时的“购物车”。把想提交的修改先放在这里。</li><li><strong>版本库 (Repository&#x2F;.git)：</strong> 最终的档案库，保存了所有历史版本。</li></ol><hr><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>第一步：配置用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;YourName&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>第二步：初始化仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> test-demo       <span class="hljs-comment"># 新建文件夹</span><br><span class="hljs-built_in">cd</span> test-demo          <span class="hljs-comment"># 进入文件夹</span><br>git init              <span class="hljs-comment"># 初始化！你会发现多了一个隐藏的 .git 文件夹</span><br></code></pre></td></tr></table></figure><p><strong>第三步： <code>add</code> 和 <code>commit</code></strong></p><ol><li><p>新建一个文件 <code>test_login.py</code>，随便写点内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p><em>看到文件名是红色的，表示它只在*<em>工作区</em></em>，Git 还没追踪它。*</p></li><li><p>添加到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test_login.py<br></code></pre></td></tr></table></figure><p><em>再次输入 <code>git status</code>，文件名变绿了，表示进了*<em>暂存区</em></em>。*</p></li><li><p>正式提交到版本库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Create login test script&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>-m</code> 后面跟的是提交信息（Commit Message）。*</li></ul></li></ol><blockquote><p>问：“git add 是做什么的？为什么不直接 commit？”</p><p>答： add 允许我们要挑选一部分修改进行提交。比如改了3个文件，但只想先把其中2个相关的提交为一个版本，就可以只 add 那两个文件。这体现了提交的原子性。</p></blockquote><hr><h2 id="常用查看命令"><a href="#常用查看命令" class="headerlink" title="常用查看命令"></a>常用查看命令</h2><p>当提交了几次后，需要回顾历史：</p><ul><li><strong><code>git log</code></strong>：查看详细的提交历史（按 <code>q</code> 退出）。</li><li><strong><code>git log --oneline</code></strong>：一行显示一条历史，非常简洁（推荐）。</li></ul><hr><h1 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h1><p>想象一下，现在的 test-demo 仓库里有一套稳定运行的自动化测试脚本。开发新增加了一个“购物车”功能，老板让你写对应的测试脚本。</p><ul><li><strong>如果不通过分支：</strong> 直接在现有文件里改改改。万一写错了，或者改到一半要去修别的 Bug，代码就乱了，原来的稳定版本也跑不起来了。</li><li><strong>使用分支：</strong> 就像开启了一个**“平行宇宙”**。在这个新宇宙里，随便折腾，原来的宇宙（主分支）不受任何影响。等写好了，再把两个宇宙合并。</li></ul><p>在业内，通常把主分支叫做 <code>main</code> (旧版本叫 <code>master</code>)，把干活的分支叫做 <code>feature/xxx</code> (新功能) 或 <code>bugfix/xxx</code> (修补丁)。</p><p>请回到终端，确保在 <code>test-demo</code> 文件夹下。</p><p><strong>第一步：查看当前分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><ul><li>应该会看到 <code>* master</code> 或 <code>* main</code>。那个星号 <code>*</code> 表示你当前所在的宇宙。</li></ul><p><strong>第二步：创建并切换到新分支</strong></p><p>要去写“购物车”的测试了，起个名字叫 feature&#x2F;cart-test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧命令：git checkout -b feature/cart-test</span><br><span class="hljs-comment"># 新命令（推荐使用）：</span><br>git switch -c feature/cart-test<br></code></pre></td></tr></table></figure><ul><li><code>-c</code> 的意思是 Create（创建）。</li><li>再输入 <code>git branch</code>，发现星号跑到了 <code>feature/cart-test</code> 前面。</li></ul><p><strong>第三步：在新分支上修改代码</strong></p><ol><li><p>新建一个文件 <code>cart_test.py</code>。</p></li><li><p>输入内容：<code>print(&quot;Testing shopping cart...&quot;)</code>。</p></li><li><p>提交它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add cart_test.py<br>git commit -m <span class="hljs-string">&quot;Add shopping cart test case&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>第四步：见证“平行宇宙”的隔离性</strong></p><p>现在关键来了！切回主分支看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch master  <span class="hljs-comment"># (或者 main，根据第一步看到的来)</span><br></code></pre></td></tr></table></figure><ul><li><strong>动作：</strong> 此时请去你的文件夹里看一眼，或者输入 <code>ls</code>。</li><li><strong>现象：</strong> 那个 <code>cart_test.py</code> <strong>消失了</strong>！</li><li><strong>原因：</strong> 那个文件只存在于 <code>feature/cart-test</code> 这个平行宇宙里，主宇宙（Master）完全不知道它的存在。这就是分支隔离。</li></ul><p><strong>第五步：合并分支（Merge）</strong></p><p>假设在 feature&#x2F;cart-test 里测试通过了，要把成果合并回主分支。</p><ul><li><strong>前提：</strong> 必须先切回想“接收”改动的分支（通常是 master&#x2F;main）</li></ul><p>执行合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge feature/cart-test<br></code></pre></td></tr></table></figure><ul><li>现在，<code>cart_test.py</code> 就会出现在 master 分支里了。</li></ul><p><strong>第六步：删除分支</strong></p><p>功能上线了，这个分支使命结束，可以删掉清理垃圾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d feature/cart-test<br></code></pre></td></tr></table></figure><hr><p>问：<strong>“Git 里的 HEAD 指针是什么？”</strong></p><p>答：</p><blockquote><p>“HEAD 就是一个指向当前光标的指针。当切换分支（checkout&#x2F;switch）时，HEAD 就指到了那个分支的最新一次提交上。所有的 commit 操作，都是基于 HEAD 当前的位置继续向前走的。”</p></blockquote><hr><h1 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h1><h2 id="远程仓库的核心命令（概念与流程）"><a href="#远程仓库的核心命令（概念与流程）" class="headerlink" title="远程仓库的核心命令（概念与流程）"></a>远程仓库的核心命令（概念与流程）</h2><p>在团队里，不会每个人都只在自己电脑上保存代码，而是有一个<strong>中央仓库</strong>（Remote Repository），通常托管在 GitHub 或 GitLab 上。</p><ol><li><strong><code>git clone &lt;url&gt;</code></strong><ul><li><strong>场景：</strong> 入职第一天。</li><li><strong>作用：</strong> 把远程的代码完整地下载到本地电脑，生成一个文件夹。</li></ul></li><li><strong><code>git pull</code></strong><ul><li><strong>场景：</strong> 每天早上开工前。</li><li><strong>作用：</strong> 把同事们昨天写的代码拉取下来，同步到本地，保持最新。</li><li><em>口诀：Pull &#x3D; Download + Merge</em></li></ul></li><li><strong><code>git push</code></strong><ul><li><strong>场景：</strong> 写完了测试脚本，在本地 commit 过了。</li><li><strong>作用：</strong> 把你的提交推送到远程服务器，这样导师和同事才能看到你的代码。</li></ul></li></ol><blockquote><p>如果push 失败，通常是因为同事刚更新了代码，而自己本地不是最新的。</p><p>原则：先 pull（同步最新），再 push（推送自己）。</p></blockquote><hr><h2 id="解决冲突-Merge-Conflict"><a href="#解决冲突-Merge-Conflict" class="headerlink" title="解决冲突 (Merge Conflict)"></a>解决冲突 (Merge Conflict)</h2><p><strong>冲突的本质：</strong> 两个人（或者两个分支）修改了<strong>同一个文件的同一行代码</strong>，Git 懵了，不知道该听谁的，于是把烂摊子扔给你来决定。</p><h3 id="1-制造冲突"><a href="#1-制造冲突" class="headerlink" title="1. 制造冲突"></a>1. 制造冲突</h3><p>制造一个场景：两个分支都改了同一行代码。</p><ul><li><p><strong>Step 1:</strong> 在 <code>master</code> 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch master<br></code></pre></td></tr></table></figure></li><li><p><strong>Step 2:</strong> 创建并切换到新分支 <code>feature/a</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -c feature/a<br></code></pre></td></tr></table></figure></li><li><p><strong>Step 3:</strong> 修改 <code>test_login.py</code> 的第一行。</p><ul><li><p>改为：<code>print(&quot;User Login: V1&quot;)</code></p></li><li><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test_login.py<br>git commit -m <span class="hljs-string">&quot;Update login to V1&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Step 4:</strong> <strong>切回 master，再创建另一个分支 <code>feature/b</code>。</strong> (注意：是从 master 切出来的，所以它还没有 V1 的改动)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch master<br>git switch -c feature/b<br></code></pre></td></tr></table></figure></li><li><p><strong>Step 5:</strong> 修改 <code>test_login.py</code> 的<strong>同一行（第一行）</strong>。</p><ul><li><p>改为：<code>print(&quot;User Login: V2&quot;)</code> </p></li><li><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test_login.py<br>git commit -m <span class="hljs-string">&quot;Update login to V2&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-引爆冲突"><a href="#2-引爆冲突" class="headerlink" title="2. 引爆冲突"></a>2. 引爆冲突</h3><p>现在，<code>feature/a</code> 说是 V1，<code>feature/b</code> 说是 V2。Master 说：我要合并你们！</p><ul><li><p><strong>Step 6:</strong> 切回 master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch master<br></code></pre></td></tr></table></figure></li><li><p><strong>Step 7:</strong> 合并分支 A（这一步会顺利成功）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge feature/a<br></code></pre></td></tr></table></figure></li><li><p><strong>Step 8:</strong> 合并分支 B（<strong>BOOM! 💥 冲突出现</strong>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge feature/b<br></code></pre></td></tr></table></figure><ul><li>看到类似这样的提示：<code>CONFLICT (content): Merge conflict in test_login.py</code>。</li><li>Git ：自动合并失败，请手动修复。</li></ul></li></ul><h3 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h3><p>现在输入 <code>git status</code>，会看到 <code>test_login.py</code> 处于 <code>both modified</code> 状态。</p><p><strong>Step 9: 打开代码编辑器，查看 test_login.py</strong>。</p><p>会看到 Git 给你留下的“记号”，长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;User Login: V1&quot;</span>)<br>=======<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;User Login: V2&quot;</span>)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/b<br></code></pre></td></tr></table></figure><ul><li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 到 <code>=======</code> 之间：是当前（Master&#x2F;A）的代码。</li><li><code>=======</code> 到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/b</code> 之间：是要合并进来（B）的代码。</li></ul><p><strong>Step 10: 手动修改代码</strong></p><p>需要做决策。假设觉得 V2 才是对的，或者是要保留两者的逻辑。总之要手动解决</p><p>操作： 删除那些 &lt;&lt;&lt;, &#x3D;&#x3D;&#x3D;, &gt;&gt;&gt; 符号，只保留你想要的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;User Login: V2&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Step 11:</strong> <strong>标记解决并提交。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test_login.py  <span class="hljs-comment"># 告诉 Git：我改好了</span><br>git commit -m <span class="hljs-string">&quot;Fix merge conflict between feature A and B&quot;</span><br></code></pre></td></tr></table></figure><hr><h1 id="IDE中使用Git"><a href="#IDE中使用Git" class="headerlink" title="IDE中使用Git"></a>IDE中使用Git</h1><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p><strong>适用场景：</strong> Python 脚本、前端测试、轻量级项目。VS Code 的 Git 功能是开箱即用的，集成在左侧侧边栏。</p><ul><li><p>查看状态 (git status)：</p><p>点击左侧的 “源代码管理” (Source Control) 图标（看起来像个树杈）。这里会列出所有 Changes（修改过的文件）。</p><ul><li><strong>M</strong>: Modified (修改)</li><li><strong>U</strong>: Untracked (未追踪&#x2F;新建)</li><li><strong>D</strong>: Deleted (删除)</li></ul></li><li><p><strong>暂存与提交 (<code>git add</code> &amp; <code>git commit</code>)</strong>：</p><ol><li>鼠标悬停在文件名上，点击 <strong><code>+</code> 号</strong> &#x3D; <code>git add</code> (放入暂存区)。</li><li>在上方的输入框写 Commit Message。</li><li>点击输入框上方的 <strong><code>Commit</code> (提交)</strong> 按钮（或者按 <code>Cmd/Ctrl + Enter</code>）。</li></ol></li><li><p>同步 (git pull &amp; git push)：</p><p>VS Code 极其贴心，提交后，左下角会显示一个 “Sync Changes” (同步更改) 按钮（或者在左侧菜单里是个刷新图标）。点击它，VS Code 会自动先 Pull 再 Push。</p></li><li><p>分支切换 (git switch)：</p><p>看窗口左下角。那里显示着当前分支名（如 main）。点击它屏幕顶部会弹出一个列表，让选择或创建新分支。</p></li></ul><hr><h3 id="PyCharm-IDEA"><a href="#PyCharm-IDEA" class="headerlink" title="PyCharm &#x2F; IDEA"></a>PyCharm &#x2F; IDEA</h3><p>适用场景： 大型自动化测试框架、Java&#x2F;Spring Boot 项目。JetBrains 的 Git 功能非常强大，尤其是“对比差异”和“解决冲突”的界面。</p><ul><li><p>提交窗口 (add &amp; commit)：</p><p>默认在左侧有一个 Commit 标签页（或者按 Cmd&#x2F;Ctrl + K 唤起）。</p><ul><li>它用<strong>复选框 (Checkbox)</strong> 代替了 <code>git add</code>。勾选文件 &#x3D; 放入暂存区。</li><li>在下方写 Message，然后点右下角的 <strong>Commit</strong> 按钮。</li><li><strong>技巧：</strong> 按钮旁边有个箭头，点开可以选择 <strong>Commit and Push</strong>，一步到位。</li></ul></li><li><p>拉取与推送 (pull &amp; push)：</p><p>右上角通常有一组 Git 按钮：</p><ul><li>↙️ (蓝色箭头向下)：<strong>Update Project</strong> (相当于 <code>git pull</code>)。</li><li>↗️ (绿色箭头向上)：<strong>Push</strong>。</li></ul></li><li><p>分支管理：</p><p>看窗口右下角（或者顶部导航栏右侧）。显示分支名，点击它会弹出一个强大的菜单，可以新建分支、Merge、Rebase 等。</p></li></ul><hr><h3 id="可视化解决冲突"><a href="#可视化解决冲突" class="headerlink" title="可视化解决冲突"></a>可视化解决冲突</h3><p>在命令行里看到的 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 那些乱七八糟的符号，在 IDE 里，再也不用看那些了。当发生冲突时，IDE 会弹出一个 <strong>“Resolve Conflicts”</strong> 窗口。</p><p><strong>三栏视图 (3-Way Merge)：</strong></p><ul><li><strong>左边：</strong> 自己的代码。</li><li><strong>右边：</strong> 传入的代码 (Their Changes &#x2F; From Server)。</li><li><strong>中间：</strong> 最终结果 (Result)。</li></ul><p>只需要看着中间的结果栏。</p><ul><li>想要左边的？点击左边的 <code>&gt;&gt;</code> 箭头。</li><li>想要右边的？点击右边的 <code>&lt;&lt;</code> 箭头。</li><li>都不想要？直接在中间那栏手动打字修改。</li><li>改完点 <strong>Apply</strong>，IDE 帮你自动生成 <code>git add</code> 和 <code>git commit</code>。</li></ul><hr><h1 id="回滚与查错"><a href="#回滚与查错" class="headerlink" title="回滚与查错"></a>回滚与查错</h1><p>问：“假如自动测试突然挂了，但不知道是哪次提交导致的，怎么办？” 或者 “写到一半需要去修别的 Bug 怎么办？”</p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>场景：正在写一个复杂的测试脚本，才写了一半，代码乱糟糟的根本没法提交（commit）。</p><p>突然，老板跑过来说：“线上有个紧急 Bug，快切分支去复现一下！”</p><ul><li><strong>错误做法：</strong> <code>commit</code> 一个半成品（比如 message 写“没写完”），污染提交历史。</li><li><strong>正确做法：</strong> 使用 <code>git stash</code> 把当前工作“藏起来”。</li></ul><p><strong>操作流程：</strong></p><ol><li><p><strong>暂存现场：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><ul><li>执行完后，用 <code>git status</code> 看，工作区变干净了！修改被 Git 存到了一个临时堆栈里。</li></ul></li><li><p>去干别的事：</p><p>此时可以放心地 git switch 去别的分支修 Bug。</p></li><li><p>恢复现场：</p><p>Bug 修完了，切回原来的分支，把刚才藏起来的代码拿回来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop<br></code></pre></td></tr></table></figure><ul><li><code>pop</code> 的意思是“弹出并恢复”，你的代码又回来了，接着写！</li></ul></li></ol><blockquote><p><strong>IDE 操作：</strong> 在 PyCharm&#x2F;VS Code 里通常叫 “Stash Changes” (存) 和 “Unstash&#x2F;Pop Changes” (取)。</p></blockquote><hr><h2 id="git-reset和git-revert"><a href="#git-reset和git-revert" class="headerlink" title="git reset和git revert"></a>git reset和git revert</h2><p>场景：提交了一个版本，结果发现把环境配错了，或者代码有重大逻辑漏洞。需要“撤销”它。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><ul><li><p><strong>作用：</strong> 彻底删除历史，回到过去。</p></li><li><p><strong>场景：</strong> 只有自己一个人在开发的<strong>本地分支</strong>，且代码还没 push 给别人。</p></li><li><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><ul><li><code>HEAD^</code> 表示上一个版本。</li><li><code>--hard</code> 表示<strong>强制</strong>，刚才写的代码会全部消失，<strong>找不回来的</strong>！</li></ul></li></ul><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a><code>git revert</code></h3><ul><li><p><strong>作用：</strong> 不删除历史，而是新增一个“反向提交”来抵消错误。</p></li><li><p><strong>场景：</strong> <strong>公共分支 (master&#x2F;main)</strong>，或者代码已经 push 出去了。</p></li><li><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;CommitID&gt;<br></code></pre></td></tr></table></figure><ul><li>Git 会自动生成一个新的 Commit，内容是把那次修改删掉。历史记录里会诚实地保留“我犯错了”和“我修正了”的记录。</li></ul></li></ul><hr><h2 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h2><p>场景：自动化测试每晚跑一次。</p><ul><li>周一：测试全部通过 ✅</li><li>周五：测试挂了 ❌</li></ul><p>这期间开发提交了 <strong>50 个 commit</strong>。是哪一个 commit 搞坏了代码？如果一个个 checkout 去试，天都黑了。Git 内置了<strong>二分查找算法</strong>来定位 Bug</p><p><strong>实战演练（逻辑篇）：</strong></p><ol><li><p><strong>启动捉虫模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect start<br></code></pre></td></tr></table></figure></li><li><p><strong>告诉 Git 现在的状态（坏的）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect bad  <span class="hljs-comment"># 表示当前版本是有 Bug 的</span><br></code></pre></td></tr></table></figure></li><li><p><strong>告诉 Git 过去的状态（好的）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect good &lt;CommitID_of_Monday&gt; <span class="hljs-comment"># 比如周一那个版本的 ID</span><br></code></pre></td></tr></table></figure></li><li><p>自动排查：Git 会自动计算中间点，跳到第 25 个 commit，然后问：“现在这个版本，Bug 还在吗？”</p><ul><li>需要跑一下测试。</li><li>如果<strong>还在</strong>：输入 <code>git bisect bad</code>（说明 Bug 在前半段）。</li><li>如果<strong>好了</strong>：输入 <code>git bisect good</code>（说明 Bug 在后半段）。</li></ul></li><li><p>循环往复：</p><p>Git 会不断缩小范围（25 -&gt; 12 -&gt; 6 -&gt; 3 -&gt; 1），最后告诉你：</p><blockquote><p><strong>“abc1234 is the first bad commit”</strong> (找到罪魁祸首了！)</p></blockquote></li><li><p><strong>结束捉虫：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect reset  <span class="hljs-comment"># 回到你最开始的地方</span><br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="CI-CD-与自动化流水线"><a href="#CI-CD-与自动化流水线" class="headerlink" title="CI&#x2F;CD 与自动化流水线"></a>CI&#x2F;CD 与自动化流水线</h1><p>“我不只写测试脚本，还配置了 CI 流水线，保证每次代码提交都能自动运行测试。”</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h3><p>有一个<strong>不知疲倦、24小时待命的机器人</strong>，名字叫“CI Server”（比如 Jenkins, GitLab CI, GitHub Actions）。它的工作很简单，但非常重要：</p><ol><li><strong>监听 (Listen)：</strong> 它死死盯着 Git 仓库。</li><li><strong>触发 (Trigger)：</strong> 一旦发现有人 <code>git push</code>（提交代码）或者提了 PR。</li><li><strong>执行 (Execute)：</strong> 它立马把代码下载下来，在它的电脑上自动安装环境，自动运行写的 <code>pytest</code> 脚本。</li><li><strong>报告 (Report)：</strong><ul><li>如果代码没问题：它给你打个 ✅。</li><li>如果代码有 Bug（测试挂了）：它给你打个 ❌，并直接通知。</li></ul></li></ol><p><strong>这就叫 CI (Continuous Integration - 持续集成)。</strong> 它的核心目的是：<strong>尽早发现 Bug</strong>。</p><hr><h3 id="用-GitHub-Actions-搭建第一条流水线"><a href="#用-GitHub-Actions-搭建第一条流水线" class="headerlink" title="用 GitHub Actions 搭建第一条流水线"></a>用 GitHub Actions 搭建第一条流水线</h3><p>因为我们不需要自己搭服务器，<strong>GitHub Actions</strong> 是最容易上手的工具，且完全免费。现在的目标是：<strong>只要把代码推送到 GitHub，GitHub 就自动运行测试。</strong></p><h4 id="第一步：准备“机器人指令书”"><a href="#第一步：准备“机器人指令书”" class="headerlink" title="第一步：准备“机器人指令书”"></a>第一步：准备“机器人指令书”</h4><p>机器人是很笨的，必须把指令写在一个 <strong>YAML 文件</strong> 里告诉它怎么做。</p><ol><li>在你的项目根目录下，创建两层文件夹：<code>.github/workflows</code><ul><li>注意：<code>.github</code> 前面有个点。</li></ul></li><li>在这个文件夹里新建一个文件，比如叫 <code>test_pipeline.yml</code>。</li></ol><h4 id="第二步：编写指令-YAML"><a href="#第二步：编写指令-YAML" class="headerlink" title="第二步：编写指令 (YAML)"></a>第二步：编写指令 (YAML)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Automated</span> <span class="hljs-string">Testing</span> <span class="hljs-string">Demo</span>  <span class="hljs-comment"># 流水线的名字</span><br><br><span class="hljs-comment"># 1. 什么时候干活？(Trigger)</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;main&quot;</span> ]  <span class="hljs-comment"># 当有人 push 到 master 或 main 分支时</span><br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;main&quot;</span> ]  <span class="hljs-comment"># 当有人提 PR 到这些分支时</span><br><br><span class="hljs-comment"># 2. 干什么活？(Jobs)</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">test-job:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>  <span class="hljs-comment"># 指定运行环境：给我分配一台最新的 Ubuntu 虚拟机</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-comment"># 第一步：把代码从仓库里拉取下来</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>    <span class="hljs-comment"># 第二步：安装 Python 环境</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Python</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-python@v4</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">python-version:</span> <span class="hljs-string">&quot;3.9&quot;</span><br><br>    <span class="hljs-comment"># 第三步：安装依赖 (比如 pytest)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        pip install pytest</span><br><span class="hljs-string"></span><br>    <span class="hljs-comment"># 第四步：正式运行测试</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">Tests</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">pytest</span>  <span class="hljs-comment"># 执行这一行命令</span><br></code></pre></td></tr></table></figure><blockquote><p>💡 测开视角：这其实就是把平时在本地终端里手动敲的命令（git pull, pip install, pytest），翻译成列表告诉服务器去自动执行。</p></blockquote><h4 id="第三步：推送到-GitHub"><a href="#第三步：推送到-GitHub" class="headerlink" title="第三步：推送到 GitHub"></a>第三步：推送到 GitHub</h4><ol><li><p>把这个新文件提交并推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .github/workflows/test_pipeline.yml<br>git commit -m <span class="hljs-string">&quot;Add CI pipeline&quot;</span><br>git push<br></code></pre></td></tr></table></figure></li></ol><h4 id="第四步：见证奇迹"><a href="#第四步：见证奇迹" class="headerlink" title="第四步：见证奇迹"></a>第四步：见证奇迹</h4><ol><li>打开你的 GitHub 仓库页面。</li><li>点击顶部的 <strong>“Actions”</strong> 标签。</li><li>会看到一个正在旋转的圆圈或者 ✅。<ul><li>点进去，能看到详细的日志。GitHub 给你分配了一台虚拟电脑，正在一行行执行命令。</li></ul></li></ol><hr><h3 id="它怎么“挡住”Bug"><a href="#它怎么“挡住”Bug" class="headerlink" title="它怎么“挡住”Bug"></a>它怎么“挡住”Bug</h3><p>模拟一次**“拦截事故”**。</p><ol><li><strong>修改本地代码：</strong> 故意把测试脚本改坏。<ul><li>比如在 <code>test_login.py</code> 里写一个肯定报错的断言：<code>assert 1 == 2</code>。</li></ul></li><li><strong>推送代码：</strong> <code>git push</code>。</li><li><strong>观察 GitHub Actions：</strong><ul><li>几秒钟后，会发现 Actions 变成了一个 <strong>红色的 ❌ (Failure)</strong>。</li><li>GitHub 会发邮件告诉你构建失败了。</li></ul></li></ol><p>在公司里的实际应用：通常会设置**“保护分支” (Branch Protection)。如果 CI 流水线是红色的（测试没过），GitLab&#x2F;GitHub 会禁止**你把代码合并进 master 分支。必须先把测试修好。</p><p>这就是测开存在的意义：<strong>代码质量的守门员。</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础命令</tag>
      
      <tag>Git</tag>
      
      <tag>远程仓库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL基础学习</title>
    <link href="/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>PostgreSQL 的结构和 MySQL 有一个<strong>巨大的区别</strong>。</p><ul><li><strong>MySQL:</strong> 实例 -&gt; 数据库 (Database) -&gt; 表 (Table)</li><li><strong>PostgreSQL:</strong> 实例 -&gt; 数据库 (Database) -&gt; <strong>模式 (Schema)</strong> -&gt; 表 (Table)</li></ul><blockquote><p> 在 PG 中，默认的模式叫做 <code>public</code>。当写 <code>SELECT * FROM users</code> 时，其实 PG 默认帮你补全成了 <code>SELECT * FROM public.users</code>。在多租户系统测试中，可能会遇到不同的 Schema 代表不同的租户。</p></blockquote><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SCHEMA</span> automated_testing;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> automated_testing.users (<br>    id <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>,  <span class="hljs-comment">-- SERIAL 相当于自增 ID</span><br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    config <span class="hljs-type">JSONB</span>            <span class="hljs-comment">-- 注意：这里用了 PG 特有的 JSONB 类型</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> automated_testing.users (username, config)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;tester_01&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;theme&quot;: &quot;dark&quot;, &quot;notifications&quot;: true&#125;&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> automated_testing.users;<br></code></pre></td></tr></table></figure><p><strong>数据类型支持</strong>：PG 对 JSON 的支持非常强大（JSONB），可以直接索引 JSON 内部字段，这在测试存储复杂配置（如上述 <code>config</code> 字段）时非常方便，而 MySQL 相对较弱。</p><p><strong>标准兼容性</strong>：PG 更符合 SQL 标准，支持更复杂的数据查询。</p><p><strong>层级结构</strong>：PG 多了一层 Schema，适合做多租户隔离测试。</p><hr><h1 id="DQL与DML"><a href="#DQL与DML" class="headerlink" title="DQL与DML"></a>DQL与DML</h1><h2 id="引号与大小写"><a href="#引号与大小写" class="headerlink" title="引号与大小写"></a>引号与大小写</h2><table><thead><tr><th align="center"><strong>特性</strong></th><th align="center"><strong>MySQL</strong></th><th align="center"><strong>PostgreSQL (PG)</strong></th><th align="center"><strong>测开避坑指南</strong></th></tr></thead><tbody><tr><td align="center"><strong>字符串引号</strong></td><td align="center">单引号 <code>&#39;</code> 或 双引号 <code>&quot;</code> 都可以</td><td align="center"><strong>严格只认单引号 <code>&#39;</code></strong></td><td align="center">写值（Value）时，<strong>永远只用单引号</strong>！ 例如 <code>WHERE name = &#39;Alice&#39;</code></td></tr><tr><td align="center"><strong>别名&#x2F;列名</strong></td><td align="center">用反引号 &#96; (键盘左上角)</td><td align="center">用 <strong>双引号 <code>&quot;</code></strong></td><td align="center">只有当列名有大写或特殊字符时才需要双引号，一般可以不加。<strong>千万别在 PG 用反引号</strong>。</td></tr><tr><td align="center"><strong>布尔值</strong></td><td align="center">0 &#x2F; 1 (Tinyint)</td><td align="center"><code>TRUE</code> &#x2F; <code>FALSE</code> (‘t’&#x2F;‘f’)</td><td align="center">验证接口返回字段时，MySQL 返回可能是 1，PG 返回是 true。</td></tr><tr><td align="center"><strong>大小写敏感</strong></td><td align="center">默认不敏感 (比如查询 ‘admin’ 能查出 ‘Admin’)</td><td align="center"><strong>默认严格敏感</strong></td><td align="center">查 ‘Admin’ 必须写 ‘Admin’，写 ‘admin’ 查不到。</td></tr></tbody></table><hr><h2 id="DQL-数据查询-的主要区别"><a href="#DQL-数据查询-的主要区别" class="headerlink" title="DQL (数据查询) 的主要区别"></a>DQL (数据查询) 的主要区别</h2><h4 id="A-模糊查询-大小写问题"><a href="#A-模糊查询-大小写问题" class="headerlink" title="A. 模糊查询 (大小写问题)"></a>A. 模糊查询 (大小写问题)</h4><ul><li><strong>MySQL:</strong> <code>LIKE</code> 默认不区分大小写。</li><li><strong>PG:</strong><ul><li><code>LIKE</code>: <strong>区分</strong>大小写。</li><li><code>ILIKE</code>: <strong>不区分</strong>大小写 (PostgreSQL 特有)。</li></ul></li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- PG 写法：想查 &#x27;Apple&#x27;，输入 &#x27;apple&#x27; 也能查到</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">ILIKE</span> <span class="hljs-string">&#x27;%apple%&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="B-字符串拼接"><a href="#B-字符串拼接" class="headerlink" title="B. 字符串拼接"></a>B. 字符串拼接</h4><ul><li><strong>MySQL:</strong> <code>CONCAT(a, b)</code></li><li><strong>PG:</strong> 使用双竖线 <code>||</code> (这是标准 SQL 写法) 或 <code>CONCAT</code>。</li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- PG 写法</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> || <span class="hljs-string">&#x27; - &#x27;</span> || <span class="hljs-keyword">role</span> <span class="hljs-keyword">FROM</span> interns;<br></code></pre></td></tr></table></figure><h4 id="C-分页-Limit"><a href="#C-分页-Limit" class="headerlink" title="C. 分页 (Limit)"></a>C. 分页 (Limit)</h4><ul><li><strong>MySQL:</strong> 支持 <code>LIMIT 0, 10</code> 这种非标准写法。</li><li><strong>PG:</strong> 不支持逗号写法，必须写全。</li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- PG 必须这样写</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> interns <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="DML-增删改-的主要区别"><a href="#DML-增删改-的主要区别" class="headerlink" title="DML (增删改) 的主要区别"></a>DML (增删改) 的主要区别</h2><h4 id="A-插入-更新后的返回值-RETURNING"><a href="#A-插入-更新后的返回值-RETURNING" class="headerlink" title="A. 插入&#x2F;更新后的返回值 (RETURNING)"></a>A. 插入&#x2F;更新后的返回值 (RETURNING)</h4><ul><li><strong>MySQL:</strong> 只能拿 ID，通常要再次查询才能看到某些默认值（如 create_time）。</li><li><strong>PG:</strong> <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 后面都可以接 <code>RETURNING *</code>，直接把受影响的行返回。</li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- PG 写法：删掉数据的同时，看看删的是谁</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> interns <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span> <span class="hljs-keyword">RETURNING</span> <span class="hljs-type">name</span>, status;<br></code></pre></td></tr></table></figure><h4 id="B-冲突处理"><a href="#B-冲突处理" class="headerlink" title="B. 冲突处理"></a>B. 冲突处理</h4><p>当“如果存在则更新，不存在则插入”时：</p><ul><li><strong>MySQL:</strong> <code>ON DUPLICATE KEY UPDATE ...</code></li><li><strong>PG:</strong> <code>ON CONFLICT (字段名) DO UPDATE ...</code></li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- PG 写法：如果 id 冲突，就什么都不做 (DO NOTHING)</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> interns (id, <span class="hljs-type">name</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Test&#x27;</span>) <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONFLICT</span> (id) <span class="hljs-keyword">DO</span> <span class="hljs-keyword">NOTHING</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>功能</strong></th><th><strong>MySQL 写法</strong></th><th><strong>PostgreSQL 写法</strong></th></tr></thead><tbody><tr><td><strong>获取刚插入的ID</strong></td><td><code>SELECT LAST_INSERT_ID();</code></td><td><code>INSERT ... RETURNING id;</code></td></tr><tr><td><strong>强制类型转换</strong></td><td><code>CAST(val AS CHAR)</code></td><td><code>val::text</code> (双冒号是 PG 的语法糖，超好用)</td></tr><tr><td><strong>正则查询</strong></td><td><code>REGEXP</code></td><td><code>~</code> (例如 <code>WHERE name ~ &#39;^[A-Z]&#39;</code>)</td></tr><tr><td><strong>当前时间</strong></td><td><code>NOW()</code> 或 <code>SYSDATE()</code></td><td><code>NOW()</code> 或 <code>CURRENT_TIMESTAMP</code></td></tr></tbody></table><ol><li><strong>构造数据脚本时</strong>：如果你在 Python 里写 SQL 构造测试数据，记得<strong>字符串全用单引号</strong>，否则代码在 PG 环境会直接报错。</li><li><strong>断言验证时</strong>：如果你在做搜索功能的自动化测试，要注意 PG 的搜索默认是<strong>区分大小写</strong>的。如果开发用的 PG 但没做处理，你搜 “test” 查不到 “Test”，这就是一个 Bug（或者特性）。</li><li><strong>使用 <code>::</code> 转换</strong>：在验证数据时，PG 的 JSONB 取出来有时需要转成文本对比，会经常用到 <code>字段::text</code> 这种写法。</li></ol><hr><h1 id="JSONB"><a href="#JSONB" class="headerlink" title="JSONB"></a>JSONB</h1><p>PG 有两种 JSON 类型：</p><ol><li><code>JSON</code>: 仅仅是把你的 JSON 当作<strong>纯文本</strong>存进去，读取时要重新解析，慢。</li><li><strong><code>JSONB</code> (Binary)</strong>: 存进去时就变成了<strong>二进制格式</strong>，去掉了空格，重新排了序。<strong>它的读取速度极快，且支持索引。</strong></li></ol><blockquote><p><strong>测开笔记：</strong> 只要涉及“存 JSON”，<strong>无脑选 JSONB</strong>。在测试验证时，绝大多数时候也是针对 JSONB 字段进行查询。</p></blockquote><hr><p>假设正在开发一个<strong>自动化测试平台</strong>，需要把每次 API 请求的响应体（Response Body）存到数据库里，方便后续分析。</p><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> api_logs;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> api_logs (<br>    id <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>    api_path <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    response_body <span class="hljs-type">JSONB</span>,  <span class="hljs-comment">-- 关键：存储 API 的响应结果</span><br>    tags <span class="hljs-type">TEXT</span>[]           <span class="hljs-comment">-- 关键：PostgreSQL 特有的数组类型，用来存标签</span><br>);<br></code></pre></td></tr></table></figure><h2 id="插入模拟数据"><a href="#插入模拟数据" class="headerlink" title="插入模拟数据"></a>插入模拟数据</h2><p>注意看 <code>response_body</code> 的结构，以及 <code>tags</code> 数组的写法（用花括号 <code>&#123;&#125;</code> 包裹）。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> api_logs (api_path, response_body, tags) <span class="hljs-keyword">VALUES</span> <br>(<br>    <span class="hljs-string">&#x27;/login&#x27;</span>, <br>    <span class="hljs-string">&#x27;&#123;&quot;code&quot;: 200, &quot;data&quot;: &#123;&quot;userId&quot;: 101, &quot;token&quot;: &quot;xyz_123&quot;, &quot;roles&quot;: [&quot;admin&quot;, &quot;tester&quot;]&#125;, &quot;msg&quot;: &quot;success&quot;&#125;&#x27;</span>,<br>    <span class="hljs-string">&#x27;&#123;&quot;smoke_test&quot;, &quot;critical&quot;&#125;&#x27;</span> <span class="hljs-comment">-- 数组写法</span><br>),<br>(<br>    <span class="hljs-string">&#x27;/user/info&#x27;</span>, <br>    <span class="hljs-string">&#x27;&#123;&quot;code&quot;: 403, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;permission denied&quot;, &quot;error_id&quot;: &quot;ERR_001&quot;&#125;&#x27;</span>,<br>    <span class="hljs-string">&#x27;&#123;&quot;regression&quot;, &quot;bug_fix&quot;&#125;&#x27;</span><br>);<br></code></pre></td></tr></table></figure><hr><h3 id="如何提取-JSON-里的字段"><a href="#如何提取-JSON-里的字段" class="headerlink" title="如何提取 JSON 里的字段"></a>如何提取 JSON 里的字段</h3><p>区分这两个操作符：</p><ul><li><strong><code>-&gt;</code></strong> (单箭头)：获取的是 <strong>JSON 对象</strong> (依旧是 JSON 格式，带引号)。</li><li><strong><code>-&gt;&gt;</code></strong> (双箭头)：获取的是 <strong>文本 (Text)</strong> (不带引号，适合做断言对比)。</li></ul><h4 id="场景-A：验证登录接口返回的-code-是不是-200"><a href="#场景-A：验证登录接口返回的-code-是不是-200" class="headerlink" title="场景 A：验证登录接口返回的 code 是不是 200"></a>场景 A：验证登录接口返回的 <code>code</code> 是不是 200</h4><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- 错误写法 (类型不匹配)</span><br><span class="hljs-comment">-- SELECT * FROM api_logs WHERE response_body-&gt;&#x27;code&#x27; = 200; </span><br><span class="hljs-comment">-- 报错：因为左边是 json 类型，右边是 integer</span><br><br><span class="hljs-comment">-- 正确写法 1：转成文本对比</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> api_logs <br><span class="hljs-keyword">WHERE</span> response_body-&gt;&gt;<span class="hljs-string">&#x27;code&#x27;</span> = <span class="hljs-string">&#x27;200&#x27;</span>;<br><br><span class="hljs-comment">-- 正确写法 2：强转成数字对比 (推荐，性能更好)</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> api_logs <br><span class="hljs-keyword">WHERE</span> (response_body-&gt;&gt;<span class="hljs-string">&#x27;code&#x27;</span>)::<span class="hljs-type">int</span> = <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><h4 id="提取深层嵌套的-token"><a href="#提取深层嵌套的-token" class="headerlink" title="提取深层嵌套的 token"></a>提取深层嵌套的 <code>token</code></h4><p>数据结构：<code>response_body</code> -&gt; <code>data</code> -&gt; <code>token</code></p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- 链式提取：先用 -&gt; 拿 data 对象，再用 -&gt;&gt; 拿 token 文本</span><br><span class="hljs-keyword">SELECT</span> <br>    api_path, <br>    response_body-&gt;<span class="hljs-string">&#x27;data&#x27;</span>-&gt;&gt;<span class="hljs-string">&#x27;token&#x27;</span> <span class="hljs-keyword">as</span> user_token<br><span class="hljs-keyword">FROM</span> api_logs<br><span class="hljs-keyword">WHERE</span> api_path = <span class="hljs-string">&#x27;/login&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="JSON-包含查询"><a href="#JSON-包含查询" class="headerlink" title="JSON 包含查询 (@&gt;)"></a>JSON 包含查询 (<code>@&gt;</code>)</h3><p>如果想验证：“返回结果里是否包含 <code>&#123;&quot;msg&quot;: &quot;success&quot;&#125;</code>？”，不需要一个个字段拆开查，直接用 <strong>包含操作符 <code>@&gt;</code></strong>。这是 PG 相比 MySQL 极其方便的一点。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- 查找所有响应体里包含 &quot;msg&quot;: &quot;success&quot; 的记录</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> api_logs <br><span class="hljs-keyword">WHERE</span> response_body @&gt; <span class="hljs-string">&#x27;&#123;&quot;msg&quot;: &quot;success&quot;&#125;&#x27;</span>;<br><br><span class="hljs-comment">-- 甚至可以查嵌套数组：查找 roles 里包含 &quot;admin&quot; 的用户</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> api_logs <br><span class="hljs-keyword">WHERE</span> response_body-&gt;<span class="hljs-string">&#x27;data&#x27;</span>-&gt;<span class="hljs-string">&#x27;roles&#x27;</span> @&gt; <span class="hljs-string">&#x27;[&quot;admin&quot;]&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="数组类型-Array-的操作"><a href="#数组类型-Array-的操作" class="headerlink" title="数组类型 (Array) 的操作"></a>数组类型 (Array) 的操作</h3><p>PG 允许直接定义 <code>TEXT[]</code> 或 <code>INT[]</code>，这在给测试用例打标签（Tags）时非常有用。</p><p>查找包含 “smoke_test” (冒烟测试) 标签的日志。不要用 <code>LIKE</code>，用 PG 专用的数组语法 <code>ANY</code>。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">-- 语法含义：&#x27;smoke_test&#x27; 是否等于 tags 数组里的 任意(ANY) 一个元素？</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> api_logs <br><span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;smoke_test&#x27;</span> = <span class="hljs-keyword">ANY</span>(tags);<br></code></pre></td></tr></table></figure><p>注意-PostgreSQL 处理 JSON 的机制：</p><ol><li>当试图去取一个<strong>不存在的键</strong>（比如 <code>amout</code>）时，PG 不会报错，而是返回 <strong><code>NULL</code></strong>。</li><li>然后 <code>NULL</code> 被转换成浮点数（<code>NULL::float</code>）依然是 <code>NULL</code>。</li><li>最后 <code>NULL &gt; 50</code> 的结果是 <strong><code>NULL</code></strong>（既不是 True 也不是 False）。</li></ol><blockquote><p>所以在写自动化校验脚本时，如果发现断言失败或者查不到数据，<strong>第一件事先检查 JSON 的 Key 有没有拼错</strong>，因为 PG 默认不会抛出异常提醒。</p></blockquote><hr><h1 id="psycopg2"><a href="#psycopg2" class="headerlink" title="psycopg2"></a>psycopg2</h1><p>使用 Python 的PG 驱动库 <code>psycopg2</code> 来连接数据库。</p><p>在 PostgreSQL + psycopg2 中，数据库里的 JSONB 类型会自动转换成 Python 的字典 (Dict)！ 这一步能省掉你无数的解析代码。</p><p>写一段 Python 代码，模拟一个完整的**“造数据 -&gt; 查数据 -&gt; 验证 JSON -&gt; 清理”**的测试闭环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> psycopg2<br><span class="hljs-keyword">from</span> psycopg2.extras <span class="hljs-keyword">import</span> RealDictCursor<br><span class="hljs-keyword">import</span> json<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_api_log_verification</span>():<br>    <span class="hljs-comment"># 1. 建立连接</span><br>    <span class="hljs-comment"># 请根据你 Docker 启动时的设置修改密码</span><br>    conn = psycopg2.connect(<br>        host=<span class="hljs-string">&quot;localhost&quot;</span>,<br>        port=<span class="hljs-string">&quot;5432&quot;</span>,<br>        database=<span class="hljs-string">&quot;test_db&quot;</span>,<br>        user=<span class="hljs-string">&quot;postgres&quot;</span>,<br>        password=<span class="hljs-string">&quot;123456&quot;</span><br>    )<br><br>    <span class="hljs-comment"># 自动提交设为 False，模拟事务控制</span><br>    conn.autocommit = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 2. 获取游标 (RealDictCursor 可以让结果变成字典，而不是元组)</span><br>        cur = conn.cursor(cursor_factory=RealDictCursor)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🚀 [Setup] 正在插入测试数据...&quot;</span>)<br><br>        <span class="hljs-comment"># 构造一个复杂的 JSON 数据</span><br>        test_response = &#123;<br>            <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>,<br>            <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">9527</span>,<br>                <span class="hljs-string">&quot;vip_level&quot;</span>: <span class="hljs-string">&quot;gold&quot;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"># 这里的 json.dumps 是为了把字典转成字符串存入 SQL</span><br>        insert_sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            INSERT INTO automated_testing.api_logs (api_path, response_body, tags) </span><br><span class="hljs-string">            VALUES (%s, %s, %s) </span><br><span class="hljs-string">            RETURNING id;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cur.execute(insert_sql, (<span class="hljs-string">&#x27;/vip/buy&#x27;</span>, json.dumps(test_response), [<span class="hljs-string">&#x27;payment&#x27;</span>, <span class="hljs-string">&#x27;vip&#x27;</span>]))<br><br>        <span class="hljs-comment"># 获取刚插入的 ID</span><br>        new_id = cur.fetchone()[<span class="hljs-string">&#x27;id&#x27;</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 数据插入成功，ID: <span class="hljs-subst">&#123;new_id&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># ----------------------------------------</span><br>        <span class="hljs-comment"># 3. [Verify] 验证阶段</span><br>        <span class="hljs-comment"># ----------------------------------------</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🔍 [Verify] 正在查询并验证 JSON 字段...&quot;</span>)<br><br>        <span class="hljs-comment"># 注意：这里我们演示直接用 SQL 查 JSON 内部字段</span><br>        <span class="hljs-comment"># 需求：找出 vip_level 是 gold 的记录</span><br>        query_sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            SELECT response_body </span><br><span class="hljs-string">            FROM automated_testing.api_logs </span><br><span class="hljs-string">            WHERE id = %s </span><br><span class="hljs-string">            AND response_body-&gt;&#x27;data&#x27;-&gt;&gt;&#x27;vip_level&#x27; = &#x27;gold&#x27;;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cur.execute(query_sql, (new_id,))<br>        result = cur.fetchone()<br><br>        <span class="hljs-comment"># 4. [Assert] 断言</span><br>        <span class="hljs-keyword">if</span> result:<br>            <span class="hljs-comment"># 关键点：psycopg2 自动把 JSONB 转回了 Python 字典，不需要你手动 json.loads()</span><br>            body = result[<span class="hljs-string">&#x27;response_body&#x27;</span>]<br>            <span class="hljs-keyword">assert</span> body[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user_id&#x27;</span>] == <span class="hljs-number">9527</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🎉 测试通过！数据库验证逻辑正确。&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;自动转换的类型为:&quot;</span>, <span class="hljs-built_in">type</span>(body))  <span class="hljs-comment"># 你会看到 &lt;class &#x27;dict&#x27;&gt;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 测试失败：未找到符合条件的数据&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 发生错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 5. [Teardown] 回滚事务</span><br>        <span class="hljs-comment"># 无论测试成功还是失败，都回滚，保证数据库干干净净</span><br>        conn.rollback()<br>        cur.close()<br>        conn.close()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🧹 [Teardown] 事务已回滚，数据已清理。&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    test_api_log_verification()<br></code></pre></td></tr></table></figure><hr><h1 id="pgvector"><a href="#pgvector" class="headerlink" title="pgvector"></a>pgvector</h1><p><strong>PGvector</strong> 是 PostgreSQL 数据库的一个扩展，专门用于在数据库中高效地存储、检索和查询<strong>向量数据（vector embeddings）</strong>。</p><ol><li><strong>存储向量</strong><br>支持多种维度的向量（通常是几十到几千维），这些向量通常来自 AI 模型（如文本、图像、音频的嵌入表示）。</li><li><strong>相似性搜索</strong><br>允许通过向量之间的<strong>距离计算</strong>（如欧氏距离、余弦相似度、内积）来查找最相似的向量。</li><li><strong>与 SQL 无缝集成</strong><br>因为它是 PostgreSQL 的扩展，所以可以直接在 SQL 语句中执行向量操作，结合关系型数据的查询，非常灵活。</li></ol><p>本地 Windows PostgreSQL 默认没有安装 <code>pgvector</code> 插件，编译安装比较麻烦。最快的方法是直接拉取一个<strong>已经装好插件的 Docker 镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意：将端口映射为 5433，避免和本地现有的 PG (5432) 冲突</span><br>docker run --name pgvector-test -e POSTGRES_PASSWORD=secret -p 5433:5432 -d pgvector/pgvector:pg16<br></code></pre></td></tr></table></figure><img src="/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="docker构建postgresql容器"><p>下面是结合硅基流动的嵌入模型BAAI&#x2F;bge-m3与pgvector测试向量存储的代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> psycopg2<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> psycopg2.extras <span class="hljs-keyword">import</span> RealDictCursor<br><br><span class="hljs-comment"># 硅基流动 API 配置</span><br>API_KEY = <span class="hljs-string">&quot;&lt;你的_SILICONFLOW_API_KEY&gt;&quot;</span>  <span class="hljs-comment"># 在这里填入 Key</span><br>API_URL = <span class="hljs-string">&quot;https://api.siliconflow.cn/v1/embeddings&quot;</span><br>MODEL_NAME = <span class="hljs-string">&quot;BAAI/bge-m3&quot;</span><br>EMBEDDING_DIM = <span class="hljs-number">1024</span>  <span class="hljs-comment"># BGE-M3 的维度是 1024</span><br><br><span class="hljs-comment"># 数据库配置 (注意端口是 5433)</span><br>DB_CONFIG = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;5433&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;postgres&quot;</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;postgres&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;secret&quot;</span><br>&#125;<br><span class="hljs-comment"># ==========================================</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_embedding</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    调用硅基流动 API 获取文本向量</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: MODEL_NAME,<br>        <span class="hljs-string">&quot;input&quot;</span>: text,<br>        <span class="hljs-string">&quot;encoding_format&quot;</span>: <span class="hljs-string">&quot;float&quot;</span>,<br>        <span class="hljs-string">&quot;dimensions&quot;</span>: EMBEDDING_DIM<br>    &#125;<br>    headers = &#123;<br>        <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">f&quot;Bearer <span class="hljs-subst">&#123;API_KEY&#125;</span>&quot;</span>,<br>        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span>:<br>        response = requests.post(API_URL, json=payload, headers=headers)<br>        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-comment"># 提取向量数据</span><br>            <span class="hljs-keyword">return</span> response.json()[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;embedding&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ API 调用失败: <span class="hljs-subst">&#123;response.text&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ API 请求异常: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_vector_test</span>():<br>    conn = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 1. 连接数据库</span><br>        conn = psycopg2.connect(**DB_CONFIG)<br>        conn.autocommit = <span class="hljs-literal">True</span> <span class="hljs-comment"># 为了演示方便，开启自动提交</span><br>        cur = conn.cursor(cursor_factory=RealDictCursor)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 数据库连接成功&quot;</span>)<br><br>        <span class="hljs-comment"># 2. [Setup] 环境初始化</span><br>        <span class="hljs-comment"># 启用插件 (如果已启用不会报错)</span><br>        cur.execute(<span class="hljs-string">&quot;CREATE EXTENSION IF NOT EXISTS vector;&quot;</span>)<br>        <br>        <span class="hljs-comment"># 重建测试表</span><br>        cur.execute(<span class="hljs-string">&quot;DROP TABLE IF EXISTS knowledge_base;&quot;</span>)<br>        <span class="hljs-comment"># 注意：这里定义了 vector(1024)</span><br>        cur.execute(<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            CREATE TABLE knowledge_base (</span><br><span class="hljs-string">                id SERIAL PRIMARY KEY,</span><br><span class="hljs-string">                content TEXT,</span><br><span class="hljs-string">                embedding vector(<span class="hljs-subst">&#123;EMBEDDING_DIM&#125;</span>)</span><br><span class="hljs-string">            );</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 表结构初始化完成 (id, content, embedding)&quot;</span>)<br><br>        <span class="hljs-comment"># 3. [Action] 模拟插入数据</span><br>        <span class="hljs-comment"># 假设我们有三段文本：两段关于水果，一段关于电脑</span><br>        test_texts = [<br>            <span class="hljs-string">&quot;苹果是一种红色或绿色的水果，口感清脆。&quot;</span>,<br>            <span class="hljs-string">&quot;香蕉是黄色的，长在热带地区，很软。&quot;</span>,<br>            <span class="hljs-string">&quot;MacBook Pro 是苹果公司生产的笔记本电脑，性能强大。&quot;</span><br>        ]<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n🚀 [Step 1] 正在通过 API 生成向量并入库 (共 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(test_texts)&#125;</span> 条)...&quot;</span>)<br>        <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> test_texts:<br>            vector = get_embedding(text)<br>            <span class="hljs-keyword">if</span> vector:<br>                <span class="hljs-comment"># 关键 SQL：直接把 list 传给 %s，psycopg2 会处理，pgvector 会自动转换</span><br>                cur.execute(<br>                    <span class="hljs-string">&quot;INSERT INTO knowledge_base (content, embedding) VALUES (%s, %s)&quot;</span>,<br>                    (text, vector)<br>                )<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   - 已存入: <span class="hljs-subst">&#123;text[:<span class="hljs-number">10</span>]&#125;</span>...&quot;</span>)<br><br>        <span class="hljs-comment"># 4. [Action] 向量相似度搜索 (RAG 核心)</span><br>        query_text = <span class="hljs-string">&quot;我想买个电脑办公&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n🚀 [Step 2] 执行语义搜索，用户问题: &#x27;<span class="hljs-subst">&#123;query_text&#125;</span>&#x27;&quot;</span>)<br>        <br>        query_vector = get_embedding(query_text)<br>        <br>        <span class="hljs-keyword">if</span> query_vector:<br>            <span class="hljs-comment"># 关键 SQL：使用 &lt;=&gt; (余弦距离) 排序，取 Top 1</span><br>            <span class="hljs-comment"># 注意：%s::vector 是为了显式告诉 PG 这是一个向量</span><br>            search_sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                SELECT id, content, embedding &lt;=&gt; %s::vector AS distance</span><br><span class="hljs-string">                FROM knowledge_base</span><br><span class="hljs-string">                ORDER BY distance ASC</span><br><span class="hljs-string">                LIMIT 1;</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            cur.execute(search_sql, (query_vector,))<br>            result = cur.fetchone()<br>            <br>            <span class="hljs-keyword">if</span> result:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   🏆 命中结果: <span class="hljs-subst">&#123;result[<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   📏 余弦距离: <span class="hljs-subst">&#123;result[<span class="hljs-string">&#x27;distance&#x27;</span>]:<span class="hljs-number">.4</span>f&#125;</span> (越小越相似)&quot;</span>)<br>                <br>                <span class="hljs-comment"># [Assert] 断言验证</span><br>                <span class="hljs-comment"># 如果搜“电脑”匹配到了“香蕉”，那就是测试失败</span><br>                <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;电脑&quot;</span> <span class="hljs-keyword">in</span> result[<span class="hljs-string">&#x27;content&#x27;</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;MacBook&quot;</span> <span class="hljs-keyword">in</span> result[<span class="hljs-string">&#x27;content&#x27;</span>]<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;   ✅ 语义匹配验证通过！&quot;</span>)<br>                <br>                <span class="hljs-comment"># 5. [Action] 删除操作测试</span><br>                target_id = result[<span class="hljs-string">&#x27;id&#x27;</span>]<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n🚀 [Step 3] 测试删除操作，删除 ID: <span class="hljs-subst">&#123;target_id&#125;</span>&quot;</span>)<br>                cur.execute(<span class="hljs-string">&quot;DELETE FROM knowledge_base WHERE id = %s&quot;</span>, (target_id,))<br>                <br>                <span class="hljs-comment"># 再次查询验证是否删除</span><br>                cur.execute(<span class="hljs-string">&quot;SELECT * FROM knowledge_base WHERE id = %s&quot;</span>, (target_id,))<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur.fetchone():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;   ✅ 删除成功，数据已清除。&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;   ❌ 删除失败，数据仍存在。&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;   ❌ 未找到任何匹配结果&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 发生系统错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> conn:<br>            cur.close()<br>            conn.close()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n🏁 测试结束，连接关闭。&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run_vector_test()<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\Anaconda\envs\lanqiao\python.exe D:\Pycharm_workspace\测开\postgresql\pgvector.py <br>✅ 数据库连接成功<br>✅ 表结构初始化完成 (<span class="hljs-built_in">id</span>, content, embedding)<br><br>🚀 [Step 1] 正在通过 API 生成向量并入库 (共 3 条)...<br>   - 已存入: 苹果是一种红色或绿色...<br>   - 已存入: 香蕉是黄色的，长在热...<br>   - 已存入: MacBook Pr...<br><br>🚀 [Step 2] 执行语义搜索，用户问题: <span class="hljs-string">&#x27;我想买个电脑办公&#x27;</span><br>   🏆 命中结果: MacBook Pro 是苹果公司生产的笔记本电脑，性能强大。<br>   📏 余弦距离: 0.4289 (越小越相似)<br>   ✅ 语义匹配验证通过！<br><br>🚀 [Step 3] 测试删除操作，删除 ID: 3<br>   ✅ 删除成功，数据已清除。<br><br>🏁 测试结束，连接关闭。<br><br>进程已结束，退出代码为 0<br></code></pre></td></tr></table></figure><img src="/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="向量数据库"><hr><h2 id="真正使用LLM实现RAG"><a href="#真正使用LLM实现RAG" class="headerlink" title="真正使用LLM实现RAG"></a>真正使用LLM实现RAG</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> psycopg2<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">from</span> psycopg2.extras <span class="hljs-keyword">import</span> RealDictCursor<br><br><span class="hljs-comment"># 禁用 SSL 警告 (解决你的网络问题)</span><br>urllib3.disable_warnings()<br><br><span class="hljs-comment"># ================= 配置区域 =================</span><br><span class="hljs-comment"># 🔴 请替换为你的 Key</span><br>API_KEY = <span class="hljs-string">&quot;&lt;你的_SILICONFLOW_API_KEY&gt;&quot;</span> <br><br><span class="hljs-comment"># 嵌入模型配置</span><br>EMBED_URL = <span class="hljs-string">&quot;https://api.siliconflow.cn/v1/embeddings&quot;</span><br>EMBED_MODEL = <span class="hljs-string">&quot;BAAI/bge-m3&quot;</span><br><br><span class="hljs-comment"># 大模型配置 (这里使用 Qwen2.5-7B-Instruct，免费且强大)</span><br>LLM_URL = <span class="hljs-string">&quot;https://api.siliconflow.cn/v1/chat/completions&quot;</span><br>LLM_MODEL = <span class="hljs-string">&quot;Qwen/Qwen2.5-7B-Instruct&quot;</span> <br><br><span class="hljs-comment"># 数据库配置 (Docker 容器)</span><br>DB_CONFIG = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;5433&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;postgres&quot;</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;postgres&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;secret&quot;</span><br>&#125;<br><span class="hljs-comment"># ===========================================</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_embedding</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;获取文本向量 (复用之前的逻辑)&quot;&quot;&quot;</span><br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: EMBED_MODEL,<br>        <span class="hljs-string">&quot;input&quot;</span>: text,<br>        <span class="hljs-string">&quot;encoding_format&quot;</span>: <span class="hljs-string">&quot;float&quot;</span>,<br>        <span class="hljs-string">&quot;dimensions&quot;</span>: <span class="hljs-number">1024</span><br>    &#125;<br>    headers = &#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">f&quot;Bearer <span class="hljs-subst">&#123;API_KEY&#125;</span>&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>&#125;<br>    <br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># verify=False 解决 SSL 问题</span><br>        resp = requests.post(EMBED_URL, json=payload, headers=headers, verify=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">return</span> resp.json()[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;embedding&#x27;</span>]<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 向量化失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">call_llm</span>(<span class="hljs-params">context, query</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    RAG 的核心：构建提示词，调用大模型</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 🌟 关键步骤：构建 Prompt (提示词工程)</span><br>    <span class="hljs-comment"># 我们告诉模型：你只能根据我给你的 [参考资料] 回答，不要瞎编。</span><br>    system_prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">    你是一个智能助手。请根据下方的【参考资料】回答用户的提问。</span><br><span class="hljs-string">    如果【参考资料】中没有答案，请直接说“我不知道”，不要使用你自带的知识编造。</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    【参考资料】：</span><br><span class="hljs-string">    <span class="hljs-subst">&#123;context&#125;</span></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: LLM_MODEL,<br>        <span class="hljs-string">&quot;messages&quot;</span>: [<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: system_prompt&#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: query&#125;<br>        ],<br>        <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.3</span>, <span class="hljs-comment"># 温度低一点，让回答更严谨</span><br>        <span class="hljs-string">&quot;max_tokens&quot;</span>: <span class="hljs-number">512</span><br>    &#125;<br>    headers = &#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">f&quot;Bearer <span class="hljs-subst">&#123;API_KEY&#125;</span>&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>&#125;<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🤖 正在思考 (调用 Qwen)...&quot;</span>)<br>        resp = requests.post(LLM_URL, json=payload, headers=headers, verify=<span class="hljs-literal">False</span>)<br>        result = resp.json()<br>        <br>        <span class="hljs-comment"># 打印原始返回方便调试</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;choices&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ LLM 调用报错: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;出错啦&quot;</span><br>            <br>        <span class="hljs-keyword">return</span> result[<span class="hljs-string">&#x27;choices&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>]<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ LLM 请求异常: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;出错啦&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    conn = psycopg2.connect(**DB_CONFIG)<br>    conn.autocommit = <span class="hljs-literal">True</span><br>    cur = conn.cursor(cursor_factory=RealDictCursor)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 1. [Setup] 初始化数据库</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🛠️ 初始化知识库...&quot;</span>)<br>        cur.execute(<span class="hljs-string">&quot;CREATE EXTENSION IF NOT EXISTS vector;&quot;</span>)<br>        cur.execute(<span class="hljs-string">&quot;DROP TABLE IF EXISTS company_docs;&quot;</span>)<br>        cur.execute(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            CREATE TABLE company_docs (</span><br><span class="hljs-string">                id SERIAL PRIMARY KEY,</span><br><span class="hljs-string">                content TEXT,</span><br><span class="hljs-string">                embedding vector(1024)</span><br><span class="hljs-string">            );</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>)<br><br>        <span class="hljs-comment"># 2. [Ingest] 写入一些“私有知识”</span><br>        <span class="hljs-comment"># 这些知识是大模型本身绝对不知道的（瞎编的内部规定）</span><br>        private_data = [<br>            <span class="hljs-string">&quot;【公司福利】实习生每两周可以获得一次&#x27;快乐星期五&#x27;，下午 3 点下班。&quot;</span>,<br>            <span class="hljs-string">&quot;【报销规定】加班打车报销代码是 &#x27;TEST-DEV-2025&#x27;，且必须使用滴滴企业版。&quot;</span>,<br>            <span class="hljs-string">&quot;【技术栈】后端主要使用 Python Flask，数据库强制要求使用 PostgreSQL 16。&quot;</span><br>        ]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;📚 正在写入私有知识库...&quot;</span>)<br>        <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> private_data:<br>            vec = get_embedding(text)<br>            <span class="hljs-keyword">if</span> vec:<br>                cur.execute(<span class="hljs-string">&quot;INSERT INTO company_docs (content, embedding) VALUES (%s, %s)&quot;</span>, (text, vec))<br><br>        <span class="hljs-comment"># 3. [RAG Loop] 模拟 RAG 问答</span><br>        user_question = <span class="hljs-string">&quot;实习生有什么特殊的福利吗？加班怎么报销？&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n👤 用户提问: <span class="hljs-subst">&#123;user_question&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 3.1 检索 (Retrieve)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🔍 正在检索相关文档...&quot;</span>)<br>        q_vec = get_embedding(user_question)<br>        <br>        <span class="hljs-comment"># 搜出最相关的 2 条</span><br>        search_sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            SELECT content, embedding &lt;=&gt; %s::vector AS distance </span><br><span class="hljs-string">            FROM company_docs </span><br><span class="hljs-string">            ORDER BY distance ASC </span><br><span class="hljs-string">            LIMIT 2;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cur.execute(search_sql, (q_vec,))<br>        rows = cur.fetchall()<br><br>        <span class="hljs-comment"># 3.2 构建上下文 (Context)</span><br>        retrieved_text = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(rows):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   📄 命中片段 <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;row[<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span> (距离: <span class="hljs-subst">&#123;row[<span class="hljs-string">&#x27;distance&#x27;</span>]:<span class="hljs-number">.4</span>f&#125;</span>)&quot;</span>)<br>            retrieved_text += <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>. <span class="hljs-subst">&#123;row[<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span>\n&quot;</span><br><br>        <span class="hljs-comment"># 3.3 生成 (Generate)</span><br>        <span class="hljs-keyword">if</span> retrieved_text:<br>            answer = call_llm(retrieved_text, user_question)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n💡 RAG 回答:\n<span class="hljs-subst">&#123;<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">20</span>&#125;</span>\n<span class="hljs-subst">&#123;answer&#125;</span>\n<span class="hljs-subst">&#123;<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">20</span>&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 未找到相关资料，无法回答。&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 程序崩溃: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        cur.close()<br>        conn.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><img src="/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="RAG"><img src="/2025/12/22/PostgreSQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="RAG2"><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>postgresql</tag>
      
      <tag>关系型数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neo4j基础学习</title>
    <link href="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>不同于 MySQL 的“表（Table）”和“行（Row）”，Neo4j只有 <strong>节点 (Nodes)</strong> 和 <strong>关系 (Relationships)</strong>。</p><ul><li><strong>节点 (Node):</strong> 实体。例如：一个用户、一个测试用例、一个 Bug。</li><li><strong>关系 (Relationship):</strong> 连接实体的线，<strong>必须有方向和类型</strong>。例如：<code>用户</code> -&gt; <code>购买了</code> -&gt; <code>商品</code>。</li><li><strong>属性 (Properties):</strong> 节点和关系都可以存储数据（Key-Value对）。</li><li><strong>标签 (Label):</strong> 给节点分类。例如 <code>:User</code>, <code>:Product</code>。</li></ul><blockquote><p><strong>简单理解：</strong> 想象在白板上画圈圈（节点）和连线（关系），这就是 Neo4j 存储数据的方式。它比 SQL 更直观，特别是在查询“朋友的朋友”这种多层关系时，性能快千倍。</p></blockquote><ul><li><strong>复杂数据构造：</strong> 构造一个“涉嫌洗钱的转账链条”测试数据，用 SQL 写起来非常痛苦，用 Neo4j 画几条线就搞定。</li><li><strong>链路分析：</strong> “修改了模块 A，会影响哪些下游服务？”，可以通过查询服务依赖图来精准确定回归测试范围。</li></ul><hr><h1 id="Cypher基础"><a href="#Cypher基础" class="headerlink" title="Cypher基础"></a>Cypher基础</h1><p>Neo4j 的查询语言叫 <strong>Cypher</strong>。它的语法非常像“画图”。</p><ul><li><code>()</code> 代表节点。</li><li><code>--</code> 代表关系。</li><li><code>-&gt;</code> 代表方向。</li><li><code>[]</code> 代表关系的详细信息。</li></ul><p>一个简单的场景：<strong>“张三（用户）编写了测试用例 A”。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cypher">// 创建一个 User 节点，名字叫张三<br>CREATE (u:User &#123;name: &quot;张三&quot;, role: &quot;SDET Intern&quot;&#125;)<br><br>// 创建一个 TestCase 节点<br>CREATE (t:TestCase &#123;id: &quot;TC_001&quot;, status: &quot;Active&quot;&#125;)<br><br>// 建立他们之间的关系：编写<br>CREATE (u)-[:WROTE &#123;date: &quot;2023-12-22&quot;&#125;]-&gt;(t)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cypher">// 查找所有编写了测试用例的用户<br>MATCH (u:User)-[r:WROTE]-&gt;(t:TestCase)<br>WHERE u.name = &quot;张三&quot;<br>RETURN u, r, t<br></code></pre></td></tr></table></figure><p>看到一个可视化的图，张三指向了 TC_001。</p><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="cypher查询"><hr><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>创建新的用户实体”李四“，并与TC_001建立关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (t:TestCase &#123;id: &quot;TC_001&quot;&#125;)<br>CREATE (u:User &#123;name: &quot;李四&quot;, role: &quot;Test Dev&quot;&#125;)<br>CREATE (u)-[:REVIEWED &#123;date: &quot;2023-12-23&quot;&#125;]-&gt;(t)<br>RETURN u, t<br></code></pre></td></tr></table></figure><p>先查 (MATCH) 后连 (CREATE)，不然会创建出全新的、重复的</p><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="create"><p>能看到，两个实体之间没有关系连着。而关系其实创建成功了，但因为查询语句只写了 <code>RETURN u, t</code>（只返回了两个点），Neo4j 浏览器有时候比较“老实”，没让他返回关系（Relationship），它就真的只画了两个点，没画中间的线</p><p>为了确保他们一定连上，同时避免创建重复的线，可以使用**<code>MERGE</code>**</p><p><code>CREATE</code>：不管有没有，直接造一个新的（容易产生重复数据）。</p><p><code>MERGE</code>：<strong>“有则匹配，无则创建”</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (u:User &#123;name: &quot;李四&quot;&#125;), (t:TestCase &#123;id: &quot;TC_001&quot;&#125;)<br>MERGE (u)-[r:REVIEWED]-&gt;(t)<br>RETURN u, r, t<br></code></pre></td></tr></table></figure><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="merge"><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>把 <code>TC_001</code> 的状态从 <code>&quot;Active&quot;</code> 改成 <code>&quot;Blocked&quot;</code>，并且给它加一个 <code>priority</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (t:TestCase &#123;id: &quot;TC_001&quot;&#125;)<br>SET t.status = &quot;Blocked&quot;, t.priority = &quot;P0&quot;<br>RETURN t<br></code></pre></td></tr></table></figure><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="update"><h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p>找出所有<strong>状态为 Blocked</strong> 且 <strong>优先级为 P0</strong> 的测试用例和被谁写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (u:User)-[:WROTE]-&gt;(t:TestCase)<br>WHERE t.status = &quot;Blocked&quot; AND t.priority = &quot;P0&quot;<br>RETURN u.name, t.id, t.status<br></code></pre></td></tr></table></figure><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image5.png" class="" title="Read"><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>如果一个节点还有连线（关系），就不能直接把点删掉,所以要先断绝关系，再删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (u:User &#123;name: &quot;张三&quot;&#125;)<br>DETACH DELETE u // 把张三的所有关系线剪断，然后把他删掉<br></code></pre></td></tr></table></figure><hr><h1 id="链路查询与聚合分析"><a href="#链路查询与聚合分析" class="headerlink" title="链路查询与聚合分析"></a>链路查询与聚合分析</h1><p>在 SQL 中，如果要查“张三写的测试用例发现了哪些 Bug”，可能需要 <code>JOIN</code> 三张表（用户表、用例表、缺陷表）。在 Neo4j 里，这是一条连贯的路径。</p><p>(A) –&gt; (B) –&gt; (C)</p><p>想知道 <strong>“张三”</strong> 到底发现了哪些 Bug？</p><p>目前的图结构是：(:User 张三) –[:WROTE]–&gt; (:TestCase TC_001) –[:FOUND]–&gt; (:Bug BUG_999)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (u:User)-[w:WROTE]-&gt;(t:TestCase)-[f:FOUND]-&gt;(b:Bug)<br>WHERE u.name = &quot;张三&quot;<br>RETURN u, w, t, f, b<br></code></pre></td></tr></table></figure><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image6.png" class="" title="链路查询"><hr><p><strong>场景：</strong> 如果张三写了很多用例，发现了 50 个 Bug，老板不需要看列表，只想看 <strong>“每个人发现了多少个 Bug”</strong>。</p><p>这在 SQL 里需要 <code>GROUP BY</code>，在 Cypher 里，<code>RETURN</code> 语句自带分组功能。</p><p><strong>代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (u:User)-[:WROTE]-&gt;(t:TestCase)-[:FOUND]-&gt;(b:Bug)<br>RETURN u.name, count(b) AS bug_count<br></code></pre></td></tr></table></figure><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image7.png" class="" title="聚合分析"><hr><h1 id="变长路径"><a href="#变长路径" class="headerlink" title="变长路径"></a>变长路径</h1><p>假设要测试微服务架构。服务 A 调用 B，B 调用 C，C 调用 D…</p><p>如果服务 D 挂了，哪些上游服务会受影响？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cypher">// 先创建一条调用链: Order -&gt; Pay -&gt; Bank -&gt; Card<br>CREATE (a:Service &#123;name: &quot;OrderService&quot;&#125;)-[:CALLS]-&gt;(b:Service &#123;name: &quot;PayService&quot;&#125;)-[:CALLS]-&gt;(c:Service &#123;name: &quot;BankService&quot;&#125;)-[:CALLS]-&gt;(d:Service &#123;name: &quot;CardService&quot;&#125;)<br></code></pre></td></tr></table></figure><p>使用*号查询：查找 <code>OrderService</code> 下游的所有服务（不管隔了几层）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cypher">MATCH (start:Service &#123;name: &quot;OrderService&quot;&#125;)-[:CALLS*]-&gt;(end:Service)<br>RETURN end<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意看 <code>[:CALLS\*]</code></strong>：这个星号表示“1跳或多跳”。它会帮你把 B, C, D 全部找出来！</p></blockquote><img src="/2025/12/22/Neo4j%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image8.png" class="" title="边长路径"><hr><h1 id="Python集成"><a href="#Python集成" class="headerlink" title="Python集成"></a>Python集成</h1><h2 id="Neo4j-Driver"><a href="#Neo4j-Driver" class="headerlink" title="Neo4j Driver"></a>Neo4j Driver</h2><p>Neo4j Python Driver 在 5.0 版本之后推出了一个<strong>超级简化</strong>的方法 <code>execute_query</code>，特别适合新手和简单的测试脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> neo4j <span class="hljs-keyword">import</span> GraphDatabase<br><br><span class="hljs-comment"># 1. 配置连接信息 (从 Sandbox 复制过来)</span><br>URI = <span class="hljs-string">&quot;bolt://13.219.239.104:7687&quot;</span>  <br>AUTH = (<span class="hljs-string">&quot;neo4j&quot;</span>, <span class="hljs-string">&quot;grooves-difficulty-partition&quot;</span>)  <br><br><span class="hljs-comment"># 2. 建立连接 (创建 Driver)</span><br><span class="hljs-comment"># 就像连接 MySQL 需要 conn 一样，这里我们需要一个 driver</span><br>driver = GraphDatabase.driver(URI, auth=AUTH)<br><br><span class="hljs-comment"># 3. 运行查询</span><br><span class="hljs-comment"># 咱们查一下之前那个 &quot;BankService&quot; (或者查任意节点 LIMIT 5)</span><br>cypher_query = <span class="hljs-string">&quot;MATCH (n:Service) RETURN n.name AS name LIMIT 5&quot;</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># execute_query 是官方推荐的新写法，自动处理连接池和事务</span><br>    records, summary, keys = driver.execute_query(cypher_query)<br><br>    <span class="hljs-comment"># 4. 处理结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;查询成功！消耗时间: <span class="hljs-subst">&#123;summary.result_available_after&#125;</span> ms&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><br>    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> records:<br>        <span class="hljs-comment"># record 就像是一个字典，可以直接用 key 取值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;服务名称: <span class="hljs-subst">&#123;record[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 5. 关闭连接 (好习惯)</span><br>    driver.close()<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">查询成功！消耗时间: 28 ms</span><br><span class="hljs-section">--------------------</span><br>服务名称: OrderService<br>服务名称: PayService<br>服务名称: BankService<br>服务名称: CardService<br></code></pre></td></tr></table></figure><hr><h2 id="参数化查询-Parameterization"><a href="#参数化查询-Parameterization" class="headerlink" title="参数化查询 (Parameterization)"></a>参数化查询 (Parameterization)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;张三&quot;</span><br><span class="hljs-comment"># 拼接语句，很危险 就像 SQL 注入一样，这会导致 Cypher 注入漏洞，且性能极差</span><br>query = <span class="hljs-string">f&quot;MATCH (u:User) WHERE u.name = &#x27;<span class="hljs-subst">&#123;name&#125;</span>&#x27; RETURN u&quot;</span> <br></code></pre></td></tr></table></figure><p>应该使用 $参数名 占位符，然后把字典传给 driver。Neo4j 会缓存执行计划，速度快且安全。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_name</span>(<span class="hljs-params">driver, user_name</span>):<br>    <span class="hljs-comment"># Cypher 里用 $name 占位</span><br>    query = <span class="hljs-string">&quot;MATCH (u:User &#123;name: $name&#125;) RETURN u&quot;</span><br>    <br>    <span class="hljs-comment"># 在 execute_query 的第二个参数里传字典</span><br>    records, _, _ = driver.execute_query(query, name=user_name)<br>    <br>    <span class="hljs-keyword">if</span> records:<br>        <span class="hljs-comment"># 这里的 records[0] 是第一行数据</span><br>        <span class="hljs-comment"># records[0][&#x27;u&#x27;] 拿到了整个节点对象</span><br>        <span class="hljs-comment"># .get(&#x27;role&#x27;) 获取节点里的属性</span><br>        node = records[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;u&#x27;</span>]<br>        <span class="hljs-keyword">return</span> node.get(<span class="hljs-string">&#x27;role&#x27;</span>, <span class="hljs-string">&#x27;Unknown Role&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 调用</span><br>role = get_user_by_name(driver, <span class="hljs-string">&quot;张三&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;张三的角色是: <span class="hljs-subst">&#123;role&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="高阶知识理论"><a href="#高阶知识理论" class="headerlink" title="高阶知识理论"></a>高阶知识理论</h1><h3 id="1-逻辑与扩展：APOC-对标-Redis-的-Lua-脚本"><a href="#1-逻辑与扩展：APOC-对标-Redis-的-Lua-脚本" class="headerlink" title="1. 逻辑与扩展：APOC (对标 Redis 的 Lua 脚本)"></a>1. 逻辑与扩展：APOC (对标 Redis 的 Lua 脚本)</h3><p>Redis 有 Lua 脚本来处理复杂原子逻辑，Neo4j 有 <strong>APOC (Awesome Procedures on Cypher)</strong>。</p><ul><li><strong>理论概念：</strong> Cypher 是“声明式”语言（告诉电脑我要什么），但在做复杂数据清洗、批量导入、或者需要写类似编程语言的 <code>if-else</code> 循环逻辑时，Cypher 就很吃力。APOC 是 Neo4j 的一个<strong>超强插件包</strong>（现在的版本很多已内置），提供了几百个存储过程。</li><li><strong>测开场景：</strong><ul><li><strong>造海量数据：</strong> 不想写 Python 脚本去插库，可以直接用 APOC 语法：<code>CALL apoc.periodic.iterate(...)</code>，在数据库内部直接生成 100 万条测试数据，速度比外部脚本快 10 倍。</li><li><strong>导入数据：</strong> 直接用 APOC 读取 JSON&#x2F;XML&#x2F;CSV 文件并落库，不需要经过后端服务。</li></ul></li></ul><h3 id="2-事务与锁：ACID-对标-Redis-的-Watch-乐观锁"><a href="#2-事务与锁：ACID-对标-Redis-的-Watch-乐观锁" class="headerlink" title="2. 事务与锁：ACID (对标 Redis 的 Watch&#x2F;乐观锁)"></a>2. 事务与锁：ACID (对标 Redis 的 Watch&#x2F;乐观锁)</h3><p>Redis 的事务比较弱，但 Neo4j 是<strong>完全符合 ACID</strong> 的事务型数据库（和 MySQL 一样强）。</p><ul><li><strong>理论概念：</strong><ul><li><strong>ACID：</strong> 即使是图数据库，转账操作要么全成功，要么全失败。</li><li><strong>乐观锁 (Optimistic Locking)：</strong> Neo4j 内部也有版本控制。如果你和我都读取了节点 A，我改了它，再想改提交时就会报错（因为版本号变了）。</li><li><strong>死锁 (Deadlock)：</strong> 在高并发测试中，如果两个事务互相锁住对方需要的节点，Neo4j 会自动检测并抛出异常。</li></ul></li><li><strong>测开场景：</strong><ul><li><strong>并发测试：</strong> 写测试脚本模拟 100 个人同时抢一张票（修改同一个节点的属性），需要验证 Neo4j 是否正确抛出了锁竞争异常，而不是把数据改乱了。</li></ul></li></ul><h3 id="3-性能调优：PROFILE-与-索引-对标-MySQL-的-Explain"><a href="#3-性能调优：PROFILE-与-索引-对标-MySQL-的-Explain" class="headerlink" title="3. 性能调优：PROFILE 与 索引 (对标 MySQL 的 Explain)"></a>3. 性能调优：PROFILE 与 索引 (对标 MySQL 的 Explain)</h3><ul><li><strong>理论概念：</strong><ul><li><strong>执行计划 (Execution Plan)：</strong> 在 Cypher 语句前加 <code>PROFILE</code> 或 <code>EXPLAIN</code>，它会告诉你查询经过了哪些步骤。是“全图扫描”（AllNodesScan，类似全表扫描，性能杀手）还是走了“索引”（IndexSeek）。</li><li><strong>索引 (Index)：</strong> 图数据库也要建索引！否则查 <code>name=&quot;张三&quot;</code> 也会慢死。Neo4j 支持 B-Tree 索引、全文索引（Full-text）甚至向量索引（Vector Index）。</li></ul></li><li><strong>测开场景：</strong><ul><li><strong>慢查询分析：</strong> 开发写的查询太慢，你作为测开，能不能甩出一张 <code>PROFILE</code> 截图告诉他：“你看，你这里发生了笛卡尔积（Cartesian Product），甚至没走索引，甚至扫了 100 万个点只返回 1 个，必须优化！”</li></ul></li></ul><h3 id="4-架构模式：因果集群-Causal-Clustering-对标-Redis-Cluster-Sentinel"><a href="#4-架构模式：因果集群-Causal-Clustering-对标-Redis-Cluster-Sentinel" class="headerlink" title="4. 架构模式：因果集群 (Causal Clustering) (对标 Redis Cluster&#x2F;Sentinel)"></a>4. 架构模式：因果集群 (Causal Clustering) (对标 Redis Cluster&#x2F;Sentinel)</h3><ul><li><strong>理论概念：</strong><ul><li>Neo4j 不只是单机版。在生产环境通常是 <strong>Core + Read Replica</strong> 架构。</li><li><strong>Raft 协议：</strong> 核心节点（Core）之间通过 Raft 协议保证数据强一致性（Leader-Follower）。</li><li><strong>因果一致性 (Causal Consistency)：</strong> 这是 Neo4j 的特色。它保证“如果是你刚写的数据，你立马就能读到”（Read your own writes），但其他人可能稍有延迟。</li></ul></li><li><strong>测开场景：</strong><ul><li><strong>故障演练 (Chaos Engineering)：</strong> 把 Leader 节点强行关机，测试系统是否会自动选主？业务是否中断？</li><li><strong>主从延迟：</strong> 刚在主库写了数据，马上在从库查，会不会查不到？（这是分布式系统测试的经典坑）。</li></ul></li></ul><h3 id="5-图算法：GDS-Graph-Data-Science-Neo4j-的杀手锏"><a href="#5-图算法：GDS-Graph-Data-Science-Neo4j-的杀手锏" class="headerlink" title="5. 图算法：GDS (Graph Data Science) (Neo4j 的杀手锏)"></a>5. 图算法：GDS (Graph Data Science) (Neo4j 的杀手锏)</h3><p>这是 Redis 和 MySQL 完全不具备的能力。</p><ul><li><strong>理论概念：</strong> 数据库不仅存数据，还能<strong>算</strong>数据。<ul><li><strong>PageRank：</strong> 算出谁是网络中最关键的节点（大V）。</li><li><strong>社群检测 (Louvain)：</strong> 自动发现哪些人是一个小团伙（反欺诈核心逻辑）。</li><li><strong>路径算法 (Dijkstra&#x2F;A*)：</strong> 算两点间的最短&#x2F;最优路径。</li></ul></li><li><strong>测开场景：</strong><ul><li><strong>算法准确性测试：</strong> 开发上线了一个“推荐可能认识的人”功能。你怎么测？需要用 GDS 库跑一遍基准算法，验证开发算出来的结果是否符合预期。</li></ul></li></ul><h3 id="6-Vector-Search-向量搜索-——-给-LLM-用的"><a href="#6-Vector-Search-向量搜索-——-给-LLM-用的" class="headerlink" title="6. Vector Search (向量搜索) —— 给 LLM 用的"></a>6. Vector Search (向量搜索) —— 给 LLM 用的</h3><ul><li><strong>理论概念：</strong> Neo4j 做为向量数据库以存“向量”（Vectors）。</li><li><strong>用途：</strong> 结合 LLM（大模型）做 <strong>GraphRAG</strong>（基于图的检索增强生成）。<ul><li>比如：把用户的知识图谱变成向量存进去。当用户问问题时，不仅靠关键词匹配，还靠向量相似度找到关联的知识，喂给 GPT。</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>Neo4J</tag>
      
      <tag>图数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB基础学习</title>
    <link href="/2025/12/22/MongoDB%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/MongoDB%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>MongoDB 是一个<strong>文档型数据库</strong>。</p><ul><li><strong>SQL (MySQL)</strong> 像 Excel 表格，必须先定义列头（Schema），每一行格式必须一样。</li><li><strong>MongoDB</strong> 像一个文件夹，里面装了很多 JSON 文件。每一个文件可以长得不一样，非常灵活。</li></ul><table><thead><tr><th align="center"><strong>MySQL (关系型)</strong></th><th align="center"><strong>MongoDB (非关系型)</strong></th><th align="center"><strong>理解</strong></th></tr></thead><tbody><tr><td align="center"><strong>Database</strong> (数据库)</td><td align="center"><strong>Database</strong> (数据库)</td><td align="center">一样的，存放数据的容器。</td></tr><tr><td align="center"><strong>Table</strong> (表)</td><td align="center"><strong>Collection</strong> (集合)</td><td align="center">比如 <code>users</code> 集合，存放所有用户信息。</td></tr><tr><td align="center"><strong>Row</strong> (行)</td><td align="center"><strong>Document</strong> (文档)</td><td align="center"><strong>关键点！</strong> 每一行数据是一个 JSON 对象。</td></tr><tr><td align="center"><strong>Column</strong> (列)</td><td align="center"><strong>Field</strong> (字段)</td><td align="center">JSON 中的 Key。</td></tr><tr><td align="center"><strong>Join</strong> (关联查询)</td><td align="center">Embedding (嵌套)</td><td align="center">通常不怎么用 Join，而是把地址直接写在用户文档里。</td></tr></tbody></table><p>在 MongoDB 中，数据是以 <strong>BSON</strong> (Binary JSON) 格式存储的，看作 <strong>JSON</strong> 就行。</p><p><strong>举个例子：</strong> 假设你要测试一个电商产品的“用户下单”功能。</p><ul><li>在 MySQL 里，可能需要去 <code>Order表</code>、<code>User表</code>、<code>Product表</code> 三个地方查数据。</li><li>在 MongoDB 里，一条订单数据可能长这样（直接嵌套）：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ObjectId(&#x27;507f1f77bcf86cd799439011&#x27;)&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 自动生成的主键</span><br>  <span class="hljs-attr">&quot;order_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ORD-20231217-001&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;total_price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">299.00</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PAID&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;customer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>              <span class="hljs-comment">// 【嵌套】用户信息直接包含在内</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;李同学&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;13800000000&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                 <span class="hljs-comment">// 【数组】买了多个商品</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;product&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;机械键盘&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;qty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;product&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;鼠标&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;qty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="基础CRUD"><a href="#基础CRUD" class="headerlink" title="基础CRUD"></a>基础CRUD</h1><p>模拟场景：测试一个**“用户注册与管理”**的功能。你需要手动在数据库里构造数据，修改状态，最后清理数据。</p><p>先创建一个名为 <code>users</code> 的集合（Collection）。</p><h2 id="1-构造测试数据"><a href="#1-构造测试数据" class="headerlink" title="1. 构造测试数据"></a>1. 构造测试数据</h2><p><strong>测试场景</strong>：往数据库里插入一个“已注册用户”，以便后续测试“登录”接口。在 MongoDB 中，如果集合（表）不存在，插入数据时会自动创建，非常省事。</p><p><strong>语法</strong>：<code>db.collection.insertOne(json_data)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 插入一条名为 &quot;test_dev_001&quot; 的测试用户数据</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertOne</span>(&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;test_dev_001&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">23</span>,<br>    <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;intern&quot;</span>,<br>    <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;testing&quot;</span>],<br>    <span class="hljs-string">&quot;is_active&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;register_date&quot;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：看到 <code>acknowledged: true</code> 就说明成功了。</p></blockquote><h2 id="2-查数据"><a href="#2-查数据" class="headerlink" title="2.  查数据"></a>2.  查数据</h2><p><strong>测试场景</strong>：前端页面显示“注册成功”，去数据库查一下，数据真的进去了吗？字段对不对？</p><p><strong>语法</strong>：<code>db.collection.find(query)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 查询 users 集合里的所有数据</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>()<br><br><span class="hljs-comment">// 2. [常用] 精确查询：查找 username 为 &quot;test_dev_001&quot; 的用户</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;test_dev_001&quot;</span> &#125;)<br><br><span class="hljs-comment">// 3. [常用] 多条件查询：查找 active 状态为 true 且 年龄为 23 的用户</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-string">&quot;is_active&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">23</span> &#125;)<br></code></pre></td></tr></table></figure><img src="/2025/12/22/MongoDB%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="查数据"><h2 id="3-修改状态-制造边界条件"><a href="#3-修改状态-制造边界条件" class="headerlink" title="3. 修改状态&#x2F;制造边界条件"></a>3. 修改状态&#x2F;制造边界条件</h2><p><strong>测试场景</strong>：测试“被封禁用户无法登录”这个逻辑。需要手动把刚才那个用户的状态改为“封禁”。</p><p><strong>语法</strong>：<code>db.collection.updateOne(filter, update_action)</code></p><p>这里有一个非常重要的概念：修改器 (Modifier)。</p><p>在 SQL 里可以直接 SET age&#x3D;24，但在 MongoDB 里，必须使用 $set 操作符。如果不用 $set，它可能会用新数据覆盖掉整个旧文档（造成数据丢失）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 把 username 为 &quot;test_dev_001&quot; 的用户，age 改为 24，is_active 改为 false</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">updateOne</span>(<br>    &#123; <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;test_dev_001&quot;</span> &#125;,  <span class="hljs-comment">// 筛选条件 (Where)</span><br>    &#123; <br>        <span class="hljs-attr">$set</span>: &#123;                      <span class="hljs-comment">// 修改操作 (Set)</span><br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">24</span>,<br>            <span class="hljs-string">&quot;is_active&quot;</span>: <span class="hljs-literal">false</span> <br>        &#125;<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><blockquote><p>问“MongoDB 更新时 $set 是干嘛的？”</p><p>答：用于指定只更新某些字段。如果不加 $set 直接传 JSON，可能会导致整个文档被替换，丢失其他原有字段。</p></blockquote><h2 id="4-环境清理"><a href="#4-环境清理" class="headerlink" title="4. 环境清理"></a>4. 环境清理</h2><p><strong>测试场景</strong>：自动化测试跑完了，需要把刚才生成的脏数据删掉，以免影响下一次测试。</p><p><strong>语法</strong>：<code>db.collection.deleteOne(query)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除 username 为 &quot;test_dev_001&quot; 的那条记录</span><br>db.<span class="hljs-property">users</span>.<span class="hljs-title function_">deleteOne</span>(&#123; <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;test_dev_001&quot;</span> &#125;)<br></code></pre></td></tr></table></figure><hr><h1 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h1><p>在实际工作中，测试环境的数据库里可能有几十万条日志或订单数据。如果出现了一个 Bug，老板问：“帮我查一下昨天下午 2 点到 4 点之间，所有失败的、且金额大于 1000 元的订单”，必须能快速写出查询语句。</p><hr><p>先<strong>批量插入</strong> 4 条测试数据（注意是用 <code>insertMany</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">insertMany</span>([<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;intern&quot;</span>, <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;c++&quot;</span>], <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">85</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">28</span>, <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;manager&quot;</span>, <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;management&quot;</span>], <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">92</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;golang&quot;</span>, <span class="hljs-string">&quot;docker&quot;</span>], <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">78</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;java&quot;</span>], <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">60</span>, <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;banned&quot;</span> &#125;<br>])<br></code></pre></td></tr></table></figure><h2 id="1-比较查询-范围测试"><a href="#1-比较查询-范围测试" class="headerlink" title="1. 比较查询 (范围测试)"></a>1. 比较查询 (范围测试)</h2><p>在 SQL 里用 &gt;, &lt;, &gt;&#x3D;。而在 MongoDB 里，需要用特殊操作符：</p><ul><li><code>$gt</code> (Greater Than) 大于</li><li><code>$lt</code> (Less Than) 小于</li><li><code>$gte</code> (Greater Than Equal) 大于等于</li><li><code>$lte</code> (Less Than Equal) 小于等于</li><li><code>$ne</code> (Not Equal) 不等于</li></ul><p><strong>例子</strong>：查找分数 <strong>大于 80 分</strong> 的用户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-string">&quot;score&quot;</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">80</span> &#125; &#125;)<br></code></pre></td></tr></table></figure><h2 id="2-包含查询-in"><a href="#2-包含查询-in" class="headerlink" title="2. 包含查询 ($in)"></a>2. 包含查询 ($in)</h2><p><strong>测试场景</strong>：手头有一批测试账号的 ID 列表（比如 <code>[&quot;user_A&quot;, &quot;user_B&quot;]</code>），想一次性把它们都查出来检查状态。</p><p><strong>例子</strong>：查找职位是 <strong>intern (实习生)</strong> 或者 <strong>manager (经理)</strong> 的人：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-string">&quot;role&quot;</span>: &#123; <span class="hljs-attr">$in</span>: [<span class="hljs-string">&quot;intern&quot;</span>, <span class="hljs-string">&quot;manager&quot;</span>] &#125; &#125;)<br></code></pre></td></tr></table></figure><h2 id="3-数组查询-Array-Query"><a href="#3-数组查询-Array-Query" class="headerlink" title="3. 数组查询 (Array Query)"></a>3. 数组查询 (Array Query)</h2><p>测试场景：验证用户是否拥有某个特定权限&#x2F;技能。</p><p><strong>例子</strong>：查找技能列表中<strong>包含 “python”</strong> 的所有用户：</p><ul><li>注意：MongoDB 很聪明，不需要告诉它“这是一个数组”，直接查就行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-string">&quot;skills&quot;</span>: <span class="hljs-string">&quot;python&quot;</span> &#125;)<br></code></pre></td></tr></table></figure><h2 id="4-逻辑查询-or-and"><a href="#4-逻辑查询-or-and" class="headerlink" title="4. 逻辑查询 ($or, $and)"></a>4. 逻辑查询 ($or, $and)</h2><p><strong>测试场景</strong>：复杂的组合条件。</p><p><strong>例子</strong>：查找 (年龄大于 25) <strong>或者</strong> (状态是 banned) 的用户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>(&#123;<br>    <span class="hljs-attr">$or</span>: [<br>        &#123; <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-attr">$gt</span>: <span class="hljs-number">25</span> &#125; &#125;,<br>        &#123; <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;banned&quot;</span> &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="5-排序与分页-Sort-Limit"><a href="#5-排序与分页-Sort-Limit" class="headerlink" title="5. 排序与分页 (Sort, Limit)"></a>5. 排序与分页 (Sort, Limit)</h2><p>测试场景：测试 App 的“下拉加载更多”功能（Pagination）。需要验证接口返回的第 1 页数据，是不是数据库里最新的那几条。</p><ul><li><code>sort(&#123; field: 1 &#125;)</code>: 1 代表升序 (从小到大)，-1 代表降序 (从大到小)。</li><li><code>limit(n)</code>: 只取前 n 条。</li><li><code>skip(n)</code>: 跳过前 n 条。</li></ul><p><strong>例子</strong>：按分数<strong>从高到低</strong>排序，取<strong>前 2 名</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">users</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">sort</span>(&#123; <span class="hljs-string">&quot;score&quot;</span>: -<span class="hljs-number">1</span> &#125;).<span class="hljs-title function_">limit</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><span class="hljs-keyword">from</span> pymongo <span class="hljs-keyword">import</span> MongoClient<br><br><span class="hljs-comment"># 1. 连接数据库</span><br><span class="hljs-comment"># mongodb://IP地址:端口/</span><br>client = MongoClient(<span class="hljs-string">&quot;mongodb://localhost:27017/&quot;</span>)<br><br><span class="hljs-comment"># 2. 选择数据库 (Database)</span><br>db = client[<span class="hljs-string">&quot;mongo_study&quot;</span>]  <br><br><span class="hljs-comment"># 3. 选择集合 (Collection)</span><br>collection = db[<span class="hljs-string">&quot;users&quot;</span>]<br><br><span class="hljs-comment"># 4. 执行查询 (Read)</span><br><span class="hljs-comment"># 找那位 &quot;Python 讲师候选人&quot; (Bob)</span><br><span class="hljs-comment"># find_one 只返回一条字典数据，非常适合做断言</span><br>user_data = collection.find_one(&#123;<br>    <span class="hljs-string">&quot;skills&quot;</span>: <span class="hljs-string">&quot;python&quot;</span>,<br>    <span class="hljs-string">&quot;score&quot;</span>: &#123; <span class="hljs-string">&quot;$gte&quot;</span>: <span class="hljs-number">80</span> &#125;<br>&#125;)<br><br><span class="hljs-comment"># 打印出来看看</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;查询到的用户: <span class="hljs-subst">&#123;user_data[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;完整数据: <span class="hljs-subst">&#123;user_data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 测开核心环节：断言 (Assertion)</span><br><span class="hljs-comment"># 模拟自动化测试中的校验步骤</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">assert</span> user_data[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-string">&quot;Bob&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;management&quot;</span> <span class="hljs-keyword">in</span> user_data[<span class="hljs-string">&#x27;skills&#x27;</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n✅ 测试通过：数据校验成功！&quot;</span>)<br><span class="hljs-keyword">except</span> AssertionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n❌ 测试失败：数据与预期不符&quot;</span>)<br><span class="hljs-keyword">except</span> TypeError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n❌ 测试失败：未查询到数据&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="批量造数据-Mock-与-清理-Teardown"><a href="#批量造数据-Mock-与-清理-Teardown" class="headerlink" title="批量造数据 (Mock) 与 清理 (Teardown)"></a>批量造数据 (Mock) 与 清理 (Teardown)</h1><p>如何构造大量的测试数据？手动插入一条条数据太慢了。应该编写 Python 脚本，在 1 秒钟内生成 1000 条订单数据，用来测试前端列表页的翻页性能，或者测试报表统计的准确性。</p><p>实战场景：开发写了一个“订单列表”接口，需要测试：</p><ol><li><strong>分页功能</strong>：当有 50 条数据时，第 2 页是否显示正确？</li><li><strong>状态过滤</strong>：筛选“已支付 (PAID)”的订单是否准确？</li></ol><p>用 Python 脚本瞬间生成 50 条模拟订单数据。</p><h2 id="1-编写批量造数脚本-Setup"><a href="#1-编写批量造数脚本-Setup" class="headerlink" title="1. 编写批量造数脚本 (Setup)"></a>1. 编写批量造数脚本 (Setup)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><span class="hljs-keyword">from</span> pymongo <span class="hljs-keyword">import</span> MongoClient<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 1. 连接数据库</span><br>client = MongoClient(<span class="hljs-string">&quot;mongodb://localhost:27017/&quot;</span>)<br>db = client[<span class="hljs-string">&quot;test&quot;</span>]<br>order_collection = db[<span class="hljs-string">&quot;orders&quot;</span>]  <span class="hljs-comment"># 新建一个 orders 集合</span><br><br><span class="hljs-comment"># 2. 准备造数据</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🚀 开始构造测试数据...&quot;</span>)<br>mock_data_list = []<br>statuses = [<span class="hljs-string">&quot;CREATED&quot;</span>, <span class="hljs-string">&quot;PAID&quot;</span>, <span class="hljs-string">&quot;SHIPPED&quot;</span>, <span class="hljs-string">&quot;CANCELLED&quot;</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-comment"># 模拟生成一条订单</span><br>    order = &#123;<br>        <span class="hljs-string">&quot;order_id&quot;</span>: <span class="hljs-string">f&quot;ORD-2023-<span class="hljs-subst">&#123;i+<span class="hljs-number">1000</span>&#125;</span>&quot;</span>,  <span class="hljs-comment"># 比如 ORD-2023-1000</span><br>        <span class="hljs-string">&quot;price&quot;</span>: random.randint(<span class="hljs-number">50</span>, <span class="hljs-number">500</span>),  <span class="hljs-comment"># 随机价格 50~500</span><br>        <span class="hljs-string">&quot;status&quot;</span>: random.choice(statuses), <span class="hljs-comment"># 随机状态</span><br>        <span class="hljs-string">&quot;created_at&quot;</span>: time.time()<br>    &#125;<br>    mock_data_list.append(order)<br><br><span class="hljs-comment"># 3. 批量插入 (核心步骤)</span><br><span class="hljs-comment"># 为什么不用 insert_one? 因为 insert_many 只需要一次网络请求，速度快几十倍。</span><br>result = order_collection.insert_many(mock_data_list)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功插入 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(result.inserted_ids)&#125;</span> 条数据！&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-验证与清理-Teardown"><a href="#2-验证与清理-Teardown" class="headerlink" title="2. 验证与清理 (Teardown)"></a>2. 验证与清理 (Teardown)</h2><p>在自动化测试框架（如 Pytest）中，应该做到测试产生的垃圾数据，测试结束后要自己打扫干净。否则下次跑测试，数据会越来越多，导致断言失败。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (连接代码同上) ...</span><br><br><span class="hljs-comment"># 4. 验证数据量 (模拟测试步骤)</span><br>count = order_collection.count_documents(&#123;&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前数据库里的订单总数: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 环境清理 (Teardown)</span><br><span class="hljs-comment"># 场景：测试跑完了，删除所有生成的测试数据</span><br><span class="hljs-comment"># ⚠️ 危险操作：在生产环境严禁使用空条件的 delete_many(&#123;&#125;)</span><br>delete_result = order_collection.delete_many(&#123;&#125;)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🧹 环境清理完毕，删除了 <span class="hljs-subst">&#123;delete_result.deleted_count&#125;</span> 条数据。&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="进阶知识理论"><a href="#进阶知识理论" class="headerlink" title="进阶知识理论"></a>进阶知识理论</h1><ol><li><strong>索引 (Index)</strong> —— 速度的来源</li><li><strong>聚合 (Aggregation)</strong> —— 复杂的流水线</li><li><strong>副本集 (Replica Set)</strong> —— 高可用不宕机</li><li><strong>分片 (Sharding)</strong> —— 海量数据扩容</li><li><strong>存储引擎 (WiredTiger)</strong> —— 底层的读写原理</li></ol><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MongoDB 的索引原理和 MySQL（InnoDB）非常像，底层大多采用 B-Tree (B树) 结构。</p><ul><li><strong>没有索引时</strong>：MongoDB 必须执行 <strong>Collection Scan (全表扫描)</strong>。就像你在查字典，没有拼音目录，得从第一页翻到最后一页去找“字”。</li><li><strong>有索引时</strong>：MongoDB 执行 <strong>Index Scan (索引扫描)</strong>。直接去 B-Tree 树上找到位置，瞬间拿到数据。</li></ul><p><strong>测开视角</strong>：</p><ul><li><strong>复合索引 (Compound Index)</strong>：如果经常查 <code>find(&#123;name: &quot;A&quot;, age: 20&#125;)</code>，那应该建立一个 <code>(name, age)</code> 的联合索引。<ul><li><em>注意点</em>：<strong>最左前缀原则</strong>（和 MySQL 一样）。如你只建了 <code>(name, age)</code> 索引，但查询时只查 <code>age</code>，这个索引是<strong>失效</strong>的！</li></ul></li><li><strong>TTL 索引</strong>：这就很有意思了。可以给索引设置一个“过期时间”（比如 1 小时）。<ul><li><em>应用</em>：验证码、临时 Token、日志。到了时间，MongoDB 会<strong>自动删除</strong>这些数据。这在测试“验证码过期”场景时经常用到。</li></ul></li></ul><hr><h2 id="聚合管道"><a href="#聚合管道" class="headerlink" title="聚合管道"></a>聚合管道</h2><p>普通的 find() 只能做简单的筛选。如果要对应 SQL 中的 Group By、Join、Sum、Avg，MongoDB 采用的是一种**“流水线” (Pipeline)** 的设计模式。</p><p>想象一个工厂流水线，数据就是原材料：</p><ol><li><strong>$match (筛选)</strong>：先过滤掉废品（只保留 2023 年的订单）。</li><li><strong>$project (整形)</strong>：把不需要的零件拆掉（只保留“金额”和“用户ID”字段）。</li><li><strong>$group (分组)</strong>：按用户ID把订单堆在一起，算总金额。</li><li><strong>$sort (排序)</strong>：按金额从大到小排。</li><li><strong>输出</strong>。</li></ol><p>**测开视角：</p><ul><li>问：“MongoDB 能做多表关联查询吗？”</li><li>答案是：<strong>能，但是不推荐</strong>。使用 <strong><code>$lookup</code></strong> 阶段可以实现类似 SQL Left Join 的功能，但性能开销很大。NoSQL 的设计理念本来就是“反范式化”（把数据嵌套在一起），尽量避免关联查询。</li></ul><hr><h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>这是生产环境的标配。单机版的 MongoDB 挂了就完了，所以需要一主多从。</p><ul><li><strong>Primary (主节点)</strong>：唯一的“老大”，负责<strong>所有的写操作</strong>（增删改）。也可以读。</li><li><strong>Secondary (从节点)</strong>：负责同步主节点的数据。默认不可读（为了保证强一致性），但可以配置成“只读”。</li><li><strong>Heartbeat (心跳)</strong>：节点之间每隔 2 秒互通一下消息：“你还活着吗？”</li><li><strong>自动故障转移 (Failover)</strong>：如果主节点挂了，剩下的从节点会<strong>投票</strong>，选出一个新的主节点。整个过程通常在几秒内完成。</li></ul><p><strong>测开视角</strong>：</p><ul><li><strong>读写分离</strong>：测试时，可以配置连接字符串，让“写”走主节点，“读”走从节点（<code>ReadPreference</code>）。需要测试数据同步是否有<strong>延迟</strong>（Replication Lag）。比如主节点刚写进去，立刻去从节点读，读到了吗？</li></ul><hr><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>当数据量达到 TB 级别，或者并发量太大，一台机器（哪怕是主从架构）也扛不住了。这时候就需要分片。</p><p>Redis 也有类似的概念（Redis Cluster）。MongoDB 的分片架构包含三个角色：</p><ol><li><strong>Mongos (路由)</strong>：这是“看门大爷”。客户端只跟它打交道。它负责把请求分发到具体的片上。</li><li><strong>Config Server (配置服)</strong>：这是“地图”。它记录了哪块数据在哪个片上。</li><li><strong>Shard (分片)</strong>：这是真正存数据的“仓库”。每个 Shard 通常也是一个副本集（保证自己不挂）。</li></ol><p>**测开视角：</p><ul><li><strong>分片键 (Shard Key)</strong>：这是最关键的。比如按“用户ID”分片。<ul><li>如果选得不好（比如按“性别”分片），会导致<strong>数据倾斜</strong>（Jumbo Chunk），所有数据都跑到其中一个片上去了，另一个片闲得慌。这是性能测试要关注的隐患。</li></ul></li></ul><hr><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MongoDB 3.2 之后默认使用 WiredTiger 引擎。只需要记住它相对于老引擎（MMAPv1）的两个巨大提升：</p><ol><li><strong>文档级锁 (Document-Level Concurrency)</strong>：<ul><li><em>老版本</em>：你要修改一条数据，MongoDB 会锁住整个库或整个集合（Collection）。别人都得排队。</li><li><em>WiredTiger</em>：<strong>只锁要修改的那一行文档</strong>。并发能力极强！</li></ul></li><li><strong>数据压缩</strong>：<ul><li>它在把数据存入磁盘前会进行压缩。所以在磁盘上看到的文件大小，往往比实际数据量要小很多。</li></ul></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>NoSQL</tag>
      
      <tag>文档型数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis基础学习</title>
    <link href="/2025/12/22/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/22/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>Redis</strong>（Remote Dictionary Server）是一个开源的、基于内存的、键值对（Key-Value）存储系统</p><p>可以把 Redis 想象成一个**“超级快、功能强的内存字典”**：</p><ul><li><strong>内存存储</strong>：数据全在内存里，读写速度极快（10W+ QPS）。</li><li><strong>键值对模型</strong>：所有的操作都围绕着 <code>Key -&gt; Value</code> 进行。</li><li><strong>数据结构丰富</strong>：不仅仅是简单的字符串，它还支持列表、哈希、集合等。</li><li><strong>持久化</strong>：虽然在内存，但它可以定时把数据存到硬盘，防止断电丢失。</li></ul><p>在面试或实际工作中，会遇到以下场景：</p><ul><li><strong>性能瓶颈分析</strong>：如果接口慢，是不是缓存没命中（Cache Miss）？</li><li><strong>数据一致性测试</strong>：数据库改了，Redis 里的缓存同步了吗？</li><li><strong>并发测试</strong>：多个请求同时抢一个红包，Redis 的分布式锁起作用了吗？</li></ul><hr><h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h1><p>String是Redis 最基本的数据类型，也是面试最常问的。它可以存储字符串、数字（整数&#x2F;浮点数），甚至是二进制数据（如图片，但很少这么干）</p><p><strong>核心命令：</strong></p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>用法</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>用途</strong></th></tr></thead><tbody><tr><td align="center"><strong>SET</strong></td><td align="center"><code>SET key value</code></td><td align="center">存入数据</td><td align="center">前置准备数据，造测试数据。</td></tr><tr><td align="center"><strong>GET</strong></td><td align="center"><code>GET key</code></td><td align="center">取出数据</td><td align="center"><strong>断言</strong>：验证存入的数据是否正确。</td></tr><tr><td align="center"><strong>EXPIRE</strong></td><td align="center"><code>EXPIRE key seconds</code></td><td align="center">设置过期时间</td><td align="center"><strong>重要！</strong> 测试验证码是否在 60 秒后失效。</td></tr><tr><td align="center"><strong>TTL</strong></td><td align="center"><code>TTL key</code></td><td align="center">查看剩余时间</td><td align="center">检查过期时间逻辑是否生效。</td></tr><tr><td align="center"><strong>INCR</strong></td><td align="center"><code>INCR key</code></td><td align="center">数值 +1</td><td align="center">测试“限制用户每分钟请求次数”或“点赞数”功能。</td></tr></tbody></table><p><strong>场景描述：</strong> 用户请求验证码，有效期 60 秒</p><p>写入验证码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SET phone:13800138000 <span class="hljs-string">&quot;8848&quot;</span><br>OK<br></code></pre></td></tr></table></figure><p>设置过期时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; EXPIRE phone:13800138000 60<br>1<br></code></pre></td></tr></table></figure><p>查看剩余时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; TTL phone:13800138000<br>56<br><br><span class="hljs-comment"># 如果返回 -1，说明永不过期，这就是 Bug</span><br></code></pre></td></tr></table></figure><p>验证数据最后是否真正消失</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt; <span class="hljs-built_in">GET</span> phone:13800138000<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><hr><p>场景描述：限制某个 IP 每分钟只能访问 10 次</p><p>步骤 1：请求进来，先计数。使用 INCR 命令。即使 key 不存在，Redis 也会自动把它创建并设为 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; INCR <span class="hljs-built_in">limit</span>:192.168.1.5<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>步骤 2：判断是否是第一次访问。如果 INCR 返回的是 1，说明这是这个时间窗口内的第一次请求。这时候必须立刻给它设置过期时间！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; EXPIRE <span class="hljs-built_in">limit</span>:192.168.1.5 60<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p><em>(这意味着：60秒后，计数器归零&#x2F;消失)</em></p><p>步骤 3：后续请求继续计数.第二次请求来了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; INCR <span class="hljs-built_in">limit</span>:192.168.1.5<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><p>第十次请求来了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; INCR <span class="hljs-built_in">limit</span>:192.168.1.5<br>(<span class="hljs-built_in">integer</span>) 10<br></code></pre></td></tr></table></figure><p>步骤 4：判定拦截。第十一次请求来了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; INCR <span class="hljs-built_in">limit</span>:192.168.1.5<br>(<span class="hljs-built_in">integer</span>) 11<br></code></pre></td></tr></table></figure><p><strong>逻辑判断：</strong> 代码拿到返回值 <strong>11</strong>，发现大于 10，于是直接返回错误提示“访问过于频繁，请稍后再试”。</p><hr><p>设计测试用例:</p><table><thead><tr><th><strong>测试点</strong></th><th><strong>操作步骤</strong></th><th><strong>预期结果（断言）</strong></th></tr></thead><tbody><tr><td><strong>正常场景</strong></td><td>发送第 1 次请求</td><td>接口返回 200，Redis 中 key 存在，TTL 约为 60s。</td></tr><tr><td><strong>边界值（上边界）</strong></td><td>连续发送 10 次请求</td><td>第 10 次请求依然成功。</td></tr><tr><td><strong>异常场景（拦截）</strong></td><td>发送第 11 次请求</td><td><strong>接口报错</strong>（如 429 Too Many Requests），Redis 计数器显示 11。</td></tr><tr><td><strong>过期重置</strong></td><td>等待 61 秒后，再次发送请求</td><td>请求成功！Redis 计数器重新变为 1（而不是 12）。</td></tr></tbody></table><p><strong>问：</strong> “如果在第 59 秒发了第 1 个请求，第 61 秒发了第 2 个请求，会怎么样？” </p><p><strong>回答：</strong> 按照刚才的逻辑，第 59 秒生成的 key 会在第 119 秒才过期。这其实是“固定窗口”限流的一个小缺陷（不够平滑），但在简单场景下是可接受的。可以用滑动窗口解决</p><hr><h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h1><p>最适合存储**“用户信息”、“商品详情”**的数据结构：<strong>Hash</strong></p><p>可以把 Redis 的 Hash 想象成 Python 里的 <strong>字典 (Dict)</strong> 或者 Java 里的 <strong>Map</strong>。 结构大概是这样：<code>Key -&gt; &#123; field1: value1, field2: value2 &#125;</code></p><p>假设要存一个用户的信息（ID: 1001, 名字: LilPear, 年龄: 22）。</p><ul><li><strong>用 String (这就很麻烦):</strong> 得把 key 定义为 <code>user:1001:name</code> 存一个，<code>user:1001:age</code> 再存一个。这会让 key 非常多，乱糟糟的。</li><li><strong>用 Hash (这就很整洁):</strong> 只要一个 key <code>user:1001</code>，里面包含 <code>name</code> 和 <code>age</code> 两个字段。</li></ul><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>用法</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>测开实战用途</strong></th></tr></thead><tbody><tr><td align="center"><strong>HSET</strong></td><td align="center"><code>HSET key field value</code></td><td align="center">存入一个字段</td><td align="center">修改用户的某个特定属性（比如只改名）。</td></tr><tr><td align="center"><strong>HGET</strong></td><td align="center"><code>HGET key field</code></td><td align="center">获取一个字段</td><td align="center">验证刚才改的名对不对。</td></tr><tr><td align="center"><strong>HGETALL</strong></td><td align="center"><code>HGETALL key</code></td><td align="center"><strong>获取所有字段</strong></td><td align="center"><strong>最常用！</strong> 一次性拉取用户所有信息进行校验。</td></tr><tr><td align="center"><strong>HDEL</strong></td><td align="center"><code>HDEL key field</code></td><td align="center">删除某字段</td><td align="center">测试“解绑手机号”功能，字段是否被删除。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; hset user:888 <span class="hljs-built_in">id</span>:101 1<br>1 <span class="hljs-comment"># 返回 1：代表新建了一个字段（之前没有）</span><br><br>&gt; hset user:888 <span class="hljs-built_in">id</span>:102 5<br>1<br><br>&gt; hget user:888 <span class="hljs-built_in">id</span>:102<br>5<br><br>&gt; hget user:888<br>ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;hget&#x27;</span> <span class="hljs-built_in">command</span> <span class="hljs-comment"># HGET 是精准查询，必须告诉它你要查“哪个 key”里的“哪个 field”</span><br><br>&gt; hset user:888 <span class="hljs-built_in">id</span>:102 4<br>0 <span class="hljs-comment"># 返回 0：代表更新了一个字段（之前有，现在值变了）</span><br><br>&gt; hgetall user:888<br><span class="hljs-built_in">id</span>:101<br>1<br><span class="hljs-built_in">id</span>:102<br>4<br></code></pre></td></tr></table></figure><hr><h1 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h1><p>这是一个与顺序有关的数据结构。List 最常用的场景是：</p><ol><li><strong>消息队列 (Message Queue)：</strong> 比如“削峰填谷”，大量请求排队处理。</li><li><strong>最新列表：</strong> 比如“朋友圈最新的 10 条动态”、“用户最近浏览记录”。</li></ol><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>记忆口诀</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>测开实战用途</strong></th></tr></thead><tbody><tr><td align="center"><strong>LPUSH</strong></td><td align="center"><strong>L</strong>eft Push</td><td align="center">从<strong>左边</strong>塞入数据</td><td align="center">模拟新消息入队。</td></tr><tr><td align="center"><strong>RPUSH</strong></td><td align="center"><strong>R</strong>ight Push</td><td align="center">从<strong>右边</strong>塞入数据</td><td align="center">模拟正常排队（先来后到）。</td></tr><tr><td align="center"><strong>LPOP</strong></td><td align="center"><strong>L</strong>eft Pop</td><td align="center">从<strong>左边</strong>弹出数据</td><td align="center">验证消费者是否取出了最早的消息。</td></tr><tr><td align="center"><strong>RPOP</strong></td><td align="center"><strong>R</strong>ight Pop</td><td align="center">从<strong>右边</strong>弹出数据</td><td align="center">同上，看业务逻辑是从哪边取。</td></tr><tr><td align="center"><strong>LRANGE</strong></td><td align="center"><strong>L</strong>-Range</td><td align="center">查看一段范围内的数据</td><td align="center"><strong>最常用！</strong> 验证“最近浏览记录”的顺序对不对。</td></tr></tbody></table><p>场景：展示“最近浏览的 3 个商品”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; lpush <span class="hljs-built_in">history</span>:user1 <span class="hljs-string">&quot;apple&quot;</span><br>1<br><br>&gt; lpush <span class="hljs-built_in">history</span>:user1 <span class="hljs-string">&quot;banana&quot;</span><br>2<br><br>&gt; lpush <span class="hljs-built_in">history</span>:user1 <span class="hljs-string">&quot;orange&quot;</span><br>3<br><br>&gt; lrange <span class="hljs-built_in">history</span>:user1 0 2<br>orange<br>banana<br>apple<br><br>&gt; lpush <span class="hljs-built_in">history</span>:user1 <span class="hljs-string">&quot;grape&quot;</span><br>4<br><br>&gt; lrange <span class="hljs-built_in">history</span>:user1 0 2<br>grape<br>orange<br>banana<br><br>&gt; rpop <span class="hljs-built_in">history</span>:user1<br>apple<br></code></pre></td></tr></table></figure><hr><h1 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h1><p>List 是有序的（像排队），但有时候需要存一堆**“不分前后、而且绝对不能重复”**的东西，比如：</p><ul><li><strong>抽奖名单</strong>（一个人不能占两个名额）。</li><li><strong>点赞用户</strong>（一个人只能给文章点一次赞）。</li><li><strong>共同好友</strong>（你和他的交集）。</li></ul><p>这时候，<strong>Set</strong> 就是最好的选择。它就像一个神奇的袋子，不管你往里面扔多少个同样的硬币，它最后只保留一个</p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>用法</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>测开实战用途</strong></th></tr></thead><tbody><tr><td align="center"><strong>SADD</strong></td><td align="center"><code>SADD key value</code></td><td align="center">添加元素</td><td align="center"><strong>返回值关键！</strong> 返回 1 表示添加成功，返回 0 表示已存在（重复）。</td></tr><tr><td align="center"><strong>SMEMBERS</strong></td><td align="center"><code>SMEMBERS key</code></td><td align="center">查看所有元素</td><td align="center">验证数据是否都在，注意：<strong>显示的顺序可能是乱的</strong>。</td></tr><tr><td align="center"><strong>SISMEMBER</strong></td><td align="center"><code>SISMEMBER key value</code></td><td align="center">判断是否存在</td><td align="center">测试“黑名单”功能，查用户是否在黑名单里。</td></tr><tr><td align="center"><strong>SREM</strong></td><td align="center"><code>SREM key value</code></td><td align="center">删除元素</td><td align="center">测试“取消关注”或“取消点赞”。</td></tr><tr><td align="center"><strong>SCARD</strong></td><td align="center"><code>SCARD key</code></td><td align="center">统计个数</td><td align="center">验证“文章总点赞数”对不对。</td></tr></tbody></table><p><strong>场景：</strong> 测试一个文章点赞功能，要求同一用户不能重复点赞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SADD like:article:100 <span class="hljs-string">&quot;user_a&quot;</span><br>1<br><br>&gt; SADD like:article:100 <span class="hljs-string">&quot;user_b&quot;</span><br>1<br><br>&gt; SADD like:article:100 <span class="hljs-string">&quot;user_a&quot;</span><br>0 <span class="hljs-comment"># 返回 0，说明 Redis 内部拦截了这次写入。如果接口返回“点赞成功”，说明后端代码没判断这个返回值，那就是 Bug！</span><br><br>&gt; SCARD like:article:100<br>2<br></code></pre></td></tr></table></figure><img src="/2025/12/22/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.jpg" class="" title="Set集合运算"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; sadd my_friends <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-string">&quot;B&quot;</span> <span class="hljs-string">&quot;C&quot;</span><br>3<br><br>&gt; sadd your_friends <span class="hljs-string">&quot;B&quot;</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;D&quot;</span><br>3<br><br>&gt; SINTER my_friends your_friends <span class="hljs-comment"># 共同好友（交集）</span><br>B<br>C<br><br>&gt; SDIFF my_friends your_friends <span class="hljs-comment"># 找不同（差集）</span><br>A<br></code></pre></td></tr></table></figure><hr><h1 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h1><p>ZSet是有序集合，其既有 Set 的“去重”特性，又有 List 的“排序”特性，但它的排序是靠**“分数（Score）”**来决定的。最经典的应用场景是排行榜</p><p>ZSet 里的每个元素都有两个属性：</p><ol><li><strong>Member (成员)</strong>：这就是具体的数据（比如用户 ID），<strong>必须唯一</strong>（像 Set 一样）。</li><li><strong>Score (分数)</strong>：这是排序的依据（比如考试成绩、销售额、时间戳），可以重复。</li></ol><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>用法</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>测开实战用途</strong></th></tr></thead><tbody><tr><td align="center"><strong>ZADD</strong></td><td align="center"><code>ZADD key score member</code></td><td align="center">添加&#x2F;更新元素</td><td align="center">设置初始排名数据。</td></tr><tr><td align="center"><strong>ZRANGE</strong></td><td align="center"><code>ZRANGE key 0 -1</code></td><td align="center"><strong>从小到大</strong>查所有</td><td align="center">验证数据是否按“分数低到高”排列。</td></tr><tr><td align="center"><strong>ZREVRANGE</strong></td><td align="center"><code>ZREVRANGE key 0 -1</code></td><td align="center"><strong>从大到小</strong>查所有</td><td align="center"><strong>最常用！</strong> 验证排行榜（谁第一名）。</td></tr><tr><td align="center"><strong>ZSCORE</strong></td><td align="center"><code>ZSCORE key member</code></td><td align="center">查看具体分数</td><td align="center">验证某个用户的积分是否更新正确。</td></tr><tr><td align="center"><strong>ZINCRBY</strong></td><td align="center"><code>ZINCRBY key increment member</code></td><td align="center">给某人加分</td><td align="center">测试“打怪加分”或“充值升级”功能。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; ZADD ranking 50 <span class="hljs-string">&quot;shop:A&quot;</span><br>1<br><br>&gt; ZADD ranking 80 <span class="hljs-string">&quot;shop:B&quot;</span><br>1<br><br>&gt; ZADD ranking 30 <span class="hljs-string">&quot;shop:C&quot;</span><br>1<br><br>&gt; ZRANGE ranking 0 -1<br>shop:C<br>shop:A<br>shop:B<br><br>&gt; ZREVRANGE ranking 0 -1 WITHSCORES<br>shop:B<br>80<br>shop:A<br>50<br>shop:C<br>30<br><br>&gt; ZINCRBY ranking 100 <span class="hljs-string">&quot;shop:C&quot;</span><br>130<br><br>&gt; ZREVRANGE ranking 0 0<br>shop:C<br></code></pre></td></tr></table></figure><hr><h1 id="Python操作redis"><a href="#Python操作redis" class="headerlink" title="Python操作redis"></a>Python操作redis</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis<br><br><span class="hljs-comment"># 1. 建立连接</span><br><span class="hljs-comment"># host: 本地就是 localhost 或 127.0.0.1</span><br><span class="hljs-comment"># decode_responses=True: 关键！让 Redis 返回字符串而不是字节(bytes)</span><br>r = redis.Redis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, decode_responses=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 2. 测试连接</span><br><span class="hljs-keyword">try</span>:<br>    response = r.ping()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接成功！Redis 返回: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Python 里的函数名和 Redis 的命令几乎是一模一样的，非常好记</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 连接</span><br>r = redis.Redis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, decode_responses=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_type</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 开始测试 String 类型 ---&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 数据准备 (Set)</span><br>    r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;user:token&quot;</span>, <span class="hljs-string">&quot;abcdefg&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 设置过期时间 (Expire) - 模拟 5 秒后过期</span><br>    r.expire(<span class="hljs-string">&quot;user:token&quot;</span>, <span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 3. 验证数据 (Get &amp; Assert)</span><br>    token = r.get(<span class="hljs-string">&quot;user:token&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前 Token: <span class="hljs-subst">&#123;token&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 测开必备：断言</span><br>    <span class="hljs-keyword">assert</span> token == <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-string">&quot;Token 内容不匹配！&quot;</span><br><br>    <span class="hljs-comment"># 4. 验证过期 (TTL)</span><br>    ttl = r.ttl(<span class="hljs-string">&quot;user:token&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;剩余时间: <span class="hljs-subst">&#123;ttl&#125;</span> 秒&quot;</span>)<br>    <span class="hljs-keyword">assert</span> ttl &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;过期时间未生效！&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;String 测试通过！✅&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_list_type</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 开始测试 List 类型 ---&quot;</span>)<br><br>    <span class="hljs-comment"># 清理旧数据（防止上次运行的数据干扰本次测试）</span><br>    r.delete(<span class="hljs-string">&quot;my_task_queue&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 模拟入队 (RPush)</span><br>    r.rpush(<span class="hljs-string">&quot;my_task_queue&quot;</span>, <span class="hljs-string">&quot;task_1&quot;</span>, <span class="hljs-string">&quot;task_2&quot;</span>, <span class="hljs-string">&quot;task_3&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 模拟出队 (LPop)</span><br>    task = r.lpop(<span class="hljs-string">&quot;my_task_queue&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;处理了任务: <span class="hljs-subst">&#123;task&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 3. 断言：先进先出，第一个应该是 task_1</span><br>    <span class="hljs-keyword">assert</span> task == <span class="hljs-string">&quot;task_1&quot;</span>, <span class="hljs-string">f&quot;顺序错误！取出的竟然是 <span class="hljs-subst">&#123;task&#125;</span>&quot;</span><br><br>    <span class="hljs-comment"># 4. 查剩余长度 (LLen)</span><br>    remaining = r.llen(<span class="hljs-string">&quot;my_task_queue&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;队列还剩 <span class="hljs-subst">&#123;remaining&#125;</span> 个任务&quot;</span>)<br>    <span class="hljs-keyword">assert</span> remaining == <span class="hljs-number">2</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;List 测试通过！✅&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_hash_type</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 测试 Hash 类型 ---&quot;</span>)<br><br>    r.delete(<span class="hljs-string">&quot;user:888&quot;</span>)<br><br>    r.hset(<span class="hljs-string">&quot;user:888&quot;</span>, <span class="hljs-string">&quot;id:101&quot;</span>, <span class="hljs-number">1</span>)<br>    r.hset(<span class="hljs-string">&quot;user:888&quot;</span>, <span class="hljs-string">&quot;id:102&quot;</span>, <span class="hljs-number">5</span>)<br>    id_102 = r.hget(<span class="hljs-string">&quot;user:888&quot;</span>, <span class="hljs-string">&quot;id:102&quot;</span>)<br>    <span class="hljs-keyword">assert</span> id_102 == <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">f&quot;Hash 值错误，预期 5，实际 <span class="hljs-subst">&#123;id_102&#125;</span>&quot;</span><br><br>    r.hset(<span class="hljs-string">&quot;user:888&quot;</span>, <span class="hljs-string">&quot;id:102&quot;</span>, <span class="hljs-number">4</span>)<br><br>    id_102 = r.hget(<span class="hljs-string">&quot;user:888&quot;</span>, <span class="hljs-string">&quot;id:102&quot;</span>)<br>    <span class="hljs-keyword">assert</span> id_102 == <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">f&quot;Hash 值错误，预期 4，实际 <span class="hljs-subst">&#123;id_102&#125;</span>&quot;</span><br><br>    user_888 = r.hgetall(<span class="hljs-string">&quot;user:888&quot;</span>)<br>    <span class="hljs-keyword">assert</span> user_888 == &#123;<span class="hljs-string">&#x27;id:101&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;id:102&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span>&#125;, <span class="hljs-string">f&quot;Hash 内容错误，实际 <span class="hljs-subst">&#123;user_888&#125;</span>&quot;</span><br><br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> user_888.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hash 测试通过！✅&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_string_type()<br>    test_list_type()<br>    test_hash_type()<br></code></pre></td></tr></table></figure><hr><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 是内存数据库，内存有个特点：<strong>断电即失</strong>。 为了保证数据安全，Redis 提供了两种把数据“存到硬盘”的方法：<strong>RDB</strong> 和 <strong>AOF</strong></p><table><thead><tr><th align="center"><strong>特性</strong></th><th align="center"><strong>RDB (Redis Database)</strong></th><th align="center"><strong>AOF (Append Only File)</strong></th></tr></thead><tbody><tr><td align="center"><strong>比喻</strong></td><td align="center"><strong>“拍照”</strong></td><td align="center"><strong>“记日记”</strong></td></tr><tr><td align="center"><strong>原理</strong></td><td align="center">每隔一段时间（比如 1 小时），把内存里所有数据生成一个快照文件 (<code>dump.rdb</code>)。</td><td align="center">你每执行一条写命令（set&#x2F;hset），它就立马追加写到日志文件 (<code>appendonly.aof</code>) 里。</td></tr><tr><td align="center"><strong>优点</strong></td><td align="center">恢复速度快（直接加载文件），文件小。</td><td align="center"><strong>数据更安全</strong>，最多只丢 1 秒的数据。</td></tr><tr><td align="center"><strong>缺点</strong></td><td align="center"><strong>容易丢数据</strong>。如果两次拍照之间宕机了，这期间的数据全没了。</td><td align="center">文件很大，恢复速度慢。</td></tr></tbody></table><p><strong>测试 RDB：</strong> 验证在没有触发快照时宕机，数据是否会丢失（预期是会丢失）。</p><p><strong>测试 AOF：</strong> 验证开启 AOF 后，即使宕机，数据是否大部分都能找回。</p><p>问：<strong>“如何测试 Redis 的持久化配置是否生效？”</strong></p><p><strong>答：</strong></p><blockquote><p>“设计一个<strong>破坏性测试</strong>。</p><ol><li>首先写入一组特定数据。</li><li>根据配置的策略（比如 RDB 的时间间隔），等待或手动触发保存，或者确认 AOF 已开启。</li><li><strong>模拟异常断电</strong>（kill 进程）。</li><li>重启 Redis 服务。</li><li><strong>自动化脚本断言</strong>：对比重启前后的数据。如果是 RDB，允许丢失少量近期数据；如果是 AOF，数据应该基本完整。”</li></ol></blockquote><hr><h1 id="雪崩、穿透、击穿"><a href="#雪崩、穿透、击穿" class="headerlink" title="雪崩、穿透、击穿"></a>雪崩、穿透、击穿</h1><h2 id="1-缓存穿透-Cache-Penetration-——-“无中生有”"><a href="#1-缓存穿透-Cache-Penetration-——-“无中生有”" class="headerlink" title="1. 缓存穿透 (Cache Penetration) —— “无中生有”"></a>1. 缓存穿透 (Cache Penetration) —— “无中生有”</h2><ul><li><strong>现象：</strong> 用户一直在请求一个<strong>根本不存在的数据</strong>（比如 <code>id = -9999</code>）。</li><li><strong>后果：</strong> Redis 查不到（Cache Miss），请求就会“穿透”Redis，直接打到数据库（DB）上。如果有黑客用脚本疯狂请求不存在的 ID，数据库会瞬间挂掉。</li><li><strong>测开视角：</strong><ul><li><strong>用例设计：</strong> 构造大量<strong>非法 ID</strong>（负数、超长字符串、随机 UUID）发起请求。</li><li><strong>断言：</strong> 监控数据库的查询量（QPS）。如果 DB 查询量暴增，说明存在穿透风险。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>缓存空对象：</strong> 即使数据库没查到，也在 Redis 里存一个 <code>null</code> 或 <code>key: -1</code>，并设置较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)：</strong> 一种高级算法，在请求到达 Redis 前先判断“这东西肯定不存在”。</li></ul></li></ul><hr><h2 id="2-缓存击穿-Cache-Breakdown-——-“集火攻击”"><a href="#2-缓存击穿-Cache-Breakdown-——-“集火攻击”" class="headerlink" title="2. 缓存击穿 (Cache Breakdown) —— “集火攻击”"></a>2. 缓存击穿 (Cache Breakdown) —— “集火攻击”</h2><ul><li><strong>现象：</strong> 针对<strong>某一个</strong>非常“热点”的 Key，它在 Redis 中<strong>刚好过期</strong>的那一瞬间。</li><li><strong>后果：</strong> 这一瞬间，成千上万的并发请求同时发现 Redis 没数据，于是全部同时冲向数据库。数据库瞬间被打死。 </li><li><strong>关键词：</strong> <strong>单一热点 Key</strong>、<strong>过期瞬间</strong>。</li><li><strong>测开视角：</strong><ul><li><strong>用例设计：</strong> 人为让某个热点 Key 过期，然后立即使用并发工具（如 JMeter 或 Python 多线程）模拟高并发读取该 Key。</li><li><strong>断言：</strong> 检查数据库日志，理论上应该只有<strong>1 次</strong>查询（因为开发应该加锁），如果发现有 1000 次查询，就是 Bug。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>互斥锁（Mutex Lock）：</strong> 当第一个线程发现 Redis 没数据时，先<strong>加把锁</strong>，再去查 DB 并回写 Redis。锁必须有过期时间，要测试死锁。</li><li><strong>逻辑：</strong> 后面来的 1000 个线程发现锁被人拿了，就乖乖排队等待（或者休眠 50ms 后重试），直到第一个人把数据写回 Redis。</li></ul></li></ul><hr><h2 id="3-缓存雪崩-Cache-Avalanche-——-“全线崩塌”"><a href="#3-缓存雪崩-Cache-Avalanche-——-“全线崩塌”" class="headerlink" title="3. 缓存雪崩 (Cache Avalanche) —— “全线崩塌”"></a>3. 缓存雪崩 (Cache Avalanche) —— “全线崩塌”</h2><ul><li><strong>现象：</strong><ol><li>Redis 里的<strong>大量 Key 在同一时间集体过期</strong>。</li><li>或者 Redis 服务直接<strong>宕机</strong>了。</li></ol></li><li><strong>后果：</strong> 所有请求瞬间全部打到数据库，数据库直接崩溃，像雪崩一样。</li><li><strong>测开视角：</strong><ul><li><strong>用例设计：</strong> 检查开发设置的过期时间。</li><li><strong>Code Review &#x2F; 静态扫描：</strong> 这里的 TTL（过期时间）是不是固定的 600 秒？有没有加随机值？</li><li><strong>断言：</strong> 如果代码里写死了 <code>expire(600)</code>，这就是 Bug！建议修改为 <code>expire(600 + random(10, 50))</code>。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>随机 TTL：</strong> 给原本固定的过期时间（比如 10 分钟）加上一个随机值（比如 1-60 秒），让它们分散过期。</li><li><strong>高可用架构：</strong> 使用 Redis Sentinel（哨兵）或 Cluster（集群），保证一台 Redis 挂了，备胎能立马顶上。</li></ul></li></ul><hr><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>当两个客户端同时想修改同一个数据（比如抢同一张票），就需要“锁”来解决并发冲突。</p><h2 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁 (Optimistic Locking)"></a>乐观锁 (Optimistic Locking)</h2><ul><li><strong>原理：</strong> 不是真的锁住数据，但会在更新前<strong>检查一下</strong>。</li><li><strong>实现方式：</strong> Redis 使用 <code>WATCH</code> 命令。<ul><li>逻辑：看一眼 <code>ticket</code> 库存是 1 -&gt; 开启事务 -&gt; 准备改成 0 -&gt; <strong>提交时再次检查</strong> <code>ticket</code> 还是不是 1？如果是，提交成功；如果变了（被别人改了），提交失败。</li></ul></li><li><strong>适用场景：</strong> 读多写少（冲突概率低）。</li><li><strong>测开视角：</strong> 测试并发修改同一数据时，是否只有一个能成功，其他的必须报错或重试。</li></ul><h2 id="分布式锁-Distributed-Lock"><a href="#分布式锁-Distributed-Lock" class="headerlink" title="分布式锁 (Distributed Lock)"></a>分布式锁 (Distributed Lock)</h2><ul><li><strong>背景：</strong> 后端服务可能部署在 10 台服务器上。Java 内部的锁锁不住别的机器，必须用 Redis 这种外部组件来做**“全局锁”**。</li><li><strong>核心原理：</strong> <code>SETNX</code> (Set If Not Exists)。<ul><li>谁能把 <code>lock_key</code> 写入 Redis，谁就拿到了锁。</li><li>用完必须删除 <code>DEL lock_key</code>。</li></ul></li><li><strong>关键痛点（Redlock）：</strong> 如果为了极致安全（防止 Redis 节点挂了锁丢失），会用 Redlock 算法（同时向多个 Redis 实例加锁），比较复杂。</li><li><strong>测开视角：</strong><ul><li><strong>TTL 测试：</strong> 如果持有锁的服务直接断电，锁会不会自动过期？（如果不自动过期，系统就死锁了，这是 P0 级 Bug）。</li></ul></li></ul><hr><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p>Redis 的单个命令（如 <code>GET</code>, <code>SET</code>）是原子的，但<strong>组合命令</strong>不是。</p><p>场景：想实现“如果库存 &gt; 0，则库存 - 1”。这需要 <code>GET</code> 然后 <code>DECR</code>。在高并发下，可能两个线程同时 <code>GET</code> 到 1，然后都减成 0，实际卖了 2 个。</p><p><strong>Lua 的作用：</strong></p><ul><li>Redis 允许你把这几步逻辑写成一段 Lua 脚本。</li><li>Redis 承诺：<strong>执行这段脚本时，绝对不会插队处理其他人的命令。</strong> 脚本执行是彻彻底底的原子操作。</li></ul><p><strong>测开视角：</strong></p><ul><li>如果业务用了 Lua，并发安全性通常较高。</li><li>需要关注<strong>性能</strong>：Lua 脚本逻辑不能太复杂（比如写了死循环），否则整个 Redis 会卡死，所有请求都进不来。</li></ul><hr><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>就像去星巴克，点完单拿到小票（入队），然后去旁边等，咖啡师做好了叫号（出队）。</p><p><strong>Redis 实现方式：</strong></p><ul><li><strong>List (最简单)：</strong> <code>LPUSH</code> 生产消息，<code>BRPOP</code> (阻塞式读取) 消费消息。</li><li><strong>Pub&#x2F;Sub (发布订阅)：</strong> 像是广播，发一条消息，所有在线的监听者都能收到（但消息不持久化，发完就丢）。</li><li><strong>Stream (专业级)：</strong> Redis 5.0 引入的，模仿 Kafka，支持分组消费、消息确认（ACK），数据更安全。</li></ul><p><strong>优缺点：</strong></p><ul><li><em>优点：</em> 轻量、部署简单（不需要单独装 Kafka）。</li><li><em>缺点：</em> 极端情况下可能丢消息；如果堆积的数据太多，Redis 内存会爆。</li></ul><p><strong>测开视角：</strong></p><ul><li><strong>积压测试：</strong> 往队列里疯狂灌数据，但不开启消费者，看 Redis 内存会不会爆。</li><li><strong>丢失测试：</strong> 消费者处理一半挂了，这条消息是丢了还是能被别人重新处理？（List 会丢，Stream 可以配置为不丢）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
      <tag>键值对</tag>
      
      <tag>击穿</tag>
      
      <tag>雪崩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础学习</title>
    <link href="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Docker能快速搭建测试环境、在 CI&#x2F;CD 流水线中运行自动化脚本（如 Pytest, Selenium 等）。</p><p>以前部署环境常用<strong>虚拟机（VM）</strong>。虚拟机像是一套完整的房子（有独立的地基、水电、操作系统），很重，启动慢。</p><p><strong>Docker（容器）</strong> 像是胶囊旅馆的床位。大家共用一栋大楼（宿主机内核），但每个床位（容器）内部又是独立的。它<strong>轻量、启动秒级、随用随扔</strong>。</p><ul><li><strong>镜像 (Image)：</strong><ul><li><strong>比喻：</strong> 它是<strong>类 (Class)</strong> 或者 <strong>游戏光盘</strong>。</li><li><strong>解释：</strong> 它是一个只读的模板，里面包含了运行程序所需的一切（代码、运行时、库、环境变量）。镜像本身是不会动的。</li></ul></li><li><strong>容器 (Container)：</strong><ul><li><strong>比喻：</strong> 它是<strong>对象 (Object)</strong> 或者 <strong>运行中的游戏</strong>。</li><li><strong>解释：</strong> 它是镜像运行起来的实例。你可以通过一个镜像启动 10 个不同的容器。你在容器里做的修改（比如生成了测试报告），如果不保存，容器删除后文件就没了。</li></ul></li><li><strong>仓库 (Repository)：</strong><ul><li><strong>比喻：</strong> 它是 <strong>GitHub</strong> 或者 <strong>App Store</strong>。</li><li><strong>解释：</strong> 用来存放镜像的地方。最常用的是 Docker Hub。</li></ul></li></ul><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="docker基础"><hr><p><strong>Linux 上运行 Docker：</strong></p><ul><li><strong>原生模式 (Native)：</strong> Docker 诞生于 Linux，它直接使用 Linux 内核的特性（Cgroups, Namespaces）。</li><li><strong>性能：</strong> 没有任何中间层，性能损耗几乎为零，效率最高。</li><li><strong>场景：</strong> 生产环境（服务器）几乎全是 Linux。</li></ul><p><strong>Windows 上运行 Docker：</strong></p><ul><li><strong>虚拟化模式：</strong> 绝大多数 Docker 容器里的软件（比如 Nginx, MySQL, Python）都是基于 <strong>Linux</strong> 开发的。Windows 的内核和 Linux 不兼容，无法直接运行这些容器。</li><li><strong>解决方案：</strong> Docker 必须在 Windows 上先创建一个<strong>微型的 Linux 虚拟机</strong>（现在通常通过 <strong>WSL 2</strong> 技术实现），然后在这个微型 Linux 里运行容器。</li><li><strong>场景：</strong> 办公电脑、开发调试环境。</li></ul><hr><h2 id="Docker-Desktop"><a href="#Docker-Desktop" class="headerlink" title="Docker Desktop"></a>Docker Desktop</h2><p>在 Linux 服务器上，我们通常只安装一个黑黑的命令行工具（Docker Engine）。但在 Windows&#x2F;Mac 上，Docker 官方推出了 Docker Desktop。</p><p>它包含了以下内容：</p><ol><li><strong>Docker Engine：</strong> 核心引擎。</li><li><strong>Docker CLI：</strong> 敲命令用的客户端（<code>docker run ...</code>）。</li><li><strong>虚拟化管理（WSL 2）：</strong> 它会自动配置好那个“微型 Linux”，感觉不到虚拟机的存在。</li><li><strong>GUI 图形界面：</strong> 一个可视化的面板，可以用鼠标点点点来查看有哪些容器在跑，查看日志，停止容器（这对新手非常友好）。</li><li><strong>Kubernetes：</strong> 它甚至内置了一个单节点的 K8s 集群供学习。</li></ol><p><strong>一句话总结：</strong> Docker Desktop 帮你在 Windows 上模拟了一个 Linux 环境，能无缝使用 Docker。</p><hr><h3 id="需要注意的“实战坑”-Interview-Key-Points"><a href="#需要注意的“实战坑”-Interview-Key-Points" class="headerlink" title="需要注意的“实战坑” (Interview Key Points)"></a>需要注意的“实战坑” (Interview Key Points)</h3><p>因为底层实现的差异，你在 Windows 上写测试脚本时，主要会遇到以下两个区别：</p><h4 id="A-文件路径的挂载-Volume-Mapping"><a href="#A-文件路径的挂载-Volume-Mapping" class="headerlink" title="A. 文件路径的挂载 (Volume Mapping)"></a>A. 文件路径的挂载 (Volume Mapping)</h4><p>这是最常见的坑。假设想把电脑里的测试报告映射到容器里。</p><ul><li><strong>Linux:</strong> 路径是 <code>/home/user/project/report</code></li><li><strong>Windows:</strong> 路径是 <code>D:\project\report</code></li><li><strong>问题：</strong> 如果你的测试脚本里写死了 Windows 风格的路径（带盘符），部署到 Linux 服务器上肯定报错。</li><li><strong>解决：</strong> 尽量使用<strong>相对路径</strong>，或者使用 Docker 提供的路径转换格式（例如 <code>/d/project/report</code>）。</li></ul><h4 id="B-网络模式-Networking"><a href="#B-网络模式-Networking" class="headerlink" title="B. 网络模式 (Networking)"></a>B. 网络模式 (Networking)</h4><ul><li><strong>Linux:</strong> 支持 <code>host</code> 模式（容器和宿主机共用网络，IP 一样）。这在做性能测试时很有用。</li><li><strong>Windows:</strong> 由于中间隔了一层 WSL 2 虚拟机，<code>host</code> 模式通常<strong>不生效</strong>，或者表现和 Linux 不一致。</li><li><strong>影响：</strong> 如果在本地用 <code>host</code> 模式调试通了，不要理所当然地认为它和服务器表现一致。在 Windows 上主要使用 <code>bridge</code> 模式（端口映射）。</li></ul><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="docker常用命令"><p>以Nginx为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx<br></code></pre></td></tr></table></figure><p>执行完后，电脑里现在已经有了 Nginx 的<strong>镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name my-nginx -p 8080:80 nginx<br></code></pre></td></tr></table></figure><p>执行后，会看到一长串字符（这是容器的唯一 ID）。这行命令虽然短，但包含了三个核心概念：</p><ol><li><strong><code>-d</code> (Detached)</strong>：<strong>后台运行</strong>。<ul><li>如果不加这个，Nginx 的日志会直接霸占终端窗口，你按 <code>Ctrl+C</code> 退出时容器也就挂了。加上 <code>-d</code>，它就在后台默默工作（就像服务的守护进程）。</li></ul></li><li><strong><code>--name my-nginx</code></strong>：<strong>起个名字</strong>。<ul><li>如果不写，Docker 会随机给它起个怪名（比如 <code>angry_torvalds</code>）。起个好记的名字方便后续管理。</li></ul></li><li><strong><code>-p 8080:80</code> (Port Mapping)</strong>：<strong>端口映射</strong>（<strong>最重要！</strong>）。<ul><li><strong>冒号左边是宿主机，右边是容器内部</strong>。</li><li><strong>容器内部：</strong> Nginx 默认监听 <code>80</code> 端口。</li><li><strong>宿主机：</strong> 把 Windows 的 <code>8080</code> 端口和容器的 <code>80</code> 连通了。</li><li><strong>结果：</strong> 访问电脑的 8080，实际上就是访问容器里的 80</li></ul></li></ol><p>查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><p>STATUS 显示 <code>Up ... seconds</code>，说明它活着。浏览器访问：<a href="http://localhost:8080/">http://localhost:8080</a></p><p><strong>看到 “Welcome to nginx!” 的白色页面</strong></p><hr><h1 id="数据卷与挂载"><a href="#数据卷与挂载" class="headerlink" title="数据卷与挂载"></a>数据卷与挂载</h1><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是 <strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong></p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>容器是一个封闭的盒子，里面的文件我们看不见摸不着。 <strong>挂载</strong> 就像是在你的 Windows 文件夹和 容器里的文件夹 之间开了一个 <strong>“虫洞”</strong>。 你在 Windows 文件夹里放什么，容器里立马就能看到什么！</p><p>实战操作一下，把 Nginx 的欢迎页换成自己写的一句话。</p><h4 id="1-准备工作（-Windows-）"><a href="#1-准备工作（-Windows-）" class="headerlink" title="1. 准备工作（ Windows ）"></a>1. 准备工作（ Windows ）</h4><ol><li><p>新建文件夹：<code>D:\Workspace\docker_study</code></p></li><li><p>在里面新建一个文本文档，重命名为 <code>index.html</code>。</p></li><li><p>用记事本打开它，随便写点什么，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Docker Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Docker! 我是未来的测开大神！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="2-清理旧容器"><a href="#2-清理旧容器" class="headerlink" title="2. 清理旧容器"></a>2. 清理旧容器</h4><p>Docker 有个规则：<strong>同一个名字的容器只能有一个</strong>。 刚才已经用过 <code>my-nginx</code> 这个名字了，所以要启动新的，必须先删掉旧的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f my-nginx<br></code></pre></td></tr></table></figure><p><em>(注：<code>-f</code> 是 force 强制删除，不管它是不是在运行，直接干掉。)</em></p><h4 id="3-启动带“挂载”的新容器"><a href="#3-启动带“挂载”的新容器" class="headerlink" title="3. 启动带“挂载”的新容器"></a>3. 启动带“挂载”的新容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name my-nginx -p 8080:80 -v D:\docker-study:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><p><strong>这条命令多了一个核心参数：</strong></p><ul><li><strong><code>-v D:\docker-study:/usr/share/nginx/html</code></strong><ul><li><strong>冒号左边：</strong> Windows 上的文件夹路径。</li><li><strong>冒号右边：</strong> 容器里的 Nginx 存放网页的默认路径（这是 Nginx 规定的）。</li><li><strong>含义：</strong> 强行把容器里的那个网页目录，替换成 D 盘的文件夹。</li></ul></li></ul><p>现在，浏览器刷新 <strong><a href="https://www.google.com/search?q=http://localhost:8080&authuser=1">http://localhost:8080</a></strong>。<strong>看到的不再是 “Welcome to nginx”，而是刚才写的那句 “我是未来的测开大神”！</strong></p><p>这种方式是直接将容器目录与宿主机指定目录挂载，有一个缺点：直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</p><hr><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><strong>数据卷（volume）<strong>是一个虚拟目录，是</strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p><p>以Nginx为例，Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果要让Nginx代理静态资源，最好是放到<code>html</code>目录；如果要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以必须利用数据卷将两个目录与宿主机目录关联</p><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="数据卷"><ul><li>创建两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来</p><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>可以发现，数据卷的目录结构较深，如果去操作数据卷目录会不太方便。在很多情况下，会直接将容器目录与宿主机指定目录挂载</p><hr><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>假如要部署一个Java项目，需要把它打包为一个自定义镜像。镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="镜像结构"><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。而这种记录镜像结构的文件就称为<strong>Dockerfile</strong></p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:7</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><h3 id="构建java镜像"><a href="#构建java镜像" class="headerlink" title="构建java镜像"></a>构建java镜像</h3><p>现在的结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\docker-study\<br>  ├── <span class="hljs-keyword">index</span>.html (刚才用的)<br>  ├── zzyl-<span class="hljs-keyword">admin</span>.jar    (后端代码)<br>  └── Dockerfile (空文件，即将编写)<br></code></pre></td></tr></table></figure><h4 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile:"></a>编写Dockerfile:</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 1. 基础镜像：我们要在一个装好 Java 11 的环境里运行</span><br><span class="hljs-keyword">FROM</span> eclipse-temurin:<span class="hljs-number">11</span>-jdk-alpine<br><br><span class="hljs-comment"># 2. 维护者信息 (可选)</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Xiaoli&quot;</span></span><br><br><span class="hljs-comment"># 3. 设置工作目录：容器里的“家”目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 4. 复制文件：把宿主机当前目录下的 jar 包，拷贝进容器的 /app 目录下</span><br><span class="hljs-comment"># 注意：第一个参数必须是本地真实的文件名，第二个参数是容器里的文件名</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> zzyl-admin.jar /app/app.jar</span><br><br><span class="hljs-comment"># 5. 暴露端口：告诉 Docker 这个容器内部服务用的是什么端口</span><br><span class="hljs-comment"># Spring Boot 默认通常是 8080，如果改过，这里也要改</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">9000</span><br><br><span class="hljs-comment"># 6. 启动命令：容器启动时自动执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="构建镜像："><a href="#构建镜像：" class="headerlink" title="构建镜像："></a>构建镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-java-app .<br></code></pre></td></tr></table></figure><p><strong><code>build</code></strong>：构建指令。</p><p><strong><code>-t my-java-app</code></strong>：给这个镜像起个名字叫 <code>my-java-app</code>（Tag）。</p><p><em><em><code>.</code> 最后那个点</em>：</em>*** 它代表“上下文路径”，告诉 Docker：“就在<strong>当前目录</strong>下找 Dockerfile 和 jar 包”。</p><p>如果出错了，大概率是源的问题 可以尝试手动拉取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull eclipse-temurin:11-jdk-alpine<br></code></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器:"></a>启动容器:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name my-backend -p 9000:9000 my-java-app<br></code></pre></td></tr></table></figure><h4 id="验证与排错"><a href="#验证与排错" class="headerlink" title="验证与排错"></a>验证与排错</h4><p>启动后，并不代表一定成功了（比如 Jar 包版本不对、代码里配置连接数据库失败等）。需要学会<strong>看日志</strong>。</p><ol><li><p><strong>查看容器是否存活：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><p>如果 <code>STATUS</code> 是 <code>Up</code>，说明容器还活着。如果列表里没有，说明容器<strong>崩了 (Exited)</strong>。</p></li><li><p><strong>查看应用日志（最重要）：</strong> 无论容器是死是活，都执行这个命令看看控制台输出了什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f my-backend<br></code></pre></td></tr></table></figure><p><em>( <code>-f</code> 表示实时跟踪日志，按 <code>Ctrl+C</code> 可以退出日志查看)</em></p></li></ol><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image5.png" class="" title="dockerfile"><p>可以看到因为还没连数据库报错了</p><hr><h1 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西比较多。如果还像之前那样手动的逐一部署容器，就太麻烦了。而Docker Compose就可以实现<strong>多个相互关联的Docker镜像的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用镜像。不再需要不需要手动启动好几个容器然后配网络了</p><p>它的核心魔法是：<strong>服务名即域名</strong>（在 Compose 里给数据库起名 <code>mysql</code>，那么 Java 代码里只要填 <code>mysql</code>，Docker 就会自动把请求转发过去，不管 IP 怎么变。）</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">docker run <span class="hljs-literal">-d</span> \<br><span class="hljs-literal">--name</span> nginx<span class="hljs-literal">-tlias</span> \<br><span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \<br><span class="hljs-literal">-v</span> /usr/local/app/html:/usr/share/nginx/html \<br><span class="hljs-literal">-v</span> /usr/local/app/conf/nginx.conf:/etc/nginx/nginx.conf \  <br><span class="hljs-literal">--network</span> itheima \<br>nginx:<span class="hljs-number">1.20</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;nginx:1.20.2&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx-tlias</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/usr/local/app/html:/usr/share/nginx/html&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/usr/local/app/conf/nginx.conf:/etc/nginx/nginx.conf&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">itheima</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">itheima:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">itheima</span><br></code></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="center"><strong>docker run 参数</strong></th><th align="center"><strong>docker compose 指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">–name</td><td align="center">container_name</td><td align="center">容器名称</td></tr><tr><td align="center">-p</td><td align="center">ports</td><td align="center">端口映射</td></tr><tr><td align="center">-e</td><td align="center">environment</td><td align="center">环境变量</td></tr><tr><td align="center">-v</td><td align="center">volumes</td><td align="center">数据卷配置</td></tr><tr><td align="center">–network</td><td align="center">networks</td><td align="center">网络</td></tr></tbody></table><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>编写好docker-compose.yml文件，就可以部署项目了。语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">docker</span> <span class="hljs-string">compose</span> [<span class="hljs-string">OPTIONS</span>] [<span class="hljs-string">COMMAND</span>]<br></code></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><h2 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>需要把 <code>127.0.0.1</code> 改成 Docker 网络里的名字。</p><ol><li>在 <code>D:\Workspace\docker_study</code> 目录下，新建一个文件叫 <code>application-docker.yml</code>。</li><li>把 <code>application-prod.yml</code> 内容全选复制进去。</li><li><strong>做如下关键修改（把 IP 换成服务名）：</strong></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># RuoYi Docker 环境专用配置文件</span><br><br><span class="hljs-comment"># 项目相关配置</span><br><span class="hljs-attr">ruoyi:</span><br>  <span class="hljs-comment"># 名称</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">RuoYi</span><br>  <span class="hljs-comment"># 版本</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">3.8</span><span class="hljs-number">.8</span><br>  <span class="hljs-comment"># 版权年份</span><br>  <span class="hljs-attr">copyrightYear:</span> <span class="hljs-number">2024</span><br>  <span class="hljs-comment"># 文件路径 (容器内路径)</span><br>  <span class="hljs-attr">profile:</span> <span class="hljs-string">/app/uploadPath</span><br>  <span class="hljs-comment"># 获取ip地址开关</span><br>  <span class="hljs-attr">addressEnabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 验证码类型 math 数字计算 char 字符验证</span><br>  <span class="hljs-attr">captchaType:</span> <span class="hljs-string">math</span><br><br><span class="hljs-comment"># 开发环境配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-comment"># 服务器的HTTP端口 (容器内监听端口)</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-comment"># 应用的访问路径</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-comment"># tomcat的URI编码</span><br>    <span class="hljs-attr">uri-encoding:</span> <span class="hljs-string">UTF-8</span><br>    <span class="hljs-attr">threads:</span><br>      <span class="hljs-attr">max:</span> <span class="hljs-number">800</span><br>      <span class="hljs-attr">min-spare:</span> <span class="hljs-number">100</span><br><br><span class="hljs-comment"># 日志配置</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.zzyl:</span> <span class="hljs-string">debug</span><br>    <span class="hljs-attr">org.springframework:</span> <span class="hljs-string">warn</span><br><br><span class="hljs-comment"># 用户配置</span><br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">password:</span><br>    <span class="hljs-attr">maxRetryCount:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">lockTime:</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># Spring配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 资源信息</span><br>  <span class="hljs-attr">messages:</span><br>    <span class="hljs-attr">basename:</span> <span class="hljs-string">i18n/messages</span><br>  <span class="hljs-comment"># 文件上传</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">20MB</span><br>  <span class="hljs-comment"># 服务模块</span><br>  <span class="hljs-attr">devtools:</span><br>    <span class="hljs-attr">restart:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br> <br>  <span class="hljs-comment"># 关键修改点 1：Redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-comment"># 这里必须填 docker-compose 里的服务名</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">zzyl-redis</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span><br><br>  <span class="hljs-comment"># 关键修改点 2：MySQL 数据库配置</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">master:</span><br>        <span class="hljs-comment"># 这里必须填 docker-compose 里的服务名</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://zzyl-mysql:3306/ry-zzyl?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">Aa123456.</span><br>      <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">minIdle:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">socketTimeout:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>      <span class="hljs-attr">maxEvictableIdleTimeMillis:</span> <span class="hljs-number">900000</span><br>      <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">webStatFilter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">statViewServlet:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span><br>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">ruoyi</span><br>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">stat:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">log-slow-sql:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">slow-sql-millis:</span> <span class="hljs-number">1000</span><br>          <span class="hljs-attr">merge-sql:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">wall:</span><br>          <span class="hljs-attr">config:</span><br>            <span class="hljs-attr">multi-statement-allow:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># token配置</span><br><span class="hljs-attr">token:</span><br>  <span class="hljs-attr">header:</span> <span class="hljs-string">Authorization</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">abcdefghijklmnopqrstuvwxyz</span><br>  <span class="hljs-attr">expireTime:</span> <span class="hljs-number">30</span><br><br><span class="hljs-comment"># MyBatisPlus配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">typeAliasesPackage:</span> <span class="hljs-string">com.zzyl.**.domain</span><br>  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath*:mapper/**/*Mapper.xml</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># PageHelper分页插件</span><br><span class="hljs-attr">pagehelper:</span><br>  <span class="hljs-attr">helperDialect:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">supportMethodsArguments:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">params:</span> <span class="hljs-string">count=countSql</span><br><br><span class="hljs-comment"># Swagger配置</span><br><span class="hljs-attr">swagger:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pathMapping:</span> <span class="hljs-string">/dev-api</span><br>  <br><span class="hljs-attr">xss:</span><br>  <span class="hljs-comment"># 过滤开关</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 排除链接（多个用逗号分隔）</span><br>  <span class="hljs-attr">excludes:</span> <span class="hljs-string">/system/notice</span><br>  <span class="hljs-comment"># 匹配链接</span><br>  <span class="hljs-attr">urlPatterns:</span> <span class="hljs-string">/system/*,/monitor/*,/tool/*</span><br><br><span class="hljs-comment"># 其他配置 (OSS/百度等保留原样)</span><br><span class="hljs-attr">oss:</span><br>  <span class="hljs-attr">endpoint:</span> <span class="hljs-string">oss-cn-beijing.aliyuncs.com</span><br>  <span class="hljs-attr">accessKeyId:</span> <span class="hljs-string">***</span><br>  <span class="hljs-attr">accessKeySecret:</span> <span class="hljs-string">***</span><br>  <span class="hljs-attr">bucketName:</span> <span class="hljs-string">linux-test1</span><br><span class="hljs-attr">baidu:</span><br>  <span class="hljs-attr">accessKey:</span> <span class="hljs-string">***</span><br>  <span class="hljs-attr">secretKey:</span> <span class="hljs-string">***</span><br>  <span class="hljs-attr">qianfanModel:</span> <span class="hljs-string">ERNIE-4.0-8K-Preview</span><br></code></pre></td></tr></table></figure><h3 id="准备数据库初始化脚本"><a href="#准备数据库初始化脚本" class="headerlink" title="准备数据库初始化脚本"></a>准备数据库初始化脚本</h3><p>准备好 <code>sql</code> 文件。为了让 MySQL 容器启动时自动建表：确保 <code>sql</code> 文件（ <code>ry-zzyl.sql</code>）也在 <code>D:\Workspace\docker_study</code> 目录下。</p><hr><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h3><p>这是这一章的核心。在目录下新建 <code>docker-compose.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-comment"># 1. 数据库服务</span><br>  <span class="hljs-attr">zzyl-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span> <span class="hljs-comment"># 根据你的驱动版本，8.0或5.7</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zzyl-mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&quot;Aa123456.&quot;</span> <span class="hljs-comment"># 必须要和你 yml 里的密码一致！</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">ry-zzyl</span>          <span class="hljs-comment"># 自动创建一个空库</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span> <span class="hljs-string">--character-set-server=utf8mb4</span> <span class="hljs-string">--collation-server=utf8mb4_unicode_ci</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># 挂载数据卷：防止删除容器后数据丢失</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./mysql-data:/var/lib/mysql</span><br>      <span class="hljs-comment"># 挂载 SQL 脚本：容器第一次启动时会自动执行这个目录下的 .sql 文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./ry-zzyl.sql:/docker-entrypoint-initdb.d/init.sql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3307:3306&quot;</span><br><br>  <span class="hljs-comment"># 2. Redis 服务</span><br>  <span class="hljs-attr">zzyl-redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:alpine</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zzyl-redis</span><br>    <span class="hljs-comment"># ports:</span><br>    <span class="hljs-comment">#  - &quot;6390:6379&quot;</span><br><br>  <span class="hljs-comment"># 3. 你的 Java 后端服务</span><br>  <span class="hljs-attr">zzyl-server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">my-java-app</span> <span class="hljs-comment"># 使用我们要刚才 build 好的镜像</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zzyl-server</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9000:9000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># 【核心大招】：把刚才修改过的配置文件，挂载进容器内部，覆盖 Jar 包里的默认配置</span><br>      <span class="hljs-comment"># 假设 Jar 包里读取配置的优先级规则允许外部配置覆盖</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./application-docker.yml:/app/application.yml</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-comment"># 强制告诉 Spring Boot 使用这个配置文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_CONFIG_LOCATION=/app/application.yml</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-comment"># 告诉 Docker：必须等数据库和 Redis 启动了，再启动我</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zzyl-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zzyl-redis</span><br></code></pre></td></tr></table></figure><hr><h3 id="一键启动"><a href="#一键启动" class="headerlink" title="一键启动"></a>一键启动</h3><p>在终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><em>(如果是第一次运行，它会下载 MySQL 和 Redis 的镜像，可能需要一点时间)</em></p><p>启动完成后，查看全局日志 (只看 server 的日志更清晰):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose logs -f zzyl-server<br></code></pre></td></tr></table></figure><p>在本地浏览器访问：**<a href="https://www.google.com/search?q=http://localhost:9000&authuser=1">http://localhost:9000</a>**显示若依前台启动成功</p><h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h3><p>后端已经就位，但用户不能直接调 API，需要把<strong>前端页面 (dist)</strong> 部署起来，并且让 Nginx 把 API 请求转发给后端容器。不需要重新创建项目，只需要在现在的 <code>docker-compose.yml</code> 里<strong>加几行配置</strong></p><p>现在的目录结构：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">D:<span class="hljs-string">\Workspace\docker_study\</span><br>  ├── ... (之前的那些文件)<br>  ├── docker-compose.yml<br>  └── nginx<span class="hljs-string">\</span><br>       ├── dist<span class="hljs-string">\</span>       &lt;-- 你的前端打包文件<br>       │    ├── index.html<br>       │    └── <span class="hljs-keyword">static</span>/css/js...<br>       └── nginx.conf  &lt;-- 你的配置文件<br></code></pre></td></tr></table></figure><p>在 Linux 服务器上，Nginx 配置里可能写的是 <code>proxy_pass http://127.0.0.1:9000;</code>。 <strong>但在 Docker 里，Nginx 容器去找后端，不能用 127.0.0.1（那是 Nginx 容器自己），必须用后端容器的名字！</strong></p><p>修改nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. Docker 容器中通常默认就是 root 运行，这行保留没问题，也可以注释掉</span><br><span class="hljs-attribute">user</span> root;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-attribute">include</span> /usr/share/nginx/modules/<span class="hljs-regexp">*.conf</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br><br>    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;<br><br>    <span class="hljs-attribute">sendfile</span>            <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nopush</span>          <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nodelay</span>         <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>   <span class="hljs-number">65</span>;<br>    <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">4096</span>;<br><br>    <span class="hljs-attribute">include</span>             /etc/nginx/mime.types;<br>    <span class="hljs-attribute">default_type</span>        application/octet-stream;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-comment"># Docker 容器内部监听 80 即可，不用改</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">listen</span>       [::]:<span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">60m</span>;<br>        <span class="hljs-attribute">client_body_buffer_size</span> <span class="hljs-number">512k</span>;<br>        <span class="hljs-attribute">client_header_buffer_size</span> <span class="hljs-number">2k</span>;<br><br>        <span class="hljs-comment"># ⚠️ 修改点 1：前端静态文件路径</span><br>        <span class="hljs-comment"># 在 Linux 虚拟机上你可能放在 /home/dist</span><br>        <span class="hljs-comment"># 但在 Docker 容器里，我们一会要把文件挂载到 Nginx 的标准目录 /usr/share/nginx/html</span><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>            <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        <span class="hljs-comment"># ⚠️ 修改点 2：反向代理地址</span><br>        <span class="hljs-comment"># 绝对不能写 127.0.0.1，因为那是 Nginx 容器自己！</span><br>        <span class="hljs-comment"># 必须写后端容器的服务名：zzyl-server</span><br>        <span class="hljs-section">location</span> /prod-api/ &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://zzyl-server:9000/;<br>            <br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> REMOTE-HOST <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;<br>        <span class="hljs-section">location</span> = /<span class="hljs-number">404</span>.html &#123;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;<br>        <span class="hljs-section">location</span> = /50x.html &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在DockerCompose添加配置，使其同时管理 后端、数据库、Redis 和 <strong>前端 Nginx</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 4. 前端 Nginx 服务</span><br>  <span class="hljs-attr">zzyl-nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:stable-alpine</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zzyl-nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span> <span class="hljs-comment"># 把宿主机(Windows)的80端口，映射到容器的80端口</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># 挂载 1：把你的静态资源文件夹(dist)，挂载到容器刚才配置的 root 目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./nginx/dist:/usr/share/nginx/html</span><br>      <span class="hljs-comment"># 挂载 2：把你的配置文件，覆盖容器里的默认配置</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./nginx/nginx.conf:/etc/nginx/nginx.conf</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zzyl-server</span> <span class="hljs-comment"># 只有后端启动了，前端才启动</span><br></code></pre></td></tr></table></figure><p>再次启动:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image7.png" class="" title="部署成功"><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image6.png" class="" title="页面展示"><h2 id="过程中踩过的坑"><a href="#过程中踩过的坑" class="headerlink" title="过程中踩过的坑"></a>过程中踩过的坑</h2><p>在开始 Docker 之前，手里的东西和之前在linux云服务器上部署是一样的：</p><ol><li><strong>后端代码：</strong> <code>zzyl-admin.jar</code></li><li><strong>前端代码：</strong> <code>dist</code> 文件夹</li><li><strong>数据库脚本：</strong> <code>ry_zzyl.sql</code></li><li><strong>配置文件：</strong> <code>application.yml</code> 和 <code>nginx.conf</code></li></ol><p>💡 核心思维转变：以前是在服务器上装软件（JDK, Nginx, MySQL）；现在是要把这些东西**“塞”进容器里**，或者**“挂”在容器身上**。</p><hr><p>把 Jar 包变成一个 Docker 镜像，这样它才能运行。</p><ul><li><strong>操作：</strong> 编写 <code>Dockerfile</code>。</li><li><strong>逻辑：</strong><ol><li><code>FROM</code>：找个底座（JDK 镜像）。</li><li><code>COPY</code>：把 Jar 包放进去。</li><li><code>CMD</code>：告诉它启动时执行 <code>java -jar ...</code>。</li></ol></li><li><strong>踩坑点：</strong> 基础镜像拉不下来（网络问题），得靠自己多去搜一下解决方法。</li></ul><hr><p><strong>容器之间的连线</strong>。</p><ul><li><strong>痛点：</strong> 容器是隔离的。容器 A (Java) 想找 容器 B (MySQL)，不能喊 <code>127.0.0.1</code>（因为那代表 Java 自己）。</li><li><strong>操作：</strong><ol><li><strong>修改 <code>application.yml</code>：</strong> 把 <code>localhost</code> 全改成 <strong>服务名</strong> (<code>zzyl-mysql</code>, <code>zzyl-redis</code>)。</li><li><strong>修改 <code>nginx.conf</code>：</strong> 把反向代理地址改成 <code>http://zzyl-server:9000</code>。</li></ol></li><li><strong>原理：</strong> Docker Compose 内部有一个 DNS，只要喊名字，就能找到对应的 IP。</li></ul><hr><p>既然有 4 个服务（MySQL, Redis, Java, Nginx），一个个 <code>docker run</code> 太累了，还需要配网络。所以要写一个总指挥书。</p><ol><li><strong>端口映射 (Ports)：</strong> 打通“现实世界”和“容器世界”。<ul><li><code>3307:3306</code>：为了避开你电脑本地的 MySQL 冲突，外面用 3307，里面还是 3306。</li><li><code>80:80</code>：网页访问入口。</li><li><strong>Redis 没映射：</strong> 既然不需要从外面连 Redis，干脆不暴露端口，只在内部互通（避开了 Windows 端口冲突）。</li></ul></li><li><strong>卷挂载 (Volumes)：</strong> 打通“数据”和“配置”。<ul><li><strong>MySQL：</strong> 挂载了数据目录（防止删容器丢数据）和初始化脚本（第一次启动自动建表）。</li><li><strong>Nginx：</strong> 挂载了 <code>dist</code>（页面）和 <code>nginx.conf</code>（配置）。</li><li><strong>Java：</strong> 挂载了 <code>application.yml</code>（不用重新打包镜像就能改配置）。</li></ul></li><li><strong>依赖顺序 (Depends_on)：</strong><ul><li>告诉 Docker：先启动数据库，再启动后端，最后启动前端。</li></ul></li></ol><hr><p>看日志排错</p><ol><li><strong>端口冲突 (Bind address already in use)：</strong><ul><li><strong>现象：</strong> MySQL 3306 启动失败。</li><li><strong>原因：</strong> 本地已经装了 MySQL。</li><li><strong>解决：</strong> 改用 3307。</li></ul></li><li><strong>数据库连接拒绝 (Connection refused)：</strong><ul><li><strong>现象：</strong> Java 报错连不上库。</li><li><strong>原因：</strong> 配置文件里还写的 127.0.0.1。</li><li><strong>解决：</strong> 改成服务名 <code>zzyl-mysql</code>。</li></ul></li><li><strong>缺少配置报错 (Could not resolve placeholder)：</strong><ul><li><strong>现象：</strong> Java 启动一半挂了。</li><li><strong>原因：</strong> 复制配置文件时漏了 <code>xss</code> 那一段。</li><li><strong>解决：</strong> 补全配置。</li></ul></li><li><strong>数据未初始化 (Table doesn’t exist)：</strong><ul><li><strong>现象：</strong> 登录报错，数据库是空的。</li><li><strong>原因：</strong> MySQL 只有在第一次（数据目录为空）时才执行脚本。之前失败的启动留下了脏数据。</li><li><strong>解决：</strong> <code>docker-compose down</code> -&gt; 删掉 <code>mysql-data</code> -&gt; 重启。</li></ul></li></ol><p><strong>备份：</strong> 把 <code>docker-compose.yml</code>, <code>Dockerfile</code>, <code>nginx.conf</code> 这些文件保存好。以后不管去哪台电脑，只要有 Docker，环境就能在一分钟内还原。</p><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image8.png" class="" title="docker-desktop"><hr><h1 id="云服务器部署docker"><a href="#云服务器部署docker" class="headerlink" title="云服务器部署docker"></a>云服务器部署docker</h1><p>租好服务器，直接利用在windows编写好的文件来部署</p><p>首先连接好服务器并执行以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 安装必要的工具</span><br>yum install -y yum-utils<br><br><span class="hljs-comment"># 2. 设置阿里云的 Docker 镜像仓库 (下载快)</span><br>yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br><br><span class="hljs-comment"># 3. 安装 Docker</span><br>yum install -y docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># 4. 启动 Docker 并设置开机自启</span><br>systemctl start docker<br>systemctl enable docker<br><br><span class="hljs-comment"># 5. 安装 Docker Compose (关键一步)</span><br><span class="hljs-comment"># (从 GitHub 下载可能会慢，这里用国内常用的加速方式，或者直接下载二进制文件)</span><br>curl -L https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v2.20.2/</span>docker-compose-`uname -s`-`uname -m` -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br><br><span class="hljs-comment"># 6. 给 docker-compose 执行权限</span><br>chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br><br><span class="hljs-comment"># 7. 验证是否成功</span><br>docker -v<br>docker-compose -v<br></code></pre></td></tr></table></figure><p>在第五步之前可以先执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose version<br></code></pre></td></tr></table></figure><p>如果这行命令能输出版本号（比如 <code>Docker Compose version v2.x.x</code>），那<strong>根本不需要下载那个文件了</strong>只需要做一个小小的“伪装”，让 <code>docker-compose</code> 这个命令指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;docker compose &quot;$@&quot;&#x27;</span> &gt; /usr/local/bin/docker-compose<br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>这样就可以继续用 <code>docker-compose up</code> 了。</p><hr><p>将在 Windows 上辛苦整理好的文件夹搬家。</p><ol><li>在 FinalShell 的下方文件窗口，进入 <code>/opt</code> 目录（通常我们要部署的软件都放这里）。</li><li>新建一个文件夹，叫 <code>docker_project</code>。</li><li>双击进入 <code>/opt/docker_project</code>。</li><li><strong>Windows <code>D:\Workspace\docker_study</code> 目录里，把以下文件直接拖进去上传：</strong><ul><li>✅ <code>app.jar</code> (后端包)</li><li>✅ <code>Dockerfile</code> (构建脚本)</li><li>✅ <code>docker-compose.yml</code> (总指挥)</li><li>✅ <code>application-docker.yml</code> (配置文件)</li><li>✅ <code>ry_zzyl.sql</code> (数据库脚本 - <strong>确保是 UTF-8</strong>)</li><li>✅ <code>nginx</code> 文件夹 (整个拖进去，包含 <code>conf</code> 和 <code>dist</code>)</li></ul></li></ol><p><strong>❌ 注意：千万不要上传 <code>mysql-data</code> 文件夹！</strong> 服务器上要生成新的！</p><p>一键启动即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 进入目录</span><br><span class="hljs-built_in">cd</span> /opt/docker_project<br><br><span class="hljs-comment"># 2. 只有第一次需要执行：构建镜像 (因为服务器上还没这个镜像)</span><br><span class="hljs-comment"># 这一步会把你的 jar 包打包成镜像，可能会花几十秒</span><br>docker build -t my-java-app .<br><br><span class="hljs-comment"># 3. 启动所有服务！</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>这一步很可能出现**阿里云服务器连接不到 Docker Hub (docker.io)**的情况。</p><p>解决方法一：用阿里云提供的一个<strong>专属</strong>的加速器地址</p><p>登录 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器镜像服务控制台</a>。 在左侧菜单点击 <strong>“镜像加速器”</strong>，看到一个 <code>https://xxxx.mirror.aliyuncs.com</code> 的地址。复制它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 创建配置目录（如果不存在）</span><br><span class="hljs-built_in">mkdir</span> -p /etc/docker<br><br><span class="hljs-comment"># 2. 写入你的专属加速地址到配置文件 (直接覆盖)</span><br><span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br><br><span class="hljs-comment"># 3. 重新加载配置并重启 Docker</span><br>systemctl daemon-reload<br>systemctl restart docker<br><br><span class="hljs-comment"># 4. (可选) 检查是否配置成功，如果在输出里看到了你的地址就说明成了</span><br>docker info | grep <span class="hljs-string">&quot;Registry Mirrors&quot;</span> -A 1<br></code></pre></td></tr></table></figure><p>解决方法二：离线搬运</p><p>既然Windows本地之前已经跑通了，说明本地有这个镜像。把它像打包行李一样打成一个文件即可</p><ol><li><p>打开 <strong>Windows PowerShell</strong> 。</p></li><li><p>输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把镜像保存成一个名为 java-base.tar 的压缩包</span><br>docker save -o java-base.tar eclipse-temurin:11-jdk-alpine<br></code></pre></td></tr></table></figure></li><li><p>执行完后，去当前目录找一下，能看到一个 100多 MB 的 <code>java-base.tar</code> 文件</p></li><li><p>打开 <strong>FinalShell</strong>。在下方的文件窗口，进入 <code>/opt/docker_project</code> 目录。把刚才生成的 <code>java-base.tar</code> <strong>直接拖拽进去</strong>，等待上传完成。</p></li><li><p>进入目录：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/docker_project<br><br><span class="hljs-comment">#  执行解压加载命令：</span><br>docker load -i java-base.tar<br></code></pre></td></tr></table></figure><p>看到类似 <code>Loaded image: eclipse-temurin:11-jdk-alpine</code> 的提示.镜像已经在服务器本地硬盘里了，Docker 不需要联网下载了,继续执行构建镜像和启动命令即可。</p><p>查看后端或者nginx日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose logs -f zzyl-server<br><br>docker-compose logs -f zzyl-nginx<br></code></pre></td></tr></table></figure><img src="/2025/12/21/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image9.png" class="" title="后端日志"><p>访问云服务器公网IP地址即可看到网页正常显示，部署成功！</p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础命令</tag>
      
      <tag>项目部署</tag>
      
      <tag>Dockerfile</tag>
      
      <tag>Docker Cpmpose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmeter基础学习</title>
    <link href="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter概述"><a href="#Jmeter概述" class="headerlink" title="Jmeter概述"></a>Jmeter概述</h1><h3 id="1-JMeter-是什么？"><a href="#1-JMeter-是什么？" class="headerlink" title="1. JMeter 是什么？"></a>1. JMeter 是什么？</h3><ul><li><strong>官方定义</strong>：Apache JMeter 是一个 100% 纯 Java 编写的开源软件，主要用于进行<strong>负载测试（Load Testing）\和\性能测量</strong>。</li><li><strong>测开视角的理解</strong>：它是一个<strong>接口测试 + 性能测试</strong>的容器。它通过模拟大量的并发用户（线程），向服务器发送请求，并收集服务器的响应数据，以此来评估系统的抗压能力。</li></ul><h3 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2. 核心特性"></a>2. 核心特性</h3><h4 id="A-它不是浏览器"><a href="#A-它不是浏览器" class="headerlink" title="A. 它不是浏览器"></a>A. 它不是浏览器</h4><p>这是新手最容易误解的地方，也是面试最爱问的。</p><ul><li><strong>浏览器</strong>：发送请求 -&gt; 接收 HTML -&gt; <strong>解析 CSS&#x2F;JS -&gt; 渲染页面</strong>。</li><li><strong>JMeter</strong>：发送请求 -&gt; 接收 HTML -&gt; <strong>结束</strong>。</li><li><strong>区别</strong>：JMeter 不会执行页面上的 JavaScript，也不会渲染样式。</li><li><strong>意义</strong>：这使得 JMeter 非常轻量级，一台普通电脑就能模拟成百上千个用户。但也意味着它不能用来测 UI 界面（比如页面布局乱没乱），只能测后端接口。</li></ul><h4 id="B-多协议支持"><a href="#B-多协议支持" class="headerlink" title="B. 多协议支持"></a>B. 多协议支持</h4><p>虽主要用它测 HTTP&#x2F;HTTPS（Web 接口），但它其实是个“万能插头”，支持：</p><ul><li><strong>Web</strong>: HTTP, HTTPS</li><li><strong>数据库</strong>: JDBC (可以直接连数据库测 SQL 性能)</li><li><strong>FTP</strong>: 文件传输</li><li><strong>消息队列</strong>: JMS, Kafka (通过插件)</li><li><strong>邮件</strong>: SMTP, POP3</li><li><strong>TCP</strong>: 纯 Socket 通信</li></ul><h4 id="C-可扩展性强"><a href="#C-可扩展性强" class="headerlink" title="C. 可扩展性强"></a>C. 可扩展性强</h4><p>JMeter 提供了丰富的插件（Plugins Manager），并且支持通过 <strong>BeanShell</strong> 或 <strong>JSR223 (Groovy)</strong> 编写脚本来处理复杂的测试逻辑。如果自带功能不够用，可以写 Java 代码来扩展它。</p><h3 id="3-主要用它做什么？"><a href="#3-主要用它做什么？" class="headerlink" title="3. 主要用它做什么？"></a>3. 主要用它做什么？</h3><p>在使用 JMeter 时，根据配置的不同（并发量、持续时间）做不同的测试：</p><ol><li><strong>负载测试 (Load Testing)</strong>：<ul><li><strong>目的</strong>：测试系统在<strong>正常或预期</strong>的负载下能否正常工作。</li><li><em>JMeter 操作</em>：模拟 100 个用户，持续运行 10 分钟，看响应时间是否达标。</li></ul></li><li><strong>压力测试 (Stress Testing)</strong>：<ul><li><strong>目的</strong>：不断增加负载，直到系统<strong>崩溃</strong>，寻找系统的极限瓶颈。</li><li><em>JMeter 操作</em>：从 100 用户增加到 1000、2000…直到报错率飙升，找到服务器挂掉的那个点。</li></ul></li><li><strong>稳定性&#x2F;耐久性测试 (Soak Testing)</strong>：<ul><li><strong>目的</strong>：长时间运行，检测是否有<strong>内存泄漏</strong>。</li><li><em>JMeter 操作</em>：保持一定的负载，连续跑 24 小时或 7 天。</li></ul></li></ol><h3 id="4-JMeter-的工作原理"><a href="#4-JMeter-的工作原理" class="headerlink" title="4. JMeter 的工作原理"></a>4. JMeter 的工作原理</h3><p>想象一个工厂：</p><ul><li><strong>Controller (控制台)</strong>：测试人员发号施令。</li><li><strong>Thread Group (线程组)</strong>：一群工人（虚拟用户）。</li><li><strong>Sampler (取样器)</strong>：工人做的具体动作（比如“发送登录请求”）。</li><li><strong>Timer (定时器)</strong>：工人的动作频率（比如“思考 1 秒再点”）。</li><li><strong>Assertion (断言)</strong>：质检员（检查返回结果对不对）。</li><li><strong>Listener (监听器)</strong>：报表员（生成图表和报告）。</li></ul><hr><h1 id="基础环境与核心元件"><a href="#基础环境与核心元件" class="headerlink" title="基础环境与核心元件"></a>基础环境与核心元件</h1><h4 id="第一步：启动与创建测试计划"><a href="#第一步：启动与创建测试计划" class="headerlink" title="第一步：启动与创建测试计划"></a>第一步：启动与创建测试计划</h4><ol><li>进入 JMeter 解压目录的 <code>bin</code> 文件夹。<ul><li><strong>Windows</strong>: 双击 <code>jmeter.bat</code>。</li><li><strong>Mac&#x2F;Linux</strong>: 在终端运行 <code>sh jmeter.sh</code>。</li></ul></li><li>看到图形界面后，会看到左侧默认有一个 <strong>Test Plan (测试计划)</strong>。<ul><li><em>这是所有测试元素的容器，相当于一个项目文件。</em></li></ul></li></ol><h4 id="第二步：创建虚拟用户池-Thread-Group"><a href="#第二步：创建虚拟用户池-Thread-Group" class="headerlink" title="第二步：创建虚拟用户池 (Thread Group)"></a>第二步：创建虚拟用户池 (Thread Group)</h4><p>需要先定义“谁”在测。</p><ol><li><strong>右键点击</strong> <code>Test Plan</code> -&gt; <strong>Add (添加)</strong> -&gt; <strong>Threads (Users) (线程)</strong> -&gt; <strong>Thread Group (线程组)</strong>。 JMeter 是由 Java 实现的，并且使用一个 Java 线程来模拟一个用户，因此线程组（Thread Group）就是指一组用户的意思</li><li>右侧会出现配置面板，目前保持默认即可：<ul><li><strong>Number of Threads</strong>: <code>1</code> (虚拟用户数)</li><li><strong>Ramp-Up Period</strong>: <code>1</code> (1秒内启动完)</li><li><strong>Loop Count</strong>: <code>1</code> (只跑一次)</li></ul></li></ol><h4 id="第三步：模拟发送请求-Sampler"><a href="#第三步：模拟发送请求-Sampler" class="headerlink" title="第三步：模拟发送请求 (Sampler)"></a>第三步：模拟发送请求 (Sampler)</h4><ol><li><strong>右键点击</strong> 刚才创建的 <code>Thread Group</code> -&gt; <strong>Add</strong> -&gt; <strong>Sampler (取样器)</strong> -&gt; <strong>HTTP Request (HTTP请求)</strong>。</li><li>在右侧面板配置以下信息：<ul><li><strong>Protocol [http]</strong>: 输入 <code>https</code> </li><li><strong>Server Name or IP</strong>: 输入 <code>www.baidu.com</code> (注意：不要带 <code>https://</code> 前缀，也不要带后面的 <code>/</code>)</li><li><strong>Port Number</strong>: 留空 (默认443)</li><li><strong>Method</strong>: 选择 <code>GET</code></li><li><strong>Path</strong>: 输入 <code>/</code> (代表访问根路径)</li></ul></li></ol><h4 id="第四步：安装监控探头-Listener"><a href="#第四步：安装监控探头-Listener" class="headerlink" title="第四步：安装监控探头 (Listener)"></a>第四步：安装监控探头 (Listener)</h4><p>请求发出去后，我们需要看到结果。</p><ol><li><strong>右键点击</strong> <code>Thread Group</code> -&gt; <strong>Add</strong> -&gt; <strong>Listener (监听器)</strong> -&gt; <strong>View Results Tree (察看结果树)</strong>。<ul><li><em>解释：这是调试脚本最常用的组件，能看到详细的请求和响应数据。</em></li></ul></li></ol><h4 id="第五步：运行与验证"><a href="#第五步：运行与验证" class="headerlink" title="第五步：运行与验证"></a>第五步：运行与验证</h4><ol><li>点击工具栏顶部的 <strong>绿色三角形 (Start)</strong> 按钮。</li><li>系统会提示保存脚本，点击 Yes，随便存个位置（例如 <code>baidu_test.jmx</code>）。</li><li>点击左侧的 <strong>View Results Tree</strong>。</li><li>看右侧的结果：<ul><li><strong>绿色盾牌</strong> ✅：表示请求成功（HTTP 状态码 200）。</li><li><strong>红色盾牌</strong> ❌：表示失败。</li></ul></li></ol><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="查看结果树"><p><strong>Sample Start (开始时间)</strong> JMeter <strong>发出请求的那个毫秒级时间戳</strong>。</p><p><strong>Latency (延迟 &#x2F; TTFB)</strong>：它不是单纯的“延迟”,是 <strong>Time To First Byte (TTFB)</strong>。</p><ul><li><strong>定义</strong>：从发送请求开始，到<strong>接收到服务器返回的第一个字节</strong>的时间。</li><li><em>意义</em>：这代表了<strong>网络传输时间 + 服务器处理时间</strong>（查库、运算）。</li></ul><p><strong>Load Time (加载时间 &#x2F; Elapsed Time)</strong>：</p><ul><li><strong>定义</strong>：从发送请求开始，到<strong>接收完最后一个字节</strong>的时间。</li><li><strong>公式</strong>：<code>Load Time = Latency + 数据下载时间</code>。</li></ul><hr><h1 id="参数化与模拟搜索"><a href="#参数化与模拟搜索" class="headerlink" title="参数化与模拟搜索"></a>参数化与模拟搜索</h1><h4 id="任务一：修改脚本进行搜索"><a href="#任务一：修改脚本进行搜索" class="headerlink" title="任务一：修改脚本进行搜索"></a>任务一：修改脚本进行搜索</h4><p>百度搜索的原理其实是访问 <code>/s</code> 这个路径，并带上 <code>wd=关键字</code> 这个参数。</p><ol><li>回到 <strong>HTTP Request</strong>。</li><li>修改配置：<ul><li><strong>Path</strong>: 修改为 <code>/s</code> (原本是 <code>/</code>)。</li></ul></li><li><strong>Parameters (参数)</strong> 部分（在 Path 下面）：<ul><li>点击 <strong>Add (添加)</strong>。</li><li><strong>Name</strong>: 输入 <code>wd</code> (百度的搜索参数名)。</li><li><strong>Value</strong>: 输入 <code>JMeter性能测试</code> (或者你想搜的任何词)。</li></ul></li><li>运行脚本，查看 <strong>View Results Tree</strong>。<ul><li>点击请求，看 <code>Request Body</code> 或 URL，应该能看到 <code>https://www.baidu.com/s?wd=JMeter性能测试</code>。</li></ul></li></ol><h4 id="任务二：参数化-CSV-Data-Set-Config"><a href="#任务二：参数化-CSV-Data-Set-Config" class="headerlink" title="任务二：参数化 (CSV Data Set Config)"></a>任务二：参数化 (CSV Data Set Config)</h4><p>如果要测试 100 个词，总不能复制 100 个 HTTP Request 吧？要把数据和脚本分离。</p><p><strong>1. 准备数据文件</strong></p><ul><li><p>在电脑上新建一个 <code>search_words.txt</code>。</p></li><li><p>里面写三行内容（不要表头）：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">python</span><br><span class="hljs-attribute">java</span><br><span class="hljs-attribute">selenium</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>2. 配置 CSV 数据读取器</strong></p><ul><li><strong>右键点击</strong> <code>Thread Group</code> -&gt; <strong>Add</strong> -&gt; <strong>Config Element (配置元件)</strong> -&gt; <strong>CSV Data Set Config</strong>。</li><li>配置面板：<ul><li><strong>Filename</strong>: 点击 Browse 选择刚才的 <code>search_words.txt</code>。</li><li><strong>Variable Names (comma-delimited)</strong>: 输入 <code>keyword</code> (这是给每一行数据起的变量名)。</li><li><strong>Ignore first line</strong>: <code>False</code> (因为没有写表头)。</li></ul></li></ul><p><strong>3. 引用变量</strong></p><ul><li>回到 <strong>HTTP Request</strong>。</li><li>找到刚才填写的 <code>wd</code> 参数。</li><li>把 Value 里的 <code>JMeter性能测试</code> 删掉，改成 <strong><code>$&#123;keyword&#125;</code></strong>。<ul><li><em>解释：在 JMeter 里，<code>$&#123;变量名&#125;</code> 是引用变量的标准语法。</em></li></ul></li></ul><p><strong>4. 调整并发数</strong></p><ul><li>点击 <strong>Thread Group</strong>。</li><li>把 <strong>Number of Threads</strong> 改成 <code>3</code> (因为我们有 3 个词)。</li><li>把 <strong>Loop Count</strong> 保持 <code>1</code>。</li></ul><p><strong>5. 运行与验证</strong></p><ul><li>点击运行。</li><li>查看 <strong>View Results Tree</strong>。</li><li>你应该看到 <strong>3 个 HTTP Request</strong>。</li><li>分别点开它们的 <strong>Request</strong> 标签，检查 URL。<ul><li>第一个应该是 <code>wd=python</code></li><li>第二个应该是 <code>wd=java</code></li><li>第三个应该是 <code>wd=selenium</code></li></ul></li></ul><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="参数化"><p>问：如果将 <strong>Number of Threads</strong> 设为 1，但把 <strong>Loop Count</strong> 设为 3，效果和上面一样吗？</p><p>答：如果把线程数设为 1，循环次数设为 3，它依然会依次读取 <code>python</code>, <code>java</code>, <code>selenium</code>。因为 <code>CSV Data Set Config</code> 是一个“全局发牌员”。不管是哪个线程、第几次循环来找它要数据，它都会把指针往下移一行。</p><p>但<strong>它们在“性能测试”中的意义完全不同：</strong></p><ul><li><strong>3 线程，1 循环</strong>：是 <strong>3 个人同时</strong> 访问百度。这叫<strong>并发（Concurrency）</strong>，用来测试服务器<strong>抗压能力</strong>。</li><li><strong>1 线程，3 循环</strong>：是 <strong>1 个人连续</strong> 访问 3 次。这叫<strong>串行（Serial）</strong>，压力很小，通常用于<strong>功能测试</strong>或稳定性测试。</li></ul><hr><h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>在真实业务中，接口之间是有联系的。</p><ul><li><em>场景</em>：用户登录 -&gt; 服务器返回一个 <code>Token</code> -&gt; 用户拿着 <code>Token</code> 去查余额。</li><li><em>问题</em>：<code>Token</code> 是动态生成的，没法写死在脚本里。</li><li><em>解决</em>：需要从第 1 个接口的<strong>响应</strong>中<strong>提取</strong>出 Token，存成变量，传给第 2 个接口。</li></ul><p>用一个专门的测试靶场：<code>httpbin.org</code>。</p><h4 id="第一步：准备环境"><a href="#第一步：准备环境" class="headerlink" title="第一步：准备环境"></a>第一步：准备环境</h4><ol><li>把之前的百度请求禁用（右键 -&gt; Disable）。</li><li>创建一个新的 <strong>Thread Group</strong>。</li></ol><h4 id="第二步：创建接口-A-获取数据"><a href="#第二步：创建接口-A-获取数据" class="headerlink" title="第二步：创建接口 A (获取数据)"></a>第二步：创建接口 A (获取数据)</h4><ol><li>添加 <strong>HTTP Request</strong>。</li><li>配置：<ul><li><strong>Server Name</strong>: <code>httpbin.org</code></li><li><strong>Method</strong>: <code>GET</code></li><li><strong>Path</strong>: <code>/uuid</code></li></ul></li><li><em>（建议先运行一下，在察看结果树里看 Response Body，会看到类似 <code>&#123;&quot;uuid&quot;: &quot;53e4...&quot;&#125;</code> 的 JSON 数据）。</em></li></ol><h4 id="第三步：添加提取器-JSON-Extractor-——-关键步骤"><a href="#第三步：添加提取器-JSON-Extractor-——-关键步骤" class="headerlink" title="第三步：添加提取器 (JSON Extractor) —— 关键步骤"></a>第三步：添加提取器 (JSON Extractor) —— <strong>关键步骤</strong></h4><p>要把uuid抓出来。</p><ol><li><strong>右键点击</strong> 刚才的“接口 A” -&gt; <strong>Add</strong> -&gt; <strong>Post Processors (后置处理器)</strong> -&gt; <strong>JSON Extractor</strong>。</li><li>配置面板：<ul><li><strong>Names of created variables</strong>: <code>my_uuid</code> (给提取出来的东西起个变量名)。</li><li><strong>JSON Path expressions</strong>: <code>$.uuid</code><ul><li><em>解释：<code>$</code> 代表根节点，<code>.uuid</code> 代表找 key 为 uuid 的值。这是标准的 JSONPath 语法。</em></li></ul></li><li><strong>Match No.</strong>: <code>1</code> (取第 1 个匹配到的)。</li></ul></li></ol><h4 id="第四步：创建接口-B-使用数据"><a href="#第四步：创建接口-B-使用数据" class="headerlink" title="第四步：创建接口 B (使用数据)"></a>第四步：创建接口 B (使用数据)</h4><ol><li>在线程组下再添加一个 <strong>HTTP Request</strong>。</li><li>配置：<ul><li><strong>Server Name</strong>: <code>httpbin.org</code></li><li><strong>Method</strong>: <code>POST</code> (注意是 POST)</li><li><strong>Path</strong>: <code>/post</code></li></ul></li><li><strong>Body Data</strong> (点击 Parameters 旁边的标签)：<ul><li>输入：<code>&#123; &quot;id&quot;: &quot;$&#123;my_uuid&#125;&quot; &#125;</code></li><li><em>解释：我们要把刚才提取出来的变量，拼装成 JSON 发回去。</em></li></ul></li></ol><h4 id="第五步：验证"><a href="#第五步：验证" class="headerlink" title="第五步：验证"></a>第五步：验证</h4><ol><li>运行脚本。</li><li>查看 <strong>View Results Tree</strong>。</li><li>点开 <strong>接口 B</strong> 的请求。<ul><li>点击 <strong>Request Body</strong>：看 <code>$&#123;my_uuid&#125;</code> 是否变成了具体的字符串（如 <code>c8f1...</code>）？</li><li>点击 <strong>Response Body</strong>：<code>httpbin</code> 会把发的数据原样返回，检查里面是否有刚才发的 ID。</li></ul></li></ol><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="关联"><hr><h1 id="调试和断言"><a href="#调试和断言" class="headerlink" title="调试和断言"></a>调试和断言</h1><h3 id="Debug-Sampler"><a href="#Debug-Sampler" class="headerlink" title="Debug Sampler"></a>Debug Sampler</h3><p>在开发脚本时，经常不知道变量到底提取到了没有。靠猜是不行的，需要看内存里的变量。</p><ol><li><strong>添加调试取样器</strong>：<ul><li><strong>右键点击</strong> <code>Thread Group</code> -&gt; <strong>Add</strong> -&gt; <strong>Sampler</strong> -&gt; <strong>Debug Sampler</strong>。</li><li>把这个 Sampler 拖到所有请求的最后面。</li></ul></li><li><strong>运行脚本</strong>：<ul><li>点击运行，查看 <strong>View Results Tree</strong>。</li><li>点击那个绿色的 <strong>Debug Sampler</strong>，查看 <strong>Response Body</strong>。</li><li>你应该能看到类似 <code>my_uuid=</code> 或者 <code>my_uuid=ERROR</code> (如果设置了默认值) 或者根本找不到 <code>my_uuid</code>。</li></ul></li></ol><p><strong>诊断</strong>：如果 <code>my_uuid</code> 后面是空的，说明 JSON Extractor 没有提取到数据。原因通常是：</p><ul><li><strong>JSON Path 写错了</strong>：比如写成了 <code>$.id</code> 但实际返回是 <code>uuid</code>。</li><li><strong>Default Value</strong>：你在提取器里把默认值留空了。<ul><li><em>建议习惯</em>：在 JSON Extractor 的 <code>Default Value</code> 里填上 <code>NOT_FOUND</code>。如果提取失败，变量就会变成 “NOT_FOUND”，在 Debug 时一眼就能看到。</li></ul></li></ul><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="debug"><hr><h3 id="修正提取器"><a href="#修正提取器" class="headerlink" title="修正提取器"></a>修正提取器</h3><ol><li>回到 <strong>JSON Extractor</strong>。</li><li>检查 <strong>JSON Path expressions</strong>：必须是 <code>$.uuid</code> (大小写敏感)。</li><li>设置 <strong>Default Value</strong>：输入 <code>NOT_FOUND</code>。</li><li>再次运行，看 Debug Sampler 里的 <code>my_uuid</code> 是否变成了具体的字符（如 <code>53e4...</code>）。</li></ol><hr><h3 id="Response-Assertion"><a href="#Response-Assertion" class="headerlink" title="Response Assertion"></a>Response Assertion</h3><p>让脚本在数据错误时<strong>自动报错（变红）</strong>，而不是人工去检查。给 <strong>接口 A</strong> 加一个“安检员”，确保它返回了想要的数据。</p><ol><li><strong>右键点击</strong> 接口 A (获取 UUID 的请求) -&gt; <strong>Add</strong> -&gt; <strong>Assertions (断言)</strong> -&gt; <strong>Response Assertion (响应断言)</strong>。</li><li>配置面板：<ul><li><strong>Apply to</strong>: <code>Main sample only</code> (默认)。</li><li><strong>Field to Test</strong>: 选择 <code>Text Response</code> (检查响应文本)。</li><li><strong>Pattern Matching Rules</strong>: 选择 <code>Contains</code> (包含)。</li><li><strong>Patterns to Test</strong>: 点击 Add，输入 <code>uuid</code>。</li><li><em>解释：这意味着，如果返回结果里连 “uuid” 这个词都没有，就判定为失败。</em></li></ul></li></ol><p><strong>更高级的用法（检查接口 B）：</strong> 我们要确保接口 B 发送的数据不是空的。</p><ol><li><strong>右键点击</strong> 接口 B -&gt; <strong>Add</strong> -&gt; <strong>Assertions</strong> -&gt; <strong>Response Assertion</strong>。</li><li><strong>Field to Test</strong>: 改选 <strong>Request Headers</strong> 或者 <strong>Request Data</strong> (注意这里是检查请求，不是响应)。<ul><li><em>JMeter 的断言通常检查响应，但也可以检查请求。不过更常用的做法是在提取后立刻检查变量。</em></li><li><strong>更好的做法</strong>：在接口 A 下面直接加一个 <strong>JSR223 Assertion</strong> (代码断言)，判断 <code>$&#123;my_uuid&#125;</code> 是否为空。不过为了不增加难度先跳过代码部分。</li></ul></li></ol><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image5.png" class="" title="断言"><hr><h1 id="场景设计与“无界面”压测"><a href="#场景设计与“无界面”压测" class="headerlink" title="场景设计与“无界面”压测"></a>场景设计与“无界面”压测</h1><p>问：“怎么执行 1000 并发的压测的？” 如果回答：“点击了界面上的绿色启动按钮” 这是不对的</p><p><strong>原因</strong>：JMeter 的图形界面 (GUI) 非常消耗内存和 CPU。真正的高并发压测，必须使用<strong>命令行 (CLI &#x2F; Non-GUI)</strong> 模式。</p><h4 id="任务一：事务控制器-Transaction-Controller"><a href="#任务一：事务控制器-Transaction-Controller" class="headerlink" title="任务一：事务控制器 (Transaction Controller)"></a>任务一：事务控制器 (Transaction Controller)</h4><p>假设一个“购买”操作包含了 3 个 API 请求。老板只想知道“购买”这个动作慢不慢，不想看每个 API 的细节。需要把它们包起来。</p><ol><li><strong>右键点击</strong> <code>Thread Group</code> -&gt; <strong>Add</strong> -&gt; <strong>Logic Controller (逻辑控制器)</strong> -&gt; <strong>Transaction Controller</strong>。</li><li>配置面板：<ul><li><strong>Generate parent sample</strong>: 勾选它。<ul><li><em>作用</em>：勾选后，报告里只会显示“Transaction Controller”这一行数据，把内部细节隐藏起来（或者作为子节点），方便看总耗时。</li></ul></li></ul></li><li><strong>移动请求</strong>：<ul><li>把之前的 <strong>接口 A (GET uuid)</strong> 和 <strong>接口 B (POST)</strong> 拖动到这个 <strong>Transaction Controller</strong> 的<strong>里面</strong>（成为子节点）。</li><li><em>现在的结构应该是：Thread Group -&gt; Transaction Controller -&gt; [接口A, 接口B]</em>。</li></ul></li></ol><h4 id="任务二：准备压测参数"><a href="#任务二：准备压测参数" class="headerlink" title="任务二：准备压测参数"></a>任务二：准备压测参数</h4><p>为了模拟一点压力，调整一下线程组参数：</p><ol><li>点击 <strong>Thread Group</strong>。</li><li><strong>Number of Threads</strong>: <code>10</code> (模拟 10 个用户)。</li><li><strong>Ramp-up Period</strong>: <code>2</code> (2秒内启动完)。</li><li><strong>Loop Count</strong>: <code>5</code> (每人跑 5 次)。</li><li><strong>保存脚本</strong>：一定要保存！假设保存为 <code>test_stage3.jmx</code>，记住保存的路径</li></ol><h4 id="任务三：命令行执行-CLI-Mode-——-核心技能"><a href="#任务三：命令行执行-CLI-Mode-——-核心技能" class="headerlink" title="任务三：命令行执行 (CLI Mode) —— 核心技能"></a>任务三：命令行执行 (CLI Mode) —— <strong>核心技能</strong></h4><ol><li><p><strong>进入脚本所在目录并打开终端&#x2F;命令行</strong></p></li><li><p><strong>输入压测命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmeter -n -t test_stage3.jmx -l result.jtl -e -o ./report<br></code></pre></td></tr></table></figure><p><strong>参数详解：</strong></p><ul><li><code>-n</code>: <strong>n</strong>on-GUI mode (无界面模式)。</li><li><code>-t</code>: 指定测试脚本文件 (<strong>t</strong>est plan)。</li><li><code>-l</code>: 指定结果文件路径 (<strong>l</strong>og)，通常存为 <code>.jtl</code> 格式。</li><li><code>-e</code>: 测试结束后生成 Web 报告 (<strong>e</strong>nd of run)。</li><li><code>-o</code>: 指定报告输出文件夹 (<strong>o</strong>utput folder)。<strong>注意：这个文件夹必须是空的或者不存在，否则会报错。</strong></li></ul></li><li><p><strong>执行</strong>：</p><ul><li>按下回车。应该会看到命令行里在滚动类似 <code>Summary + ...</code> 的日志。等待它显示 <code>... end of run</code>。</li></ul></li></ol><h4 id="任务四：查看上帝视角报告"><a href="#任务四：查看上帝视角报告" class="headerlink" title="任务四：查看上帝视角报告"></a>任务四：查看上帝视角报告</h4><ol><li>打开脚本目录。</li><li>多了一个 <code>report</code> 文件夹。</li><li>进入文件夹，双击 <code>index.html</code>。</li></ol><p>这是一个非常专业的 HTML 性能测试报告。找到 <strong>Charts</strong> -&gt; <strong>Response Times</strong> -&gt; <strong>Response Time Percentiles</strong>。</p><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image6.png" class="" title="报告首页"><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image7.png" class="" title="响应时间"><hr><h1 id="解读Statistics-表格核心指标"><a href="#解读Statistics-表格核心指标" class="headerlink" title="解读Statistics 表格核心指标"></a>解读Statistics 表格核心指标</h1><ol><li><strong>Samples (样本数)</strong>: 总请求数。</li><li><strong>Average (平均值)</strong>: 平均分。<ul><li><em>误区</em>：<strong>平均值是最会骗人的！</strong> 比如我和马云的平均资产是几千亿，但这不能代表我的真实水平。在性能测试中，只要有几个极端的慢请求（比如超时），平均值就会被拉高或拉低，掩盖真相。</li></ul></li><li><strong>Min &#x2F; Max</strong>: 响应最快和最慢的时间</li><li><strong>Error %</strong>: 报错的请求占比。通常要求 <strong>0%</strong> 或者 <strong>&lt; 0.1%</strong>。</li><li><strong>Throughput (吞吐量&#x2F;TPS)</strong>: 代表服务器“每秒能处理多少个请求”。</li></ol><hr><h3 id="Percentiles-百分位数-P90-P95-P99"><a href="#Percentiles-百分位数-P90-P95-P99" class="headerlink" title="Percentiles (百分位数 - P90, P95, P99)"></a>Percentiles (百分位数 - P90, P95, P99)</h3><p><strong>互联网大厂定验收标准（SLA）</strong> 的依据。</p><ul><li><strong>P90 (90th pct)</strong>：将所有请求的响应时间从小到大排列，排在 <strong>90%</strong> 位置的那个时间。<ul><li><em>人话</em>：<strong>“90% 的用户都能在 X 秒内得到响应。”</strong></li></ul></li><li><strong>P99 (99th pct)</strong>：排在 <strong>99%</strong> 位置的时间。<ul><li><em>人话</em>：<strong>“99% 的用户都能在 X 秒内得到响应。”</strong> (排除了 1% 的极端慢请求)。</li></ul></li></ul><p><strong>如果 Average 是 100ms，但 P90 是 500ms，说明了什么？</strong></p><blockquote><p><strong>结论：系统不稳定，存在严重的“长尾效应” (Long Tail)。</strong></p></blockquote><ul><li><strong>分析</strong>：<ul><li>平均值 100ms 很低，说明<strong>大部分</strong>请求都非常快（可能只有 50-80ms）。</li><li>但 P90 到了 500ms，说明<strong>有至少 10% 的用户</strong>体验非常差，比正常慢了 5 倍以上。</li></ul></li><li><strong>常见原因</strong>：<ul><li><strong>代码问题</strong>：偶尔触发了复杂的逻辑分支。</li><li><strong>Java 应用</strong>：发生了 <strong>Full GC</strong> (垃圾回收)，导致系统暂停了几百毫秒。</li><li><strong>数据库</strong>：偶尔遇到了锁等待，或者缓存刚好失效了（缓存穿透）。</li></ul></li></ul><blockquote><p>“不能只看平均值，因为平均值会掩盖性能抖动。在这个场景下，虽然平均响应快，但 P90 差距过大，说明系统存在偶发性的卡顿或资源争用，不满足稳定性要求，需要排查 GC 日志或慢查询。”</p></blockquote><hr><h1 id="监控与瓶颈定位"><a href="#监控与瓶颈定位" class="headerlink" title="监控与瓶颈定位"></a>监控与瓶颈定位</h1><p>**如果分数低（响应慢），到底是谁的锅？**是网络卡？CPU 满了？还是数据库死锁了？</p><p>JMeter 本身只能告诉你“慢”，不能告诉你“为什么慢”。需要给服务器插上“体温计”。</p><h4 id="任务一：安装插件管理器-Plugins-Manager"><a href="#任务一：安装插件管理器-Plugins-Manager" class="headerlink" title="任务一：安装插件管理器 (Plugins Manager)"></a>任务一：安装插件管理器 (Plugins Manager)</h4><p>JMeter 原生功能有限，需要安装最强的插件来监控服务器。</p><p><strong>下载插件管理器</strong>：去官网下载 <code>jmeter-plugins-manager-1.x.jar</code></p><p>**替代方案： 不依赖 JMeter 插件，而是学习用 **Linux 命令来监控。</p><h4 id="任务二：模拟瓶颈与观察-思想实验"><a href="#任务二：模拟瓶颈与观察-思想实验" class="headerlink" title="任务二：模拟瓶颈与观察 (思想实验)"></a>任务二：模拟瓶颈与观察 (思想实验)</h4><p>发现 TPS 上不去了，P99 特别高。需要立即去服务器上敲以下命令：</p><ol><li><strong><code>top</code></strong> —— <strong>看 CPU 和 内存</strong><ul><li>如果你看到 <code>us</code> (User CPU) 飙到 90% 以上：说明是<strong>代码计算量太大</strong>（算法不行，或者死循环）。</li><li>如果你看到 <code>wa</code> (Wait I&#x2F;O) 很高：说明 CPU 都在等<strong>磁盘读写</strong>（数据库在疯狂刷盘，或者日志打得太疯）。</li></ul></li><li><strong><code>free -m</code></strong> —— <strong>看内存</strong><ul><li>如果 <code>available</code> 几乎为 0，且 Swap 被大量使用：说明<strong>内存泄漏</strong> (Memory Leak) 或内存不足。</li></ul></li><li><strong><code>netstat -nat | grep ESTABLISHED | wc -l</code></strong> —— <strong>看网络连接</strong><ul><li>查看当前建立了多少连接。如果连接数过多但处理不过来，可能是连接池配置太小。</li></ul></li></ol><p>问：如果压测时，<strong>JMeter 这一端的 CPU 占用率达到了 100%</strong>，而服务器端 CPU 只有 10%。这时候生成的测试报告可信吗？</p><p>答：<strong>绝对不可信，报告是废的。</strong></p><ul><li><strong>原因</strong>：这叫“施压机瓶颈”。<ul><li>就像想测试法拉利（服务器）能跑多快，但骑着自行车（JMeter）去追。</li><li>因为你的自行车最快只能骑 20km&#x2F;h（CPU 满了，发不出更多请求了），所以会误以为法拉利最高时速只有 20km&#x2F;h。</li><li>实际上服务器可能根本没感觉。</li></ul></li><li><strong>解决办法</strong>：<ol><li>优化脚本（关掉 View Results Tree，用命令行跑）。</li><li><strong>分布式压测</strong>：找 3 台电脑一起向服务器发起攻击</li></ol></li></ul><hr><h1 id="代码扩展"><a href="#代码扩展" class="headerlink" title="代码扩展"></a>代码扩展</h1><p>当工具满足不了需求时，你要能写代码解决。JMeter 支持用 Java&#x2F;Groovy 代码来处理逻辑。</p><p>现在的 App 接口通常都很安全。比如登录时，密码不是明文传输的，而是 <code>md5(密码 + 时间戳)</code>。JMeter 自带的加密功能很弱，这时候就得写代码。</p><h4 id="任务一：添加-JSR223-PreProcessor"><a href="#任务一：添加-JSR223-PreProcessor" class="headerlink" title="任务一：添加 JSR223 PreProcessor"></a>任务一：添加 JSR223 PreProcessor</h4><p>模拟：在发送请求<strong>前</strong>，把密码加密成 MD5。</p><ol><li>回到 <strong>HTTP Request</strong>（比如之前的百度搜索）。</li><li><strong>右键</strong> -&gt; <strong>Add</strong> -&gt; <strong>Pre Processors (前置处理器)</strong> -&gt; <strong>JSR223 PreProcessor</strong>。<ul><li><em>注意：尽量用 JSR223 + Groovy 语言，不要用 BeanShell，因为 Groovy 性能快得多。</em></li></ul></li><li><strong>Language</strong>: 选择 <code>groovy</code>。</li></ol><h4 id="任务二：编写-Groovy-代码"><a href="#任务二：编写-Groovy-代码" class="headerlink" title="任务二：编写 Groovy 代码"></a>任务二：编写 Groovy 代码</h4><p>在 Script 区域输入以下代码（这是标准的 Java&#x2F;Groovy 写法）：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.apache.commons.codec.digest.DigestUtils;<br><br><span class="hljs-comment">// 1. 获取当前时间戳</span><br>String timestamp = String.valueOf(System.currentTimeMillis());<br><br><span class="hljs-comment">// 2. 模拟一个密码</span><br>String password = <span class="hljs-string">&quot;123456&quot;</span>;<br><br><span class="hljs-comment">// 3. 进行拼接并 MD5 加密 (需要 commons-codec 包，JMeter 自带)</span><br><span class="hljs-comment">// 假设规则是：密码 + 时间戳</span><br>String signature = DigestUtils.md5Hex(password + timestamp);<br><br><span class="hljs-comment">// 4. 将结果存入 JMeter 变量，供后面使用</span><br>vars.put(<span class="hljs-string">&quot;my_sign&quot;</span>, signature);<br>vars.put(<span class="hljs-string">&quot;my_time&quot;</span>, timestamp);<br><br><span class="hljs-comment">// 调试一下，打印到控制台（黑窗口）</span><br>log.info(<span class="hljs-string">&quot;加密结果: &quot;</span> + signature);<br></code></pre></td></tr></table></figure><h4 id="任务三：在请求中使用"><a href="#任务三：在请求中使用" class="headerlink" title="任务三：在请求中使用"></a>任务三：在请求中使用</h4><ol><li>回到 <strong>HTTP Request</strong>。</li><li>添加一个参数（或者修改之前的 wd）：<ul><li>Name: <code>sign</code></li><li>Value: <code>$&#123;my_sign&#125;</code></li></ul></li><li>打开 <strong>Log Viewer</strong>（菜单栏 Options -&gt; Log Viewer，底部会出现日志窗口）。</li><li>运行脚本。</li></ol><p><strong>看一下：</strong></p><ol><li>底部日志窗口有没有打印出 <code>加密结果: xxxxx...</code>？</li><li>察看结果树里，发出的请求参数 <code>sign</code> 是不是变成了一串乱码一样的 MD5 值？</li></ol><img src="/2025/12/20/Jmeter%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image8.png" class="" title="代码扩展"><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能测试</tag>
      
      <tag>压力测试</tag>
      
      <tag>jmeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux基础学习</title>
    <link href="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="操作系统"><h1 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h1><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="linux介绍"><p>简单说，Linux 和平时用的 Windows、macOS 一样，都是<strong>操作系统（Operating System）</strong>。</p><p>但它有两个核心特点，注定让它成为了服务器领域的霸主：</p><ol><li><strong>开源免费</strong>：源代码是公开的，任何人都可以修改。</li><li><strong>极度稳定</strong>：它可以连续运行几年不关机、不重启，而且效率极高。</li></ol><p>在 Windows&#x2F;Mac 电脑上写代码、写文档（这是工作环境）；但测试的代码、数据库、服务，通常都运行在远端的 Linux 服务器上（这是生产&#x2F;测试环境）。</p><hr><p>可以把 Linux 系统想象成一家<strong>餐厅</strong>：</p><ul><li><strong>硬件（Hardware）</strong> ➜ <strong>厨房的食材和灶具</strong><ul><li>这是底层的 CPU、内存、硬盘。</li></ul></li><li><strong>内核（Kernel）</strong> ➜ <strong>大厨</strong><ul><li>这是 Linux 的核心。只有大厨（内核）有权直接操作灶具（硬件），别人不能乱动。它负责管理内存、CPU 调度。</li></ul></li><li><strong>Shell（终端&#x2F;命令行）</strong> ➜ <strong>服务员</strong><ul><li>这就是以后要面对的那个“黑底白字的窗口”。</li><li><strong>顾客</strong>不能直接进厨房炒菜，必须把需求告诉服务员（输入命令），服务员传达给大厨（内核），大厨做好后，服务员再显示结果。</li></ul></li><li><strong>应用程序（Applications）</strong> ➜ <strong>菜品</strong><ul><li>在上面跑的 MySQL 数据库、Tomcat、Nginx 或者写的 Python 自动化脚本。</li></ul></li></ul><hr><h3 id="Linux-发行版（Distributions）"><a href="#Linux-发行版（Distributions）" class="headerlink" title="Linux 发行版（Distributions）"></a>Linux 发行版（Distributions）</h3><p>Ubuntu、CentOS、RedHat、Debian… 其实，Linux <strong>内核</strong> 只有一个。但是不同的公司为了方便用户使用，把内核 + 各种常用软件 + 安装工具打包在一起，就变成了<strong>发行版</strong>。</p><ul><li><strong>CentOS &#x2F; RedHat</strong>：企业级服务器**最常用的版本。特点是稳，但软件版本比较老。</li><li><strong>Ubuntu</strong>：开发者和 AI 领域最喜欢的。界面友好，软件比较新。</li><li><strong>Kali Linux</strong>：黑客和安全测试人员专用的（如果你做安全测试会用到）。</li></ul><p>命令是通用的。学会了 CentOS，Ubuntu 也能上手，反之亦然。</p><hr><h3 id="为什么测开不用图形界面（GUI）"><a href="#为什么测开不用图形界面（GUI）" class="headerlink" title="为什么测开不用图形界面（GUI）"></a>为什么测开不用图形界面（GUI）</h3><p>在 Linux 服务器上，通常通过 <strong>SSH（远程连接）</strong> 对话。</p><ol><li><strong>省资源</strong>：图形界面非常吃内存和 CPU。服务器资源要留给跑代码，而不是用来渲染漂亮的窗口。</li><li><strong>效率</strong>：<ul><li>想删除 1000 个特定的日志文件。</li><li><strong>Windows</strong>：按住 Ctrl 选半天，或者框选。</li><li><strong>Linux</strong>：一行代码 <code>rm *.log</code>，0.1 秒搞定。</li></ul></li><li><strong>自动化</strong>：测开的核心是自动化。图形界面的操作很难写进脚本里，但命令行（Shell 脚本）天生就是为了自动化而生的。</li></ol><p>问题：为什么说 Linux 没 GUI，但有时候在双系统&#x2F;租云服务器时又能看到界面？</p><p><strong>Linux内核</strong> 本身只是一个命令行（文本界面）的核心。它的主要职责是管理硬件和资源（进程、内存、设备等），<strong>不负责绘制窗口、按钮、菜单或处理鼠标点击</strong>。而GUI是<strong>它们在Linux内核之上，叠加了一整套庞大的“图形化软件栈”</strong>。这套软件栈不是内核的一部分，而是运行在内核之上的应用程序和服务。简单来说，图形界面只是一个普通的软件。</p><hr><h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><p>简单理解为：<strong>一台位于远程数据中心、24小时不断电、通过网络租给你用的高性能电脑。</strong></p><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="云服务器"><p>在互联网公司（比如你要去的实习岗位），所有的代码、数据库、测试环境，<strong>都不会</strong>跑在开发人员自己的笔记本上，而是跑在云服务器上。</p><ul><li><strong>随时随地访问</strong>：合上笔记本回家了，服务器还在运行自动化测试脚本。</li><li><strong>公网 IP</strong>：云服务器有一个公网 IP 地址。在上面部署一个网站，全世界的人都能通过浏览器访问它。</li><li><strong>弹性</strong>：今天测试压力小，租个 2核4G 的；明天搞双十一压测，一键升级成 64核128G 的。</li></ul><h4 id="2-打个比方"><a href="#2-打个比方" class="headerlink" title="2. 打个比方"></a>2. 打个比方</h4><ul><li><strong>虚拟机&#x2F;WSL（本地环境）</strong>：就像在自己家里买了一台跑步机。如果不维护（关机&#x2F;重装系统），它就停了。</li><li><strong>云服务器</strong>：就像办了一张健身房年卡。场地、设备人家都维护好了，只需要去“用”就行，而且那是公共场所（公网），可以约朋友（用户）一起来。</li></ul><hr><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="终端"><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>Linux 是一个倒挂的大树，树根是 <code>/</code>。</p><ul><li><strong><code>pwd</code></strong> (Print Working Directory)：显示当前路径。<ul><li>输入 <code>pwd</code> 回车。应该在 <code>/root</code></li></ul></li><li><strong><code>ls</code></strong> (List)：看看这里有什么。<ul><li><em>试一试</em>：输入 <code>ls</code>，或者更常用的 <code>ls -l</code> (显示详细信息)。</li></ul></li><li><strong><code>cd</code></strong> (Change Directory)：传送门。<ul><li><em>试一试</em>：<ol><li><code>cd /</code> (回到根目录，这里是系统的起点)</li><li><code>cd ~</code> (波浪号代表<strong>回家</strong>。无你在哪里，一键回到家目录)</li></ol></li></ul></li></ul><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image5.png" class="" title="目录操作1"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image6.png" class="" title="目录操作2"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image7.png" class="" title="目录操作3"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image8.png" class="" title="操作"><hr><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image10.png" class="" title="创建文件1"><ul><li><strong><code>mkdir</code></strong> (Make Directory)：建文件夹。<ul><li><em>试一试</em>：<code>mkdir my_test_project</code></li></ul></li><li><strong><code>touch</code></strong>：建空文件（或者更新文件时间戳）。<ul><li><em>试一试</em>：<code>cd my_test_project</code> (进入刚才建的目录)，然后 <code>touch readme.txt</code></li></ul></li><li><strong><code>cp</code></strong> (Copy)：复制（备份神器）。<ul><li><em>试一试</em>：<code>cp readme.txt readme.txt.bak</code></li><li><em>场景</em>：修改生产环境配置前，<strong>必须</strong>先 cp 备份一份，防止改挂了回不去。</li></ul></li><li><strong><code>mv</code></strong> (Move)：移动，或者<strong>重命名</strong>。<ul><li><em>试一试</em>：<code>mv readme.txt config.txt</code> (把 readme.txt 改名为 config.txt)</li><li>mv和cp命令在移动或复制过程中都可以重命名</li></ul></li><li><strong><code>rm</code></strong> (Remove)：删除（慎用！）。<ul><li><em>试一试</em>：<code>rm readme.txt.bak</code> (删除刚才那个备份文件)</li><li><strong>高危警告</strong>：<code>rm -rf 目录名</code> 是强制删除目录及其下所有东西。千万不要手滑敲成 <code>rm -rf /</code>，那样服务器就“自杀”了。</li></ul></li></ul><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image9.png" class="" title="创建文件2"><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image13.png" class="" title="查找文件"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image11.png" class="" title="查找文件2"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image12.png" class="" title="查找文件3"><h3 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h3><p>在 Linux 上用 <strong>Vim</strong>。 Vim 有两个模式</p><ol><li><strong>命令模式</strong>（默认）：键盘是用来发号施令的（复制、粘贴、保存），不能打字。</li><li><strong>编辑模式</strong>：这才是打字的。</li></ol><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image14.png" class="" title="Vim模式"><p><strong>⚡️ 极速上手三板斧：</strong></p><ol><li><strong>打开文件</strong>：<code>vim config.txt</code></li><li><strong>开始打字</strong>：按一下 <strong><code>i</code></strong> 键（Insert）。（发现左下角变成了 <code>-- INSERT --</code>，现在可以像记事本一样打字了）。</li><li><strong>保存退出</strong>：<ul><li>按一下 <strong><code>Esc</code></strong> 键（退出编辑模式，左下角 INSERT 消失）。</li><li>输入 <strong><code>:wq</code></strong> </li><li><strong>回车</strong>。</li><li><em>解释：<code>:</code>是指令开始，<code>w</code>&#x3D;write(保存)，<code>q</code>&#x3D;quit(退出)。</em></li></ul></li></ol><blockquote><p><strong>如果不小心搞乱了想强制退出（不保存）</strong>：按 <code>Esc</code>，输入 <code>:q!</code> 然后回车。</p></blockquote><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image15.png" class="" title="编辑模式"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image16.png" class="" title="底行模式"><p>可能会遇到的问题：</p><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image17.png" class="" title="编辑常见问题"><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image18.png" class="" title="查看文件1"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image19.png" class="" title="查看文件2"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image20.png" class="" title="查看文件3"><hr><h3 id="文件解压缩"><a href="#文件解压缩" class="headerlink" title="文件解压缩"></a>文件解压缩</h3><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image22.png" class="" title="解压缩1"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image21.png" class="" title="解压缩2"><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image23.png" class="" title="解压缩3"><p><code>tar</code> 是 Linux 最经典的打包命令，通常打包出来的文件叫 <code>.tar.gz</code>。只需要记住两句口诀：</p><ul><li><strong>打包（压缩）</strong> ➜ <strong><code>czvf</code></strong><ul><li>命令：<code>tar -czvf my_logs.tar.gz ./logs</code></li><li><em>记忆法</em>：<strong>C</strong>reate (创建) <strong>Z</strong>ipped (压缩) <strong>V</strong>erbose (显示过程) <strong>F</strong>ile (档案)。</li><li><em>意思</em>：把当前目录下的 <code>logs</code> 文件夹，打包成 <code>my_logs.tar.gz</code>。</li></ul></li><li><strong>解包（解压）</strong> ➜ <strong><code>xzvf</code></strong><ul><li>命令：<code>tar -xzvf my_logs.tar.gz</code></li><li><em>记忆法</em>：<strong>X</strong>tract (提取&#x2F;解压)。把 C 换成 X 就行了。</li></ul></li></ul><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>Linux 哪怕只有一个人用，它也会假想出三种角色。执行 <code>ls -l</code>，会看到类似 <code>-rwxr-xr--</code> 的代码，它是这样分组的：</p><ol><li><strong>Owner (属主&#x2F;u)</strong>：<strong>文件的亲爹</strong>。通常是创建这个文件的人。拥有最高话语权。</li><li><strong>Group (属组&#x2F;g)</strong>：<strong>亲友团</strong>。属于这个组的人，共享同一套权限。（比如“开发组”的几个人都能改代码，但不能删）。</li><li><strong>Others (其他人&#x2F;o)</strong>：<strong>路人甲</strong>。除了上面两种人之外的所有人。</li></ol><hr><h4 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h4><p>这是最基础的，但要注意：<strong>对文件</strong>和<strong>对目录</strong>，它们的含义略有不同！</p><table><thead><tr><th><strong>权限符</strong></th><th><strong>对应数字</strong></th><th><strong>对文件的含义</strong></th><th><strong>对目录的含义 (⚠️重点)</strong></th></tr></thead><tbody><tr><td><strong>r</strong> (Read)</td><td><strong>4</strong></td><td>可以查看内容 (<code>cat</code>)</td><td>可以列出里面有什么文件 (<code>ls</code>)</td></tr><tr><td><strong>w</strong> (Write)</td><td><strong>2</strong></td><td>可以修改内容 (<code>vim</code>)</td><td>可以<strong>在里面</strong>创建或删除文件 (<code>touch</code>&#x2F;<code>rm</code>)</td></tr><tr><td><strong>x</strong> (eXecute)</td><td><strong>1</strong></td><td>可以运行它 (如果是脚本)</td><td><strong>可以进入该目录</strong> (<code>cd</code>)</td></tr><tr><td><strong>-</strong></td><td><strong>0</strong></td><td>无权限</td><td>无权限</td></tr></tbody></table><blockquote><p>如果一个目录有 r (读) 权限，但没有 x (执行) 权限，能 cd 进去吗？</p><p>答案：不能。你能看到里面有啥，但你进不去。</p></blockquote><hr><h4 id="chmod-改权限"><a href="#chmod-改权限" class="headerlink" title="chmod (改权限)"></a>chmod (改权限)</h4><h5 id="数字法"><a href="#数字法" class="headerlink" title="数字法"></a>数字法</h5><p>这是基于二进制计算的：R&#x3D;4, W&#x3D;2, X&#x3D;1。</p><p>想要什么权限，就把数字加起来。</p><ul><li><strong>7</strong> &#x3D; 4+2+1 (读+写+执行，全能)</li><li><strong>6</strong> &#x3D; 4+2 (读+写)</li><li><strong>5</strong> &#x3D; 4+1 (读+执行)</li><li><strong>0</strong> &#x3D; 什么都不行</li></ul><p><strong>常见组合：</strong></p><ul><li><strong><code>chmod 777 file</code></strong>：每个人都能读写执行（<strong>极度不安全</strong>，除非测试需要）。</li><li><strong><code>chmod 755 file</code></strong>：<ul><li>Owner (7): 啥都能干。</li><li>Group (5): 只能看和运行，不能改。</li><li>Others (5): 只能看和运行，不能改。</li><li><em>(这是脚本&#x2F;程序的标准权限)</em></li></ul></li><li><strong><code>chmod 644 file</code></strong>：<ul><li>Owner (6): 读写。</li><li>Group (4): 只读。</li><li>Others (4): 只读。</li><li><em>(这是普通配置文件的标准权限)</em></li></ul></li></ul><h5 id="字母法（适合微调）"><a href="#字母法（适合微调）" class="headerlink" title="字母法（适合微调）"></a>字母法（适合微调）</h5><p>公式：<code>u/g/o</code> (谁) <code>+/-</code> (加减) <code>r/w/x</code> (权限)</p><ul><li><code>chmod u+x run.sh</code>：给<strong>Owner</strong>增加<strong>执行</strong>权限。</li><li><code>chmod go-w config.ini</code>：把<strong>Group</strong>和<strong>Others</strong>的<strong>写</strong>权限去掉（防止别人乱改）。</li></ul><hr><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>有时候文件权限是对的（777），但程序还是报错，为什么？因为文件的主人不对。</p><p>比如 Nginx 服务通常是用 www 用户运行的，如果你的网页文件属于 root，Nginx 可能就读不动。</p><ul><li><p><strong>命令</strong>：<code>chown 用户名:组名 文件名</code></p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> mysql:mysql my_database.db<br></code></pre></td></tr></table></figure><p><em>(把这个数据库文件过户给 mysql 用户)</em></p></li></ul><hr><h4 id="终极权限：Sudo-Root"><a href="#终极权限：Sudo-Root" class="headerlink" title="终极权限：Sudo &amp; Root"></a>终极权限：Sudo &amp; Root</h4><ul><li><strong>Root</strong>：Linux 的神。无视所有规则。即使文件是只读的，Root 也能强行删除。</li><li><strong>Sudo</strong>：当用普通用户（比如 <code>ubuntu</code>）登录时，想干只有 Root 才能干的事（比如安装软件 <code>apt install</code>），你就要加 <code>sudo</code>。<ul><li>它的意思是：“以超级管理员的身份执行这条命令”。</li></ul></li></ul><hr><h1 id="进程与端口管理"><a href="#进程与端口管理" class="headerlink" title="进程与端口管理"></a>进程与端口管理</h1><ul><li>“我部署了服务，但网页打不开，是没启动吗？”</li><li>“我想启动一个新的测试环境，系统提示端口被占用（Address already in use）。”</li><li>“服务器 CPU 突然飙到 100%，是谁在搞鬼？”</li></ul><p>解决这些问题，需要掌握这套“<strong>查进程 -&gt; 杀进程 -&gt; 查端口</strong>”的连招。</p><hr><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>在 Windows 任务管理器里可以看到运行的所有软件。在 Linux 里，用 <code>ps</code> (Process Status)。</p><h4 id="核心命令：ps-ef"><a href="#核心命令：ps-ef" class="headerlink" title="核心命令：ps -ef"></a>核心命令：<code>ps -ef</code></h4><p>这会列出系统当前运行的所有进程。但因为进程太多，直接敲这个命令会刷屏。所以配合 grep：</p><p>查看 python 程序有没有在运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep python<br></code></pre></td></tr></table></figure><p>会看到类似这样的很多行：</p><p>root      1234     1  0 10:00 ?        00:00:00 python3 server.py</p><ul><li><strong><code>root</code></strong>: 谁启动的</li><li><strong><code>1234</code> (PID)</strong>: 身份证号 (Process ID)。这是操作它的唯一凭证，后面傻进程全靠它。</li><li><strong><code>python3 server.py</code></strong>: 启动命令是什么？</li></ul><blockquote><p><strong>💡 注意</strong>：通常会看到两行，其中一行是 <code>grep python</code> 本身，那是你刚才敲的命令，忽略它。</p></blockquote><h4 id="进阶命令：top"><a href="#进阶命令：top" class="headerlink" title="进阶命令：top"></a>进阶命令：<code>top</code></h4><p>如果想看“谁最吃 CPU”或者“内存还剩多少”，输入 <code>top</code>。</p><ul><li>这就相当于 Windows 任务管理器的“性能”页。</li><li><strong>按 <code>q</code> 退出</strong>。</li></ul><hr><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>当某个服务卡死了，或者想重启它，需要先把它“杀掉”。</p><h4 id="核心命令：kill"><a href="#核心命令：kill" class="headerlink" title="核心命令：kill"></a>核心命令：<code>kill</code></h4><ul><li><strong>温柔一刀</strong>：<code>kill PID</code><ul><li>例如：<code>kill 1234</code></li><li>这是发送信号让程序“收拾收拾自己退出”，大部分正常程序会听话。</li></ul></li><li><strong>强制处决</strong>：<code>kill -9 PID</code><ul><li>例如：<code>kill -9 1234</code></li><li><strong><code>-9</code></strong> 代表“强制杀死”。不管程序正在干嘛，直接从内存里抹去。当程序死锁无响应时，用这个。</li></ul></li></ul><hr><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><p>有时候进程在运行，但网页打不开，可能是**端口（Port）**没对上，或者被防火墙挡了。</p><h4 id="核心命令：netstat-或-ss"><a href="#核心命令：netstat-或-ss" class="headerlink" title="核心命令：netstat 或 ss"></a>核心命令：<code>netstat</code> 或 <code>ss</code></h4><p><em>注：如果提示 <code>netstat: command not found</code>，请先运行 <code>apt install net-tools</code> 安装它。</em></p><p>想知道 8080 端口现在是被谁占用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">netstat -nlp | grep <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>*(记忆口诀：<strong>nlp</strong> &#x3D; <strong>N</strong>umeric(数字显示) <strong>L</strong>istening(监听中) <strong>P</strong>rogram(显示程序名))*</p><p>输出解读：tcp  0  0 0.0.0.0:8080  0.0.0.0:* LISTEN  5678&#x2F;java</p><ul><li>说明 <strong>8080</strong> 端口正在被 PID 为 <strong>5678</strong> 的 <strong>java</strong> 程序占用。</li><li>如果想启动新程序也用 8080，就得先 <code>kill 5678</code>。</li></ul><hr><h1 id="监控与分析"><a href="#监控与分析" class="headerlink" title="监控与分析"></a>监控与分析</h1><h2 id="实时监控-tail-f"><a href="#实时监控-tail-f" class="headerlink" title="实时监控 (tail -f)"></a>实时监控 (<code>tail -f</code>)</h2><p>场景：在前端点一个按钮（比如“提交订单”），页面转圈圈没反应。需要立刻知道后台此刻报没报错。</p><p>这时候用 cat 是不行的，因为文件是静态的。需要动态地盯着它。</p><ul><li><strong>命令</strong>：<code>tail -f 文件名</code><ul><li><code>-f</code> &#x3D; follow（跟随）。</li><li><strong>效果</strong>：屏幕会卡住，一旦日志文件有新内容写入，屏幕上会立刻滚动显示出来。就像你看直播弹幕一样。</li></ul></li><li><strong>退出</strong>：按 <code>Ctrl + C</code>。</li></ul><hr><h2 id="多维过滤-Advanced-grep"><a href="#多维过滤-Advanced-grep" class="headerlink" title="多维过滤 (Advanced grep)"></a>多维过滤 (Advanced <code>grep</code>)</h2><p>第一阶段学了基础的 <code>grep</code>，但实战中情况更复杂。</p><ul><li><strong>场景 A：不仅想看 Error，还想看 Warning</strong><ul><li><strong>命令</strong>：<code>grep -E &quot;Error|Warning&quot; server.log</code></li><li><em>解释</em>：<code>-E</code> 开启扩展正则，<code>|</code> 代表“或者”。</li></ul></li><li><strong>场景 B：报错太多了，想统计一下到底报了多少次</strong><ul><li><strong>命令</strong>：<code>grep &quot;Error&quot; server.log | wc -l</code></li><li><em>解释</em>：<code>|</code> 是<strong>管道符</strong>（把前一个命令的结果传给后一个命令）；<code>wc -l</code> (Word Count -lines) 是之前学的数行数。</li><li><em>结果</em>：直接输出一个数字，比如 <code>520</code>。</li></ul></li></ul><hr><h2 id="精准提取-awk"><a href="#精准提取-awk" class="headerlink" title="精准提取 (awk)"></a>精准提取 (<code>awk</code>)</h2><p><strong>提取某一列</strong></p><p>场景：</p><p>日志格式通常是这样的（空格分隔）：2025-12-18  10:00:01  Error  User_A  Timeout</p><p>(第1列)      (第2列)   (第3列) (第4列)  (第5列)</p><p>如果想<strong>把所有报错的用户（第4列）提取出来</strong>，做成一个名单：</p><ul><li><p><strong>命令</strong>：<code>awk &#39;&#123;print $4&#125;&#39; server.log</code></p><ul><li><p><em>解释</em>：<code>$4</code> 代表第四列。awk 会自动按空格切分每一行。</p></li><li><p><em>效果</em>：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">User_A<br>User_B<br>User_A<br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>进阶组合（去重统计）：</p><p>“我想知道哪个用户报错最多？”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $4&#125;&#x27;</span> server.log | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br></code></pre></td></tr></table></figure><ul><li><code>sort</code>：排序（把一样的排到一起）。</li><li><code>uniq -c</code>：去重并计数 (Count)。</li></ul></li></ul><hr><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h2><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><ol><li><p><strong>更新软件源</strong>（防止下载到旧版本）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br></code></pre></td></tr></table></figure></li><li><p><strong>安装 MySQL Server</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install mysql-server -y<br></code></pre></td></tr></table></figure></li><li><p><strong>启动并设置开机自启</strong>（防止服务器重启后数据库挂了）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysql<br>systemctl <span class="hljs-built_in">enable</span> mysql<br></code></pre></td></tr></table></figure></li><li><p><strong>检查状态</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysql<br></code></pre></td></tr></table></figure><p><em>看到绿色的 <code>active (running)</code> 后，按 <code>q</code> 退出。</em></p></li></ol><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image24.png" class="" title="MySQL部署"><hr><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>Ubuntu 安装的 MySQL 默认 root 账号没有密码，但只能在服务器内部用 <code>sudo</code> 登录。需要给它设置一个密码，方便后续代码连接。</p><ol><li><p><strong>直接进入数据库</strong>（利用 sudo 权限）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql<br></code></pre></td></tr></table></figure><p><em>看到提示符变成了 <code>mysql&gt;</code>。</em></p></li><li><p>修改密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p><em>解释：<code>mysql_native_password</code> 是为了兼容性，防止旧版 Java 连接驱动报错。</em></p></li><li><p><strong>刷新权限</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p><strong>退出</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">exit;<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="导入sql文件"><a href="#导入sql文件" class="headerlink" title="导入sql文件"></a>导入sql文件</h3><ol><li><strong>图形化方法（用 Navicat）</strong>：最简单，鼠标点点就行。</li><li><strong>命令行方法（在 Linux 里）</strong>：</li></ol><p><strong>上传文件</strong>：</p><ul><li>用 FinalShell 下方的文件窗口，把 <code>xxx.sql</code> 拖拽到 <code>/root</code> 目录。</li></ul><p><strong>执行导入命令</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 语法：mysql <span class="hljs-operator">-</span>u 用户名 <span class="hljs-operator">-</span>p 数据库名 <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">sql</span>文件名<br>mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">&lt;</span> <span class="hljs-operator">/</span>root<span class="hljs-operator">/</span>init.sql<br></code></pre></td></tr></table></figure><p><em>(输入密码后，没有任何提示说明导入成功)</em></p><hr><h3 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h3><p>默认情况下，MySQL 只允许本机（127.0.0.1）访问。这意味着： 想用 Navicat&#x2F;DBeaver 连接服务器，都会连不上。</p><p>需要做两件事：<strong>改配置</strong> 和 <strong>授权用户</strong>。</p><h4 id="1-修改配置文件-bind-address"><a href="#1-修改配置文件-bind-address" class="headerlink" title="1. 修改配置文件 (bind-address)"></a>1. 修改配置文件 (bind-address)</h4><ol><li><p><strong>用 Vim 编辑配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/mysql/mysql.conf.d/mysqld.cnf<br></code></pre></td></tr></table></figure><p><em>(如果这个路径找不到文件，试一下 <code>vim /etc/mysql/my.cnf</code>)</em></p></li><li><p><strong>找到 <code>bind-address</code> 这一行</strong>：</p><ul><li>默认是：<code>bind-address = 127.0.0.1</code></li><li><strong>修改为</strong>：<code>bind-address = 0.0.0.0</code></li><li><em>(操作提示：按方向键找到那行 -&gt; 按 <code>i</code> 进入编辑 -&gt; 改完后按 <code>Esc</code> -&gt; 输入 <code>:wq</code> 保存退出)</em></li></ul></li><li><p><strong>重启 MySQL 让配置生效</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart mysql<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-授权-root-用户远程登录"><a href="#2-授权-root-用户远程登录" class="headerlink" title="2. 授权 root 用户远程登录"></a>2. 授权 root 用户远程登录</h4><p>默认的 root 用户只允许 <code>localhost</code> 登录。要再创建一个允许<strong>任意 IP</strong> 登录的 root 账号（或者修改规则）。</p><ol><li><p><strong>用新密码重新登录 MySQL</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p><em>(输入刚才设置的密码)</em></p></li><li><p><strong>执行授权 SQL</strong>（允许任何人用 root 登录 —— <strong>测试环境</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use mysql;<br>update user <span class="hljs-built_in">set</span> host = <span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-built_in">where</span> user = <span class="hljs-string">&#x27;root&#x27;</span>;<br>FLUSH PRIVILEGES;<br><span class="hljs-built_in">exit</span>;<br></code></pre></td></tr></table></figure><p><em>解释：<code>%</code> 在数据库里代表“所有 IP”。</em></p></li></ol><hr><h3 id="阿里云防火墙放行"><a href="#阿里云防火墙放行" class="headerlink" title="阿里云防火墙放行"></a>阿里云防火墙放行</h3><p>改了服务器内部的所有配置，但阿里云的大门（安全组）还关着。</p><ol><li>回到<strong>阿里云网页控制台</strong>。</li><li>找到 <strong>“网络与安全组” -&gt; “安全组配置”</strong>。</li><li>点击 <strong>“手动添加”</strong>。</li><li><strong>端口范围</strong>：填 <code>3306</code> (MySQL 的默认端口)。</li><li><strong>授权对象</strong>：填 <code>0.0.0.0/0</code> (允许所有人访问)。</li><li>保存。</li></ol><hr><h2 id="部署Redis"><a href="#部署Redis" class="headerlink" title="部署Redis"></a>部署Redis</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">apt install redis-<span class="hljs-keyword">server</span> -y<br></code></pre></td></tr></table></figure><h3 id="修改配置文件-开启远程访问-设置密码"><a href="#修改配置文件-开启远程访问-设置密码" class="headerlink" title="修改配置文件 (开启远程访问 &amp; 设置密码)"></a>修改配置文件 (开启远程访问 &amp; 设置密码)</h3><p>默认 Redis 也是只允许本地访问，且没有密码。</p><ul><li><p><strong>打开配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/redis/redis.conf<br></code></pre></td></tr></table></figure></li><li><p><strong>修改两处 (利用 Vim 的搜索功能 <code>/</code> )</strong>：</p><ol><li><strong>允许远程连接</strong>：<ul><li>输入 <code>/bind 127.0.0.1</code> 回车找到这行。</li><li>把 <code>bind 127.0.0.1 ::1</code> 修改为 <code>bind 0.0.0.0</code></li><li><em>(或者直接在这行前面加 <code>#</code> 注释掉，效果一样)</em></li></ul></li><li>**设置密码：<ul><li>输入 <code>/requirepass</code> 回车搜索。</li><li>找到 <code># requirepass foobared</code> 这一行。</li><li>去掉前面的 <code>#</code>，把 <code>foobared</code> 改成你的密码（比如 <code>123456</code>）。</li><li><em>最终样子：<code>requirepass 123456</code></em></li></ul></li></ol></li><li><p><strong>保存退出</strong>：<code>Esc</code> -&gt; <code>:wq</code>。</p></li></ul><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image25.png" class="" title="Redis部署"><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart redis-server<br></code></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> redis-server<br></code></pre></td></tr></table></figure><h3 id="阿里云放行端口"><a href="#阿里云放行端口" class="headerlink" title="阿里云放行端口"></a>阿里云放行端口</h3><p>Redis 的默认端口是 <strong>6379</strong>。</p><ul><li>去阿里云控制台 -&gt; 安全组 -&gt; 添加规则 -&gt; 放行 <code>6379</code>。</li></ul><hr><h2 id="接入阿里云OSS、大模型"><a href="#接入阿里云OSS、大模型" class="headerlink" title="接入阿里云OSS、大模型"></a>接入阿里云OSS、大模型</h2><p>在application-prod.yml中配置好即可,不用在linux上安装软件</p><hr><h2 id="部署jdk"><a href="#部署jdk" class="headerlink" title="部署jdk"></a>部署jdk</h2><h3 id="手动解压"><a href="#手动解压" class="headerlink" title="手动解压"></a>手动解压</h3><h4 id="1-上传安装包"><a href="#1-上传安装包" class="headerlink" title="1. 上传安装包"></a>1. 上传安装包</h4><p>利用 FinalShell 的文件传输功能：</p><ul><li>在下方文件窗口，进入 <code>/root</code> 目录。</li><li>把电脑上的 <code>jdk-11.x.x_linux-x64_bin.tar.gz</code> <strong>拖拽</strong>进去。</li></ul><h4 id="2-解压与归位"><a href="#2-解压与归位" class="headerlink" title="2. 解压与归位"></a>2. 解压与归位</h4><p>为了管理方便，通常把手动安装的软件放在 <code>/usr/local</code> 目录下。</p><ol><li><p><strong>创建目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/java<br></code></pre></td></tr></table></figure></li><li><p><strong>解压文件</strong>（请把下面的 <code>jdk-xxx.tar.gz</code> 换成你真实的文件名，可以用 Tab 键补全）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf jdk-11.0.xx_linux-x64_bin.tar.gz -C /usr/local/java<br></code></pre></td></tr></table></figure><p><em>解释：<code>-C</code> 参数意思是解压到指定目录。</em></p></li></ol><h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h4><p>解压完只是文件躺在那儿了，系统还不知道 <code>java</code> 命令在哪里。我们需要修改配置文件。</p><ol><li><p><strong>查看解压后的文件夹名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /usr/local/java<br></code></pre></td></tr></table></figure><p><em>(记下那个文件夹的名字，比如叫 <code>jdk-11.0.12</code>)</em></p></li><li><p><strong>编辑配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/profile<br></code></pre></td></tr></table></figure></li><li><p><strong>添加配置</strong>： 按 <code>G</code> (大写) 跳到文件最后一行，按 <code>i</code> 进入编辑模式，在最后粘贴以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Java Environment</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java/jdk-11.0.12  <span class="hljs-comment"># &lt;--- 这里换成你刚才看到的真实文件夹名</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br></code></pre></td></tr></table></figure></li><li><p><strong>保存退出</strong>：按 <code>Esc</code> -&gt; 输入 <code>:wq</code> -&gt; 回车。</p></li></ol><h4 id="4-刷新并验证"><a href="#4-刷新并验证" class="headerlink" title="4. 刷新并验证"></a>4. 刷新并验证</h4><p>配置文件修改后不会立即生效，需要刷新一下。</p><ol><li><p><strong>刷新配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></li><li><p><strong>验证</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br></code></pre></td></tr></table></figure><p><em>如果看到 <code>java version &quot;11.0.xx&quot;</code>，恭喜你，JDK 11 手动部署成功！</em></p></li></ol><hr><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><p>直接用命令行安装 <strong>OpenJDK</strong>（开源免费版，生产环境通用）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 更新软件源</span><br>apt update<br><br><span class="hljs-comment"># 2. 安装 OpenJDK 11</span><br>apt install openjdk-11-jdk -y<br></code></pre></td></tr></table></figure><hr><h2 id="部署jar包"><a href="#部署jar包" class="headerlink" title="部署jar包"></a>部署jar包</h2><ul><li>在 FinalShell 的下方文件窗口，进入 <code>/root</code> 目录。</li><li>把本地打包好的 JAR 包直接拖拽进去。</li></ul><h3 id="前台运行（用于测试）"><a href="#前台运行（用于测试）" class="headerlink" title="前台运行（用于测试）"></a>前台运行（用于测试）</h3><p>在正式后台运行之前，先在<strong>前台</strong>跑一次。这样做的好处是：<strong>如果有报错，能立刻在屏幕上看到，方便调试。</strong></p><ol><li><p>执行启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar project-backend.jar<br></code></pre></td></tr></table></figure></li><li><p><strong>观察控制台输出</strong>：</p><ul><li>会看到 Spring Boot 的 Logo。</li><li>接着会滚动很多日志。</li><li><strong>关键标志</strong>：如果看到类似 <code>Started Application in x.xxx seconds</code> 的字样，且没有抛出 <code>Exception</code> 或 <code>Error</code>。</li><li><em>此时，不要关闭窗口，也不要按 Ctrl+C。</em></li></ul></li><li><p><strong>验证服务</strong>：</p><ul><li>打开浏览器，访问 <code>http://公网IP:8080</code> 。</li><li>如果没配首页，可能会显示 “Whitelabel Error Page”，但这说明服务是通的！</li><li><em>注意：如果打不开，检查阿里云安全组有没有放行 8080 端口。</em></li></ul></li><li><p><strong>停止服务</strong>：</p><ul><li>确认没问题后，回到终端，按 <strong><code>Ctrl + C</code></strong> 停止它。</li></ul></li></ol><hr><h3 id="后台运行（正式部署）"><a href="#后台运行（正式部署）" class="headerlink" title="后台运行（正式部署）"></a>后台运行（正式部署）</h3><p>前台运行的缺点是，一旦关掉 Xshell，服务就挂了。需要用 <code>nohup</code> 让它在后台默默工作。</p><ol><li><p><strong>执行后台启动命令</strong>（这是一句标准生产环境命令，请背诵）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> java -jar ***.jar &gt; app.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><blockquote><p><strong>命令拆解：</strong></p></blockquote><blockquote><ul><li><code>nohup</code>：<strong>No Hang Up</strong>（不挂断）。意思是你退出终端，它也不准死。</li><li><code>java -jar ...</code>：启动命令。</li><li><code>&gt; app.log</code>：把本来要显示在屏幕上的日志，<strong>重定向</strong>写入到 <code>app.log</code> 文件里。</li><li><code>2&gt;&amp;1</code>：把“错误日志”也一起写入到 <code>app.log</code> 里（不漏掉任何报错）。</li><li><code>&amp;</code>：<strong>后台运行</strong>。让出命令行，让你能继续敲其他命令。</li></ul></blockquote></li><li><p>确认启动成功：</p><p>输入以下命令，查看进程是否存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep java<br></code></pre></td></tr></table></figure><p><em>看到一行包含 <code>***.jar</code> 的记录，说明稳了！</em></p></li></ol><hr><h3 id="查看实时日志"><a href="#查看实时日志" class="headerlink" title="查看实时日志"></a>查看实时日志</h3><p>服务跑在后台了，看不见屏幕输出怎么办</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f app.log<br></code></pre></td></tr></table></figure><ul><li><strong>效果</strong>：会看到日志像流水一样滚屏出来。</li><li><strong>退出</strong>：看完了按 <code>Ctrl + C</code>（这只是退出查看模式，不会停止服务）。</li></ul><hr><h3 id="如何停止-重启服务？"><a href="#如何停止-重启服务？" class="headerlink" title="如何停止&#x2F;重启服务？"></a>如何停止&#x2F;重启服务？</h3><p>下次要更新代码重新部署时，必须先杀掉旧的进程。</p><ol><li><p><strong>找到进程 ID (PID)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep java<br></code></pre></td></tr></table></figure><p><em>(假设输出里看到 PID 是 <code>12345</code>)</em></p></li><li><p><strong>强制关闭</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 12345<br></code></pre></td></tr></table></figure></li><li><p>重新启动：</p><p>重复第三步的 nohup 命令即可。</p></li></ol><hr><h3 id="Screen-vs-Nohup"><a href="#Screen-vs-Nohup" class="headerlink" title="Screen vs Nohup"></a>Screen vs Nohup</h3><p><code>screen</code> 和 <code>nohup</code> 是两个流派，<strong>它们的目的都是一样的：让程序在你断开 SSH 连接后继续跑</strong></p><h4 id="Nohup-——-“监控录像模式”"><a href="#Nohup-——-“监控录像模式”" class="headerlink" title="Nohup —— “监控录像模式”"></a>Nohup —— “监控录像模式”</h4><ul><li><strong>原理</strong>：把程序往后台一丢，告诉它：“把日志写到 <code>app.log</code> 也就是那个文件里，别烦我。”</li><li><strong>优点</strong>：<strong>命令简单</strong>，不需要安装额外软件，不仅适合人敲，也适合写在自动化脚本里（Jenkins 只能用这个）。</li><li><strong>缺点</strong>：一旦后台运行了，就“看不见”它的实时控制台了。想看发生了什么，必须用 <code>tail -f app.log</code> 去查日志文件（就像去查监控录像）。</li><li><strong>场景</strong>：<strong>正式的生产环境部署</strong>、自动化部署。</li></ul><h4 id="Screen-——-“电视直播模式”"><a href="#Screen-——-“电视直播模式”" class="headerlink" title="Screen —— “电视直播模式”"></a>Screen —— “电视直播模式”</h4><ul><li><strong>原理</strong>：<code>screen</code> 会在 Linux 里开一个<strong>虚拟窗口</strong>（你可以理解为开了一个分身）。<ul><li>你在这个分身里运行 <code>java -jar</code>，能直观地看到控制台在刷屏。</li><li>当按快捷键（Ctrl+A+D）离开时，这个分身窗口并没有关，只是被<strong>最小化</strong>了。</li><li>下次回来，输入 <code>screen -r</code>，那个窗口又弹出来了，一切还在继续，仿佛从未离开。</li></ul></li><li><strong>优点</strong>：<strong>所见即所得</strong>。可以随时切回去看现场直播，甚至可以在运行途中暂停程序输入指令。</li><li><strong>缺点</strong>：需要额外安装 (<code>apt install screen</code>)；如果忘了关掉无用的 screen 窗口，服务器内存会被吃光；<strong>不适合自动化脚本</strong>。</li><li><strong>场景</strong>：<strong>调试 Bug</strong>、跑那种耗时几个小时的一次性脚本（比如导数据）</li></ul><hr><h2 id="部署Nginx"><a href="#部署Nginx" class="headerlink" title="部署Nginx"></a>部署Nginx</h2><p>后端通了，现在要把 <code>http://121.40.207.233:9000</code> 隐藏起来，让用户通过优雅的 <strong>80 端口</strong>（默认端口，不用输冒号）来访问。同时，为部署前端 Vue 做准备</p><h4 id="1-安装-Nginx"><a href="#1-安装-Nginx" class="headerlink" title="1. 安装 Nginx"></a>1. 安装 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br>apt install nginx -y<br></code></pre></td></tr></table></figure><h4 id="2-上传前端代码-关键"><a href="#2-上传前端代码-关键" class="headerlink" title="2. 上传前端代码 (关键)"></a>2. 上传前端代码 (关键)</h4><p>Vue 项目打包后会生成一个 <code>dist</code> 文件夹（里面是 index.html 和一堆 js&#x2F;css）。</p><ul><li><strong>操作</strong>：在本地把 Vue 项目打包 (<code>npm run build:prod</code>)。</li><li><strong>上传</strong>：把生成的 <code>dist</code> 文件夹，整个拖拽到服务器的 <code>/home</code> 目录下。<ul><li><em>确认路径</em>：上传完后，输入 <code>ls /home/dist</code> 应该能看到 <code>index.html</code>。</li></ul></li></ul><h4 id="3-修改-Nginx-配置"><a href="#3-修改-Nginx-配置" class="headerlink" title="3. 修改 Nginx 配置"></a>3. 修改 Nginx 配置</h4><ol><li><p><strong>打开配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/nginx/sites-available/default<br></code></pre></td></tr></table></figure><p><em>(如果是 yum 安装的 Nginx，路径可能是 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf，但在 Ubuntu 上通常改上面这个)</em></p></li><li><p><strong>清空并写入新配置</strong>：</p><ul><li>在 vim 里按 <code>gg</code> (跳到首行)，然后按 <code>dG</code> (删除所有内容)。</li><li>按 <code>i</code> 进入编辑模式。</li><li><strong>复制粘贴下面的配置：</strong></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    <span class="hljs-comment"># 端口配置</span><br>    listen 80;<br>    listen [::]:80;<br>    server_name localhost;<br><br>    <span class="hljs-comment"># --- 从你教程里保留的优化配置 ---</span><br>    <span class="hljs-comment"># 限制上传文件大小（防止传大图报错）</span><br>    client_max_body_size 60m;<br>    <span class="hljs-comment"># 缓冲区大小设置</span><br>    client_body_buffer_size 512k;<br>    client_header_buffer_size 2k;<br><br>    <span class="hljs-comment"># --- 1. 前端 Vue 配置 ---</span><br>    location / &#123;<br>        <span class="hljs-comment"># ⚠️ 关键修改：你的 dist 在 /home 下，而不是 /var/www</span><br>        root   /home/dist;<br>        index  index.html index.htm;<br>        <br>        <span class="hljs-comment"># 解决 Vue 刷新 404 问题</span><br>        try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>    &#125;<br><br>    <span class="hljs-comment"># --- 2. 后端 Java 转发配置 ---</span><br>    location /prod-api/ &#123;<br>        <span class="hljs-comment"># ⚠️ 关键修改：后端就在本机，用 127.0.0.1:9000</span><br>        <span class="hljs-comment"># 千万别漏了最后的斜杠 /</span><br>        proxy_pass http://127.0.0.1:9000/;<br><br>        <span class="hljs-comment"># 保留标准请求头，让 Java 能拿到真实 IP</span><br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        proxy_set_header REMOTE-HOST <span class="hljs-variable">$remote_addr</span>;<br>        proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <br>        <span class="hljs-comment"># WebSocket 支持（教程里带的，保留着没坏处）</span><br>        proxy_set_header Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>        proxy_set_header Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># 错误页面配置</span><br>    error_page 404 /404.html;<br>    location = /404.html &#123;<br>    &#125;<br><br>    error_page 500 502 503 504 /50x.html;<br>    location = /50x.html &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-修改主配置文件"><a href="#4-修改主配置文件" class="headerlink" title="4.修改主配置文件"></a>4.修改主配置文件</h3><p>因为前端文件放在 <code>/home/dist</code>，而 Ubuntu 默认的 Nginx 用户（<code>www-data</code>）没有权限读取 <code>/home</code> 目录。需要修改一下主配置文件：</p><ol><li><p>打开主配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure></li><li><p><strong>只改第一行</strong>： 把 <code>user www-data;</code> 改成 <code>user root;</code> <em>(虽然生产环境不推荐用 root，但作为练习这是解决 Permission Denied 最快的方法)</em></p></li><li><p>保存退出。</p></li></ol><h3 id="5-重启"><a href="#5-重启" class="headerlink" title="5.重启"></a>5.重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t            <span class="hljs-comment"># 检查有没有拼写错误</span><br>systemctl restart nginx<br></code></pre></td></tr></table></figure><img src="/2025/12/18/linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image26.png" class="" title="部署完毕"><hr><h2 id="云监控"><a href="#云监控" class="headerlink" title="云监控"></a>云监控</h2><h3 id="1-什么是云监控"><a href="#1-什么是云监控" class="headerlink" title="1. 什么是云监控"></a>1. 什么是云监控</h3><p><strong>核心功能</strong>：它是阿里云自带的监控工具，用来实时盯着服务器（ECS）、数据库（RDS）等资源的健康状况 。</p><ul><li><p><strong>作用</strong>：就像医院的心电监护仪。如果不装这个，服务器死机了你都不知道，只能等用户投诉。</p></li><li><p><strong>关键动作</strong>：</p><p><strong>安装插件 (Agent)</strong>：有些数据（比如 CPU）阿里云能直接看到，但有些数据（比如内存使用率）需要你在服务器里装一个小插件（Agent）才能采集到 。</p><p><strong>可视化大屏</strong>：可以自定义一个仪表盘，把 CPU、内存、网络流量画成折线图，看起来更直观 。</p></li></ul><h3 id="2-告警服务"><a href="#2-告警服务" class="headerlink" title="2. 告警服务"></a>2. 告警服务</h3><p>这是做<strong>稳定性测试</strong>时必须要用的功能。</p><ul><li><p><strong>设置规则</strong>：可以定义“什么情况算异常”。</p><p><em>例子</em>：连续 1 分钟 CPU &gt; 80% -&gt; 警告；连续 5 分钟 &gt; 95% -&gt; 紧急报警 。</p><p><strong>通知方式</strong>：一旦触发规则，系统会自动发短信、邮件，或者通过 WebHook（比如钉钉群机器人）通知你 。</p><p><strong>一键报警</strong>：对于新手，阿里云提供了一键开启常见规则的功能（比如 CPU、磁盘、带宽满了自动报警） 。</p></li></ul><h3 id="3-系统运维常见问题排查"><a href="#3-系统运维常见问题排查" class="headerlink" title="3. 系统运维常见问题排查"></a>3. 系统运维常见问题排查</h3><h4 id="A-CPU-负载过高-CPU-Load"><a href="#A-CPU-负载过高-CPU-Load" class="headerlink" title="A. CPU 负载过高 (CPU Load)"></a>A. CPU 负载过高 (CPU Load)</h4><ul><li><p><strong>如何判断</strong>：</p><ul><li><p>使用 <code>top</code> 或 <code>htop</code> 命令 。</p><p><strong>关键指标</strong>：<code>Load Average</code>（平均负载）。如果这个数值超过了 CPU 核心数的 <strong>0.5 倍</strong>，就要警惕；超过 <strong>1 倍</strong> 就是负载高了 。</p></li></ul><p><strong>常见原因 &amp; 解决</strong> ：</p><ol><li><strong>代码死循环&#x2F;计算密集</strong>：某个 Java 进程 CPU 飙升。（解决：<code>top</code> 找到 PID -&gt; <code>kill -9</code>）。</li><li><strong>I&#x2F;O 瓶颈</strong>：磁盘读写太慢，导致 CPU 在等待。（解决：换 SSD 或优化数据库查询）。</li><li><strong>僵尸进程</strong>：进程死了但资源没释放。（解决：重启或清理依赖）。</li><li><strong>被攻击</strong>：CPU 高但找不到进程，可能是中了挖矿病毒。</li></ol></li></ul><h4 id="B-内存爆满-Memory-Full"><a href="#B-内存爆满-Memory-Full" class="headerlink" title="B. 内存爆满 (Memory Full)"></a>B. 内存爆满 (Memory Full)</h4><ul><li><p><strong>如何判断</strong>：</p><ul><li>使用 <code>top</code> 查看。如果 <code>free</code>（空闲内存）几乎为 0，或者使用率持续接近 100% 。</li></ul><p><strong>常见原因 &amp; 解决</strong> ：</p><ol><li><strong>内存泄漏 (Memory Leak)</strong>：这是测开最需要抓的 Bug！程序只申请内存不释放。</li><li><strong>配置不当</strong>：Java 的堆内存（Heap）设置得比服务器物理内存还大。</li><li><strong>僵尸文件</strong>：文件被删了，但进程还占用着句柄，导致空间不释放。</li></ol></li></ul><h3 id="4-巡检报告"><a href="#4-巡检报告" class="headerlink" title="4. 巡检报告"></a>4. 巡检报告</h3><ul><li>这是一个体检报告，包含性能监控、安全风险（有没有被 DDoS 攻击）、资源配置分析（磁盘是不是快满了）等 。</li></ul><hr><p>测开视角：</p><ol><li><strong>性能测试 (Performance Testing)</strong>：<ul><li>当用 JMeter 对接口发起高并发压测时，必须盯着这些监控图表。</li><li><em>场景</em>：如果 TPS（每秒处理事务数）上不去，是因为 CPU 满了？还是因为内存漏了？或者是带宽不够了？<strong>这就叫“性能瓶颈分析”。</strong></li></ul></li><li><strong>Bug 定位</strong>：<ul><li>开发说：“我本地跑没问题啊。”</li><li>甩出一张监控截图：“每次调这个接口，内存就涨 500M 且不回落，明显的内存泄漏。”（这比只会说“程序崩了”要专业得多）。</li></ul></li><li><strong>监控脚本</strong>：<ul><li>甚至可以写自动化脚本，利用阿里云的 API 去查询这些监控数据，如果发现测试环境资源不足，自动停止测试，防止误报。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础命令</tag>
      
      <tag>项目部署</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler基础学习</title>
    <link href="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>Fiddler</strong> 是一款<strong>免费的</strong> HTTP&#x2F;HTTPS 抓包与调试代理工具，主要用于Web和移动端应用的网络请求分析。它运行在Windows系统上，通过设置自身为系统代理来捕获所有经过的HTTP&#x2F;HTTPS流量</p><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="Fildder功能"><h1 id="界面熟悉"><a href="#界面熟悉" class="headerlink" title="界面熟悉"></a>界面熟悉</h1><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="Fildder界面"><p><strong>1. 界面分区</strong></p><ul><li><strong>左侧（Session List）</strong>：显示所有抓到的请求会话。关注 <code>Result</code>（状态码）、<code>Host</code>（主机名）、<code>URL</code>。</li><li><strong>右侧（Inspectors）</strong>：查看请求和响应的详细内容。<ul><li><strong>Request（上半部分）</strong>：查看请求头、Cookies、请求体（Raw&#x2F;JSON）。</li><li><strong>Response（下半部分）</strong>：查看响应头、响应体（Raw&#x2F;JSON&#x2F;XML）。</li></ul></li></ul><p><strong>2. 过滤干扰（Filters）</strong> 如果不设置过滤，系统 updates、聊天软件的包都会混在一起。</p><ul><li><strong>操作路径</strong>：右侧选项卡点击 <code>Filters</code> -&gt; 勾选 <code>Use Filters</code>。</li><li><strong>设置</strong>：在 <code>Hosts</code> 区域，选择 <code>Show only the following Hosts</code>。</li><li><strong>输入</strong>：输入你想抓的域名（例如 <code>www.baidu.com</code> 或你的测试环境 IP）。</li><li><strong>生效</strong>：点击 <code>Actions</code> -&gt; <code>Run Filterset now</code>。</li></ul><hr><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="过滤请求"><a href="#过滤请求" class="headerlink" title="过滤请求"></a>过滤请求</h2><p>如果不设置过滤，Fiddler 会抓到电脑上所有软件（微信、Windows更新、杀毒软件）的流量，非常乱。通过右侧的 <strong>Filters（过滤器）</strong> 选项卡来操作：</p><h4 id="第一步：开启过滤"><a href="#第一步：开启过滤" class="headerlink" title="第一步：开启过滤"></a>第一步：开启过滤</h4><ol><li>点击右侧选项卡中的 <strong><code>Filters</code></strong>。</li><li>勾选最顶部的 <strong><code>Use Filters</code></strong>（勾选后，选项卡标题可能会变色，提醒你过滤已开启）。</li></ol><h4 id="第二步：设置过滤规则（Hosts）"><a href="#第二步：设置过滤规则（Hosts）" class="headerlink" title="第二步：设置过滤规则（Hosts）"></a>第二步：设置过滤规则（Hosts）</h4><p>找到 <strong><code>Hosts</code></strong> 区域，这里决定了我们要看谁的请求。</p><ul><li><p><strong>场景 A：只看特定网站（最常用）</strong></p><ol><li>在下拉框选择 <strong><code>Show only the following Hosts</code></strong>（只显示以下主机）。</li><li>在下方输入框填写域名。支持多个域名（用分号隔开）和通配符。</li></ol><ul><li><em>示例</em>：你想抓百度的包，输入：<code>www.baidu.com; *.baidu.com</code></li><li><em>解释</em>：<code>*.baidu.com</code> 表示匹配 map.baidu.com, <a href="https://www.google.com/search?q=tieba.baidu.com">https://www.google.com/search?q=tieba.baidu.com</a> 等所有二级域名。</li></ul></li><li><p><strong>场景 B：排除特定网站</strong></p><ol><li>在下拉框选择 <strong><code>Hide the following Hosts</code></strong>。</li><li>输入你想屏蔽的域名（比如屏蔽掉无关的广告域名）。</li></ol></li></ul><h4 id="第三步：使规则生效"><a href="#第三步：使规则生效" class="headerlink" title="第三步：使规则生效"></a>第三步：使规则生效</h4><ul><li>点击 Filters 面板右上角的 <strong><code>Actions</code></strong> 按钮。</li><li>选择 <strong><code>Run Filterset now</code></strong>。</li><li>左侧列表中，不符合规则的请求瞬间消失了（变灰或被隐藏）</li></ul><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="过滤操作"><hr><h2 id="控制抓取"><a href="#控制抓取" class="headerlink" title="控制抓取"></a>控制抓取</h2><p>在测试过程中，通常<strong>只在需要的时候开启抓包</strong>。比如只想测“点击登录”这一个动作，那就先暂停抓包，清空面板，准备好后再开启。</p><ul><li><strong>状态查看</strong>：看 Fiddler 界面<strong>左下角</strong>。<ul><li>显示 <strong>Capturing</strong>（有图标）：表示正在抓包。</li><li>空白（无图标）：表示停止抓包。</li></ul></li><li><strong>快捷操作</strong>：<ul><li><strong>鼠标点击</strong>：直接点击左下角的 <code>Capturing</code> 区域来切换开关。</li><li><strong>快捷键</strong>：按下键盘上的 <strong><code>F12</code></strong>。这是最常用的快捷键，按一下开，再按一下关。</li><li><strong>菜单栏</strong>：<code>File</code> -&gt; <code>Capture Traffic</code>（打钩表示开启）。</li></ul></li></ul><blockquote><p><strong>测试场景</strong>：当准备复现一个 Bug 时，先按 F12 停止抓包，清理掉无关数据，再按 F12 开启，操作 APP&#x2F;网页，操作完立刻 F12 停止。这样抓到的包最纯净。</p></blockquote><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image4.png" class="" title="控制抓取"><hr><h2 id="删除请求"><a href="#删除请求" class="headerlink" title="删除请求"></a>删除请求</h2><p>为了防止看花眼，需要频繁清理 Session 列表（左侧的会话列表）。</p><ul><li><strong>常用操作</strong>：<ul><li><strong>清空所有</strong>：点击工具栏上的 <strong><code>X</code></strong> 图标（Go 按钮旁边），或者使用快捷键 <strong><code>Ctrl + X</code></strong>。</li><li><strong>删除选定</strong>：选中一条或多条请求（按住 Shift 或 Ctrl 多选），按键盘 <strong><code>Delete</code></strong> 键。</li></ul></li><li><strong>高级删除（右键菜单）</strong>：<ul><li>在列表右键 -&gt; <code>Remove</code> -&gt; <code>Images</code></li><li>在列表右键 -&gt; <code>Remove</code> -&gt; <code>Unselected Sessions</code>（只保留选中的，其他的全删掉）。</li></ul></li><li><strong>命令行写法</strong>：<ul><li>在左下角黑色小框（QuickExec）输入 <strong><code>cls</code></strong> 然后回车，也可以清空列表（Clear Screen 的缩写）。</li></ul></li></ul><hr><h2 id="基础定位与解析"><a href="#基础定位与解析" class="headerlink" title="基础定位与解析"></a>基础定位与解析</h2><p>打开百度搜索HelloWorld：</p><p>百度是一个极其复杂的网站，当点击“百度一下”时，它会在后台发送几十个请求（联想词、图片、统计埋点、广告等）。</p><p><strong>如何快速找到你要的那个“搜索请求”？<strong>即利用</strong>关键字搜索</strong>和<strong>查看参数</strong>。</p><p><strong>操作演练：</strong></p><ol><li><strong>清空面板</strong>：按 <code>Ctrl + X</code>，让世界清静一下。</li><li><strong>触发请求</strong>：在百度搜索框输入HelloWorld，然后点击“百度一下”。</li><li><strong>停止抓包</strong>：页面加载完立刻按 <code>F12</code> 停止。</li><li><strong>查找（Find）</strong>：<ul><li>在 Fiddler 界面按 <strong><code>Ctrl + F</code></strong>。</li><li>在弹出的框里输入你刚才搜的词：<code>test12345</code>。</li><li>点击 <code>Find Sessions</code>。</li></ul></li><li><strong>观察结果</strong>：<ul><li>Fiddler 会把包含这个词的请求<strong>高亮显示</strong>（通常是黄色）。</li><li>找到高亮的那个请求，看它的 <strong>URL</strong>。</li><li>百度的搜索接口通常包含 <code>/s?</code> 或者 <code>/search?</code>。</li></ul></li></ol><p>找到请求后，怎么看它发了什么？</p><p>看右侧的 <strong>Inspectors（检查器）</strong>：</p><h4 id="1-看请求（Request-上半部分）"><a href="#1-看请求（Request-上半部分）" class="headerlink" title="1. 看请求（Request - 上半部分）"></a>1. 看请求（Request - 上半部分）</h4><p>不要直接看 <code>Raw</code>（原始数据太难看），点击 <strong><code>WebForms</code></strong> 选项卡。</p><ul><li><strong>WebForms</strong>：它会把杂乱的 URL 参数格式化成表格。</li><li><strong>找重点</strong>：会看到一个名为 <code>wd</code> (word) 或者 <code>q</code> 的字段，后面的值就是 <code>HelloWorld</code>。</li><li><strong>结论</strong>：这就证明了，前端确实把搜索词通过 <code>wd</code> 这个参数发给了后端。</li></ul><h4 id="2-看响应（Response-下半部分）"><a href="#2-看响应（Response-下半部分）" class="headerlink" title="2. 看响应（Response - 下半部分）"></a>2. 看响应（Response - 下半部分）</h4><ul><li>如果返回的是网页（百度搜索结果页）：点击 <strong><code>WebView</code></strong>（可以预览网页效果）或者 <strong><code>TextView</code></strong>（看 HTML 源码）。</li><li>如果返回的是数据（通常是接口）：点击 <strong><code>JSON</code></strong>。</li></ul><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image5.png" class="" title="请求与响应"><hr><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><p>点开某个请求，右侧 Response 区域全是乱码（看不懂的符号）。 <strong>原因</strong>：这不是 Fiddler 坏了。为了节省网络流量，服务器（百度）把数据“打包压缩”（Gzip&#x2F;Brotli 格式）。浏览器会自动解压，但 Fiddler 默认展示原始的压缩数据，所以是乱码。</p><p><strong>解决方法（两步走）：</strong></p><ol><li><strong>临时解压（针对当前请求）</strong><ul><li>选中那个乱码的请求。</li><li>看右侧 <strong>Inspectors -&gt; Response</strong> 区域顶部，有一个<strong>黄色的长条</strong>提示</li><li>上面写着：<code>Response is encoded and may need to be decoded before inspection. Click here to transform.</code></li><li><strong>点击这个黄条</strong>，乱码瞬间就会变成正常的 HTML 或 JSON 代码。</li></ul></li><li><strong>永久自动解压</strong><ul><li>在 Fiddler 顶部工具栏，找到 <strong><code>Decode</code></strong> 按钮。</li><li>点击它，确保它处于<strong>按下（高亮）状态</strong>。</li><li>以后抓到的所有包，Fiddler 都会自动解压，再也不会有乱码了。</li></ul></li></ol><h3 id="灰色请求"><a href="#灰色请求" class="headerlink" title="灰色请求"></a>灰色请求</h3><p>设置了过滤，但还是有很多灰色的请求。这通常是因为：<strong>Tunnel to… (443)</strong>：这是 HTTPS 建立连接的握手通道，Fiddler 必须保留它们才能解密后续内容，通常可以忽略。</p><h3 id="与F12的区别"><a href="#与F12的区别" class="headerlink" title="与F12的区别"></a>与F12的区别</h3><p><strong>F12 是“显微镜”（看单个网页内部），Fiddler 是“海关检查站”（看进出电脑的所有关卡）。</strong></p><p>如果你只是看一眼“接口返了什么”，F12 足够了；但作为<strong>测试开发</strong>，还需要做<strong>篡改、弱网、手机抓包</strong>，Fiddler 则是必选项。</p><h4 id="1-抓包范围（Fiddler-完胜）"><a href="#1-抓包范围（Fiddler-完胜）" class="headerlink" title="1. 抓包范围（Fiddler 完胜）"></a>1. 抓包范围（Fiddler 完胜）</h4><ul><li><strong>浏览器 F12</strong>：<strong>只能抓当前标签页</strong>。<ul><li>如果刷新页面，上个页面的包可能就被清空了（除非开了 Preserve log）；如果跳到了新页面，或者调用了浏览器插件的接口，F12 往往抓不到。</li></ul></li><li><strong>Fiddler</strong>：<strong>系统级代理（抓一切）</strong>。<ul><li>它能抓到 Chrome、Firefox、电脑上运行的<strong>PC端微信小程序</strong>、<strong>Outlook 邮件</strong>、<strong>某网盘客户端</strong>的包。只要是走 HTTP&#x2F;HTTPS 协议的，它全都能拦下来。</li></ul></li></ul><blockquote><p><strong>场景</strong>：测试一个“PC客户端”软件（比如钉钉电脑版），F12 根本无从下手，只能靠 Fiddler。</p></blockquote><h4 id="2-移动端测试能力"><a href="#2-移动端测试能力" class="headerlink" title="2. 移动端测试能力"></a>2. 移动端测试能力</h4><ul><li><strong>浏览器 F12</strong>：<strong>无法直接抓手机 APP</strong>。<ul><li>虽然 F12 有个“手机模式”，那只是把浏览器窗口变窄，模拟手机<strong>分辨率</strong>，它跑的本质还是电脑网页，不是真的手机环境。</li></ul></li><li><strong>Fiddler</strong>：<strong>可以抓真机（手机&#x2F;平板）</strong>。<ul><li><em>操作</em>：只要手机连上代理指向电脑，你在手机 APP 上点的所有按钮，请求都会发到电脑的 Fiddler 上。</li></ul></li></ul><h4 id="3-篡改与-Mock-能力（Fiddler-更强更直观）"><a href="#3-篡改与-Mock-能力（Fiddler-更强更直观）" class="headerlink" title="3. 篡改与 Mock 能力（Fiddler 更强更直观）"></a>3. 篡改与 Mock 能力（Fiddler 更强更直观）</h4><p><em>“后端接口没写好，前端怎么先测？”</em> 或者 <em>“如何测试支付失败的异常流程？”</em></p><ul><li><strong>浏览器 F12</strong>：<strong>很难修改</strong>。<ul><li>F12 主要用来“看”。虽然 Chrome 现在也有本地覆盖功能，但配置极其繁琐，而且修改的是静态文件，很难动态修改接口返回的 JSON 数据。</li></ul></li><li><strong>Fiddler</strong>：<strong>天生就是为了“改”而生的</strong>。<ul><li><strong>AutoResponder</strong>：可以直接把百度的 Logo 换成照片，或者把“登录成功”的接口硬改成“500 服务器爆炸”，让前端以为服务器挂了，看它会不会崩溃。</li></ul></li></ul><h4 id="4-协议底层细节"><a href="#4-协议底层细节" class="headerlink" title="4. 协议底层细节"></a>4. 协议底层细节</h4><ul><li><strong>浏览器 F12</strong>：看到的是**“浏览器处理后”**的结果。<ul><li>有些请求即使网络不通，F12 可能也会显示个大致情况，或者经过了浏览器缓存处理。</li></ul></li><li><strong>Fiddler</strong>：看到的是**“原始数据”**。<ul><li>它是真实的<strong>网络传输层</strong>数据。比如 HTTPS 握手过程、证书错误细节，Fiddler 能看得很清楚，而 F12 可能直接报个 <code>(failed)</code> 就结束了。</li></ul></li></ul><hr><h3 id="总结：什么时候用谁？"><a href="#总结：什么时候用谁？" class="headerlink" title="总结：什么时候用谁？"></a>总结：什么时候用谁？</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐工具</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>日常开发&#x2F;调试 UI</strong></td><td><strong>F12</strong></td><td>查 CSS 样式、看 Console 报错、调试 JS 代码（Fiddler 做不到调试 JS）。</td></tr><tr><td><strong>看接口返回 JSON</strong></td><td><strong>F12</strong></td><td>简单、快，不用开额外软件。</td></tr><tr><td><strong>测 APP &#x2F; 小程序</strong></td><td><strong>Fiddler</strong></td><td>F12 只有模拟器，测不了真机 APP 兼容性。</td></tr><tr><td><strong>构造异常数据 (Mock)</strong></td><td><strong>Fiddler</strong></td><td>需要修改 Request&#x2F;Response 测试前端健壮性。</td></tr><tr><td><strong>模拟弱网 (慢速网络)</strong></td><td><strong>Fiddler</strong></td><td>Fiddler 的弱网控制比 F12 更精准、可编程。</td></tr></tbody></table><ul><li><strong>F12 是你的左手</strong>：用来快速定位是不是前端 JS 报错了。</li><li><strong>Fiddler 是你的右手</strong>：用来分析协议、抓手机包、做破坏性测试（Mock）。</li></ul><hr><h1 id="模拟请求与模拟响应"><a href="#模拟请求与模拟响应" class="headerlink" title="模拟请求与模拟响应"></a>模拟请求与模拟响应</h1><p><strong>Mock（挡板测试）与接口重放</strong>。</p><ol><li><strong>模拟请求</strong>：后端接口修好了，想快速验证一下，但不想去页面上填那十几个输入框，这时候用 Fiddler <strong>重放</strong>。</li><li><strong>模拟响应</strong>：想测 APP 在“服务器挂了（500）”或“数据为空”时的表现，但服务器现在好好的，这时候用 Fiddler <strong>篡改</strong>。</li></ol><hr><h3 id="第一部分：模拟请求（Composer-——-接口重放）"><a href="#第一部分：模拟请求（Composer-——-接口重放）" class="headerlink" title="第一部分：模拟请求（Composer —— 接口重放）"></a>第一部分：模拟请求（Composer —— 接口重放）</h3><p>这相当于 Fiddler 内置了一个简易版的 Postman。</p><p><strong>场景</strong>：刚才在百度搜索了 <code>helloworld</code>，现在想模拟搜索 <code>fiddler</code>，但不想打开浏览器去输入，直接发包。</p><p><strong>操作步骤：</strong></p><ol><li><strong>找到原请求</strong>：在左侧会话列表中，找到刚才搜索 <code>helloworld</code> 的那条记录（URL 里含 <code>/s?wd=...</code>）。</li><li><strong>拖拽（Drag &amp; Drop）</strong>：<ul><li>鼠标左键按住这条请求不放。</li><li>直接把它拖到右侧选项卡中的 <strong><code>Composer</code></strong>（构建器）标签页里。</li><li><em>松手后，会发现 Request Body 和 Headers 自动填好了！</em></li></ul></li><li><strong>修改参数</strong>：<ul><li>在 <code>Composer</code> 的 <strong>Request Body</strong> 区域（如果是 GET 请求则在顶部的 URL 栏），找到 <code>wd=helloworld</code>。</li><li>把它改成 <code>wd=xiaoli</code>。</li></ul></li><li><strong>发送（Execute）</strong>：<ul><li>点击右上角的 <strong><code>Execute</code></strong> 按钮。</li></ul></li><li><strong>验证</strong>：<ul><li>看左侧列表，会在最下方新增一条请求。</li><li>点开它，看右侧 <code>Inspectors</code> -&gt; <code>WebForms</code>，你会发现参数确实变成了 <code>xiaoli</code>。</li></ul></li></ol><blockquote><p><strong>测开面试点</strong>：这就叫“接口自动化”的雏形。可以用这个功能快速测试 SQL 注入（比如把参数改成 <code>&#39; OR &#39;1&#39;=&#39;1</code> 看服务器反不报错）。</p></blockquote><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image6.png" class="" title="模拟请求"><hr><h3 id="第二部分：模拟响应（AutoResponder-——-核心-Mock）"><a href="#第二部分：模拟响应（AutoResponder-——-核心-Mock）" class="headerlink" title="第二部分：模拟响应（AutoResponder —— 核心 Mock）"></a>第二部分：模拟响应（AutoResponder —— 核心 Mock）</h3><p>这是 Fiddler 最强大的功能。要欺骗浏览器，让它以为服务器返回了我们指定的内容。</p><p><strong>实战目标</strong>：将百度的“百度一下”按钮文字改掉，或者让百度首页的一张图片加载失败（模拟资源丢失）。</p><p>我们选择最直观的：<strong>让百度首页显示 404</strong>。</p><p><strong>操作步骤：</strong></p><ol><li><strong>准备工作</strong>：<ul><li>打开浏览器访问百度首页。</li><li>在 Fiddler 左侧找到百度的请求。</li></ul></li><li><strong>建立规则</strong>：<ul><li>点击右侧 <strong><code>AutoResponder</code></strong>（自动响应器）选项卡。</li><li><strong>必须勾选</strong>顶部的两个框：<ul><li><code>Enable rules</code>（开启规则）。</li><li><code>Unmatched requests passthrough</code>（没匹配到的请求放行 —— <strong>这步不选会导致全网断网！</strong>）。</li></ul></li><li>把刚才找到的 Logo 请求，直接<strong>拖入</strong> AutoResponder 的空白列表中。</li></ul></li><li><strong>修改响应（篡改）</strong>：<ul><li>在 AutoResponder 列表里选中刚才那条规则。</li><li>看下方的 <strong>Rule Editor</strong>（规则编辑器）：<ul><li>第一行（匹配条件）：保持不变（是 Logo 的 URL）。</li><li>第二行（响应行为）：点击下拉框，选择 <strong><code>404_Plain.dat</code></strong>（或者 <code>500_Plain.dat</code>）。</li></ul></li><li>点击右边的 <strong><code>Save</code></strong>。</li></ul></li><li><strong>见证奇迹</strong>：<ul><li>回到浏览器。</li><li><strong>强制刷新</strong>（这是关键）：按 <strong><code>Ctrl + F5</code></strong>（防止浏览器用本地缓存，强制它重新去问 Fiddler）。</li><li>你会发现百度首页变成404了。</li></ul></li></ol><img src="/2025/12/17/Fiddler%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image7.png" class="" title="模拟响应"><blockquote><p>进阶玩法（替换文件）：</p><p>在第3步的下拉框里，选择最后一项 Find a file…，然后从你电脑桌面选一张搞怪的图片（比如表情包）。保存后刷新百度，百度的 Logo 就会变成你的表情包！</p></blockquote><hr><p>“如何测试系统的健壮性（Robustness）”</p><blockquote><p>“使用 Fiddler 的 AutoResponder 功能进行 Mock 测试。</p><p>比如在测试转账功能时，前端发起了请求，通过 Fiddler 拦截响应，</p><ol><li>将状态码改为 500，看 APP 是否会崩溃，还是会优雅地提示‘服务器繁忙’。</li><li>将返回的数据篡改为超长字符串或 Null，测试前端是否有数据校验机制。”</li></ol></blockquote><hr><h1 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h1><p>即模仿网速慢的情况</p><h2 id="第一阶段：一键开启“拨号上网”模式"><a href="#第一阶段：一键开启“拨号上网”模式" class="headerlink" title="第一阶段：一键开启“拨号上网”模式"></a>第一阶段：一键开启“拨号上网”模式</h2><p>Fiddler 内置了一个最简单的开关，能瞬间把百兆光纤变成 90 年代的电话拨号网速。</p><ol><li><strong>开启</strong>：<ul><li>点击顶部菜单栏 <strong><code>Rules</code></strong> -&gt; <strong><code>Performance</code></strong>。</li><li>勾选 <strong><code>Simulate Modem Speeds</code></strong>（模拟调制解调器速度）。</li></ul></li><li><strong>体验</strong>：<ul><li>现在去刷新一下百度或者学校官网。</li><li>你会发现图片是一行一行慢慢刷出来的，文字出现得很慢。</li><li><strong>注意</strong>：这个模式是全局的！开启后，电脑上所有软件（包括微信、视频）都会变慢。</li></ul></li><li><strong>关闭</strong>：<ul><li>测试完一定要记得去把那个勾<strong>去掉</strong>！</li></ul></li></ol><hr><h2 id="第二阶段：进阶——自定义网速（精准模拟-3G-4G）"><a href="#第二阶段：进阶——自定义网速（精准模拟-3G-4G）" class="headerlink" title="第二阶段：进阶——自定义网速（精准模拟 3G&#x2F;4G）"></a>第二阶段：进阶——自定义网速（精准模拟 3G&#x2F;4G）</h2><p>问：“Fiddler 默认的弱网速度是多少？怎么修改成我想要的 3G 速度？”</p><p>默认的 Simulate Modem Speeds 实在是太慢了（它模拟的是老式 Modem），在现代测试中，通常需要自定义数值。</p><p>需要修改 Fiddler 的脚本文件（Script）。只需要改两个数字。</p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p><strong>打开脚本编辑器</strong>：</p><ul><li>点击菜单栏 <code>Rules</code> -&gt; <strong><code>Customize Rules...</code></strong>。</li><li>这会弹出一个编辑器窗口（Fiddler ScriptEditor），里面满是代码。</li></ul></li><li><p><strong>查找代码</strong>：</p><ul><li>按 <strong><code>Ctrl + F</code></strong>，输入搜索关键字：<code>m_SimulateModem</code>。</li><li>点击“Find Next”：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (m_SimulateModem) &#123;<br>    <span class="hljs-comment">// Delay sends by 300ms per KB uploaded.</span><br>    oSession[<span class="hljs-string">&quot;request-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;300&quot;</span>;<br>    <span class="hljs-comment">// Delay receives by 150ms per KB downloaded.</span><br>    oSession[<span class="hljs-string">&quot;response-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;150&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>读懂参数（面试考点）</strong>：</p><ul><li><code>request-trickle-delay</code>: <strong>上传延迟</strong>。这里的 <code>300</code> 意思是：每上传 1KB 数据，强制延迟 300 毫秒。</li><li><code>response-trickle-delay</code>: <strong>下载延迟</strong>。这里的 <code>150</code> 意思是：每下载 1KB 数据，强制延迟 150 毫秒。</li></ul><p><em>数值越大 &#x3D; 网速越慢。</em></p></li><li><p>修改数值（模拟不同网络）：</p><p>可以根据以下参考值修改这两个数字（保存即生效）：</p><table><thead><tr><th><strong>网络类型</strong></th><th><strong>上传延迟 (request)</strong></th><th><strong>下载延迟 (response)</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>2G (极慢)</strong></td><td>1000</td><td>800</td><td>几乎打不开图片</td></tr><tr><td><strong>3G (卡顿)</strong></td><td>300</td><td>150</td><td>默认设置，适合测超时</td></tr><tr><td><strong>弱 4G (抖动)</strong></td><td>100</td><td>50</td><td>偶尔卡顿，模拟信号差</td></tr></tbody></table></li><li><p><strong>实测效果</strong>：</p><ul><li>确保 <code>Rules</code> -&gt; <code>Performance</code> -&gt; <code>Simulate Modem Speeds</code> 还是勾选状态。</li><li>去刷新网页。会发现即使是一张小图片，都要加载好几秒！</li></ul></li></ol><hr><h2 id="第三阶段：弱网测试要“看”什么？"><a href="#第三阶段：弱网测试要“看”什么？" class="headerlink" title="第三阶段：弱网测试要“看”什么？"></a>第三阶段：弱网测试要“看”什么？</h2><p>作为测试开发，开启弱网后，要重点观察以下几个现象：</p><ol><li><strong>超时处理（Timeout）</strong>：<ul><li>如果网速慢到一定程度，APP 应该弹出提示“网络连接超时，请重试”，而不是一直白屏或崩溃。</li></ul></li><li><strong>重复请求（Duplicate Requests）</strong>：<ul><li>在弱网下，快速点击“提交”按钮，Fiddler 里会不会出现多条相同的请求？（如果有，就是严重 Bug，后端没做幂等性校验，前端没做防抖）。</li></ul></li><li><strong>UI 异常</strong>：<ul><li>图片没加载出来时，是否有默认的占位图（骨架屏）？还是界面排版直接乱了？</li></ul></li></ol><hr><h1 id="前端性能测试"><a href="#前端性能测试" class="headerlink" title="前端性能测试"></a>前端性能测试</h1><p>Fiddler 的性能分析主要关注<strong>网络层面的性能</strong>，也就是：<strong>“数据从服务器跑到浏览器，到底花了多久？堵在哪了？”</strong></p><p>主要使用两个核心面板：<strong>Statistics（统计）</strong> 和 <strong>Timeline（时间轴）</strong>。</p><hr><h3 id="Statistics（统计面板）"><a href="#Statistics（统计面板）" class="headerlink" title="Statistics（统计面板）"></a>Statistics（统计面板）</h3><p><strong>这批请求一共多大？花了多久？谁最占网速？</strong></p><h4 id="实操步骤："><a href="#实操步骤：" class="headerlink" title="实操步骤："></a>实操步骤：</h4><ol><li><strong>清空 Fiddler</strong>：<code>Ctrl + X</code>。</li><li><strong>打开一个网页</strong>：比如访问百度或者学校官网。</li><li><strong>停止抓包</strong>：页面加载完按 <code>F12</code>，防止新数据干扰。</li><li><strong>选中所有请求</strong>：在左侧列表中，<code>Ctrl + A</code> 全选（或者选中你想分析的那几十条请求）。</li><li><strong>查看右侧面板</strong>：点击 <strong><code>Statistics</code></strong> 选项卡。</li></ol><h4 id="你需要关注的核心数据（面试考点）："><a href="#你需要关注的核心数据（面试考点）：" class="headerlink" title="你需要关注的核心数据（面试考点）："></a>你需要关注的核心数据（面试考点）：</h4><ol><li><strong>Bytes Sent &#x2F; Received (流量大小)</strong><ul><li>下面会显示 <code>ESTIMATED WORLDWIDE LATENCY</code>（预估全球延迟）。</li><li><strong>分析点</strong>：如果 <code>Bytes Received</code> 居然有 10MB，那网页肯定慢。检查是不是<strong>图片没压缩</strong>，或者引入了不必要的<strong>超大 JS 库</strong>。</li></ul></li><li><strong>Response Counts (请求数量)</strong><ul><li><strong>分析点</strong>：如果一个简单的页面发了 200 个请求，说明前端资源太碎了。建议前端做<strong>资源合并</strong>（雪碧图、JS合并），减少 HTTP 连接开销。</li></ul></li><li><strong>Show Chart (饼图)</strong><ul><li>点击面板底部的 <code>Show Chart</code> 链接。</li><li>它会弹出一个饼图，告诉流量都去哪了（图片占多少、JS 占多少）。</li></ul></li></ol><hr><h3 id="Timeline（时间轴）"><a href="#Timeline（时间轴）" class="headerlink" title="Timeline（时间轴）"></a>Timeline（时间轴）</h3><p>这是最专业的视图，用于分析<strong>并发情况</strong>和<strong>阻塞问题</strong>。</p><h4 id="实操步骤：-1"><a href="#实操步骤：-1" class="headerlink" title="实操步骤："></a>实操步骤：</h4><ol><li>在左侧列表中，选中刚才那几十条请求（<code>Ctrl + A</code>）。</li><li>点击右侧的 <strong><code>Timeline</code></strong> 选项卡（或者右键 -&gt; <code>Timeline</code>）。</li><li>看到一张色彩斑斓的<strong>瀑布流图</strong>（Waterfall Chart）。</li></ol><h4 id="如何看懂这张图（测试开发必修）："><a href="#如何看懂这张图（测试开发必修）：" class="headerlink" title="如何看懂这张图（测试开发必修）："></a>如何看懂这张图（测试开发必修）：</h4><p>这张图横轴是时间，纵轴是请求。</p><ol><li><strong>看“长条”的颜色与长度</strong>：<ul><li><strong>绿色条（下载中）</strong>：越长说明文件越大，或者网速越慢。</li><li><strong>黑色竖线（连接复用）</strong>：这代表浏览器复用了之前的 TCP 连接，是好事（说明 HTTP Keep-Alive 生效）。</li><li><strong>红色（错误）</strong>：如果是红色，说明请求报错（404&#x2F;500），必须修。</li></ul></li><li><strong>看“阶梯”形状（并发 vs 阻塞）</strong>：<ul><li><strong>好的性能</strong>：图形应该是**“高耸的”**，很多条子同时开始（并行下载）。</li><li><strong>差的性能</strong>：图形是**“细长的阶梯状”**，上一个没下完，下一个就不开始（串行阻塞）。</li><li><strong>测开建议</strong>：如果看到明显的阶梯状，要建议前端检查代码，是不是 JS 放在了头部阻塞了页面渲染，或者没有开启 HTTP&#x2F;2。</li></ul></li><li><strong>看“空白”间隙（服务器延迟）</strong>：<ul><li>如果条子前面有一大段<strong>灰色或空白</strong>，说明浏览器发了请求，但<strong>服务器迟迟不响应</strong>。</li><li><strong>结论</strong>：这是<strong>后端</strong>的问题（数据库查询慢、逻辑处理慢），不是前端的问题。甩锅给后端开发！</li></ul></li></ol><hr><h3 id="单请求详情（TTFB-分析）"><a href="#单请求详情（TTFB-分析）" class="headerlink" title="单请求详情（TTFB 分析）"></a>单请求详情（TTFB 分析）</h3><p>有时候整体很快，就是某一个接口卡住了。需要分析这一个接口慢在哪。</p><ol><li>双击左侧那个<strong>很慢的请求</strong>。</li><li>点击右侧 <strong><code>Inspectors</code></strong> -&gt; <strong><code>Statistics</code></strong>（注意是 Inspectors 里的子标签，或者直接看 Connection 部分）。</li><li>查看 <strong><code>Timings</code></strong> 区域的数据。</li></ol><h4 id="关键指标（面试必问）："><a href="#关键指标（面试必问）：" class="headerlink" title="关键指标（面试必问）："></a>关键指标（面试必问）：</h4><ul><li><strong>DNS Lookup</strong>：DNS 解析时间。如果这里超过 100ms，说明域名解析有问题。</li><li><strong>TCP&#x2F;IP Connect</strong>：建立连接时间（三次握手）。如果大，说明网络延迟高（比如服务器在美国）。</li><li><strong>Time to First Byte (TTFB)</strong>：<strong>首字节时间</strong>。<ul><li><strong>含义</strong>：从发送请求到收到服务器返回的第一个字节，等了多久。</li><li><strong>判定</strong>：这是衡量<strong>后端处理速度</strong>的最核心指标。</li><li><strong>标准</strong>：如果 TTFB &gt; 500ms，后端接口性能一定有问题（需要优化 SQL 或代码逻辑）。</li></ul></li></ul><hr><h1 id="手机抓包"><a href="#手机抓包" class="headerlink" title="手机抓包"></a>手机抓包</h1><p><strong>手机</strong>（安卓或苹果均可）和电脑连接在<strong>同一个 Wi-Fi</strong> 下。<strong>电脑端设置 -&gt; 手机端代理 -&gt; 安装证书</strong></p><hr><h3 id="电脑端设置"><a href="#电脑端设置" class="headerlink" title="电脑端设置"></a>电脑端设置</h3><ol><li><strong>打开设置</strong>：<ul><li>菜单栏 <code>Tools</code> -&gt; <code>Options</code>。</li></ul></li><li><strong>切换选项卡</strong>：<ul><li>点击 <strong><code>Connections</code></strong> 选项卡。</li></ul></li><li><strong>关键勾选</strong>：<ul><li>勾选 <strong><code>Allow remote computers to connect</code></strong>（允许远程计算机连接）。</li><li><em>注意：Fiddler listening on port 默认是 <strong>8888</strong>，不用改，记下来就行。</em></li></ul></li><li><strong>重启 Fiddler</strong>（非常重要）：<ul><li>配置修改后，<strong>必须重启 Fiddler</strong> 才会生效！请关闭并重新打开它。</li></ul></li><li><strong>查看本机 IP</strong>：<ul><li>将鼠标悬停在 Fiddler 窗口工具栏最右侧的 <strong><code>Online</code></strong> 按钮（或者一个小电脑图标）上。</li><li>它会浮现一个小黑条，显示你的 IP 地址。通常是 <code>192.168.x.x</code>。记下这个 IP，我们暂且叫它 <code>电脑IP</code>。</li></ul></li></ol><hr><h3 id="手机端设置"><a href="#手机端设置" class="headerlink" title="手机端设置"></a>手机端设置</h3><p>让手机的流量不直接去互联网，而是先绕道去电脑的 Fiddler 走一圈。</p><ol><li><strong>打开 Wi-Fi 设置</strong>：<ul><li>进入手机 <code>设置</code> -&gt; <code>Wi-Fi</code> (WLAN)。</li><li>找到当前连接的那个 Wi-Fi（必须和电脑是同一个）。</li></ul></li><li><strong>修改网络配置</strong>：<ul><li><strong>Android</strong>：通常是长按 Wi-Fi 名称 -&gt; <code>修改网络</code> -&gt; 勾选 <code>高级选项</code>。</li><li><strong>iOS</strong>：点击 Wi-Fi 名称右边的蓝色 <code>i</code> 图标 -&gt; 滑到最下面找到 <code>配置代理</code>。</li></ul></li><li><strong>设置手动代理</strong>：<ul><li>代理模式选择：<strong>手动 (Manual)</strong>。</li><li><strong>主机名 (Server&#x2F;Host)</strong>：输入刚才查到的 <strong><code>电脑IP</code></strong>（例如 <code>192.168.1.5</code>）。</li><li><strong>端口 (Port)</strong>：输入 <strong><code>8888</code></strong>。</li></ul></li><li><strong>保存</strong>。</li></ol><p>🚨 验证时刻：</p><p>此时，请在手机上随便打开一个浏览器（Safari 或 Chrome），访问 <a href="http://www.baidu.com./">http://www.baidu.com。</a></p><ul><li>如果<strong>能打开</strong>，且 Fiddler 列表里瞬间跳出一堆百度的请求 -&gt; <strong>连接成功！</strong></li><li>如果<strong>打不开</strong>（网页无法访问），通常是因为电脑的<strong>防火墙</strong>挡住了。<ul><li><em>解决</em>：暂时关闭电脑防火墙，或者允许 Fiddler 通过防火墙。</li></ul></li></ul><hr><h3 id="安装手机证书-解密-HTTPS-必做"><a href="#安装手机证书-解密-HTTPS-必做" class="headerlink" title="安装手机证书 (解密 HTTPS 必做)"></a>安装手机证书 (解密 HTTPS 必做)</h3><p>如果不装证书，你抓到的 APP 包全是灰色的锁头，或者显示 <code>Tunnel to...</code>，看不到内容。</p><ol><li><strong>下载证书</strong>：<ul><li>保持代理开启状态。</li><li>打开手机浏览器（推荐系统自带的 Safari 或 Chrome）。</li><li>在地址栏输入：<strong><code>http://电脑IP:8888</code></strong> （例如 <code>http://192.168.1.5:8888</code>）。</li><li>会看到一个简陋的 Fiddler Echo Service 页面。</li><li>点击最下方的粗体链接：<strong><code>FiddlerRoot certificate</code></strong>。</li><li>手机会提示下载，点击“允许”或“下载”。</li></ul></li><li><strong>安装与信任证书</strong>（iOS 和 Android 略有不同）：<ul><li><strong>🤖 Android (安卓)</strong>：<ul><li>打开下载的文件，系统会问证书名称，随便填（如 <code>fiddler</code>），凭据用途选“VPN和应用”或“WLAN”，点击确定安装。</li><li><em>注意：安卓 7.0 以上版本安全性很高，部分 APP 默认不信任用户安装的证书（只信任系统证书）。如果你发现浏览器能抓包但 APP 抓不到，这是正常的。<strong>“对于安卓 7.0+，我们需要用 Xposed 模块 JustTrustMe 来绕过证书校验，或者让开发打一个允许 Debug 证书的测试包。”</strong></em></li></ul></li><li><strong>🍎 iOS (苹果) —— 必须做两步！</strong><ol><li><strong>安装</strong>：去 <code>设置</code> -&gt; <code>已下载描述文件</code> -&gt; 点击安装 Fiddler 证书。</li><li><strong>信任 (关键)</strong>：去 <code>设置</code> -&gt; <code>通用</code> -&gt; <code>关于本机</code> -&gt; 拉到最下面 <strong><code>证书信任设置</code></strong> -&gt; 找到 <code>DO_NOT_TRUST_FiddlerRoot</code> -&gt; <strong>开启开关</strong>（变绿）。</li></ol></li></ul></li></ol><hr><h3 id="第四步：实战抓包"><a href="#第四步：实战抓包" class="headerlink" title="第四步：实战抓包"></a>第四步：实战抓包</h3><p>手机已经完全被 Fiddler 监控了。</p><ol><li>打开手机上的<strong>知乎</strong>、<strong>小红书</strong>或者<strong>学校官网 APP</strong>。</li><li>随便刷一刷。</li><li>看电脑上的 Fiddler 屏幕。<ul><li>能看到大量的请求疯狂滚动。</li><li>找那些 Host 是 <code>api.zhihu.com</code> 或者类似的请求。</li><li>点开看 JSON，能看到刚才刷到的文章标题！</li></ul></li></ol><p>当结束抓包学习后，一定要把手机的代理关掉！</p><p>否则当电脑关机或 Fiddler 关闭后，手机就会断网（因为它还在傻傻地找代理）。</p><ul><li>手机 Wi-Fi 设置 -&gt; 代理 -&gt; 改回 <strong>“无”</strong>。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抓包工具</tag>
      
      <tag>Fiddler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣SQL题目总结</title>
    <link href="/2025/12/16/%E5%8A%9B%E6%89%A3SQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/16/%E5%8A%9B%E6%89%A3SQL%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="lc181"><a href="#lc181" class="headerlink" title="lc181"></a>lc181</h1> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> e.name Employee<br><span class="hljs-keyword">from</span> Employee e<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> m.salary <span class="hljs-keyword">from</span> Employee m <span class="hljs-keyword">where</span> m.id <span class="hljs-operator">=</span> e.managerId)<br></code></pre></td></tr></table></figure><p>问题：如果有 N 个员工，这个子查询就要被触发 N 次。如果 N 是 10 万，就要查询 10 万次。这就是经典的 <strong>N+1 问题</strong>。在大数据量下通常需要优化（比如改成 <code>JOIN</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> e1.name Employee<br><span class="hljs-keyword">from</span> Employee e1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Employee e2<br><span class="hljs-keyword">on</span> e1.managerId <span class="hljs-operator">=</span> e2.id<br><span class="hljs-keyword">where</span> e1.salary <span class="hljs-operator">&gt;</span> e2.salary<br></code></pre></td></tr></table></figure><hr><h1 id="lc-182"><a href="#lc-182" class="headerlink" title="lc 182"></a>lc 182</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> email<br><span class="hljs-keyword">from</span> Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> email<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(email) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>一旦使用了 <code>GROUP BY</code>，<code>SELECT</code> 后面只能跟两类东西：</p><ol><li><strong>参加分组的字段</strong>（即 GROUP BY 后面的那个字段，如 <code>module</code>）。</li><li><strong>聚合函数</strong>（被捏扁后的统计结果，如 <code>COUNT()</code>, <code>MAX()</code>, <code>AVG()</code>）。</li></ol><hr><h1 id="lc-183"><a href="#lc-183" class="headerlink" title="lc 183"></a>lc 183</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.name Customers<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Orders o <br><span class="hljs-keyword">on</span> c.id <span class="hljs-operator">=</span> o.customerId<br><span class="hljs-keyword">where</span> o.customerId <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>同样的问题，需要执行子查询获取所有 customerId，子查询的时间复杂度很高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.name Customers<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">where</span> c.id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<br>    <span class="hljs-keyword">select</span> o.customerId<br>    <span class="hljs-keyword">from</span> Orders o<br>)<br></code></pre></td></tr></table></figure><p>左连接，本题性能最好的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.name Customers<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">from</span> Orders o<br>    <span class="hljs-keyword">where</span> c.id <span class="hljs-operator">=</span> o.customerId<br>)<br></code></pre></td></tr></table></figure><p>如果子查询结果集大，EXISTS 在找到第一个匹配后立即返回，在某些数据库中对大表可能比 LEFT JOIN 更好且对 <code>Orders.customerId</code> 有索引时效率高。</p><hr><h1 id="lc-196"><a href="#lc-196" class="headerlink" title="lc 196"></a>lc 196</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>MySQL</tag>
      
      <tag>PostgreSQL</tag>
      
      <tag>多表查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣常见算法题型总结</title>
    <link href="/2025/12/15/%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/15/%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h2><h3 id="lc-1456"><a href="#lc-1456" class="headerlink" title="lc 1456"></a>lc 1456</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxVowels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        ans = cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            c = s[right]<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;aeiou&quot;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &lt; k:<br>                <span class="hljs-keyword">continue</span><br>            ans = <span class="hljs-built_in">max</span>(ans, cnt)<br>            c = s[left]<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;aeiou&quot;</span>:<br>                cnt -= <span class="hljs-number">1</span><br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxVowels</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; s.length(); right++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ch[right];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>                cnt ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; k)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ans = Math.max(ans, cnt);<br>            c = ch[left];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>                cnt --;<br>            &#125;<br>            left ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lc-1423"><a href="#lc-1423" class="headerlink" title="lc 1423"></a>lc 1423</h3><p>逆向思维-求中间的n-k个数的最小值即可-定长滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxScore</span>(<span class="hljs-params">self, cardPoints: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(cardPoints)<br>        length = n - k<br>        ans = inf<br>        left = cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            cnt += cardPoints[right]<br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &lt; length:<br>                <span class="hljs-keyword">continue</span><br>            ans = <span class="hljs-built_in">min</span>(ans, cnt)<br>            cnt -= cardPoints[left]<br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(cardPoints) - ans <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cardPoints) != k <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span>(cardPoints)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cardPoints, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : cardPoints)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cardPoints.length;<br>        <span class="hljs-keyword">if</span> (n == k)&#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; n; right++)&#123;<br>            cnt += cardPoints[right];<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; n - k)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ans = Math.min(ans, cnt);<br>            cnt -= cardPoints[left];<br>            left ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="不定长滑动窗口"><a href="#不定长滑动窗口" class="headerlink" title="不定长滑动窗口"></a>不定长滑动窗口</h2><p>滑动窗口相当于在维护一个<strong>队列</strong>。右指针的移动可以视作<strong>入队</strong>，左指针的移动可以视作<strong>出队</strong></p><h3 id="越短越合法-求最长-最大"><a href="#越短越合法-求最长-最大" class="headerlink" title="越短越合法&#x2F;求最长&#x2F;最大"></a>越短越合法&#x2F;求最长&#x2F;最大</h3><h4 id="lc-3"><a href="#lc-3" class="headerlink" title="lc 3"></a>lc 3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        left = length = ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            c = s[right]<br>            cnt[c] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> cnt[c] &gt; <span class="hljs-number">1</span>:<br>                cnt[s[left]] -= <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; s.length(); right++)&#123;<br>            map.merge(ch[right], <span class="hljs-number">1</span>, (a, b) -&gt; (a + b));<br>            <span class="hljs-keyword">while</span> (map.get(ch[right]) &gt; <span class="hljs-number">1</span>)&#123;<br>                map.put(ch[left], map.get(ch[left]) - <span class="hljs-number">1</span>);<br>                left ++;<br>            &#125;<br>            ans = Math.max(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了提升性能效率，可以将Map换为数组 int[] cnt &#x3D; new int[128]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>java</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习</title>
    <link href="/2025/12/15/Mysql%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/Mysql%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql基础概念"><a href="#Mysql基础概念" class="headerlink" title="Mysql基础概念"></a>Mysql基础概念</h1><p>MySQL 是一个关系型数据库管理系统（RDBMS）。</p><ul><li><p><strong>关系型</strong>：数据以“表”（Table）的形式存储，表与表之间有关联（Relation）。</p></li><li><p><strong>C&#x2F;S 架构</strong>：MySQL 分为<strong>服务端（Server）和客户端（Client）</strong>。</p><ul><li><strong>服务端</strong>：负责存储数据、处理查询（就在你的服务器或本地后台运行）。</li><li><strong>客户端</strong>：负责发送指令（你用的 Navicat、DBeaver，或者 Python 代码，本质都是客户端）。</li></ul></li><li><p>核心层级结构</p></li><li><p><strong>Database（数据库）</strong>：相当于整个 Excel 文件（比如 <code>Project_A.xlsx</code>）。</p></li><li><p><strong>Table（表）</strong>：相当于 Excel 中的一个 Sheet（比如 <code>User_Sheet</code>）。</p></li><li><p><strong>Column（列&#x2F;字段）</strong>：表头，定义数据的属性（如 <code>username</code>, <code>password</code>）。</p></li><li><p><strong>Row（行&#x2F;记录）</strong>：具体的每一行数据。</p></li></ul><hr><h2 id="SQL-语言四大分类（DDL-DML-DQL-DCL）"><a href="#SQL-语言四大分类（DDL-DML-DQL-DCL）" class="headerlink" title="SQL 语言四大分类（DDL, DML, DQL, DCL）"></a>SQL 语言四大分类（DDL, DML, DQL, DCL）</h2><h3 id="1-DDL-Data-Definition-Language-——-数据定义语言"><a href="#1-DDL-Data-Definition-Language-——-数据定义语言" class="headerlink" title="1. DDL (Data Definition Language) —— 数据定义语言"></a>1. DDL (Data Definition Language) —— 数据定义语言</h3><p><strong>作用</strong>：用来定义数据库对象（库、表、列）。也就是<strong>搭建架子</strong>。</p><ul><li><strong>测开场景</strong>：自动化脚本运行前，初始化测试环境（建表），或测试结束后清理环境（删表）。</li><li><strong>关键词</strong>：<code>CREATE</code>, <code>DROP</code>, <code>ALTER</code>, <code>TRUNCATE</code></li></ul><p><strong>语法实战：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 1. 创建数据库</span><br><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> test_db;<br><br><span class="hljs-comment">-- 2. 切换到该数据库</span><br>USE test_db;<br><br><span class="hljs-comment">-- 3. 创建表（假设我们要存测试用例）</span><br><span class="hljs-comment">-- 重点：注意数据类型 (INT, VARCHAR, DATETIME) 和 约束 (PRIMARY KEY)</span><br><span class="hljs-keyword">CREATE TABLE</span> test_cases (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用例ID&#x27;</span>,<br>    case_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;用例名称&#x27;</span>,<br>    priority <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;P1&#x27;</span> COMMENT <span class="hljs-string">&#x27;优先级&#x27;</span>,<br>    create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span><br>);<br><br><span class="hljs-comment">-- 4. 修改表结构（比如测试需求变了，要加一个“状态”字段）</span><br><span class="hljs-keyword">ALTER TABLE</span> test_cases <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">-- 5. 清空表（保留表结构，删除所有数据，速度快，不可回滚！）</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> test_cases;<br><br><span class="hljs-comment">-- 6. 删除表（连表结构一起删掉）</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> test_cases;<br></code></pre></td></tr></table></figure><h3 id="2-DML-Data-Manipulation-Language-——-数据操作语言"><a href="#2-DML-Data-Manipulation-Language-——-数据操作语言" class="headerlink" title="2. DML (Data Manipulation Language) —— 数据操作语言"></a>2. DML (Data Manipulation Language) —— 数据操作语言</h3><p><strong>作用</strong>：用来对表中的数据进行增、删、改。</p><ul><li><strong>测开场景</strong>：<strong>构造测试数据</strong>（Insert），修改订单状态以模拟支付成功（Update），清理脏数据（Delete）。</li><li><strong>关键词</strong>：<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></li></ul><p><strong>语法实战：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1. 插入数据（构造数据）</span><br><span class="hljs-keyword">INSERT INTO</span> test_cases (case_name, priority, status) <br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;登录成功测试&#x27;</span>, <span class="hljs-string">&#x27;P0&#x27;</span>, <span class="hljs-string">&#x27;Pass&#x27;</span>);<br><br><span class="hljs-comment">-- 也可以一次插入多条</span><br><span class="hljs-keyword">INSERT INTO</span> test_cases (case_name, priority, status) <br><span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;密码错误测试&#x27;</span>, <span class="hljs-string">&#x27;P1&#x27;</span>, <span class="hljs-string">&#x27;Fail&#x27;</span>),<br>(<span class="hljs-string">&#x27;账号为空测试&#x27;</span>, <span class="hljs-string">&#x27;P2&#x27;</span>, <span class="hljs-string">&#x27;Skip&#x27;</span>);<br><br><span class="hljs-comment">-- 2. 更新数据（修改状态）</span><br><span class="hljs-comment">-- ⚠️注意：一定要加 WHERE，否则全表更新（生产环境事故之源）！</span><br><span class="hljs-keyword">UPDATE</span> test_cases <br><span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Pass&#x27;</span>, priority <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;P0&#x27;</span> <span class="hljs-comment">-- 注意是逗号不是and</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">-- 3. 删除数据</span><br><span class="hljs-comment">-- ⚠️注意：同样要加 WHERE</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> test_cases <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Skip&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="3-DQL-Data-Query-Language-——-数据查询语言"><a href="#3-DQL-Data-Query-Language-——-数据查询语言" class="headerlink" title="3. DQL (Data Query Language) —— 数据查询语言"></a>3. DQL (Data Query Language) —— 数据查询语言</h3><p><strong>作用</strong>：从数据库中查询数据。这是<strong>最核心、最复杂</strong>的部分。</p><ul><li><strong>测开场景</strong>：<strong>断言（Assertion）</strong>。接口返回说“查询成功”，你需要去数据库查一下，看是不是真的有这条数据，或者数据对不对。</li><li><strong>关键词</strong>：<code>SELECT</code>, <code>WHERE</code>, <code>GROUP BY</code>, <code>ORDER BY</code>, <code>HAVING</code>…</li></ul><p><strong>语法实战（基础版）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1. 查询所有列（测试时不建议用 *，但在调试时常用）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test_cases;<br><br><span class="hljs-comment">-- 2. 查询指定列（效率更高）</span><br><span class="hljs-keyword">SELECT</span> case_name, status <span class="hljs-keyword">FROM</span> test_cases;<br><br><span class="hljs-comment">-- 3. 条件查询（WHERE）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test_cases <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Fail&#x27;</span>;<br><br><span class="hljs-comment">-- 4. 排序（ORDER BY）- 默认是 ASC (升序), DESC (降序)</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test_cases <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 5. 分页查询（LIMIT）- 测开验证“分页功能”时必用</span><br><span class="hljs-comment">-- 取前 5 条</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test_cases LIMIT <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 跳过前 2 条，取 3 条</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test_cases LIMIT <span class="hljs-number">2</span>, <span class="hljs-number">3</span>; <br></code></pre></td></tr></table></figure><h3 id="4-DCL-Data-Control-Language-——-数据控制语言"><a href="#4-DCL-Data-Control-Language-——-数据控制语言" class="headerlink" title="4. DCL (Data Control Language) —— 数据控制语言"></a>4. DCL (Data Control Language) —— 数据控制语言</h3><p><strong>作用</strong>：定义数据库的访问权限和安全级别。</p><ul><li><strong>测开场景</strong>：通常由 DBA（数据库管理员）负责。作为测开，可能需要给自己开权限，或者测试“无权限用户”是否能访问数据。</li><li><strong>关键词</strong>：<code>GRANT</code> (授权), <code>REVOKE</code> (撤销)</li></ul><p><strong>语法实战：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建一个测试账号，只能查询，不能删除</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> test_db.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;tester_li&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p><strong>问：<code>DELETE</code>、<code>TRUNCATE</code> 和 <code>DROP</code> 都是删除，有什么区别？</strong></p><ol><li><strong>所属分类不同</strong>：<ul><li><code>DELETE</code> 是 <strong>DML</strong>（操作数据）。</li><li><code>TRUNCATE</code> 和 <code>DROP</code> 是 <strong>DDL</strong>（定义结构）。</li></ul></li><li><strong>回滚（事务安全）</strong>：<ul><li><code>DELETE</code> 可以回滚（如果开启了事务，误删可以救回来）。</li><li><code>TRUNCATE</code> 和 <code>DROP</code> <strong>不可回滚</strong>（删了就真没了）。</li></ul></li><li><strong>删除力度</strong>：<ul><li><code>DELETE</code>：删数据，保留表结构，速度慢（一行行删）。</li><li><code>TRUNCATE</code>：删数据，保留表结构，速度快（直接重置表）。</li><li><code>DROP</code>：连表结构一起炸掉。</li></ul></li></ol><hr><h1 id="约束-Constraints"><a href="#约束-Constraints" class="headerlink" title="约束 (Constraints)"></a>约束 (Constraints)</h1><p>在测开工作中，前端页面限制了输入，但后端接口不一定限制了。<strong>直接绕过前端调接口</strong>是测开发现 Bug 的常见手段。你需要熟知数据库层面的防线。</p><p><strong>五大核心约束：</strong></p><table><thead><tr><th><strong>约束类型</strong></th><th><strong>关键字</strong></th><th><strong>测开应用场景 (Test Case)</strong></th></tr></thead><tbody><tr><td><strong>主键</strong></td><td><code>PRIMARY KEY</code></td><td>唯一标识。测试：插入重复 ID，数据库应报错。</td></tr><tr><td><strong>非空</strong></td><td><code>NOT NULL</code></td><td>必填项。测试：传入 <code>NULL</code> 或不传该字段，验证接口是否拦截。</td></tr><tr><td><strong>唯一</strong></td><td><code>UNIQUE</code></td><td>手机号&#x2F;邮箱注册。测试：注册已存在的手机号，验证是否提示“已存在”。</td></tr><tr><td><strong>默认</strong></td><td><code>DEFAULT</code></td><td>状态字段。测试：创建订单时不传状态，验证是否默认为“待支付”。</td></tr><tr><td><strong>外键</strong></td><td><code>FOREIGN KEY</code></td><td>数据一致性。测试：删除父表数据（如班级），验证子表（学生）数据是否被处理。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> users (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,  <span class="hljs-comment">-- 主键，自增</span><br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span>,        <span class="hljs-comment">-- 唯一</span><br>    password <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>,      <span class="hljs-comment">-- 非空</span><br>    status <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,               <span class="hljs-comment">-- 默认值</span><br>    dept_id <span class="hljs-type">INT</span>,<br>    <span class="hljs-comment">-- 外键约束 (实际工作中一般都不设置物理外键，而是通过代码逻辑控制)</span><br>    <span class="hljs-keyword">CONSTRAINT</span> fk_dept <span class="hljs-keyword">FOREIGN KEY</span> (dept_id) <span class="hljs-keyword">REFERENCES</span> departments(id)<br>);<br></code></pre></td></tr></table></figure><hr><h1 id="常用函数-Functions"><a href="#常用函数-Functions" class="headerlink" title="常用函数 (Functions)"></a>常用函数 (Functions)</h1><h2 id="1-聚合函数-Aggregation"><a href="#1-聚合函数-Aggregation" class="headerlink" title="1. 聚合函数 (Aggregation)"></a>1. 聚合函数 (Aggregation)</h2><p>用于统计。<strong>注意：聚合函数通常配合 <code>GROUP BY</code> 使用，且不能用在 <code>WHERE</code> 后面。</strong></p><ul><li><code>COUNT(*)</code> &#x2F; <code>COUNT(列名)</code>：统计行数。</li><li><code>SUM()</code>, <code>AVG()</code>, <code>MAX()</code>, <code>MIN()</code>：求和、平均、最大、最小。</li></ul><h2 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a>2. 字符串函数</h2><ul><li><code>CONCAT(s1, s2)</code>: 拼接字符串。<em>场景：构造全名 <code>CONCAT(last_name, first_name)</code>。</em></li><li><code>SUBSTRING(str, pos, len)</code>: 截取。</li></ul><h2 id="3-日期函数-重点"><a href="#3-日期函数-重点" class="headerlink" title="3. 日期函数 (重点)"></a>3. 日期函数 (重点)</h2><p>测开经常要查询“最近 7 天的日志”或者“过期的订单”。</p><ul><li><code>NOW()</code>: 当前时间。</li><li><code>DATE_ADD(date, INTERVAL 1 DAY)</code>: 日期加法。</li><li><code>DATEDIFF(date1, date2)</code>: 计算两个日期相差的天数。</li></ul><hr><h1 id="核心-DQL-进阶"><a href="#核心-DQL-进阶" class="headerlink" title="核心 DQL 进阶"></a>核心 DQL 进阶</h1><p><strong>问：SQL 的执行顺序是什么？</strong></p><p>顺序：</p><ol><li><strong>FROM</strong> (先确定从哪张表找)</li><li><strong>JOIN &#x2F; ON</strong> (如果有连接，先拼接数据)</li><li><strong>WHERE</strong> (<strong>分组前</strong>过滤数据) ⬅️ <em>关键点：这里不能用聚合函数</em></li><li><strong>GROUP BY</strong> (数据分组)</li><li><strong>HAVING</strong> (<strong>分组后</strong>过滤数据) ⬅️ <em>关键点：这里可以用聚合函数，如 <code>COUNT(id) &gt; 5</code></em></li><li><strong>SELECT</strong> (最后选择显示哪些列)</li><li><strong>DISTINCT</strong> (去重)</li><li><strong>ORDER BY</strong> (排序)</li><li><strong>LIMIT</strong> (分页)</li></ol><p>找出平均分不及格（&lt;60）的课程 ID，且该课程至少要有 3 个人选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> course_id, <span class="hljs-built_in">AVG</span>(score)<br><span class="hljs-keyword">FROM</span> student_scores<br><span class="hljs-comment">-- WHERE AVG(score) &lt; 60  &lt;-- 错误！WHERE 后面不能接聚合函数</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> course_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(score) <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> <span class="hljs-built_in">COUNT</span>(student_id) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">-- 正确，在分组后筛选</span><br></code></pre></td></tr></table></figure><p>一旦使用了 <code>GROUP BY</code>，<code>SELECT</code> 后面只能跟两类东西：</p><ol><li><strong>参加分组的字段</strong>（即 GROUP BY 后面的那个字段，如 <code>module</code>）。</li><li><strong>聚合函数</strong>（被捏扁后的统计结果，如 <code>COUNT()</code>, <code>MAX()</code>, <code>AVG()</code>）。</li></ol><hr><h1 id="多表查询-Joins"><a href="#多表查询-Joins" class="headerlink" title="多表查询 (Joins)"></a>多表查询 (Joins)</h1><img src="/2025/12/15/Mysql%E5%AD%A6%E4%B9%A0/image1.png" class="" title="多表查询"><h2 id="1-内连接-INNER-JOIN"><a href="#1-内连接-INNER-JOIN" class="headerlink" title="1. 内连接 (INNER JOIN)"></a>1. 内连接 (INNER JOIN)</h2><ul><li><strong>口诀</strong>：两边都有才显示。交集。</li><li><strong>语法</strong>：<code>SELECT * FROM A INNER JOIN B ON A.id = B.id</code></li></ul><h2 id="2-左连接-LEFT-JOIN-——-最常用"><a href="#2-左连接-LEFT-JOIN-——-最常用" class="headerlink" title="2. 左连接 (LEFT JOIN) —— 最常用"></a>2. 左连接 (LEFT JOIN) —— <strong>最常用</strong></h2><ul><li><strong>口诀</strong>：左边全显示，右边没有补 NULL。</li><li><strong>场景</strong>：查询“所有用户及其订单信息”（即使用户没下过单，用户也得显示出来）。</li></ul><p>leetcode 175：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> p.FirstName, p.LastName, a.City, a.State<br><span class="hljs-keyword">from</span> Person p<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address a<br><span class="hljs-keyword">on</span> p.PersonId <span class="hljs-operator">=</span> a.PersonId<br></code></pre></td></tr></table></figure><h2 id="3-自连接-Self-Join"><a href="#3-自连接-Self-Join" class="headerlink" title="3. 自连接 (Self Join)"></a>3. 自连接 (Self Join)</h2><ul><li><strong>概念</strong>：自己连接自己。把一张表当两张表用。</li><li><strong>场景</strong>：员工表里有 <code>manager_id</code>，查询“员工名字和他领导的名字”。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    e.name <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;员工&#x27;</span>, <br>    m.name <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;领导&#x27;</span><br><span class="hljs-keyword">FROM</span> employee e<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employee m <span class="hljs-keyword">ON</span> e.manager_id <span class="hljs-operator">=</span> m.id;<br></code></pre></td></tr></table></figure><h2 id="4-不相关子查询"><a href="#4-不相关子查询" class="headerlink" title="4.不相关子查询"></a>4.不相关子查询</h2><p><strong>核心特点</strong>：子查询可以<strong>独立运行</strong>。它不依赖外部查询的任何数据。</p><p><strong>执行流程</strong>：</p><ol><li>先执行子查询（只执行一次）。</li><li>拿到子查询的结果。</li><li>再执行外部查询。</li></ol><p><strong>场景</strong>： 查询<strong>工资高于所有员工平均工资</strong>的员工名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-comment">-- 这一部分可以单独拎出来运行，它只是算一个数字</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <br>);<br></code></pre></td></tr></table></figure><h2 id="5-相关子查询"><a href="#5-相关子查询" class="headerlink" title="5.相关子查询"></a>5.相关子查询</h2><p><strong>核心特点</strong>：子查询<strong>不能独立运行</strong>。子查询内部引用了外部查询表中的字段。 <strong>执行流程</strong>：<strong>循环执行（Loop）</strong>。</p><ol><li>外部查询取出一行数据（Row 1）。</li><li>将 Row 1 的某个值（比如 <code>dept_id</code>）传给子查询。</li><li>子查询运行，算出结果。</li><li>外部查询根据结果判断是否保留 Row 1。</li><li>外部查询取出下一行（Row 2）……重复上述过程。</li></ol><p>leetcode 181:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name Employee<br><span class="hljs-keyword">from</span> Employee e<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-comment">-- ⚠️ 这里是性能杀手：相关子查询</span><br>    <span class="hljs-keyword">select</span> m.salary <br>    <span class="hljs-keyword">from</span> Employee m <br>    <span class="hljs-keyword">where</span> m.id <span class="hljs-operator">=</span> e.managerId<br>)<br></code></pre></td></tr></table></figure><ul><li><strong>性能隐患</strong>：如果有 N 个员工，这个子查询就要被触发 N 次。如果 N 是 10 万，就要查询 10 万次。这就是经典的 <strong>N+1 问题</strong>。在大数据量下通常需要优化（比如改成 <code>JOIN</code>）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.Name <span class="hljs-keyword">AS</span> Employee<br><span class="hljs-keyword">FROM</span> Employee e<br><span class="hljs-keyword">JOIN</span> Employee m <br>  <span class="hljs-keyword">ON</span> e.ManagerId <span class="hljs-operator">=</span> m.Id  <span class="hljs-comment">-- 把员工和对应的领导连成一行</span><br><span class="hljs-keyword">WHERE</span> e.Salary <span class="hljs-operator">&gt;</span> m.Salary; <span class="hljs-comment">-- 此时，领导工资就在同一行里，直接比大小</span><br></code></pre></td></tr></table></figure><h2 id="6-Exists"><a href="#6-Exists" class="headerlink" title="6.Exists"></a>6.Exists</h2><p><code>EXISTS</code> 是一个**返回布尔值（True&#x2F;False）**的关键字。它不返回具体的数据，只告诉数据库：“这里有没有数据？”</p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> A<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> B <span class="hljs-keyword">WHERE</span> A.id <span class="hljs-operator">=</span> B.id);<br></code></pre></td></tr></table></figure><p><strong>核心逻辑</strong>：</p><ol><li>只要子查询查到<strong>至少一条</strong>记录，<code>EXISTS</code> 就返回 <code>TRUE</code>，外层查询保留该行。</li><li><strong>一旦找到一条，立刻停止扫描</strong>（Short-circuit），所以它通常比直接 <code>COUNT(*)</code> 要快。</li></ol><p><strong>实战场景：</strong> 找出<strong>有过订单记录</strong>的用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">FROM</span> orders o <br>    <span class="hljs-keyword">WHERE</span> o.user_id <span class="hljs-operator">=</span> u.id<br>);<br></code></pre></td></tr></table></figure><p><em>(子查询里的 <code>SELECT 1</code> 还是 <code>SELECT \*</code> 甚至 <code>SELECT &#39;x&#39;</code> 都不重要，因为 <code>EXISTS</code> 只在这个结果集是否为空，不关心里面是什么内容。习惯上写 <code>SELECT 1</code>)</em></p><hr><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>传统的 <code>GROUP BY</code> 有一个巨大的痛点：<strong>它会把多行数据“坍缩”成一行</strong>。</p><p>有一张学生成绩表。</p><ul><li><strong>需求 A</strong>：算出每个班级的<strong>平均分</strong>。<ul><li>✅ 用 <code>GROUP BY</code> 没问题，算出每个班一行数据。</li></ul></li><li><strong>需求 B</strong>：算出每个班级<strong>排名第一的学生</strong>，并列出他的名字和分数。<ul><li>❌ 用 <code>GROUP BY</code> 就很尴尬了。因为一旦 <code>GROUP BY 班级</code>，你就丢失了“学生名字”这个细节，只剩下聚合后的数据了。</li></ul></li></ul><p>窗口函数的作用：它可以在不减少原表行数的情况下，对每一行数据进行“局部聚合”或“排名”。</p><p>简单说：它能让你同时看到“班级平均分”和“学生个人成绩”在同一行里。</p><hr><h2 id="核心语法公式"><a href="#核心语法公式" class="headerlink" title="核心语法公式"></a>核心语法公式</h2><p>窗口函数的标志就是关键字 <code>OVER</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>窗口函数<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">OVER</span> ( <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>分组字段<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>排序字段<span class="hljs-operator">&gt;</span> )<br></code></pre></td></tr></table></figure><ul><li><strong>PARTITION BY</strong>：相当于 <code>GROUP BY</code>，把数据分成一个个小窗口（比如按“班级”分）。</li><li><strong>ORDER BY</strong>：在每个小窗口内部怎么排（比如按“分数”倒序）。</li><li><strong>&lt;窗口函数&gt;</strong>：你想在这个窗口里算什么？（排名？求和？平均？）</li></ul><hr><h2 id="最常用的三剑客：排名函数"><a href="#最常用的三剑客：排名函数" class="headerlink" title="最常用的三剑客：排名函数"></a>最常用的三剑客：排名函数</h2><p>这是面试最爱问的。假设有 4 个学生的成绩：<code>100, 90, 90, 80</code>。我们看看三个不同的函数算出来的排名有什么区别：</p><ol><li><strong><code>ROW_NUMBER()</code></strong> —— <strong>不管重名，硬排</strong><ul><li>结果：1, 2, 3, 4</li><li><em>特点</em>：即使分数一样，也会强制分出先后（通常按记录读取顺序）。</li><li><em>场景</em>：分页查询，或者只需要取出任意一条重复数据时。</li></ul></li><li><strong><code>RANK()</code></strong> —— <strong>并列跳号</strong><ul><li>结果：1, <strong>2, 2</strong>, 4  (注意没有第 3 名)</li><li><em>特点</em>：分数一样并列，但后面的名次会跳过。</li><li><em>场景</em>：像奥运会奖牌榜，如果有两个银牌，就没有铜牌了。</li></ul></li><li><strong><code>DENSE_RANK()</code></strong> —— <strong>并列不跳号</strong><ul><li>结果：1, <strong>2, 2</strong>, 3</li><li><em>特点</em>：分数一样并列，后面的名次紧接着排。</li><li><em>场景</em>：<strong>面试最常用！</strong> 比如“找出每门课前三名的学生”，通常希望即使有人并列，也不要少人。</li></ul></li></ol><hr><p>验证“热门商品推荐”功能，逻辑是推荐每个品类下价格最高的 2 个商品。</p><p>数据表 products：category (类别), product_name (商品名), price (价格)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> <br>        category,<br>        product_name,<br>        price,<br>        <span class="hljs-comment">-- 这里开始使用窗口函数</span><br>        <span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> category <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> price <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">as</span> ranking<br>    <span class="hljs-keyword">FROM</span> products<br>) <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">WHERE</span> t.ranking <span class="hljs-operator">&lt;=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 取出每个类别的前两名</span><br></code></pre></td></tr></table></figure><p><strong>代码解析（一步步看）：</strong></p><ol><li><strong><code>PARTITION BY category</code></strong>：把数据按“家电”、“服饰”、“食品”切分成不同的窗口。</li><li><strong><code>ORDER BY price DESC</code></strong>：在“家电”窗口里，按价格从高到低排。</li><li><strong><code>DENSE_RANK()</code></strong>：给它们打上标签 1, 2, 3…</li><li><strong>外层 WHERE</strong>：最后筛选出标签 <code>&lt;= 2</code> 的数据。</li></ol><hr><h2 id="LAG-和LEAD"><a href="#LAG-和LEAD" class="headerlink" title="LAG()和LEAD()"></a>LAG()<code>和</code>LEAD()</h2><ul><li><code>LAG(col, n)</code>: 向前看 n 行。</li><li><code>LEAD(col, n)</code>: 向后看 n 行.</li></ul><p>场景：检查日志表中，有没有哪次操作的时间间隔异常（例如两次点击间隔小于 1 秒）。你需要拿当前行的时间减去上一行的时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    id, <br>    click_time,<br>    <span class="hljs-comment">-- 取出上一行的 click_time 放在当前行旁边</span><br>    <span class="hljs-built_in">LAG</span>(click_time, <span class="hljs-number">1</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> click_time) <span class="hljs-keyword">as</span> prev_time <br><span class="hljs-keyword">FROM</span> user_logs;<br></code></pre></td></tr></table></figure><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务就是<strong>一组 SQL 语句的集合</strong>。这组语句要么<strong>全部成功</strong>，要么<strong>全部失败</strong>（回滚到原样），不能只执行一半</p><p>在 MySQL 中，默认情况下每条 SQL 都是自动提交（Auto Commit）的。要使用事务，需要手动“告诉”数据库。</p><ol><li><strong>开启事务</strong>：<code>START TRANSACTION;</code> 或 <code>BEGIN;</code><ul><li><em>潜台词：数据库兄弟，接下来我说的话先别急着存硬盘，先拿个小本本记下来。</em></li></ul></li><li><strong>提交事务</strong>：<code>COMMIT;</code><ul><li><em>潜台词：没问题了，把刚才的操作永久写入硬盘吧。</em></li></ul></li><li><strong>回滚事务</strong>：<code>ROLLBACK;</code><ul><li><em>潜台词：我草刚才的操作搞错了&#x2F;出错了，撤销！全部恢复成 <code>BEGIN</code> 之前的样子。</em></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_order</span>():<br>    <span class="hljs-comment"># 1. 连接数据库，开启事务</span><br>    conn.execute(<span class="hljs-string">&quot;BEGIN;&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 执行测试操作（比如插入一条测试订单）</span><br>    conn.execute(<span class="hljs-string">&quot;INSERT INTO orders ...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 进行断言（验证插入成功没）</span><br>    result = conn.execute(<span class="hljs-string">&quot;SELECT * FROM orders...&quot;</span>)<br>    <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-comment"># 4. 关键点：测试结束，直接回滚！</span><br>    <span class="hljs-comment"># 这样数据库里干干净净，像什么都没发生过一样，不需要写额外的清理代码</span><br>    conn.execute(<span class="hljs-string">&quot;ROLLBACK;&quot;</span>) <br></code></pre></td></tr></table></figure><hr><h2 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性 (ACID)"></a>事务的四大特性 (ACID)</h2><ol><li><strong>A - Atomicity (原子性)</strong><ul><li><strong>解释</strong>：要么全做，要么全不做。事务是不可分割的最小单位。</li><li><em>原理</em>：靠 <code>Undo Log</code> 日志实现（记录了怎么撤销你的操作）。</li></ul></li><li><strong>C - Consistency (一致性)</strong><ul><li><strong>解释</strong>：事务前后，数据的完整性没有被破坏。</li><li><em>例子</em>：转账不管成不成功，A 和 B 的钱加起来的总数是不变的。</li></ul></li><li><strong>I - Isolation (隔离性)</strong><ul><li><strong>解释</strong>：多个事务同时进行时（并发），互不干扰。</li></ul></li><li><strong>D - Durability (持久性)</strong><ul><li><strong>解释</strong>：事务一旦 <code>COMMIT</code> 提交，数据就永久保存在磁盘上了，即使数据库崩溃重启，数据也不会丢。</li><li><em>原理</em>：靠 <code>Redo Log</code> 日志实现。</li></ul></li></ol><hr><h2 id="并发带来的问题（隔离级别）"><a href="#并发带来的问题（隔离级别）" class="headerlink" title="并发带来的问题（隔离级别）"></a>并发带来的问题（隔离级别）</h2><p>当两个用户（两个事务）同时操作同一张表时，会发生什么奇葩现象？</p><p>假设表里现有存款：<strong>1000 元</strong>。</p><h4 id="1-脏读-Dirty-Read-——-最严重的-Bug"><a href="#1-脏读-Dirty-Read-——-最严重的-Bug" class="headerlink" title="1. 脏读 (Dirty Read) —— 最严重的 Bug"></a>1. 脏读 (Dirty Read) —— 最严重的 Bug</h4><ul><li><strong>场景</strong>：事务 A 正在把余额改成 2000，<strong>还没提交</strong>。事务 B 居然读到了 2000。结果事务 A 回滚了（改回 1000）。</li><li><strong>后果</strong>：事务 B 拿着根本不存在的“2000 元”去操作了。</li></ul><h4 id="2-不可重复读-Non-repeatable-Read"><a href="#2-不可重复读-Non-repeatable-Read" class="headerlink" title="2. 不可重复读 (Non-repeatable Read)"></a>2. 不可重复读 (Non-repeatable Read)</h4><ul><li><strong>场景</strong>：<ul><li>事务 A 第一次查，余额 1000。</li><li>此时，事务 B 冲进来，把余额改成 200 (并且提交了)。</li><li>事务 A 还没结束，又查了一次，余额变成 200 了。</li></ul></li><li><strong>问题</strong>：同一个事务里，两次查询结果不一样，像见了鬼一样。</li></ul><h4 id="3-幻读-Phantom-Read"><a href="#3-幻读-Phantom-Read" class="headerlink" title="3. 幻读 (Phantom Read)"></a>3. 幻读 (Phantom Read)</h4><ul><li><strong>场景</strong>：<ul><li>事务 A 查了一下，“咦，工资表中没有‘李同学’这条记录”。</li><li>此时，事务 B 冲进来，插入了一条“李同学”的记录并提交。</li><li>事务 A 准备插入“李同学”，数据库报错：“主键冲突！李同学已存在”。</li><li>事务 A 傻了：“我刚才查明明没有啊？怎么像出了幻觉一样？”</li></ul></li><li><strong>区别</strong>：不可重复读重点在于<strong>修改</strong>（值变了），幻读重点在于<strong>新增&#x2F;删除</strong>（行数变了）。</li></ul><hr><h3 id="五、-MySQL-的解决方案：事务隔离级别"><a href="#五、-MySQL-的解决方案：事务隔离级别" class="headerlink" title="五、 MySQL 的解决方案：事务隔离级别"></a>五、 MySQL 的解决方案：事务隔离级别</h3><p>为了解决上面三个问题，数据库提供了四种隔离级别（从低到高）：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>性能</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>Read Uncommitted</strong> (读未提交)</td><td>✅发生</td><td>✅发生</td><td>✅发生</td><td>极快</td><td>没人用，不安全</td></tr><tr><td><strong>Read Committed (RC)</strong> (读已提交)</td><td>❌解决</td><td>✅发生</td><td>✅发生</td><td>快</td><td>Oracle&#x2F;Postgres 默认</td></tr><tr><td><strong>Repeatable Read (RR)</strong> (可重复读)</td><td>❌解决</td><td>❌解决</td><td>❌大部分解决</td><td>一般</td><td><strong>MySQL 默认级别</strong></td></tr><tr><td><strong>Serializable</strong> (串行化)</td><td>❌解决</td><td>❌解决</td><td>❌解决</td><td>极慢</td><td>也就是排队做，完全没并发</td></tr></tbody></table><blockquote><p>💡 面试官坑点：</p><p>问：MySQL 默认的隔离级别是什么？</p><p>答：Repeatable Read (RR)。</p><p>问：那 Oracle 呢？</p><p>答：Oracle 默认是 Read Committed (RC)。</p></blockquote><hr><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h3 id="一、-什么是存储引擎？"><a href="#一、-什么是存储引擎？" class="headerlink" title="一、 什么是存储引擎？"></a>一、 什么是存储引擎？</h3><p>想象开了一家<strong>银行（MySQL Server）</strong>。</p><ul><li><strong>Server 层（老板）</strong>：负责接待客户（连接器）、听懂客户需求（分析器）、制定存取款计划（优化器）。<strong>这层决定了 SQL 语法怎么写。</strong></li><li><strong>存储引擎层（柜员）</strong>：老板不干苦力，真正负责<strong>把钱存进保险柜</strong>或者<strong>从保险柜拿钱</strong>的人是柜员。</li></ul><p>柜员是**可插拔（Pluggable）**的。可以根据业务需求，随时换掉柜员。</p><ul><li>想存钱安全、不出错？用 <strong>InnoDB</strong>（细心严谨的柜员）。</li><li>想存取速度极快、不关心记账细节？用 <strong>MyISAM</strong>（动作飞快的柜员）。</li></ul><hr><h3 id="二、-两大主角：InnoDB-vs-MyISAM"><a href="#二、-两大主角：InnoDB-vs-MyISAM" class="headerlink" title="二、 两大主角：InnoDB vs MyISAM"></a>二、 两大主角：InnoDB vs MyISAM</h3><h4 id="1-InnoDB-默认引擎，老大哥"><a href="#1-InnoDB-默认引擎，老大哥" class="headerlink" title="1. InnoDB (默认引擎，老大哥)"></a>1. InnoDB (默认引擎，老大哥)</h4><p>从 MySQL 5.5 版本开始，它就是默认引擎了。</p><ul><li><strong>特点</strong>：稳重、安全。</li><li><strong>必杀技</strong>：<ol><li><strong>支持事务 (ACID)</strong>：支持回滚，崩了能恢复。</li><li><strong>行级锁 (Row Lock)</strong>：你改你的行，我改我的行，互不干扰（并发高）。</li><li><strong>支持外键</strong>：保证数据完整性。</li></ol></li><li><strong>适用场景</strong>：几乎所有现代业务（支付、电商、用户系统）。<strong>测开工作中遇到的表 95% 都是 InnoDB。</strong></li></ul><h4 id="2-MyISAM-老前辈，已逐渐淘汰"><a href="#2-MyISAM-老前辈，已逐渐淘汰" class="headerlink" title="2. MyISAM (老前辈，已逐渐淘汰)"></a>2. MyISAM (老前辈，已逐渐淘汰)</h4><p>MySQL 5.5 之前的默认引擎。</p><ul><li><strong>特点</strong>：简单、快（某些特定场景下）。</li><li><strong>必杀技</strong>：<ol><li><strong>不支持事务</strong>：崩了数据就丢了，没法回滚。</li><li><strong>表级锁 (Table Lock)</strong>：一个人写数据，整张表锁死，其他人全得等着（并发极差）。</li><li><strong>文件小</strong>：存储结构简单，省磁盘空间。</li></ol></li><li><strong>适用场景</strong>：极少写的纯读业务（比如纯展示的日志归档、旧版博客文章表）。</li></ul><hr><h3 id="三、-面试高频-PK-表（背下来）"><a href="#三、-面试高频-PK-表（背下来）" class="headerlink" title="三、 面试高频 PK 表（背下来）"></a>三、 面试高频 PK 表（背下来）</h3><p>这是测开面试中<strong>区分度很高</strong>的考点，特别是关于 <code>Count(*)</code> 和锁的区别。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>InnoDB (推荐)</strong></th><th><strong>MyISAM (过时)</strong></th><th><strong>测开面试解读</strong></th></tr></thead><tbody><tr><td><strong>事务 (Transaction)</strong></td><td>✅ <strong>支持</strong></td><td>❌ 不支持</td><td>只要涉及钱&#x2F;核心数据，必须选 InnoDB。</td></tr><tr><td><strong>锁机制 (Locking)</strong></td><td><strong>行锁</strong> (Row)</td><td><strong>表锁</strong> (Table)</td><td>MyISAM 在高并发写入时会死锁或排长队。</td></tr><tr><td><strong>外键 (Foreign Key)</strong></td><td>✅ 支持</td><td>❌ 不支持</td><td>只有 InnoDB 能利用数据库层面做外键约束测试。</td></tr><tr><td><strong>Count(*) 效率</strong></td><td><strong>慢</strong> (要一行行扫描)</td><td><strong>极快</strong> (内部存了一个计数器)</td><td>如果业务需要频繁查总数且对精确度要求不高，MyISAM 有优势。</td></tr><tr><td><strong>崩溃恢复</strong></td><td>✅ 自动恢复 (Redo Log)</td><td>❌ 容易损坏</td><td>突然断电测试：InnoDB 数据还在，MyISAM 可能文件损坏。</td></tr></tbody></table><blockquote><p>💡 面试官陷阱题：</p><p>问：SELECT COUNT(*) FROM table 哪个引擎快？</p><p>答：如果不加 WHERE 条件，MyISAM 快。因为它内部直接存了总行数，拿出来就是 O(1)。而 InnoDB 因为有多版本并发控制（MVCC），它不确定此刻有多少行对当前事务可见，所以必须一行行去数。</p></blockquote><hr><h3 id="四、-测开实战中的应用"><a href="#四、-测开实战中的应用" class="headerlink" title="四、 测开实战中的应用"></a>四、 测开实战中的应用</h3><p><strong>场景 1：并发性能测试瓶颈分析</strong></p><ul><li><strong>现象</strong>：你在做压测，发现并发上不去，大量请求超时。</li><li><strong>排查</strong>：你去看数据库监控，发现数据库锁等待严重。</li><li><strong>原因</strong>：开发人员建表时偷懒或者复制粘贴，用了默认的 <strong>MyISAM</strong> 引擎。结果一个用户修改数据，整张表锁住了，导致 TPS（每秒事务数）极低。</li><li><strong>你的价值</strong>：指出这个问题，建议改为 InnoDB，性能瞬间提升。</li></ul><p><strong>场景 2：脏数据清理</strong></p><ul><li><strong>操作</strong>：我们之前说的 <code>BEGIN</code> … <code>ROLLBACK</code> 清理测试数据大法。</li><li><strong>前提</strong>：表必须是 <strong>InnoDB</strong>。如果你在一个 MyISAM 表上执行 <code>ROLLBACK</code>，MySQL 不会报错，但数据<strong>根本撤销不回来</strong>（因为不支持事务）。这会让你的自动化脚本变得不可靠。</li></ul><hr><h3 id="五、-动手看看"><a href="#五、-动手看看" class="headerlink" title="五、 动手看看"></a>五、 动手看看</h3><p><strong>1. 查看当前支持的引擎：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br><span class="hljs-comment">-- 你会看到 InnoDB 是 DEFAULT，支持 Transactions。</span><br></code></pre></td></tr></table></figure><p><strong>2. 查看某张表用的是什么引擎：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE TABLE</span> table_name;<br><span class="hljs-comment">-- 结果里会有一句 ENGINE=InnoDB</span><br></code></pre></td></tr></table></figure><p><strong>3. 修改引擎（危险操作，生产环境慎用）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> table_name ENGINE <span class="hljs-operator">=</span> InnoDB;<br></code></pre></td></tr></table></figure><hr><p>除非有极其特殊的理由（比如只读不写、为了省空间），否则无脑选 InnoDB。看到 MyISAM 的表要警惕“并发性能差”和“事务回滚失效”的问题。</p><hr><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="一、-什么是索引？"><a href="#一、-什么是索引？" class="headerlink" title="一、 什么是索引？"></a>一、 什么是索引？</h3><p><strong>索引就是一本“字典的目录”。</strong></p><ul><li><p>没有索引（全表扫描）：</p><p>想在一本 1000 页的乱序书里找一个名字LiHongXiang。只能从第 1 页翻到第 1000 页。如果运气不好在最后一页，就要翻 1000 次（IO 操作）。</p><ul><li><em>效率</em>：O(N)</li></ul></li><li><p>有索引：</p><p>先查目录，拼音 L -&gt; Li -&gt; 找到页码 520。你直接翻到 520 页。可能只需要翻 3 次。</p><ul><li><em>效率</em>：O(\log N)</li></ul></li><li><p><strong>好处</strong>：查询（SELECT）快得飞起。</p></li><li><p><strong>坏处</strong>：写入（INSERT&#x2F;UPDATE&#x2F;DELETE）<strong>变慢</strong>。</p><ul><li><em>为什么？</em> 因为每存一条数据，不仅要写数据表，还要去修改目录（重新排序）。</li><li>所以如果发现<strong>批量插入测试数据</strong>特别慢，第一时间检查是不是表上的索引建太多了。</li></ul></li></ul><hr><h3 id="二、-索引的数据结构：为什么是-B-树？"><a href="#二、-索引的数据结构：为什么是-B-树？" class="headerlink" title="二、 索引的数据结构：为什么是 B+ 树？"></a>二、 索引的数据结构：为什么是 B+ 树？</h3><p>MySQL 的 InnoDB 引擎，索引底层使用的是 <strong>B+ 树</strong>。</p><p>为什么不用哈希表？为什么不用二叉树？</p><ol><li><strong>哈希表 (Hash)</strong>：<ul><li>虽然查 <code>WHERE id = 1</code> 极快（O(1)），但它不支持<strong>范围查询</strong>。</li><li>想查 <code>WHERE score &gt; 60</code>，哈希表就瞎了，因为它存的数据是无序散列的。</li></ul></li><li><strong>二叉树 (Binary Tree)</strong>：<ul><li>如果数据很多，树会变得<strong>非常高（瘦高）</strong>。</li><li>每一层节点都需要一次磁盘 IO。树太高，IO 次数多，速度就慢。</li></ul></li></ol><p>B+ 树的超能力：它是一种多路平衡查找树。简单说，它长得**“矮胖”**。</p><ul><li><strong>矮胖</strong>：即使存千万级的数据，树的高度通常也只有 3 层左右。这意味着查任何数据只需要 3 次磁盘 IO。</li><li><strong>叶子节点手拉手</strong>：注意看图的最下面，所有的数据都存在<strong>叶子节点</strong>（Leaf Nodes），而且叶子之间用<strong>双向链表</strong>连起来了。<ul><li>这就是为什么 MySQL 范围查询（<code>BETWEEN</code>, <code>&gt;</code>, <code>&lt;</code>）特别快的原因——找到起点，顺着链表往下拿就行了。</li></ul></li></ul><hr><h3 id="三、-InnoDB-的两大索引分类（面试核心）"><a href="#三、-InnoDB-的两大索引分类（面试核心）" class="headerlink" title="三、 InnoDB 的两大索引分类（面试核心）"></a>三、 InnoDB 的两大索引分类（面试核心）</h3><p>在 InnoDB 引擎中，根据<strong>叶子节点存的内容不同</strong>，索引分为两类。搞懂这个，就理解了为什么有些 SQL 慢，有些快。</p><h4 id="1-聚簇索引-Clustered-Index-——-“主索引”"><a href="#1-聚簇索引-Clustered-Index-——-“主索引”" class="headerlink" title="1. 聚簇索引 (Clustered Index) —— “主索引”"></a>1. 聚簇索引 (Clustered Index) —— “主索引”</h4><ul><li><strong>地位</strong>：它是<strong>唯一的</strong>，也是<strong>最高贵</strong>的。</li><li><strong>Key</strong>：主键 ID (Primary Key)。</li><li><strong>Value</strong>：<strong>整行数据</strong>（所有字段都在这里）。</li><li><strong>物理存储</strong>：在 InnoDB 里，<strong>数据本身就是按聚簇索引组织的</strong>。找到了主键，就找到了这一行完整的数据。</li></ul><h4 id="2-辅助索引-Secondary-Index-——-“非聚簇索引”"><a href="#2-辅助索引-Secondary-Index-——-“非聚簇索引”" class="headerlink" title="2. 辅助索引 (Secondary Index) —— “非聚簇索引”"></a>2. 辅助索引 (Secondary Index) —— “非聚簇索引”</h4><ul><li><strong>地位</strong>：除了主键以外的索引（比如你给 <code>name</code> 字段建的索引）。</li><li><strong>Key</strong>：你索引的那个字段（如 <code>name</code>）。</li><li><strong>Value</strong>：<strong>主键 ID</strong> (注意！这里不存完整数据，只存主键值)。</li></ul><hr><h3 id="四、-关键概念：回表-Back-to-Table"><a href="#四、-关键概念：回表-Back-to-Table" class="headerlink" title="四、 关键概念：回表 (Back to Table)"></a>四、 关键概念：回表 (Back to Table)</h3><p>这是测开面试中判断你是否懂原理的“试金石”。</p><p>表 users 有两个索引：主键 id（聚簇），和 name（辅助）。</p><p>执行：SELECT * FROM users WHERE name &#x3D; ‘Li’;</p><p><strong>数据库经历了什么？</strong></p><ol><li><strong>第一步（查辅助索引）</strong>：<ul><li>去 <code>name</code> 的 B+ 树里找 <code>&#39;Li&#39;</code>。</li><li>找到了！拿到它对应的 Value —— 主键 ID（比如 <code>id = 101</code>）。</li></ul></li><li><strong>第二步（回表）</strong>：<ul><li>手里拿着 <code>id = 101</code>，再去 <strong>聚簇索引</strong> 的 B+ 树里找。</li><li>找到了 <code>101</code> 对应的叶子节点。</li><li>读取出这一行的<strong>完整数据</strong>（包含 <code>age</code>, <code>email</code> 等其他字段）。</li></ul></li><li><strong>返回结果</strong>。</li></ol><p>结论：查询辅助索引通常需要扫描两棵树（除非只查 ID）。这就是所谓的“回表”。</p><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>刚才讲存储引擎时，把引擎比作“柜员”。数据结构，就是这个柜员整理档案的方法。</p><p><strong>数据库也是软件</strong>。MySQL 的存储引擎在把数据写到硬盘（或者内存）上时，必须选择一种方式来组织这些数据，否则数据就是一堆乱码。<strong>这种“组织方式”，就叫索引的数据结构。</strong></p><p><strong>不同的存储引擎，选择了不同的数据结构作为自己的“核心武器”。</strong></p><ul><li><strong>InnoDB 引擎</strong>：<ul><li><strong>选择的数据结构</strong>：<strong>B+ 树</strong>。</li><li><em>为什么？</em> 因为它要支持<strong>范围查询</strong>（<code>&gt; 20</code> 岁的人），也要支持<strong>排序</strong>。树结构最适合。而且 B+ 树把数据都放在叶子节点用链表连起来，扫表特别快。</li></ul></li><li><strong>Memory 引擎</strong>：<ul><li><strong>选择的数据结构</strong>：<strong>哈希表 (Hash)</strong>。</li><li><em>为什么？</em> 因为它是做临时表用的，全在内存里，追求极致的快（$O(1)$），而且通常不需要查范围（很少有人会问“缓存里大于 10 的数有哪些”）。</li></ul></li><li><strong>MyISAM 引擎</strong>：<ul><li><strong>选择的数据结构</strong>：也是 <strong>B+ 树</strong>。</li><li><em>但在实现上有区别</em>：InnoDB 是把数据藏在树里（聚簇）；MyISAM 是树和数据分开放（树的叶子节点存的是数据的<strong>物理地址指针</strong>，而不是数据本身）。</li></ul></li></ul><hr><h3 id="为什么是-B-树？"><a href="#为什么是-B-树？" class="headerlink" title="为什么是 B+ 树？"></a>为什么是 B+ 树？</h3><ol><li><strong>二叉查找树 (BST)</strong>：<ul><li><em>原理</em>：左边比我小，右边比我大。</li><li><em>缺陷</em>：如果我有 1, 2, 3, 4, 5… 存进去，树会退化成一个“链表”（一根棍子）。找 100 要翻 100 次。太慢。</li></ul></li><li><strong>平衡二叉树 (AVL) &#x2F; 红黑树</strong>：<ul><li><em>原理</em>：会自动旋转，保证左右平衡。</li><li><em>缺陷</em>：一个节点只存一个数。如果有 1000 万数据，树会<strong>很高</strong>（几十层）。</li><li><em>致命伤</em>：数据库的数据存在硬盘上。访问一层节点 &#x3D; 读一次硬盘。树高 20 层 &#x3D; 读 20 次硬盘 &#x3D; 极慢。</li></ul></li><li><strong>B 树 (B-Tree)</strong>：<ul><li><em>原理</em>：为了把树变<strong>矮</strong>，我让一个节点能存<strong>很多个</strong>数（比如一个节点存 1000 个数）。这样树就只有 3-4 层了。</li><li><em>缺陷</em>：B 树的中间节点里也存了数据（Data）。这导致一个节点能存的索引（Key）变少了（被 Data 占了地盘）。</li></ul></li><li><strong>B+ 树 (最终形态)</strong>：<ul><li><em>改良</em>：<ol><li><strong>非叶子节点只存索引 (Key)</strong>，不存数据。这样一行能存更多的索引值，树就更矮更胖。</li><li><strong>所有数据都落在叶子节点</strong>。</li><li><strong>叶子节点之间有指针连接</strong>。</li></ol></li><li><em>结果</em>：查任何数据都只要 2-3 次磁盘 IO。完美。</li></ul></li></ol><hr><h2 id="建索引"><a href="#建索引" class="headerlink" title="建索引"></a>建索引</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>假设表名是 <code>users</code>，字段是 <code>name</code>。</p><ul><li><p><strong>方式 A：建表时直接加（最常用）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> users (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    age <span class="hljs-type">INT</span>,<br>    KEY idx_name (name)  <span class="hljs-comment">-- 创建一个名为 idx_name 的普通索引</span><br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>方式 B：表建好了再补加（ALTER）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> users <span class="hljs-keyword">ADD</span> INDEX idx_name_age (name, age);<br><span class="hljs-comment">-- 这是一个“组合索引”，同时索引了 name 和 age 两个字段</span><br></code></pre></td></tr></table></figure></li><li><p><strong>方式 C：创建唯一索引（既加速又约束唯一性）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email <span class="hljs-keyword">ON</span> users(email);<br></code></pre></td></tr></table></figure></li></ul><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_name <span class="hljs-keyword">ON</span> users;<br></code></pre></td></tr></table></figure><hr><h3 id="组合索引与“最左前缀原则”"><a href="#组合索引与“最左前缀原则”" class="headerlink" title="组合索引与“最左前缀原则”"></a>组合索引与“最左前缀原则”</h3><p><strong>如何创建出能“命中”的索引，避免全表扫描。<strong>这里有一个核心概念叫</strong>组合索引（Composite Index）</strong>，以及随之而来的<strong>最左前缀原则</strong>。</p><p>有一个<strong>组合索引</strong>：INDEX idx_abc (a, b, c)。</p><p>这相当于建立了一个目录，它是先按 a 排序，a 一样时按 b 排序，b 还一样时按 c 排序。</p><p><strong>最左前缀原则（Leftmost Prefix Principle）</strong>：查询时，MySQL 会从索引的最左边开始匹配。如果最左边的断了，后面的索引就全部失效。</p><p>把它比喻成**“爬楼梯”**：</p><ul><li>索引 <code>(a, b, c)</code> 就像一个三层的台阶。</li><li>要想踩到 <code>b</code>，必须先踩到 <code>a</code>。</li><li>要想踩到 <code>c</code>，必须先踩到 <code>a</code> 和 <code>b</code>。</li><li>如果想跳过 a去踩 <code>b</code>，或者踩完 <code>a</code> 直接去踩 <code>c</code>（中间断了），索引就会失效或部分失效。</li></ul><h4 id="❌-索引失效的经典案例"><a href="#❌-索引失效的经典案例" class="headerlink" title="❌ 索引失效的经典案例"></a>❌ 索引失效的经典案例</h4><p>假设索引是 <code>(name, age)</code>：</p><ol><li><p><strong>全值匹配（完美命中）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Li&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure><ul><li>✅ <strong>命中</strong>。先找 name，再找 age。</li></ul></li><li><p><strong>只查左边（命中）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Li&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>✅ <strong>命中</strong>。只用到了 name 这一层。</li></ul></li><li><p><strong>跳过第一列（失效）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure><ul><li>❌ <strong>完全失效</strong>。</li><li><em>原因</em>：因为 B+ 树是先按 name 排好序的。跳过 name 直接看 age，age 是乱序的（只有在 name 相同的时候 age 才有序）。这时候只能全表扫描。</li></ul></li><li><p><strong>模糊查询的坑（最左前缀的变体）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- A. 查姓“李”的人</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Li%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>✅ <strong>命中</strong>。因为“Li”在索引树的最左边是排好序的。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- B. 查名字以“Li”结尾的人</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Li&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>❌ <strong>失效</strong>。因为最左边是 <code>%</code>（未知），树不知道从哪开始找，只能从头翻到尾。</li></ul></li></ol><hr><h3 id="哪些坑会导致索引失效？"><a href="#哪些坑会导致索引失效？" class="headerlink" title="哪些坑会导致索引失效？"></a>哪些坑会导致索引失效？</h3><p>测开做性能测试时，如果发现慢 SQL，通常就是踩了下面这些坑：</p><ol><li><strong>对索引字段做计算&#x2F;函数操作</strong><ul><li>❌ <code>WHERE YEAR(create_time) = 2024</code></li><li><em>原因</em>：数据库存储的是 <code>create_time</code> 的原始值，不是计算后的值。你这一算，树就用不上了。</li><li>✅ <em>优化</em>：<code>WHERE create_time BETWEEN &#39;2024-01-01&#39; AND &#39;2024-12-31&#39;</code></li></ul></li><li><strong>类型转换（隐式转换）</strong><ul><li>假设 <code>phone</code> 字段是 <code>VARCHAR</code> 类型。</li><li>❌ <code>WHERE phone = 13800001234</code> (传了个数字)</li><li><em>原因</em>：MySQL 会在后台默默把字符串转成数字再比，相当于加了函数，索引失效。</li><li>✅ <em>优化</em>：<code>WHERE phone = &#39;13800001234&#39;</code> (传字符串)</li></ul></li><li><strong>范围查询右边的列失效</strong><ul><li>索引 <code>(a, b, c)</code></li><li><code>WHERE a = 1 AND b &gt; 10 AND c = 5</code></li><li><em>结果</em>：<code>a</code> 用到了，<code>b</code> 用到了（范围），<strong><code>c</code> 失效了</strong>。</li><li><em>原因</em>：因为 <code>b</code> 是范围，在 <code>b &gt; 10</code> 的结果里，<code>c</code> 又是乱序的了。</li></ul></li></ol><hr><h3 id="什么时候不要建索引？"><a href="#什么时候不要建索引？" class="headerlink" title="什么时候不要建索引？"></a>什么时候<strong>不要</strong>建索引？</h3><p>虽然索引快，但不能滥用。以下情况建了反而拖后腿：</p><ol><li><strong>区分度低的字段</strong><ul><li>比如“性别”（男&#x2F;女）、“状态”（0&#x2F;1）。</li><li><em>原因</em>：如果一个字段只有 2 种取值，建了索引，B+ 树分叉极少。查“男”可能要扫一半的表，MySQL 优化器觉得还不如直接全表扫描快。</li></ul></li><li><strong>频繁更新的字段</strong><ul><li>每次 update，都要调整树结构，性能损耗大。</li></ul></li><li><strong>数据量太小的表</strong><ul><li>几百行数据，全表扫一下也就几毫秒，建索引纯属浪费空间。</li></ul></li></ol><hr><h3 id="🧠-测开实战模拟题（请接招）"><a href="#🧠-测开实战模拟题（请接招）" class="headerlink" title="🧠 测开实战模拟题（请接招）"></a>🧠 测开实战模拟题（请接招）</h3><p>李同学，这是面试中最能体现你是否真的懂“最左前缀”的题目。</p><p>题目：</p><p>有一张表 t，建立了组合索引 INDEX idx_abc (a, b, c)。</p><p>请分析以下 SQL 语句，索引分别用到了哪些字段？</p><ol><li><code>WHERE a = 1 AND b = 2</code></li><li><code>WHERE a = 1 AND c = 3</code></li><li><code>WHERE b = 2 AND c = 3</code></li><li><code>WHERE a = 1 AND b &gt; 2 AND c = 3</code></li></ol><p>请把你的分析发给我（格式：1. 用到了 a, b…）。答完这个，你对索引的理解就达到中级水平了！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>SQL语句</tag>
      
      <tag>查询</tag>
      
      <tag>优化</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apifox学习</title>
    <link href="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p> • 接口是软件组件之间相互通信的协议和桥梁。</p><p> • 前端（如浏览器）通过调用接口来获取数据或执行操作。 </p><p> • 后端处理请求并通过接口返回结果。</p><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image1.png" class="" title="HTTP协议"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image2.png" class="" title="url解析"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image3.png" class="" title="请求"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image4.png" class="" title="状态码"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image5.png" class="" title="响应"><h1 id="Query、Body、Header"><a href="#Query、Body、Header" class="headerlink" title="Query、Body、Header"></a>Query、Body、Header</h1><p>API文档介绍：</p><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image6.png" class="" title="API文档"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/query.png" class="" title="query"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/body.png" class="" title="body"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/header.png" class="" title="header"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image7.png" class="" title="区别"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image8.png" class="" title="GET请求"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image9.png" class="" title="POST请求"><p>Postman 的 <code>raw</code> 模式更灵活，适合快速调试一段随便粘贴的代码；但 Apifox 的 <code>json</code> 模式更规范，因为它把 JSON 当作<strong>数据模型</strong>来管理，这对于我们做<strong>自动化测试</strong>和<strong>维护接口文档</strong>非常有帮助，因为我们可以直接引用定义好的数据结构，而不是每次都复制粘贴一堆文本</p><hr><h1 id="断言验证"><a href="#断言验证" class="headerlink" title="断言验证"></a>断言验证</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image10.png" class="" title="断言1"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image11.png" class="" title="断言2"><h3 id="第一步：找到“后置操作”"><a href="#第一步：找到“后置操作”" class="headerlink" title="第一步：找到“后置操作”"></a>第一步：找到“后置操作”</h3><ol><li>在界面下方找到 <strong>“后置操作”</strong> 标签页。</li><li>点击 <strong>“添加后置操作”</strong> 按钮。</li><li>在弹出的菜单中选择 <strong>“断言”</strong>。</li></ol><h3 id="第二步：配置断言规则"><a href="#第二步：配置断言规则" class="headerlink" title="第二步：配置断言规则"></a>第二步：配置断言规则</h3><p>直接验证最核心的数据内容（JSONPath）：验证返回列表里的第一只宠物，它的 status 字段必须是 sold。</p><p>请在表格里这样填写：</p><ol><li><strong>名称</strong>：<code>验证第一个宠物状态</code></li><li><strong>取值来源</strong>：<code>Response JSON</code></li><li><strong>属性 (关键点)</strong>：输入 <code>$[0].status</code><ul><li><code>$</code> 代表根节点（整个返回数据）。</li><li><code>[0]</code> 代表数组里的第一个元素（因为返回的是个列表）。</li><li><code>.status</code> 代表这个元素的 status 字段。</li></ul></li><li><strong>断言条件</strong>：<code>等于</code> (Equals)</li><li><strong>预期值</strong>：<code>sold</code></li></ol><blockquote><p><strong>知识点（JSONPath）</strong>：这是测开必考题。面试官问“怎么提取多层嵌套的数据？”，答案就是 JSONPath。</p></blockquote><h3 id="第三步：运行验证"><a href="#第三步：运行验证" class="headerlink" title="第三步：运行验证"></a>第三步：运行验证</h3><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image12.png" class="" title="断言验证"><h2 id="JSONPath"><a href="#JSONPath" class="headerlink" title="JSONPath"></a>JSONPath</h2><p>JSONPath 是一种用于从 JSON 数据结构中提取数据的查询语言，类似于 XPath 对 XML 的作用</p><p>官方说明文档：<a href="https://docs.apifox.com/doc-5725287">https://docs.apifox.com/doc-5725287</a></p><hr><h1 id="环境与变量"><a href="#环境与变量" class="headerlink" title="环境与变量"></a>环境与变量</h1><ol><li><strong>“环境”</strong>：如何一键切换测试服和正式服。</li><li><strong>“变量”</strong>：如何实现“上一个接口的输出，自动变成下一个接口的输入”。</li></ol><hr><h2 id="环境管理-Environment"><a href="#环境管理-Environment" class="headerlink" title="环境管理 (Environment)"></a>环境管理 (Environment)</h2><p>有两套服务器：</p><ul><li><strong>测试环境 (Dev&#x2F;Test)</strong>: <code>http://192.168.1.100</code> </li><li><strong>生产环境 (Prod)</strong>: <code>https://api.myapp.com</code></li></ul><p>如果接口 URL 写死了 <code>https://api.myapp.com/login</code>，那测试的时候还得一个个改 URL，太累了。</p><h4 id="操作练习："><a href="#操作练习：" class="headerlink" title="操作练习："></a>操作练习：</h4><ol><li><strong>寻找入口</strong>：在 Apifox 界面右上角，会看到一个显示为 <strong>“默认环境”</strong>（或者“No Environment”）的下拉框。点击它，选择 <strong>“管理环境”</strong>。</li><li><strong>配置服务</strong>：<ul><li>在左侧选中 <strong>“默认环境”</strong>（或者新建一个环境叫“学习环境”）。</li><li>在 <strong>“前置 URL”</strong> -&gt; <strong>“服务”</strong> 下面填写：<code>https://petstore.swagger.io/v2/</code>。</li><li>点击 <strong>“保存”</strong>。</li></ul></li><li><strong>修改接口</strong>：<ul><li>回到你刚才写的 <strong>“新增宠物”</strong> 接口。</li><li>把 URL 修改为：<code>pet/findByStatus</code></li></ul></li><li><strong>运行</strong>：<ul><li>再次点击 <strong>“发送”</strong>。Apifox 会自动把“环境里的前置 URL”和“接口路径”拼起来。</li></ul></li></ol><blockquote><p><strong>意义</strong>：以后要切换到生产环境，只需要在右上角切换环境，所有接口的地址就自动变了！</p></blockquote><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image13.png" class="" title="环境变量"><hr><h2 id="变量提取与传递-Variable-Extraction"><a href="#变量提取与传递-Variable-Extraction" class="headerlink" title="变量提取与传递 (Variable Extraction)"></a>变量提取与传递 (Variable Extraction)</h2><p>场景目标：</p><ol><li><strong>接口 A (POST)</strong>：创建一只宠物，服务器给它生成了一个 ID（比如 <code>992211</code>）。</li><li><strong>中间动作</strong>：Apifox 自动把这个 <code>992211</code> 抓出来，存到一个叫 <code>my_pet_id</code> 的变量里。</li><li><strong>接口 B (GET)</strong>：查询这只宠物，URL 自动引用这个变量。</li></ol><h3 id="步骤-1：在-POST-请求中“提取变量”"><a href="#步骤-1：在-POST-请求中“提取变量”" class="headerlink" title="步骤 1：在 POST 请求中“提取变量”"></a>步骤 1：在 POST 请求中“提取变量”</h3><ol><li>打开 <strong>“新增宠物”</strong> 接口 -&gt; <strong>“修改文档”</strong>。</li><li>找到 <strong>“后置操作”</strong>，点击 <strong>“添加后置操作”</strong> -&gt; <strong>“提取变量”</strong>。</li><li>填写提取规则（看图填空）：<ul><li><strong>提取变量名</strong>：<code>my_pet_id</code> (这是我们自己起的名字)。</li><li><strong>变量类型</strong>：<code>环境变量</code> (存在当前环境里)。</li><li><strong>取值来源</strong>：<code>Response JSON</code>。</li><li><strong>JSONPath 表达式</strong>：<code>$.id</code> (表示提取返回 JSON 里的 id 字段)。</li></ul></li><li>点击 <strong>“保存”</strong>。</li></ol><p>关键验证步骤：</p><p>切换到 “运行” 界面，点击 “发送”。</p><ul><li>发送成功后，请点击右上角那个 <strong>“眼睛图标”</strong> (查看环境变量)。</li><li>应该能看到里面多了一行：<code>my_pet_id</code>，值为刚才生成的数字。<strong>如果有值，说明提取成功！</strong></li></ul><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image14.png" class="" title="变量提取"><h3 id="步骤-2：创建新的-GET-接口使用变量"><a href="#步骤-2：创建新的-GET-接口使用变量" class="headerlink" title="步骤 2：创建新的 GET 接口使用变量"></a>步骤 2：创建新的 GET 接口使用变量</h3><p>我们要验证刚才生成的 ID 能不能用。</p><ol><li><strong>新建接口</strong>：名称叫 <code>查询刚创建的宠物</code>。</li><li><strong>方法</strong>：<code>GET</code>。</li><li><strong>URL</strong>：输入 <code>/pet/&#123;&#123;my_pet_id&#125;&#125;</code>。</li><li><strong>保存</strong> 并 <strong>运行</strong>。</li></ol><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image15.png" class="" title="变量使用"><hr><h1 id="数据库验证"><a href="#数据库验证" class="headerlink" title="数据库验证"></a>数据库验证</h1><blockquote><p>为什么要做数据库校验？</p><p>接口测试验证的是逻辑正确性（请求-响应过程是否成功）。</p><p>数据库验证验证的是数据正确性（数据是否按预期准确持久化）。</p><p>两者结合，才能构成完整的测试闭环</p></blockquote><hr><h2 id="第一步：配置数据库连接-全局设置"><a href="#第一步：配置数据库连接-全局设置" class="headerlink" title="第一步：配置数据库连接 (全局设置)"></a>第一步：配置数据库连接 (全局设置)</h2><p>在 Apifox 里，数据库连接是项目级别的资源。</p><ol><li><strong>打开设置</strong>：点击左侧菜单栏最下方的 <strong>“项目设置”</strong> (通常是个齿轮图标，或者在左侧目录的“外部资源”里)。</li><li><strong>找到入口</strong>：在菜单中选择 <strong>“外部程序”</strong> -&gt; <strong>“数据库连接”</strong>。</li><li><strong>新建连接</strong>：点击右上角的 <strong>“新建”</strong>。</li><li><strong>填写配置</strong>：<ul><li><strong>类型</strong>：Apifox 支持 MySQL, SQL Server, PostgreSQL, Oracle, MongoDB, ClickHouse 等。</li><li><strong>连接名</strong>：起个名字，比如 <code>Local_DB</code>。</li><li><strong>Host&#x2F;Port&#x2F;User&#x2F;Password</strong>：填入数据库的真实信息。</li><li><strong>数据库名</strong>：填入具体的 Database Name。</li></ul></li><li><strong>测试连接</strong>：点击“点击测试”，如果通了会提示成功。</li></ol><hr><h2 id="第二步：在接口中使用数据库-核心逻辑"><a href="#第二步：在接口中使用数据库-核心逻辑" class="headerlink" title="第二步：在接口中使用数据库 (核心逻辑)"></a>第二步：在接口中使用数据库 (核心逻辑)</h2><p>逻辑是这样的：<strong>执行 SQL -&gt; 拿到结果 -&gt; 存入变量 -&gt; 断言变量</strong>。</p><p>假设要验证“新增宠物”后，数据库里真的多了一条数据。在“新增宠物”接口的 <strong>“后置操作”</strong> 里做文章。</p><ol><li>回到 <strong>“新增宠物”</strong> 接口 -&gt; <strong>“修改文档”</strong>。</li><li>在 <strong>“后置操作”</strong> 点击添加 -&gt; 选择 <strong>“数据库操作”</strong>。</li><li><strong>配置 SQL 步骤</strong>：<ul><li><strong>数据库连接</strong>：选择刚才配好的 <code>Local_DB</code>。</li><li><strong>SQL命令</strong>：输入查询语句。<ul><li>这里可以用变量！</li><li><code>SELECT status FROM t_pet WHERE id = &#39;&#123;&#123;my_pet_id&#125;&#125;&#39;</code></li></ul></li><li><strong>提取结果</strong>：<ul><li>这是关键。Apifox 不会直接拿 SQL 结果去断言，而是先把结果存给一个变量。</li><li><strong>变量名</strong>：<code>db_status_verify</code></li><li><strong>JSONPath</strong>：<code>$[0].status</code> (提取查询结果第一行的 status 字段)。</li></ul></li></ul></li></ol><hr><h2 id="第三步：断言数据库结果"><a href="#第三步：断言数据库结果" class="headerlink" title="第三步：断言数据库结果"></a>第三步：断言数据库结果</h2><p>现在，变量 <code>db_status_verify</code> 里存储的就是<strong>数据库里的真实值</strong>。我们要拿它和<strong>我们期望的值</strong>做对比。</p><ol><li>继续在 <strong>“后置操作”</strong> 里，点击添加 -&gt; <strong>“断言”</strong>。</li><li><strong>配置断言</strong>：<ul><li><strong>对象</strong>：<code>变量</code> (注意：这里不再选 Response JSON 了)。</li><li><strong>变量名</strong>：<code>db_status_verify</code> (刚才存 SQL 结果的那个变量)。</li><li><strong>条件</strong>：<code>等于</code>。</li><li><strong>预期值</strong>：<code>sold</code>。</li></ul></li></ol><p><strong>流程闭环了：</strong> 接口返回成功 -&gt; 查库 -&gt; 拿到库里数据 -&gt; 确认库里数据也是 sold -&gt; 测试通过。</p><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image16.png" class="" title="数据库连接"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image17.png" class="" title="数据库验证"><hr><h1 id="生成API文档"><a href="#生成API文档" class="headerlink" title="生成API文档"></a>生成API文档</h1><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image18.png" class="" title="生成API文档"><hr><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><p>Mock：就是模拟一个真实对象的行为。在接口测试中，即模拟一个真实的服务器接口，返回预设的响应数据</p><ul><li>解除阻塞：前端无需等待后端接口完成，即可对接调试；测试可提前编写测试用例。 </li><li>模拟异常：轻松模拟各种异常场景（如服务器错误500、网络超时、 返回空数据），测试前端兼容性和鲁棒性。 </li><li>隔离测试：当某个下游接口不稳定时，可Mock它返回稳定数据，从而隔离并测试自身服务的逻辑。</li></ul><p>为什么需要Mock？</p><p>用一个**“餐厅”**的比喻来给你解释，你就全懂了。</p><hr><h3 id="1-谁在用这个-Mock-结果？"><a href="#1-谁在用这个-Mock-结果？" class="headerlink" title="1. 谁在用这个 Mock 结果？"></a>1. 谁在用这个 Mock 结果？</h3><p><strong>答案：主要是前端开发人员（做网页&#x2F;APP的人），其次是测试人员。</strong></p><p>想象一下：</p><ul><li><strong>后端（厨师）</strong>：负责做菜（写代码，查数据库，返回真实数据）。</li><li><strong>前端（服务员&#x2F;装修工）</strong>：负责把菜端上来，摆盘，展示给客人看（把数据显示在网页上）。</li><li><strong>接口文档（菜单）</strong>：规定了这道菜叫什么，有哪些配料（字段）。</li></ul><h4 id="场景一：厨师还没来上班（后端没开发完）"><a href="#场景一：厨师还没来上班（后端没开发完）" class="headerlink" title="场景一：厨师还没来上班（后端没开发完）"></a>场景一：厨师还没来上班（后端没开发完）</h4><p>项目刚开始，后端还在设计数据库，代码一行都没写。但是前端不能干等着啊！前端需要把网页的“骨架”搭好，把“头像”、“用户名”这些位置留出来。</p><ul><li><strong>如果没有 Mock</strong>：前端只能瞎写，或者写死数据（硬编码），等后端写好了再改代码，效率极低。</li><li><strong>有了 Mock</strong>：在 Apifox 里定义好字段，Apifox 就充当了一个 <strong>“塑料食物模型机器”</strong>。前端直接请求 Mock 地址，拿到了假的“塑料菜”（Mock数据），先把盘子摆好。等真的厨师（后端）做好了，把地址切回真实服务器就行了。</li></ul><hr><h3 id="2-为什么要在正常的接口里“改变字段-造假”？"><a href="#2-为什么要在正常的接口里“改变字段-造假”？" class="headerlink" title="2. 为什么要在正常的接口里“改变字段&#x2F;造假”？"></a>2. 为什么要在正常的接口里“改变字段&#x2F;造假”？</h3><p>Mock 对<strong>测开</strong>的巨大价值：<strong>模拟极端和异常场景。</strong></p><h4 id="例子：测试“用户被封号”的弹窗"><a href="#例子：测试“用户被封号”的弹窗" class="headerlink" title="例子：测试“用户被封号”的弹窗"></a>例子：测试“用户被封号”的弹窗</h4><p>想测试 App 上这样一个功能：如果用户被封号了，登录时会弹出一个红色的警告框。</p><ul><li><strong>用真接口（Real Backend）</strong>：<ul><li>需要去联系后端改数据库，把你的账号状态改成“banned”。</li><li>测试完，还得改回来，不然登录不上去了。</li><li>万一把测试环境弄坏了，别人也测不了。</li><li><strong>太麻烦，太危险！</strong></li></ul></li><li><strong>用 Mock（造假）</strong>：<ul><li>在 Apifox 里，不需要动后端一行代码。</li><li>只要在 Mock 规则里，把 <code>status</code> 字段强制改成 <code>banned</code>。</li><li>然后让 App 去连 Mock 地址。</li><li>App 一请求，收到了 <code>banned</code>，立刻弹出了红色警告框。</li><li><strong>测试通过！</strong> 验证了客户端的逻辑是正确的，而且没有骚扰后端，也没有脏数据。</li></ul></li></ul><hr><h3 id="3-它和原接口有什么关系？是新接口吗？"><a href="#3-它和原接口有什么关系？是新接口吗？" class="headerlink" title="3. 它和原接口有什么关系？是新接口吗？"></a>3. 它和原接口有什么关系？是新接口吗？</h3><p>它<strong>不是</strong>新接口，它是原接口的**“平行宇宙”**。</p><p>在 Apifox 里，同一个接口定义，有两个“门”可以进：</p><ol><li><strong>A 门（正式环境）</strong>：<code>http://api.myapp.com/login</code><ul><li>进去后，是真实的后端服务器在处理。</li><li>它查真的数据库，返回真的结果。</li></ul></li><li><strong>B 门（Mock 环境）</strong>：<code>http://127.0.0.1:4523/m1/xxx/login</code> (Apifox 提供的)<ul><li>进去后，是 Apifox 的虚拟服务器在处理。</li><li>它<strong>不查数据库</strong>，它只看在文档里定义的规则（比如：让 age 随机生成 18-20）。</li><li>它返回的是设定的“假数据”。</li></ul></li></ol><p><strong>两者的关系：</strong> 它们共享同一套**“长相定义”<strong>（都有 id, name, status 字段），但</strong>“内容来源”**完全不同。</p><hr><h3 id="总结：Mock-到底解决了什么？"><a href="#总结：Mock-到底解决了什么？" class="headerlink" title="总结：Mock 到底解决了什么？"></a>总结：Mock 到底解决了什么？</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>不用 Mock 的痛苦</strong></th><th><strong>用 Mock 的爽点</strong></th></tr></thead><tbody><tr><td><strong>后端没开发完</strong></td><td>前端只能干等，项目延期</td><td>前端用 Mock 数据先开发，前后端并行工作</td></tr><tr><td><strong>测试报错页面</strong></td><td>很难让服务器故意报错 (500 Error)</td><td>在 Mock 里设置“期望”，直接返回 500，秒测前端容错能力</td></tr><tr><td><strong>测试大量数据</strong></td><td>手工去数据库里造 1000 条数据</td><td>Mock 设置循环规则，一秒生成 1000 条列表数据，测试分页功能</td></tr></tbody></table><p>在APIfox中分为<strong>智能 Mock</strong>、<strong>自定义规则</strong> 和 <strong>高级 Mock（期望）</strong>。</p><hr><h2 id="智能-Mock-Smart-Mock"><a href="#智能-Mock-Smart-Mock" class="headerlink" title="智能 Mock (Smart Mock)"></a>智能 Mock (Smart Mock)</h2><p>Apifox 会根据字段名自动猜要什么数据。</p><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image19.png" class="" title="响应结果"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image20.png" class="" title="智能mock"><blockquote><p><strong>原理</strong>：Apifox 内置了一个强大的规则库，只要字段名叫 <code>url</code>, <code>email</code>, <code>phone</code>, <code>city</code> 等，它都能自动生成像模像样的假数据。</p></blockquote><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image21.png" class="" title="智能mock匹配规则"><hr><h2 id="自定义-Mock-规则-Regex-Wildcard"><a href="#自定义-Mock-规则-Regex-Wildcard" class="headerlink" title="自定义 Mock 规则 (Regex&#x2F;Wildcard)"></a>自定义 Mock 规则 (Regex&#x2F;Wildcard)</h2><p>有时候智能识别不够用。比如要测试国内手机号，必须是 11 位且以 1 开头，随便生成的字符串通过不了校验代码。</p><h4 id="场景：生成真实的手机号"><a href="#场景：生成真实的手机号" class="headerlink" title="场景：生成真实的手机号"></a>场景：生成真实的手机号</h4><ol><li>在响应字段里，添加一个 <code>mobile</code> 字段。</li><li>点击 <strong>Mock</strong> 列的输入框。</li><li><strong>方法 A：使用内置生成器 (推荐)</strong><ul><li>点击输入框，选择 <strong>“手机号”</strong>。</li></ul></li><li><strong>方法 B：使用正则表达式 (进阶)</strong><ul><li>如果非常特殊的格式（比如以 <code>138</code> 开头的号码）。</li><li>在 Mock 栏输入正则：<code>/^138\d&#123;8&#125;$/</code>。</li></ul></li><li><strong>方法 C：使用 Mock.js 语法</strong><ul><li>Apifox 兼容 Mock.js。输入 <code>@integer(18, 60)</code> 可以生成 18 到 60 岁的年龄。</li></ul></li></ol><hr><h3 id="第三层级：高级-Mock-期望-Expectations-——-测开必修"><a href="#第三层级：高级-Mock-期望-Expectations-——-测开必修" class="headerlink" title="第三层级：高级 Mock (期望 &#x2F; Expectations) —— 测开必修"></a>第三层级：高级 Mock (期望 &#x2F; Expectations) —— 测开必修</h3><p>这是 Mock 的终极形态。</p><p>场景：</p><ul><li>如果我传 <code>id=1</code>，你要给我返回“张三”的信息。</li><li>如果我传 <code>id=999</code>，你要给我返回“用户不存在”（404 错误）。</li><li>普通 Mock 做不到这点（它只会随机），必须用 <strong>“高级 Mock”</strong>。</li></ul><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>在接口详情页，点击上方的 <strong>“高级 Mock”</strong> 标签。</p></li><li><p>点击 <strong>“新建期望”</strong>。</p></li><li><p><strong>配置期望 1（正常情况）</strong>：</p><ul><li><p><strong>名称</strong>：<code>查询张三成功</code></p></li><li><p><strong>触发条件</strong>：参数 <code>id</code> <strong>等于</strong> <code>1</code>。</p></li><li><p><strong>响应内容</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">200</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Zhang San&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;balance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置期望 2（异常情况）</strong>：</p><ul><li>点击 <strong>“新建期望”</strong>。</li><li><strong>名称</strong>：<code>查询不存在的用户</code></li><li><strong>触发条件</strong>：参数 <code>id</code> <strong>等于</strong> <code>999</code>。</li><li><strong>响应内容</strong>：<ul><li>HTTP 状态码改为 <code>404</code>。</li><li>Body 填：<code>&#123; &quot;error&quot;: &quot;User not found&quot; &#125;</code>。</li></ul></li></ul></li></ol><hr><h3 id="为什么这对测开很重要？"><a href="#为什么这对测开很重要？" class="headerlink" title="为什么这对测开很重要？"></a>为什么这对测开很重要？</h3><p>问：“你如何测试前端对‘服务器500错误’或‘超时’的处理？”</p><p>答：</p><blockquote><p>“利用 Apifox 的 <strong>高级 Mock (期望)</strong> 功能。不需要去搞挂真实的服务器，只需要配置一个 Mock 期望，当传入特定参数时，Mock Server 直接返回 500 状态码。这样就能验证前端页面会不会正确弹出‘服务器繁忙’的提示，而不会白屏崩溃。”</p></blockquote><hr><h1 id="测试场景（容器）"><a href="#测试场景（容器）" class="headerlink" title="测试场景（容器）"></a>测试场景（容器）</h1><p>在“测试场景”这个容器里，可以放入 100 个接口，按顺序排列。</p><p><strong>它的核心价值：</strong></p><ol><li><strong>上下文传递</strong>：步骤 1 的结果，自动传给步骤 2（基于之前学的变量）。</li><li><strong>流程控制</strong>：可以循环跑、等待几秒再跑、或者根据条件决定跑不跑。</li><li><strong>独立运行</strong>：这个容器可以独立被 CI&#x2F;CD 调用，也可以一键生成测试报告。</li></ol><hr><h3 id="搭建基础业务流"><a href="#搭建基础业务流" class="headerlink" title="搭建基础业务流"></a>搭建基础业务流</h3><ol><li><strong>新建场景</strong>：<ul><li>点击左侧菜单栏的 <strong>“自动化测试”</strong>。</li><li>点击 <strong>“新建测试场景”</strong>（或者点 <code>+</code> 号）。</li><li>命名为：<code>宠物全生命周期测试</code>。</li></ul></li><li><strong>导入步骤（装填容器）</strong>：<ul><li>在场景详情页，点击下方的 <strong>“导入步骤”</strong>。</li><li>选择 <strong>“接口用例”</strong>。</li><li>在弹出的列表里，勾选我们之前做好的：<ol><li><code>新增宠物</code></li><li><code>查询已售出宠物</code></li></ol></li><li>点击 <strong>“确定”</strong>。</li></ul></li><li><strong>运行</strong>：<ul><li>点击右上角的 <strong>“运行”</strong>。</li><li>会在右侧看到执行日志：它会自动依次执行这两个接口，如果之前的变量提取（后置操作）配置对了，它们会自动传递参数。</li><li><strong>结果</strong>：最后会生成一个总的“通过率”报告。</li></ul></li></ol><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image22.png" class="" title="场景"><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image23.png" class="" title="场景2"><blockquote><p>测开知识点（引用 vs 复制）：</p><p>Apifox 有个很好的特性：这里导入的步骤默认是 “引用” 模式。</p><p>意思是：如果你去“接口管理”里修改了原接口的参数，这个测试场景里的步骤会自动同步更新。这大大降低了维护成本！</p></blockquote><hr><h3 id="流程控制（循环与等待）"><a href="#流程控制（循环与等待）" class="headerlink" title="流程控制（循环与等待）"></a>流程控制（循环与等待）</h3><p>真实的业务往往不是一根筋走到底的。</p><p>场景：用户下单后，系统处理需要时间，不能立刻查，得等 1 秒。或者想连续创建 10 只宠物压压惊。</p><ol><li><strong>添加等待（Think Time）</strong>：<ul><li>点击右侧的 <strong>“添加步骤”</strong> -&gt; <strong>“等待”</strong>。</li><li>把它拖动到“新增宠物”和“查询”之间。</li><li>设置等待时间：<code>1000</code> ms (1秒)。</li><li><em>（这是为了防止数据还没写入数据库，马上查会报错的常见稳健性处理）。</em></li></ul></li><li><strong>设置循环（Loop）</strong>：<ul><li>点击场景列表里的 <strong>“新增宠物”</strong> 这一行。</li><li>在右侧属性栏，找到 <strong>“循环次数”</strong>。</li><li>设置为 <code>5</code>。</li><li><strong>效果</strong>：系统会先连续执行 5 次新增，休息 1 秒，然后执行查询。</li></ul></li></ol><img src="/2025/12/15/Apifox%E5%AD%A6%E4%B9%A0/image24.png" class="" title="场景3"><hr><h3 id="条件分支（If-Else）"><a href="#条件分支（If-Else）" class="headerlink" title="条件分支（If-Else）"></a>条件分支（If-Else）</h3><p>这是测试脚本智能化的关键。</p><p>场景：只有当“新增宠物”成功（状态码 200）时，才去执行“查询”。如果第一步就挂了，后面没必要跑。</p><ol><li>点击 <strong>“添加步骤”</strong> -&gt; <strong>“条件分支”</strong> (Condition)。</li><li><strong>配置条件</strong>：<ul><li>比如：判断变量 <code>code</code> 等于 <code>200</code>。</li></ul></li><li><strong>拖拽层级</strong>：<ul><li>把“查询宠物”这个步骤，<strong>拖进</strong> 这个“条件分支”的内部（像文件夹一样）。</li></ul></li><li><strong>逻辑</strong>：如果条件不满足，里面的步骤就会被 <code>Skipped</code> (跳过)。</li></ol><hr><h3 id="数据驱动测试-Data-Driven-Testing"><a href="#数据驱动测试-Data-Driven-Testing" class="headerlink" title="数据驱动测试 (Data-Driven Testing)"></a>数据驱动测试 (Data-Driven Testing)</h3><p>如果想明确指定：</p><ul><li>第一次用名：Cat_A</li><li>第二次用名：Cat_B</li><li>第三次用名：Cat_C</li></ul><p><strong>操作流程：</strong></p><ol><li><p><strong>准备数据文件 (CSV)</strong>：</p><ul><li><p>在电脑上新建一个 <code>pet_data.csv</code> 文件。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pet_name,pet_status<br>旺财,available<br>来福,sold<br>咪咪,pending<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改接口参数</strong>：</p><ul><li>回到“新增宠物”接口。</li><li>把 Body 里的名字改成变量：<code>&#123;&#123;pet_name&#125;&#125;</code>。</li><li>把状态改成变量：<code>&#123;&#123;pet_status&#125;&#125;</code>。</li></ul></li><li><p><strong>配置测试场景</strong>：</p><ul><li>回到测试场景的运行界面。</li><li>打开 <strong>“测试数据”</strong> 开关。</li><li>点击 <strong>“管理测试数据”</strong> -&gt; <strong>“导入”</strong> -&gt; 上传刚才的 CSV。</li><li><strong>关键点</strong>：会看到 Apifox 自动预览了数据，并且把 CSV 的表头（pet_name）对应到了变量。</li></ul></li><li><p><strong>运行</strong>：</p><ul><li>点击运行。</li><li>系统会自动运行 <strong>3 次</strong>（因为 CSV 有 3 行数据）。</li><li>第一次用“旺财”，第二次用“来福”…</li></ul></li></ol><hr><h1 id="Runner与定时任务"><a href="#Runner与定时任务" class="headerlink" title="Runner与定时任务"></a>Runner与定时任务</h1><p>Runner（运行器） 解决了“批量运行”的问题。定时任务 (Scheduled Tasks) 解决了“无人值守运行”的问题。</p><hr><h2 id="Runner-运行器配置"><a href="#Runner-运行器配置" class="headerlink" title="Runner (运行器配置)"></a>Runner (运行器配置)</h2><p>当点击“自动化测试”场景右上角的“运行”时，弹出的那个配置框就是 <strong>Runner</strong>。。</p><h4 id="1-核心运行参数"><a href="#1-核心运行参数" class="headerlink" title="1. 核心运行参数"></a>1. 核心运行参数</h4><ul><li><strong>运行环境</strong>：一定要确认好！别把脏数据写到生产环境（Prod）去了，一定要选测试环境（Test）。</li><li><strong>循环次数 (Iterations)</strong>：<ul><li><strong>功能测试</strong>：通常填 <code>1</code>。</li><li><strong>稳定性测试</strong>：填 <code>100</code> 或更多。用于检测接口是不是跑着跑着就报错了（比如内存泄漏导致后面变慢）。</li></ul></li><li><strong>线程数 (Threads) —— 面试考点</strong>：<ul><li><strong>默认 1</strong>：串行执行。上一个跑完，下一个才开始。适合有逻辑依赖的业务（比如：注册 -&gt; 登录）。</li><li><strong>大于 1 (比如 10)</strong>：并行执行。模拟 10 个人同时点按钮。</li><li><strong>注意</strong>：Apifox 的并发能力主要用于轻量级验证。如果问“怎么做高并发压测？”，建议回答用 <strong>JMeter</strong> 或 <strong>K6</strong>，Apifox 更多用于功能流程的自动化。</li></ul></li><li><strong>遇到错误时停止</strong>：<ul><li>调试时勾选。</li><li>正式跑回归测试时<strong>不要勾选</strong>，要看总体的成功率。</li></ul></li></ul><h4 id="2-运行报告-Test-Report"><a href="#2-运行报告-Test-Report" class="headerlink" title="2. 运行报告 (Test Report)"></a>2. 运行报告 (Test Report)</h4><p>跑完之后，Runner 会生成一份报告。这是你要发给领导或开发看的东西。</p><ul><li><strong>概览</strong>：通过率（比如 95%）。</li><li><strong>失败详情</strong>：点击红色的用例，不仅能看到报错，还能看到<strong>当时发送的请求</strong>和<strong>当时返回的响应</strong>。</li></ul><hr><h2 id="定时任务-Scheduled-Tasks"><a href="#定时任务-Scheduled-Tasks" class="headerlink" title="定时任务 (Scheduled Tasks)"></a>定时任务 (Scheduled Tasks)</h2><p>场景：每天凌晨 2 点，自动把所有接口跑一遍。早上上班时，如果收到邮件说全绿，就能安心摸鱼；如果红了，马上修 Bug。</p><p>Apifox 实现定时任务主要有两种方式：</p><h4 id="方式-A：使用-Apifox-自带的“定时任务”-最简单"><a href="#方式-A：使用-Apifox-自带的“定时任务”-最简单" class="headerlink" title="方式 A：使用 Apifox 自带的“定时任务” (最简单)"></a>方式 A：使用 Apifox 自带的“定时任务” (最简单)</h4><ol><li>在左侧“自动化测试”栏，找到 <strong>“定时任务”</strong>。</li><li><strong>新建任务</strong>：<ul><li>选择你要跑的 <strong>测试场景</strong>。</li><li><strong>Crontab 表达式</strong>（核心）：这是 Linux 通用的定时规则。<ul><li>每天凌晨 2 点：<code>0 0 2 * * ?</code></li><li>每隔 10 分钟：<code>0 0/10 * * * ?</code></li><li><em>Apifox 界面通常提供了可视化的选择器。</em></li></ul></li></ul></li><li><strong>通知配置</strong>：<ul><li>配置钉钉&#x2F;飞书机器人 webhook，或者邮件。</li><li><strong>效果</strong>：任务跑失败了，群里自动弹消息：“报警！登录接口挂了！”</li></ul></li></ol><h4 id="方式-B：CI-CD-集成-DevOps-标准做法"><a href="#方式-B：CI-CD-集成-DevOps-标准做法" class="headerlink" title="方式 B：CI&#x2F;CD 集成 (DevOps 标准做法 )"></a>方式 B：CI&#x2F;CD 集成 (DevOps 标准做法 )</h4><p>通过 <strong>命令行 (CLI)</strong> 来驱动测试。</p><ol><li><p><strong>安装 CLI</strong>：</p><ul><li>需要 Node.js 环境。</li><li>在终端运行：<code>npm install -g apifox-cli</code></li></ul></li><li><p><strong>获取运行命令</strong>：</p><ul><li><p>回到 Apifox 的测试场景页面。</p></li><li><p>点击右上角的 <strong>“CI&#x2F;CD”</strong> (或者叫“发布&#x2F;流水线”) 按钮。</p></li><li><p>配置好环境（测试环境）。</p></li><li><p>Apifox 会自动生成一串长长的命令，类似于：</p><p>apifox run <a href="https://api.apifox.cn/api/v1/projects/">https://api.apifox.cn/api/v1/projects/</a>… -r html,cli</p></li></ul></li><li><p><strong>执行与集成</strong>：</p><ul><li>在本地终端粘贴这行命令，回车，会发现测试在黑底白字的命令行里跑起来了！</li><li><strong>最终大招</strong>：把这行命令复制到 <strong>Jenkins</strong> 或 <strong>GitLab CI</strong> 的配置文件里。</li><li><strong>意义</strong>：每当开发提交代码 (Git Push)，Jenkins 自动运行这行命令。如果 Apifox 测试失败，禁止代码上线。</li></ul></li></ol><p>问：“自动化测试是怎么执行的？”</p><blockquote><p>“我们的自动化测试分为两个层级：</p><ol><li><strong>日常调试</strong>：使用 Apifox 的 Runner 进行小批量的功能验证。</li><li><strong>回归体系</strong>：配置 <strong>CI&#x2F;CD 流水线</strong>。使用 Apifox CLI 生成了运行命令，集成了 Jenkins。</li><li><strong>监控</strong>：设置了<strong>定时任务</strong>，每天凌晨自动全量运行一次，生成的 HTML 报告会自动发送到团队群里，确保主要业务流程没有被当天的代码搞坏。”</li></ol></blockquote><hr><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>Apifox 的性能测试功能不如 JMeter 那么全面（比如没有复杂的阶梯加压、分布式压测），但用来做<strong>轻量级的压力测试</strong>和<strong>冒烟压测</strong>绰绰有余。</p><hr><h2 id="配置并发-设置虚拟用户"><a href="#配置并发-设置虚拟用户" class="headerlink" title="配置并发 (设置虚拟用户)"></a>配置并发 (设置虚拟用户)</h2><p>性能测试的核心就是：<strong>模拟很多人同时点同一个按钮。</strong></p><ol><li><strong>找到入口</strong>：<ul><li>打开 <strong>“测试场景”</strong>。</li><li>点击右上角的 <strong>“运行”</strong> 按钮。</li></ul></li><li><strong>调整运行模式</strong>：<ul><li>默认是“自动化测试”模式（串行执行）。关注下面的参数来变成“性能测试”模式。</li></ul></li><li><strong>关键参数设置</strong>：<ul><li><strong>循环次数 (Loop Count)</strong>：每个用户做几次操作？（比如填 <code>20</code>）。</li><li><strong>线程数 (Thread Count)</strong>：这是重点！这里代表<strong>并发人数</strong>。<ul><li>如果填 <code>1</code>，就是一个人慢慢点，不算压测。</li><li><strong>请填 <code>10</code></strong>：模拟 10 个用户同时操作。</li></ul></li><li><strong>总请求数</strong>：Apifox 会自动计算：<code>10 (线程) * 20 (循环) = 200 次请求</code>。</li></ul></li></ol><blockquote><p><strong>注意</strong>：由于 Apifox 是基于 Node.js 运行的本地程序，单机并发线程数建议不要设置过大（比如不要超过 100-200），如果需要上万并发，还是得用 JMeter。</p></blockquote><hr><h2 id="执行压测与防呆设置"><a href="#执行压测与防呆设置" class="headerlink" title="执行压测与防呆设置"></a>执行压测与防呆设置</h2><p>在点击“运行”之前，有两个细节</p><h4 id="1-固定延迟-Think-Time"><a href="#1-固定延迟-Think-Time" class="headerlink" title="1. 固定延迟 (Think Time)"></a>1. 固定延迟 (Think Time)</h4><p>真实的 10 个用户，不会像机器一样毫秒不差地同时点击。</p><ul><li>在**“高级设置”** 里，设置 <strong>“停顿&#x2F;延迟”</strong>。</li><li>比如设置 <code>500ms</code>。</li><li><strong>意义</strong>：模拟用户思考时间。</li></ul><h4 id="2-失败处理"><a href="#2-失败处理" class="headerlink" title="2. 失败处理"></a>2. 失败处理</h4><ul><li><strong>“遇到错误时停止测试”</strong>：做性能测试时，<strong>千万不要勾选</strong>这个！</li><li><strong>原因</strong>：性能测试本来就是为了看服务器什么时候报错。如果有 1% 的请求失败了，我们希望看到剩下的 99% 是快还是慢，而不是立刻停下来。</li></ul><hr><h2 id="分析性能报告-核心能力"><a href="#分析性能报告-核心能力" class="headerlink" title="分析性能报告 (核心能力)"></a>分析性能报告 (核心能力)</h2><p>跑完后，不要只看通过率，要看 “性能指标”。</p><p>Apifox 的报告会给你几个关键数据：</p><ol><li><strong>平均耗时 (Average Response Time)</strong>：<ul><li>比如 <code>350ms</code>。这代表用户平均要等多久。</li><li><em>标准</em>：一般来说，互联网接口要求在 200ms - 500ms 以内。</li></ul></li><li><strong>最小&#x2F;最大耗时 (Min&#x2F;Max)</strong>：<ul><li>如果最小 <code>100ms</code>，最大 <code>5000ms</code> (5秒)。</li><li><strong>说明</strong>：系统极不稳定，发生了**“抖动”**。可能是数据库锁死，或者 Java 的 GC (垃圾回收) 卡顿了。这是严重的性能隐患。</li></ul></li><li><strong>吞吐量 (TPS&#x2F;RPS)</strong>：<ul><li>报告里可能显示 <code>Request per Second</code>。</li><li>这代表服务器每秒能处理多少个请求。数值越大性能越好。</li></ul></li><li><strong>错误率 (Error Rate)</strong>：<ul><li>如果有红色报错，查看是 <code>Timeout</code> (超时) 还是 <code>500 Internal Error</code> (服务器崩了)。</li></ul></li></ol><hr><h2 id="导出与汇报"><a href="#导出与汇报" class="headerlink" title="导出与汇报"></a>导出与汇报</h2><p>Apifox 允许导出 <strong>HTML 格式</strong> 的报告。</p><ul><li>点击报告右上角的 <strong>“导出”</strong>。</li><li><strong>场景</strong>：开发说“优化了代码，再测测”。<ul><li>跑一次，导出 <code>Report_Before.html</code>。</li><li>再跑一次，导出 <code>Report_After.html</code>。</li><li><strong>对比数据</strong>：平均耗时从 800ms 降到了 300ms。</li></ul></li></ul><hr><p>问：“既然 Apifox 能做，为什么还要招会 JMeter 的人？”</p><p><strong>满分回答范例：</strong></p><blockquote><p>“使用 Apifox 做<strong>研发阶段的快速压测</strong>。</p><ol><li><strong>优势</strong>：由于平时就用 Apifox 管理接口和做自动化，脚本是现成的，改一下线程数就能跑，不需要重新写 JMeter 脚本，<strong>效率极高</strong>。适合开发自测或冒烟测试。</li><li><strong>局限</strong>：Apifox 是单机运行，受限于本地资源，难以模拟<strong>高并发</strong>（如几万并发）或<strong>分布式压测</strong>。而且它的报告图表不如 JMeter 详细（比如没有梯形加压图）。</li><li><strong>结论</strong>：所以，日常小并发验证用 Apifox；如果是上线前的大型全链路压测，会把 Apifox 的接口导出为 cURL 或脚本，导入到 <strong>JMeter</strong> 中去执行。”</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能测试</tag>
      
      <tag>接口测试</tag>
      
      <tag>自动化测试</tag>
      
      <tag>Mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Postman学习</title>
    <link href="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="API接口测试基础"><a href="#API接口测试基础" class="headerlink" title="API接口测试基础"></a>API接口测试基础</h1><p>稳定的练习网站：<strong>JSONPlaceholder</strong>。<a href="https://jsonplaceholder.typicode.com.它模拟了一个博客系统(有帖子/">https://jsonplaceholder.typicode.com。它模拟了一个博客系统（有帖子</a> <code>posts</code>，评论 <code>comments</code>，用户 <code>users</code> 等）。</p><hr><h2 id="GET-请求-获取数据"><a href="#GET-请求-获取数据" class="headerlink" title="GET 请求 - 获取数据"></a>GET 请求 - 获取数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image1.png" class="" title="GET请求"><hr><h2 id="第二步：POST-请求（增）-提交数据"><a href="#第二步：POST-请求（增）-提交数据" class="headerlink" title="第二步：POST 请求（增）- 提交数据"></a>第二步：POST 请求（增）- 提交数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image4.png" class="" title="POST请求1"><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image5.png" class="" title="POST请求2"><hr><h2 id="第三步：PUT-请求（改）-修改数据"><a href="#第三步：PUT-请求（改）-修改数据" class="headerlink" title="第三步：PUT 请求（改）- 修改数据"></a>第三步：PUT 请求（改）- 修改数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image2.png" class="" title="PUT请求1"><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image3.png" class="" title="PUT请求2"><hr><h2 id="第四步：DELETE-请求（删）-删除数据"><a href="#第四步：DELETE-请求（删）-删除数据" class="headerlink" title="第四步：DELETE 请求（删）- 删除数据"></a>第四步：DELETE 请求（删）- 删除数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image6.png" class="" title="DELETE请求"><hr><p>注意：在此网址进行测试POST请求和PUT请求时，JSON内容除了输入到raw中，还输入到form-data中也能测试通过</p><p>虽然在这个练习网站（JSONPlaceholder）上两者都能跑通，但在<strong>真实的实习工作中，它们是完全不同的东西</strong>。如果混用，90%的情况下后端会报错。这个问题直击了<strong>后端开发与接口测试的核心：数据传输格式（Content-Type）</strong>。：</p><h3 id="1-本质区别：数据的“包装”方式不同"><a href="#1-本质区别：数据的“包装”方式不同" class="headerlink" title="1. 本质区别：数据的“包装”方式不同"></a>1. 本质区别：数据的“包装”方式不同</h3><ul><li><strong>Raw (JSON)</strong>：就像<strong>寄一封信</strong>。内容必须按照严格的语法（JSON格式）写在纸上。它不仅能写简单的“姓名：小明”，还能写复杂的嵌套结构（比如“爱好”里包含一个列表）。</li><li><strong>Form-data</strong>：就像<strong>填一张表格</strong>，或者<strong>寄一个包裹</strong>。它是一格一格填写的（键值对）。它最大的特点是<strong>可以夹带附件（上传文件）</strong>。</li></ul><h3 id="2-细节：HTTP-Header（请求头）"><a href="#2-细节：HTTP-Header（请求头）" class="headerlink" title="2. 细节：HTTP Header（请求头）"></a>2. 细节：HTTP Header（请求头）</h3><ol><li>选中 <strong>Body</strong> -&gt; <strong>raw (JSON)</strong>，然后点击 Request 区域（中间部分）的 <strong>Headers</strong> 标签。<ul><li>Postman 自动加了一行：<code>Content-Type: application/json</code>。</li><li>这是告诉服务器：“我发给你的是 JSON 字符串。”</li></ul></li><li>选中 <strong>Body</strong> -&gt; <strong>form-data</strong>，再去 <strong>Headers</strong> 标签看。<ul><li>Postman 在发送时会加上：<code>Content-Type: multipart/form-data; boundary=...</code>。</li><li>这是告诉服务器：“我发给你的是表单数据，可能包含文件。”</li></ul></li></ol><p>而 <code>jsonplaceholder</code> 是一个<strong>模拟服务器</strong>，它的设计初衷就是为了方便大家测试，所以它非常“宽容”。它的后端逻辑大概是：“不管你给我 JSON 还是 Form-data，只要能解析出 <code>title</code> 和 <code>body</code>，我就算你成功。”</p><p><strong>但在真实开发中：</strong></p><ul><li>如果后端（例如 Java Spring Boot）代码写的是 <code>@RequestBody User user</code>，它<strong>只接受 JSON</strong>。你如果用 form-data 发送，会直接报 <strong>415 Unsupported Media Type</strong> 或者 <strong>400 Bad Request</strong>。</li><li>如果后端写的是 <code>@RequestParam</code> 或者涉及到文件上传，它才接受 form-data。</li></ul><h3 id="3-总结：什么时候用哪个？"><a href="#3-总结：什么时候用哪个？" class="headerlink" title="3. 总结：什么时候用哪个？"></a>3. 总结：什么时候用哪个？</h3><table><thead><tr><th><strong>模式</strong></th><th><strong>这里的 raw (JSON)</strong></th><th><strong>这里的 form-data</strong></th></tr></thead><tbody><tr><td><strong>全称</strong></td><td><code>application/json</code></td><td><code>multipart/form-data</code></td></tr><tr><td><strong>主要用途</strong></td><td><strong>最常用</strong>。用于发送复杂的结构化数据。</td><td>主要用于<strong>文件上传</strong>（图片、文档）。</td></tr><tr><td><strong>能否嵌套</strong></td><td>能（对象套数组，数组套对象）。</td><td>很难，通常只能是扁平的键值对。</td></tr><tr><td><strong>实习建议</strong></td><td><strong>95%的接口都用这个</strong>。</td><td>只有测“上传头像&#x2F;文件”功能时才用这个。</td></tr></tbody></table><hr><h1 id="断言验证"><a href="#断言验证" class="headerlink" title="断言验证"></a>断言验证</h1><h2 id="检查状态码"><a href="#检查状态码" class="headerlink" title="检查状态码"></a>检查状态码</h2><p>服务器是否正常响应了？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// pm.test 是定义一个测试用例，引号内是测试的名字</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;状态码必须是 200&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// pm.response.to.have.status(200) 是具体的判断逻辑</span><br>    pm.<span class="hljs-property">response</span>.<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image7.png" class="" title="状态码断言"><h2 id="检查返回数据"><a href="#检查返回数据" class="headerlink" title="检查返回数据"></a>检查返回数据</h2><p>光看状态码是不够的。有时候服务器报错也会返回 200（假成功）。需要检查内容是否对得上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 先把返回的 JSON 字符串转换成 JS 对象，方便操作</span><br><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><br><span class="hljs-comment">// 2. 编写断言</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查返回的 ID 是否为 1&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// expect(实际值).to.eql(期望值)</span><br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">id</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br><span class="hljs-comment">// 3. 再加一个：检查 Title 是否存在（不为空）</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查 Title 字段是否存在&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">title</span>).<span class="hljs-property">to</span>.<span class="hljs-property">exist</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image8.png" class="" title="返回数据断言"><h2 id="检查响应时间"><a href="#检查响应时间" class="headerlink" title="检查响应时间"></a>检查响应时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;响应时间必须小于 500ms&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-title function_">expect</span>(pm.<span class="hljs-property">response</span>.<span class="hljs-property">responseTime</span>).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">below</span>(<span class="hljs-number">500</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image9.png" class="" title="响应时间断言"><hr><p>问：“Postman 的断言是用什么语法写的？”</p><p>回答：是基于 JavaScript 的，使用了 Chai Assertion Library (Chai 断言库) 的语法，比如 pm.expect().to.eql()。</p><p>问“你在 Postman 中怎么验证接口返回数据的正确性？”</p><p>回答：使用 <code>pm.test</code> 编写断言脚本，结合 <code>pm.response.json()</code> 解析响应体，使用 Chai 断言库语法（expect…to.eql）来校验关键字段的值和数据类型，同时也会校验 Status Code 和响应时间。</p><hr><h1 id="参数化测试：使用变量、数据驱动"><a href="#参数化测试：使用变量、数据驱动" class="headerlink" title="参数化测试：使用变量、数据驱动"></a><strong>参数化测试</strong>：使用变量、数据驱动</h1><p>三步走：<strong>环境&#x2F;全局变量</strong> -&gt; <strong>接口关联（动态变量）</strong> -&gt; <strong>数据驱动（CSV&#x2F;JSON）</strong>。</p><hr><h2 id="第一步：使用环境变量-Environment-Variables"><a href="#第一步：使用环境变量-Environment-Variables" class="headerlink" title="第一步：使用环境变量 (Environment Variables)"></a>第一步：使用环境变量 (Environment Variables)</h2><p><strong>场景</strong>：每次都在 URL 里写 <code>https://jsonplaceholder.typicode.com</code>。如果明天公司把测试环境换成了 <code>http://192.168.1.100</code>，不可能去修改几十个接口。</p><ol><li><p><strong>创建环境</strong>：</p><ul><li>Postman 右上角，默认应该是 “No Environment”。</li><li>点击右边的“眼睛图标” (Environment quick look) -&gt; <strong>Add</strong>。</li><li>Name 填：<code>Dev Environment</code>。</li><li><strong>Variable</strong>: <code>host</code></li><li><strong>Current Value</strong>: <code>https://jsonplaceholder.typicode.com</code></li><li>点击 <strong>Save</strong>，然后关闭弹窗。</li></ul><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image10.png" class="" title="环境变量设置"></li><li><p><strong>选择环境</strong>：</p><ul><li>在右上角下拉框选择刚才创建的 <code>Dev Environment</code>。</li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>回到GET 请求。</li><li>把 URL 里的 <code>https://jsonplaceholder.typicode.com</code> 删掉，替换为 <code>&#123;&#123;host&#125;&#125;</code>。</li><li>现在的 URL 应该是：<code>&#123;&#123;host&#125;&#125;/posts/1</code>。</li></ul></li><li><p><strong>发送</strong>：点击 Send。如果依然成功返回 200，说明变量引用成功。</p></li></ol><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image11.png" class="" title="引用变量"><hr><h2 id="第二步：接口关联（动态获取变量）"><a href="#第二步：接口关联（动态获取变量）" class="headerlink" title="第二步：接口关联（动态获取变量）"></a>第二步：接口关联（动态获取变量）</h2><ol><li><strong>接口A（POST）</strong> 创建了一个帖子，服务器生成了 <code>id: 101</code>。</li><li><strong>接口B（GET）</strong> 想要查询刚才生成的那个帖子。</li><li>你需要把 A 的<strong>输出</strong>，变成 B 的<strong>输入</strong>。</li></ol><p><strong>操作步骤</strong>：</p><ol><li><p><strong>在 POST 请求中提取数据</strong>：</p><ul><li>打开之前的 POST 请求 (<code>&#123;&#123;host&#125;&#125;/posts</code>)。</li><li>进入 <strong>Tests</strong> 标签页。</li><li>输入以下代码，把服务器返回的 ID 存入环境变量：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 解析返回的 JSON</span><br><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><br><span class="hljs-comment">// 2. 打印一下看看（养成看 Console 的习惯）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器生成的新ID是: &quot;</span> + jsonData.<span class="hljs-property">id</span>);<br><br><span class="hljs-comment">// 3. 把这个 ID 设置为环境变量 &#x27;new_post_id&#x27;</span><br>pm.<span class="hljs-property">environment</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;new_post_id&quot;</span>, jsonData.<span class="hljs-property">id</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>运行 POST</strong>：点击 Send。</p><ul><li><em>验证</em>：点击右上角的“眼睛图标”，你应该能看到 <code>new_post_id</code> 已经出现在列表里了，值通常是 101。</li></ul></li><li><p><strong>在 GET 请求中使用数据</strong>：</p><ul><li>新建或修改一个 GET 请求。</li><li>URL 写成：<code>&#123;&#123;host&#125;&#125;/posts/&#123;&#123;new_post_id&#125;&#125;</code></li><li>点击 Send。</li></ul></li></ol><p><strong>原理</strong>：Postman 会先解析 <code>&#123;&#123;new_post_id&#125;&#125;</code> 为 101，然后再发送请求。</p><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image12.png" class="" title="接口关联"><hr><h2 id="第三步：数据驱动测试-Data-Driven-Testing"><a href="#第三步：数据驱动测试-Data-Driven-Testing" class="headerlink" title="第三步：数据驱动测试 (Data-Driven Testing)"></a>第三步：数据驱动测试 (Data-Driven Testing)</h2><p><strong>场景</strong>：测试“发布帖子”的功能。需要测试以下 3 种情况：</p><ol><li>标题正常，内容正常。</li><li>标题为空（预期报错或处理）。</li><li>标题超长（预期截断或报错）。</li></ol><p>不需要写 3 个请求，只需要写 <strong>1 个请求 + 1 个数据文件</strong>。</p><ol><li>准备数据文件 (CSV)</li></ol><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title_case,body_case,user_id<br><span class="hljs-keyword">Test </span>Normal,This is normal content,1<br><span class="hljs-keyword">Test </span>Empty,,1<br><span class="hljs-keyword">Test </span>Special,Special #$% Characters,2<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 POST 请求为“参数化”</li></ol><p>回到你的 POST 请求，修改 Body 中的数据，把写死的内容改成变量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;title_case&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;body_case&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span>user_id<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>*(注意：JSON 中的字符串需要引号，数字不需要，但 </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;<span class="hljs-meta">&#123;...&#125;</span>&#125;<br></code></pre></td></tr></table></figure><p> 只是文本替换，所以如果是字符串类型，外面要保留引号)</p><ol start="3"><li>修改断言 (Tests)</li></ol><p>因为数据变了，断言也要动态化。修改 Tests 脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><span class="hljs-comment">// pm.iterationData.get(&quot;csv表头&quot;) 用来获取当前这行 CSV 的数据</span><br><span class="hljs-keyword">var</span> expectedTitle = pm.<span class="hljs-property">iterationData</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;title_case&quot;</span>);<br><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查标题是否匹配&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 验证返回的 title 是否等于 CSV 里写的 title</span><br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">title</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(expectedTitle);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>4. 启动 Collection Runner (集合运行器)</strong></p><ol><li>保存好请求，确保它在某个 Collection（集合）里。</li><li>点击左侧集合名称旁边的 <code>...</code> -&gt; <strong>Run collection</strong>。</li><li><strong>关键步骤</strong>：<ul><li>在 <strong>Data</strong> 选项处，点击 <strong>Select File</strong>，上传刚才的 <code>test_data.csv</code>。</li><li>看到 <strong>Iterations</strong> 自动变成了 3 (因为它识别出了有3行数据)。</li><li>点击 <strong>Preview</strong> 确认数据读取无误。</li></ul></li><li>点击 <strong>Run …</strong>。</li></ol><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image13.png" class="" title="集合运行"><hr><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>测开工程师需要把这些测试<strong>集成到代码流水线（CI&#x2F;CD）中。服务器上通常没有图形界面（GUI），所以我们需要学会命令行运行 Postman</strong>。要学习的工具叫 <strong>Newman</strong>。</p><h3 id="命令行运行-Newman-——-自动化集成的基础"><a href="#命令行运行-Newman-——-自动化集成的基础" class="headerlink" title="命令行运行 (Newman) —— 自动化集成的基础"></a>命令行运行 (Newman) —— 自动化集成的基础</h3><h4 id="第一步：准备“原料”-导出-JSON"><a href="#第一步：准备“原料”-导出-JSON" class="headerlink" title="第一步：准备“原料” (导出 JSON)"></a>第一步：准备“原料” (导出 JSON)</h4><p>要在命令行跑测试，需要先把 Postman 里的东西“搬”出来。需要导出两个文件：</p><ol><li><strong>导出集合 (Collection)</strong>：<ul><li>点击左侧的 <code>...</code>。</li><li>选择 <strong>Export</strong>。</li><li>选择 <strong>Collection v2.1</strong> (默认推荐)，点击 <strong>Export</strong>。</li><li>保存为 <code>my_collection.json</code>。</li></ul></li><li><strong>导出环境 (Environment)</strong> (如果你用了环境变量的话)：<ul><li>点击左侧边栏的 <strong>Environments</strong>。</li><li>点击你的 <code>Dev Environment</code> 旁边的 <code>...</code> -&gt; <strong>Export</strong>。</li><li>保存为 <code>dev_env.json</code>。</li></ul></li><li><strong>准备数据</strong>：<ul><li>把你刚才的 <code>test.csv</code> 也放在同一个文件夹里。</li></ul></li></ol><p>现在你的文件夹里应该有三个文件：<code>my_collection.json</code>, <code>dev_env.json</code>, <code>test.csv</code>。</p><h4 id="第二步：安装-Newman"><a href="#第二步：安装-Newman" class="headerlink" title="第二步：安装 Newman"></a>第二步：安装 Newman</h4><p>Newman 是 Postman 的命令行引擎，它是基于 Node.js 的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g newman<br></code></pre></td></tr></table></figure><p><em>(如果安装成功，输入 <code>newman -v</code> 应该能看到版本号)</em></p><h4 id="第三步：在命令行运行测试"><a href="#第三步：在命令行运行测试" class="headerlink" title="第三步：在命令行运行测试"></a>第三步：在命令行运行测试</h4><p>这是最帅的一步。假设你现在在那个存放了三个文件的目录下，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">newman run my_collection.json -e dev_env.json -d test.csv<br></code></pre></td></tr></table></figure><p><strong>命令解析</strong>：</p><ul><li><code>run</code>: 运行指令。</li><li><code>my_collection.json</code>: 指定要跑哪个集合。</li><li><code>-e</code>: 指定环境文件 (Environment)。</li><li><code>-d</code>: 指定数据文件 (Data)。</li></ul><p>观察结果：在黑色的终端窗口里看到酷炫的 ASCII 表格，显示每一条请求的执行结果、断言通过情况、以及最终的统计报表。</p><p>问：“你如何将接口测试集成到 Jenkins 或 GitLab CI 中？”</p><p>回答：</p><blockquote><p>“先在 Postman 本地调试好 Collection 和断言，然后导出为 JSON 文件。在 CI&#x2F;CD 流水线中，使用 <strong>Newman</strong> 命令行工具来运行这些脚本，并生成 HTML 或 JUnit 格式的测试报告（使用 <code>-r html</code> 参数），如果测试失败，流水线就会自动报错阻断。”</p></blockquote><hr><h3 id="第五阶段：代码生成-Code-Snippet-——-偷懒神器"><a href="#第五阶段：代码生成-Code-Snippet-——-偷懒神器" class="headerlink" title="第五阶段：代码生成 (Code Snippet) —— 偷懒神器"></a>第五阶段：代码生成 (Code Snippet) —— 偷懒神器</h3><p>作为测开，经常需要写 Python 脚本来做更复杂的逻辑（比如造数据、清洗数据库）。如果已经在 Postman 里调通了一个复杂的接口（Header 巨多、Body 巨复杂），不想手动去写 Python <code>requests</code> 代码，怎么办？</p><ol><li>回到 Postman，点击你配置好的 <strong>POST 请求</strong>。</li><li>在右侧边栏（就是刚才我们找 Tests Snippets 的那个地方），上面有一个图标是 <code>&lt; / &gt;</code> (Code)。点击它。</li><li>你会看到一个下拉菜单，默认可能是 <code>cURL</code>。</li><li>下拉选择 <strong>Python - Requests</strong>。</li></ol><p>Postman 自动帮你生成了完整的 Python 代码！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br>url = <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span><br><br>payload = json.dumps(&#123;<br>  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;title_case&#125;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;body_case&#125;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;userId&quot;</span>: <span class="hljs-number">1</span><br>&#125;)<br>headers = &#123;<br>  <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>, url, headers=headers, data=payload)<br><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>可以直接复制这段代码到 PyCharm&#x2F;VS Code 里去用。支持 Java (OkHttp&#x2F;Unirest)、Go 等各种语言。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口测试</tag>
      
      <tag>自动化测试</tag>
      
      <tag>请求响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django基础学习</title>
    <link href="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Django入门"><a href="#Django入门" class="headerlink" title="Django入门"></a>Django入门</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架，其提供了全栈开发所需的工具，包括数据库 ORM、模板引擎、路由系统、用户认证等，大幅减少重复代码。Django 遵循 MVC（Model-View-Controller）架构，但在 Django 中更常被称为 MTV（Model-Template-View）</p><img src="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="MVT"><h3 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h3><ul><li><strong>Model (模型)</strong>：处理与数据库的交互，定义数据的结构和业务逻辑。</li><li><strong>View (视图)</strong>：负责数据展示，生成用户看到的 HTML 页面。</li><li><strong>Controller (控制器)</strong>：接收用户请求，调用 Model 处理数据，并将结果传递给 View 渲染页面。</li></ul><p><strong>流程：</strong></p><ol><li>用户发送请求到 Controller。</li><li>Controller 处理逻辑，调用 Model 获取数据。</li><li>Controller 将数据传递给 View。</li><li>View 渲染并返回 HTML 页面给用户。</li></ol><h3 id="MVT-Model-Template-View-——-Django-的实现方式"><a href="#MVT-Model-Template-View-——-Django-的实现方式" class="headerlink" title="MVT (Model-Template-View) —— Django 的实现方式"></a>MVT (Model-Template-View) —— Django 的实现方式</h3><p>Django 中采用了 <strong>MVT</strong> 设计模式，类似于 MVC，但有一些区别：</p><ul><li><strong>Model (模型)</strong>：与数据库交互，处理数据的创建、读取、更新、删除。</li><li><strong>Template (模板)</strong>：负责页面渲染，生成最终的 HTML 内容。</li><li><strong>View (视图)</strong>：Django 的 View 更偏向于控制器的角色，接收请求并决定使用哪个模板和数据。</li></ul><p><strong>流程：</strong></p><ol><li>用户访问 URL，请求被 Django 的 <code>urls.py</code> 映射到相应的 View。</li><li>View 处理业务逻辑，调用 Model 获取数据。</li><li>View 将数据传递给 Template。</li><li>Template 渲染 HTML，最终返回给用户。</li></ol><h2 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h2><table><thead><tr><th align="left">功能</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Admin 后台</strong></td><td align="left">自动生成管理界面，无需手动编写 CRUD 逻辑。</td></tr><tr><td align="left"><strong>ORM</strong></td><td align="left">用 Python 类操作数据库，无需写 SQL。</td></tr><tr><td align="left"><strong>表单处理</strong></td><td align="left">内置表单验证，防止 CSRF 攻击。</td></tr><tr><td align="left"><strong>用户认证</strong></td><td align="left">提供登录、注册、权限管理（<code>django.contrib.auth</code>）。</td></tr><tr><td align="left"><strong>路由系统</strong></td><td align="left">URL 映射灵活，支持正则表达式。</td></tr><tr><td align="left"><strong>缓存机制</strong></td><td align="left">支持 Memcached、Redis 等后端。</td></tr></tbody></table><hr><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><ul><li><strong>快速开发</strong>:Django 提供了大量内置功能，如认证、管理后台、表单处理等，让开发者专注于业务逻辑，而非底层实现。</li><li><strong>自动化管理后台</strong>:只需简单的模型定义，即可生成强大的后台管理界面，支持增删改查。</li><li><strong>ORM 数据库映射</strong>:Django 内置 ORM (Object-Relational Mapping)，可以让开发者使用 Python 类与数据库交互，无需编写 SQL。</li><li><strong>强大的 URL 路由</strong>:使用正则表达式灵活定义 URL，轻松实现页面路由。</li><li><strong>模板引擎</strong>:内置强大的模板系统，支持逻辑判断、循环处理，方便渲染 HTML 页面。</li><li><strong>国际化支持</strong>:Django 支持多语言国际化，非常适合全球化应用。</li><li><strong>高安全性</strong>:内置多种安全保护措施，如防止 SQL 注入、XSS 攻击、CSRF 攻击等。</li><li><strong>丰富的社区与扩展</strong>:大量开源的第三方库，如 Django REST framework、Django CMS 等，快速扩展功能。</li><li><strong>FastAPI</strong>: 通常用装饰器 <code>@app.get(&quot;/items&quot;)</code> 直接在函数头上定义路由。</li><li><strong>Django</strong>: 路由（urls.py）和逻辑（views.py）是分离的。这在大型项目中管理几百个接口时会更清晰，但写起来稍微繁琐一点。</li></ul><hr><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="第一阶段：环境搭建"><a href="#第一阶段：环境搭建" class="headerlink" title="第一阶段：环境搭建"></a>第一阶段：环境搭建</h3><p><strong>目标</strong>：跑通第一个 Django 项目，理解目录结构。</p><h4 id="1-安装-Django"><a href="#1-安装-Django" class="headerlink" title="1. 安装 Django"></a>1. 安装 Django</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install django<br></code></pre></td></tr></table></figure><h4 id="2-创建项目-Project"><a href="#2-创建项目-Project" class="headerlink" title="2. 创建项目 (Project)"></a>2. 创建项目 (Project)</h4><p>Django 的层级是：一个项目 (Project) 包含多个应用 (App)。先在终端运行以下命令创建一个名为 TestPlatform 的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">django-admin startproject startdjango<br><span class="hljs-built_in">cd</span> startdjango<br></code></pre></td></tr></table></figure><h4 id="3-认识目录结构"><a href="#3-认识目录结构" class="headerlink" title="3. 认识目录结构"></a>3. 认识目录结构</h4><ul><li><code>manage.py</code>: 项目的管理脚本，以后会经常用它来运行服务、创建数据库表（迁移）等。</li><li><code>startdjango/</code> :<ul><li><code>settings.py</code>: <strong>核心配置文件</strong>。数据库配置、注册 App、中间件都在这。（问：如何配置多环境？）</li><li><code>urls.py</code>: <strong>路由入口</strong>。相当于“总台”，决定哪个 URL 由哪个函数处理。</li><li><code>wsgi.py</code> &#x2F; <code>asgi.py</code>: 部署上线时用的接口文件。</li></ul></li></ul><h4 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4. 启动服务"></a>4. 启动服务</h4><p>在 <code>startdjango</code> 根目录下运行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> runserver<br></code></pre></td></tr></table></figure><p>打开浏览器访问 <code>http://127.0.0.1:8000/</code>。看到一支小火箭🚀就是跑通了！</p><hr><h3 id="第二阶段：创建第一个-App-与-视图"><a href="#第二阶段：创建第一个-App-与-视图" class="headerlink" title="第二阶段：创建第一个 App 与 视图"></a>第二阶段：创建第一个 App 与 视图</h3><p><strong>目标</strong>：理解 Django 的 MVT (Model-View-Template) 模式中的 V (View) 和 URL 映射。Django 提倡将功能模块化。比如创建一个 <code>book</code> 的app。</p><h4 id="1-创建-App"><a href="#1-创建-App" class="headerlink" title="1. 创建 App"></a>1. 创建 App</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py startapp book<br></code></pre></td></tr></table></figure><p>会发现多了一个 book 文件夹。</p><p>重要步骤：去 startdjango&#x2F;settings.py，找到 INSTALLED_APPS 列表，把 ‘book’, 加进去。如果不加，Django 根本不知道这个 App 的存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TestPlatform/settings.py</span><br>INSTALLED_APPS = [<br>    ...<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-comment"># 新增这一行</span><br>]<br></code></pre></td></tr></table></figure><h4 id="2-写一个简单的视图-View"><a href="#2-写一个简单的视图-View" class="headerlink" title="2. 写一个简单的视图 (View)"></a>2. 写一个简单的视图 (View)</h4><p>视图函数负责处理请求并返回响应。打开 book&#x2F;views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-comment"># 查询参数 示例:  /book?id=5</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">book_detail_query_string</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># request.GET 获取查询参数的字典 &#123;&#x27;id&#x27;: &#x27;5&#x27;&#125;</span><br>    book_id = request.GET.get(<span class="hljs-string">&quot;id&quot;</span>)<br>    book_name = request.GET.get(<span class="hljs-string">&quot;name&quot;</span>)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;你要查找的图书是: <span class="hljs-subst">&#123;book_id&#125;</span>, 图书名称是: <span class="hljs-subst">&#123;book_name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="3-配置-URL-路由"><a href="#3-配置-URL-路由" class="headerlink" title="3. 配置 URL 路由"></a>3. 配置 URL 路由</h4><p>我们需要告诉 Django，访问什么网址时触发上面这个函数。</p><p><strong>第一步</strong>：在 <code>book</code> 目录下新建一个 <code>urls.py</code>（默认没有，需手动建），写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># case_manager/urls.py</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    <span class="hljs-comment"># 访问 /book/ 时，调用 views.index</span><br>    path(<span class="hljs-string">&quot;&quot;</span>, views.book_detail_query_string, name=<span class="hljs-string">&quot;book_detail_query_string&quot;</span>), <br>]<br></code></pre></td></tr></table></figure><p><strong>第二步</strong>：将 App 的路由注册到项目总路由 <code>startdjango/urls.py</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include <span class="hljs-comment"># 记得导入 include</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    <span class="hljs-comment"># 只要是 book/ 开头的路径，都分发给 book 去处理</span><br>    path(<span class="hljs-string">&#x27;book/&#x27;</span>, include(<span class="hljs-string">&#x27;case_manager.urls&#x27;</span>)), <br>]<br></code></pre></td></tr></table></figure><h4 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> runserver<br></code></pre></td></tr></table></figure><p>访问  <a href="http://127.0.0.1:8000/book?id=3&name=123">http://127.0.0.1:8000/book?id=3&amp;name=123</a> 会显示“你要查找的图书是: 3, 图书名称是: 123”</p><hr><h2 id="Path函数"><a href="#Path函数" class="headerlink" title="Path函数"></a>Path函数</h2><p>在 Django 中，<code>path()</code> 函数用于定义 URL 模式。</p><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. <strong>基本语法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;route/&#x27;</span>, views.view_function, name=<span class="hljs-string">&#x27;view-name&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><h2 id="2-参数详解"><a href="#2-参数详解" class="headerlink" title="2. 参数详解"></a>2. <strong>参数详解</strong></h2><h3 id="第一个参数：路由字符串"><a href="#第一个参数：路由字符串" class="headerlink" title="第一个参数：路由字符串"></a><strong>第一个参数：路由字符串</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 指定app命名空间</span><br>app_name = <span class="hljs-string">&quot;book&quot;</span><br><br>urlpatterns = [<br>    <span class="hljs-comment"># /book?id=5</span><br>    path(<span class="hljs-string">&quot;&quot;</span>, views.book_detail_query_string, name=<span class="hljs-string">&quot;book_detail_query_string&quot;</span>),<br>    path(<span class="hljs-string">&quot;&lt;int:book_id&gt;/&quot;</span>, views.book_datail_path, name=<span class="hljs-string">&quot;book_datail_path&quot;</span>),<br>    path(<span class="hljs-string">&quot;str/&lt;str:book_id&gt;/&quot;</span>, views.book_str, name=<span class="hljs-string">&quot;book_str&quot;</span>),<br>    path(<span class="hljs-string">&quot;slug/&lt;slug:book_id&gt;/&quot;</span>, views.book_slug, name=<span class="hljs-string">&quot;book_slug&quot;</span>),<br>    path(<span class="hljs-string">&quot;path/&lt;path:book_id&gt;/&quot;</span>, views.book_path, name=<span class="hljs-string">&quot;book_path&quot;</span>),<br>]<br></code></pre></td></tr></table></figure><h3 id="第二个参数：视图"><a href="#第二个参数：视图" class="headerlink" title="第二个参数：视图"></a><strong>第二个参数：视图</strong></h3><p>可以为一个视图函数或者是类视图.as_view()或者是django.urls.include()函数 的返回值</p><h3 id="第三个参数：kwargs（可选）"><a href="#第三个参数：kwargs（可选）" class="headerlink" title="第三个参数：kwargs（可选）"></a><strong>第三个参数：kwargs（可选）</strong></h3><p>向视图传递额外的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;about/&#x27;</span>, views.about, &#123;<span class="hljs-string">&#x27;template_name&#x27;</span>: <span class="hljs-string">&#x27;custom_about.html&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="第四个参数：name（可选）"><a href="#第四个参数：name（可选）" class="headerlink" title="第四个参数：name（可选）"></a><strong>第四个参数：name（可选）</strong></h3><p>这个参数是给这个url取个名字的，这在项目比较大，url比较多的时候用处很大。对URL 命名，用于反向解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;articles/&lt;int:id&gt;/&#x27;</span>, views.article_detail, name=<span class="hljs-string">&#x27;article-detail&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在模板中使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;article-detail&#x27; id=1 %&#125;&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-路径转换器类型"><a href="#3-路径转换器类型" class="headerlink" title="3. 路径转换器类型"></a>3. <strong>路径转换器类型</strong></h2><p>Django 内置了多种类型转换器：</p><table><thead><tr><th>转换器</th><th>说明</th><th>示例</th><th>匹配示例</th></tr></thead><tbody><tr><td><code>str</code></td><td>匹配非空字符串（不包括 <code>/</code>）</td><td><code>&lt;str:name&gt;</code></td><td><code>john</code>, <code>article-1</code></td></tr><tr><td><code>int</code></td><td>匹配正整数</td><td><code>&lt;int:id&gt;</code></td><td><code>123</code>, <code>0</code></td></tr><tr><td><code>slug</code></td><td>匹配字母、数字、连字符、下划线</td><td><code>&lt;slug:post_slug&gt;</code></td><td><code>my-post-2023</code></td></tr><tr><td><code>uuid</code></td><td>匹配 UUID 格式字符串</td><td><code>&lt;uuid:uuid&gt;</code></td><td><code>123e4567-e89b-12d3...</code></td></tr><tr><td><code>path</code></td><td>匹配包含 <code>/</code> 的字符串</td><td><code>&lt;path:filepath&gt;</code></td><td><code>docs/user/guide.pdf</code></td></tr></tbody></table><hr><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>现在的主流开发方式倾向于“前后端分离”（Django 只写 API，前端用 Vue&#x2F;React），但**Django 模版（Templates）**是其基础</p><p>目前市面上有非常多的模板系统，其中最知名最好用的就是DTL和Jinja2。 DTL 是 Django Template Language 三个单词的缩写，也就是Django自带的模板语言。当然也可以配置Django支持Jinja2等其他模板引擎，但是作为Django内置的模板语言，和Django可以达到无缝衔接而不会产生一些不兼容的情况</p><h2 id="DTL概念"><a href="#DTL概念" class="headerlink" title="DTL概念"></a>DTL概念</h2><p>DTL模板是一种带有特殊语法的HTML文件，这个HTML文件可以被Django编译，可以传递参数进去，实 现数据动态化。在编译完成后，生成一个普通的HTML文件，然后发送给客户端。</p><p>直接将模板渲染成字符串和包装成 HttpResponse 对象一步到位完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;index.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>问：</p><blockquote><p><strong>“Django 的模版渲染是在前端执行还是后端执行的？”</strong></p></blockquote><p>是在<strong>后端</strong>执行的。 Django 在服务器端把 HTML 里的 <code>&#123;&#123; &#125;&#125;</code> 替换成真实数据，生成纯静态的 HTML 字符串，然后发给浏览器。浏览器收到的只是普通的 HTML，看不到任何 <code>&#123;% for %&#125;</code> 代码。这也就是为什么叫“服务端渲染 (SSR)”。</p><h2 id="模版查找路径位置"><a href="#模版查找路径位置" class="headerlink" title="模版查找路径位置"></a>模版查找路径位置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">&quot;BACKEND&quot;</span>: <span class="hljs-string">&quot;django.template.backends.django.DjangoTemplates&quot;</span>,<br>        <span class="hljs-string">&quot;DIRS&quot;</span>: [<br>            <span class="hljs-comment"># 项目级模板目录</span><br>            os.path.join(BASE_DIR, <span class="hljs-string">&#x27;templates&#x27;</span>),<br>        ],<br>        <span class="hljs-string">&quot;APP_DIRS&quot;</span>: <span class="hljs-literal">True</span>, <span class="hljs-comment"># 必须为 True，才能查找应用内的templates目录</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;context_processors&quot;</span>: [<br>                <span class="hljs-string">&quot;django.template.context_processors.request&quot;</span>,<br>                <span class="hljs-string">&quot;django.contrib.auth.context_processors.auth&quot;</span>,<br>                <span class="hljs-string">&quot;django.contrib.messages.context_processors.messages&quot;</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>]<br></code></pre></td></tr></table></figure><p>查找顺序：比如代码 render(‘list.html’) 。先会在 DIRS 这个列表中依次查找路径下有没有这个模版，如果有就返回。如果DIRS 列表中所有的路径都没有找到，那么会先检查当前这个视图所处的app是否已经安装，如果已经安装了，那么就先在当前这个 app 下的 templates 文件夹中查找模板，如果没有找到，那么会在其他已经安装了的 app 中查找。如果所有路径下都没有找到，那么会抛出一个 TemplateDoesNotExist 的异常。</p><h2 id="DTL语法"><a href="#DTL语法" class="headerlink" title="DTL语法"></a>DTL语法</h2>Django 的模版语言（DTL）核心就两点：- **`{{ 变量 }}`**：挖坑，填值。- **`{% 逻辑 %}`**：写代码逻辑，比如循环 `for` 或判断 `if`。<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># 1.普通变量</span><br>    username = <span class="hljs-string">&quot;小黎&quot;</span><br>    <span class="hljs-comment"># 2.字典</span><br>    book = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;施耐庵&quot;</span>&#125;<br>    <span class="hljs-comment"># 3.列表</span><br>    books = [&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;施耐庵&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;罗贯中&quot;</span>&#125;]<br>    <span class="hljs-comment"># 4.对象</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>            <span class="hljs-variable language_">self</span>.name = name<br>            <span class="hljs-variable language_">self</span>.age = age<br>    <span class="hljs-comment"># 传递给模版</span><br>    context = &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: username,<br>        <span class="hljs-string">&#x27;book&#x27;</span>: book,<br>        <span class="hljs-string">&#x27;books&#x27;</span>: books,<br>        <span class="hljs-string">&#x27;person&#x27;</span>: person(<span class="hljs-string">&quot;小黎&quot;</span>, <span class="hljs-number">23</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;info.html&#x27;</span>, context=context)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;book.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;book.author&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;books.0&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;books.1.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;person.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;person.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="DTL模版变量"><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h4 id="1-if-elif-else"><a href="#1-if-elif-else" class="headerlink" title="1. if &#x2F; elif &#x2F; else"></a>1. <strong><code>if</code> &#x2F; <code>elif</code> &#x2F; <code>else</code></strong></h4><p>if标签相当于 Python 中的标签符号（ if 语句，有 elif 和 else 相对应，但是所有的标签都需要）进行包裹。if标签中可以使用 &#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、in、not in、is、is  not 等判断运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">if_view</span>(<span class="hljs-params">request</span>):<br>    age = <span class="hljs-number">23</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;if.html&#x27;</span>, context=&#123;<span class="hljs-string">&#x27;age&#x27;</span>: age&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> age &gt; 18 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您已满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">elif</span></span> age == 18 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您刚满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">else</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您未满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a>2. <strong>for 循环</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 基本循环 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; item.name &#125;&#125;</span><span class="language-xml">: </span><span class="hljs-template-variable">&#123;&#123; item.price &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 循环变量 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.counter &#125;&#125;</span><span class="language-xml">        </span><span class="hljs-comment">&#123;# 从1开始计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.counter0 &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 从0开始计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.revcounter &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 倒序计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.revcounter0 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 倒序从0开始 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.first &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 是否第一次循环 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.last &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 是否最后一次循环 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.parentloop &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 父级循环对象 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 空循环处理 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">empty</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>No items available.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 字典循环 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> key, value <span class="hljs-keyword">in</span> data.items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; key &#125;&#125;</span><span class="language-xml">: </span><span class="hljs-template-variable">&#123;&#123; value &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-with-创建局部变量"><a href="#3-with-创建局部变量" class="headerlink" title="3. &#96;with 创建局部变量"></a>3. <strong>&#96;with 创建局部变量</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> total=products|<span class="hljs-name">length</span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Total products: </span><span class="hljs-template-variable">&#123;&#123; total &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> alpha=1 beta=2 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sum: </span><span class="hljs-template-variable">&#123;&#123; alpha|<span class="hljs-name">add</span>:beta &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-url-反向解析-URL"><a href="#4-url-反向解析-URL" class="headerlink" title="4.url 反向解析 URL"></a>4.<strong><code>url</code> 反向解析 URL</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 不带参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;home&#x27; %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 带位置参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;article-detail&#x27; 2023 &#x27;django-tutorial&#x27; %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Article<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 带关键字参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;profile&#x27; username=user.username %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Profile<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在变量中使用 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;api-endpoint&#x27; <span class="hljs-keyword">as</span> api_url %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; api_url &#125;&#125;</span><span class="language-xml">&quot;;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2>在模版中，有时候需要对一些数据进行处理以后才能使用。在模版中，则是通过过滤器来实现的。过滤器使用的是|来使用。比如使用 add 过滤器<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-variable">&#123;&#123;  value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;2&quot;</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure>过滤器用于在模板中修改变量的显示格式，语法为 `{{ variable|filter:argument }}`<h3 id="1-文本格式化"><a href="#1-文本格式化" class="headerlink" title="1. 文本格式化"></a>1. <strong>文本格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为小写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;HELLO WORLD&quot;|<span class="hljs-name">lower</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# hello world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">upper</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# HELLO WORLD #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 首字母大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">capfirst</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Hello world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 每个单词首字母大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# Hello World #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-长度和截断"><a href="#2-长度和截断" class="headerlink" title="2. 长度和截断"></a>2. <strong>长度和截断</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 获取长度 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello&quot;|<span class="hljs-name">length</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 5 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">length</span> &#125;&#125;</span><span class="language-xml">                  </span><span class="hljs-comment">&#123;# 列表长度 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 字符截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long text&quot;|<span class="hljs-name">truncatechars</span>:10 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# This is... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long text&quot;|<span class="hljs-name">truncatechars</span>:15 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# This is a lon... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 单词截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long sentence to demonstrate truncation&quot;|<span class="hljs-name">truncatewords</span>:5 &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-comment">&#123;# This is a long sentence... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 保留HTML标签的截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_content|<span class="hljs-name">truncatewords</span>_html:20 &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# 安全截断HTML内容 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-空格和换行处理"><a href="#3-空格和换行处理" class="headerlink" title="3. 空格和换行处理"></a>3. <strong>空格和换行处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除空白字符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;  hello  world  &quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot; &quot;</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# helloworld #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello\tworld\n&quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot;\t&quot;</span> &#125;&#125;</span><span class="language-xml">            </span><span class="hljs-comment">&#123;# helloworld\n #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除指定字符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;Hello-World&quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot;-&quot;</span> &#125;&#125;</span><span class="language-xml">                </span><span class="hljs-comment">&#123;# HelloWorld #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 换行符转换 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;Line1\nLine2\r\nLine3&quot;|<span class="hljs-name">linebreaks</span> &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# &lt;p&gt;Line1&lt;br&gt;Line2&lt;br&gt;Line3&lt;/p&gt; #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; text|<span class="hljs-name">linebreaksbr</span> &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 只转换为&lt;br&gt;标签 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-数字格式化"><a href="#4-数字格式化" class="headerlink" title="4. 数字格式化"></a>4. <strong>数字格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 四舍五入 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span>:2 &#125;&#125;</span><span class="language-xml">        </span><span class="hljs-comment">&#123;# 3.14 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.1|<span class="hljs-name">floatformat</span>:<span class="hljs-string">&quot;-2&quot;</span> &#125;&#125;</span><span class="language-xml">         </span><span class="hljs-comment">&#123;# 3.1 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span>:<span class="hljs-string">&quot;0&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 千位分隔符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1000000|intcomma &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 1,000,000 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1234.56|intcomma &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 1,234.56 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 文件大小格式化（需要humanize） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1024|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 1.0 KB #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1048576|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 1.0 MB #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 123456789|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 117.7 MB #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-数学运算"><a href="#5-数学运算" class="headerlink" title="5. 数学运算"></a>5. <strong>数学运算</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 加法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;5&quot;</span> &#125;&#125;</span><span class="language-xml">                </span><span class="hljs-comment">&#123;# value + 5 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;10&quot;|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;5&quot;</span> &#125;&#125;</span><span class="language-xml">                 </span><span class="hljs-comment">&#123;# 15 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list1|<span class="hljs-name">add</span>:list2 &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# 合并两个列表 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 减法（需要自定义或使用计算） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;-5&quot;</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 间接实现减法 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 乘法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> value 1 100 %&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# value * 100 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> 5 1 100 %&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 500 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 除法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> 100 5 1 %&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 20 (100 ÷ 5 × 1) #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> value max_value 100 <span class="hljs-keyword">as</span> percentage %&#125;</span><span class="language-xml"></span><br><span class="language-xml">                                   </span><span class="hljs-comment">&#123;# 计算百分比 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 绝对值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; -5|abs &#125;&#125;</span><span class="language-xml">                       </span><span class="hljs-comment">&#123;# 需要自定义过滤器 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-日期格式化"><a href="#6-日期格式化" class="headerlink" title="6. 日期格式化"></a>6. <strong>日期格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 基本格式化 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;Y-m-d&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2023-12-15 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;d/m/Y&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 15/12/2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 常用格式 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;Y年m月d日&quot;</span> &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# 2023年12月15日 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;F j, Y&quot;</span> &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# December 15, 2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;D d M Y&quot;</span> &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# Fri 15 Dec 2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 时间格式化 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;H:i&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 14:30 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;H:i:s&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 14:30:45 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;g:i A&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2:30 PM #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7-时间相关处理"><a href="#7-时间相关处理" class="headerlink" title="7. 时间相关处理"></a>7. <strong>时间相关处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 相对时间（需要humanize） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; post.pub_date|naturaltime &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2 hours ago #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|naturalday &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# today, yesterday #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 时间差 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">timesince</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 2 days, 3 hours #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">timesince</span>:other_datetime &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 到某时间的时间差 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; deadline|<span class="hljs-name">timeuntil</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 3 days, 2 hours #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="8-列表操作"><a href="#8-列表操作" class="headerlink" title="8. 列表操作"></a>8. <strong>列表操作</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 获取第一个/最后一个元素 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">first</span> &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# 第一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">last</span> &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 最后一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 随机排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">random</span> &#125;&#125;</span><span class="language-xml">                  </span><span class="hljs-comment">&#123;# 随机一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|shuffle &#125;&#125;</span><span class="language-xml">                 </span><span class="hljs-comment">&#123;# 返回None，实际使用需自定义 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 连接列表 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">join</span>:<span class="hljs-string">&quot;, &quot;</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# item1, item2, item3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">join</span>:<span class="hljs-string">&quot; • &quot;</span> &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# item1 • item2 • item3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 切片 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">slice</span>:<span class="hljs-string">&quot;:5&quot;</span> &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# 前5个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">slice</span>:<span class="hljs-string">&quot;1:3&quot;</span> &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 第2到第3个元素 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="9-排序和唯一"><a href="#9-排序和唯一" class="headerlink" title="9. 排序和唯一"></a>9. <strong>排序和唯一</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 字典列表按字段排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsort</span>:<span class="hljs-string">&quot;name&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 按name排序 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsort</span>:<span class="hljs-string">&quot;age&quot;</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 按age排序 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 按字段降序排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsortreversed</span>:<span class="hljs-string">&quot;age&quot;</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 唯一值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; duplicate_list|unordered_list &#125;&#125;</span><span class="language-xml"> </span><span class="hljs-comment">&#123;# 转为无序列表HTML #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; duplicate_list|unique &#125;&#125;</span><span class="language-xml">         </span><span class="hljs-comment">&#123;# 需要自定义过滤器 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="10-布尔值处理"><a href="#10-布尔值处理" class="headerlink" title="10. 布尔值处理"></a>10. <strong>布尔值处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 默认值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;N/A&quot;</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 如果value为空或不存在 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&quot;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty string&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# Empty string #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Nothing&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Nothing #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 默认值为空字符串 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">default</span>_if_none:&quot;--&quot; &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# 仅当None时替换 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 布尔值显示 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; True|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 是 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; False|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 否 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 可能 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;yup,nope&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 自定义选项 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="11-空值检查"><a href="#11-空值检查" class="headerlink" title="11. 空值检查"></a>11. <strong>空值检查</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 检查是否为空 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&quot;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty&quot;</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# Empty #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; []|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty list&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# Empty list #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &#123;&#125;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty dict&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# Empty dict #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Nothing&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Nothing #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="12-HTML处理"><a href="#12-HTML处理" class="headerlink" title="12. HTML处理"></a>12. <strong>HTML处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转义HTML --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;|<span class="hljs-name">escape</span> &#125;&#125;</span><span class="language-xml"> </span><br><span class="language-xml"></span><span class="hljs-comment">&#123;# &amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;/script&amp;gt; #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 简写形式 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_input|force_escape &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 强制转义 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 标记为安全HTML --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_string|<span class="hljs-name">safe</span> &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 谨慎使用！ #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除HTML标签 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&lt;p&gt;Hello&lt;/p&gt;&quot;|<span class="hljs-name">striptags</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# Hello #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_content|<span class="hljs-name">striptags</span>|<span class="hljs-name">truncatewords</span>:30 &#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="13-URL处理"><a href="#13-URL处理" class="headerlink" title="13. URL处理"></a>13. <strong>URL处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- URL编码 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">urlencode</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# hello%20world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; query_string|<span class="hljs-name">urlencode</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# name=John&amp;age=30 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 转义URL --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; path|<span class="hljs-name">iriencode</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 国际化URL编码 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="14-JSON格式"><a href="#14-JSON格式" class="headerlink" title="14. JSON格式"></a>14. <strong>JSON格式</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为JSON --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; python_dict|json_script:&quot;data&quot; &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# 安全输出JSON #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在JavaScript中使用 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; data|json_script:&quot;data-attr&quot; &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;data-attr&#x27;</span>).<span class="hljs-property">textContent</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="15-复数和序数"><a href="#15-复数和序数" class="headerlink" title="15. 复数和序数"></a>15. <strong>复数和序数</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 序数 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1|apnumber &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# one #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3|apnumber &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# three #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 数字转为序数词 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 1st #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 2|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 2nd #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 3rd #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 11|ordinal &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# 11th #&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="模版结构"><a href="#模版结构" class="headerlink" title="模版结构"></a>模版结构</h2><table><thead><tr><th>特性</th><th><code>extend</code></th><th><code>include</code></th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>模板继承，定义骨架</td><td>模块化重用，嵌入片段</td></tr><tr><td><strong>关系</strong></td><td>父子关系</td><td>包含关系</td></tr><tr><td><strong>位置</strong></td><td>必须是模板第一个标签</td><td>可在任意位置</td></tr><tr><td><strong>使用频率</strong></td><td>每个页面通常只继承一次</td><td>一个页面可包含多次</td></tr><tr><td><strong>修改内容</strong></td><td>通过 block 替换</td><td>直接嵌入整个模板</td></tr></tbody></table><h3 id="1、extend-模板继承"><a href="#1、extend-模板继承" class="headerlink" title="1、extend 模板继承"></a>1、<strong>extend 模板继承</strong></h3><h4 id="1-基础结构"><a href="#1-基础结构" class="headerlink" title="1. 基础结构"></a>1. <strong>基础结构</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- base.html (父模板) --&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="language-xml">默认标题</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml">网站头部</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 默认内容 --&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> footer %&#125;</span><span class="language-xml">版权信息</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> scripts %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-子模板使用"><a href="#2-子模板使用" class="headerlink" title="2. 子模板使用"></a>2. <strong>子模板使用</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- home.html (子模板) --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 1. 覆盖title块 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="language-xml">首页 - 我的网站</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2. 添加额外的head内容 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;首页描述&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/home.css&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 3. 覆盖header --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到我的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;nav.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 4. 覆盖content --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hero&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>主要内容区域<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 保留父模板的默认内容 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>额外的首页内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-多级继承"><a href="#3-多级继承" class="headerlink" title="3. 多级继承"></a>3. <strong>多级继承</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- base.html --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- blog_base.html --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 继承base的extra_head --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/blog.css&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;blog_nav.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- post_detail.html --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;blog_base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="hljs-template-variable">&#123;&#123; post.title &#125;&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; post.title &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; post.content|<span class="hljs-name">safe</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2、include-模板包含"><a href="#2、include-模板包含" class="headerlink" title="2、include 模板包含"></a>2、<strong>include 模板包含</strong></h3><h4 id="1-基本包含"><a href="#1-基本包含" class="headerlink" title="1. 基本包含"></a>1. <strong>基本包含</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含静态模板 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;header.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含带上下文 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;user_card.html&quot; with user=current_user %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含多个变量 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;product.html&quot; with product=item price=item.price only %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- only关键字：限制变量传递 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;component.html&quot; with data=data only %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-动态包含"><a href="#2-动态包含" class="headerlink" title="2. 动态包含"></a>2. <strong>动态包含</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 根据变量包含不同模板 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> user.is_premium %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;premium_features.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">else</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;basic_features.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 使用变量作为模板名 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> template_name %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 循环中包含 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> product <span class="hljs-keyword">in</span> products %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;product_item.html&quot; with product=product %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-包含传参示例"><a href="#3-包含传参示例" class="headerlink" title="3. 包含传参示例"></a>3. <strong>包含传参示例</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- card.html --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card </span></span></span><span class="hljs-template-variable">&#123;&#123; extra_class &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; title &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; content &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> show_button %&#125;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; button_class &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; button_text &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 使用card --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;card.html&quot; with </span><br><span class="hljs-template-tag">    title=&quot;用户面板&quot; </span><br><span class="hljs-template-tag">    content=user.bio </span><br><span class="hljs-template-tag">    show_button=True </span><br><span class="hljs-template-tag">    button_text=&quot;编辑资料&quot; </span><br><span class="hljs-template-tag">    button_class=&quot;btn-primary&quot; </span><br><span class="hljs-template-tag">    extra_class=&quot;user-card&quot; </span><br><span class="hljs-template-tag">%&#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><h2 id="ORM基础概念与模型创建"><a href="#ORM基础概念与模型创建" class="headerlink" title="ORM基础概念与模型创建"></a>ORM基础概念与模型创建</h2><p><strong>ORM (Object Relational Mapping)</strong> 把 Python 的<strong>类 (Class)</strong> 映射成数据库里的<strong>表 (Table)</strong>。</p><p>只需要定义一个 Python 类，Django 就会自动帮建表、帮写 <code>SELECT/INSERT</code> 语句。</p><img src="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image3.png" class="" title="ORM"><p>先在settings.py中配置好数据库信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">&quot;default&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;ENGINE&quot;</span>: <span class="hljs-string">&quot;django.db.backends.mysql&quot;</span>,  <span class="hljs-comment"># 使用 MySQL 数据库</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>: <span class="hljs-string">&#x27;database_demo&#x27;</span>,  <span class="hljs-comment"># 数据库名称</span><br>        <span class="hljs-string">&quot;USER&quot;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,           <span class="hljs-comment"># 数据库用户名</span><br>        <span class="hljs-string">&quot;PASSWORD&quot;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,       <span class="hljs-comment"># 数据库密码</span><br>        <span class="hljs-string">&quot;HOST&quot;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,      <span class="hljs-comment"># 数据库主机地址</span><br>        <span class="hljs-string">&quot;PORT&quot;</span>: <span class="hljs-string">&#x27;3306&#x27;</span>,           <span class="hljs-comment"># 数据库端口</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ORM 模型一般都是放在app 的 models.py 文件中。每个 app 都可以拥有自己的模型。并且要在 settings.py 的 INSTALLED_APP 中进行安装。以下是一个简单的书籍模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    author = models.CharField(max_length=<span class="hljs-number">20</span>)<br>    pub_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>)<br>    price = models.FloatField(default=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>执行两步命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python manage.py makemigrations<br>python manage.py migrate<br></code></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_book</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># book = Book(name=&quot;Django入门&quot;, author=&quot;张三&quot;, price=59.9)</span><br>    book = Book(name=<span class="hljs-string">&quot;水浒传&quot;</span>, author=<span class="hljs-string">&quot;施耐庵&quot;</span>, price=<span class="hljs-number">39.9</span>)<br>    book.save()<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;图书 <span class="hljs-subst">&#123;book.name&#125;</span> 添加成功，ID为 <span class="hljs-subst">&#123;book.<span class="hljs-built_in">id</span>&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_book</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># books = Book.objects.all()  # 获取所有对象</span><br>    books = Book.objects.<span class="hljs-built_in">filter</span>(name=<span class="hljs-string">&quot;Django入门&quot;</span>)  <span class="hljs-comment"># 条件查询</span><br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:<br>        <span class="hljs-built_in">print</span>(book.name, book.author, book.price)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;查询图书成功&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_book</span>(<span class="hljs-params">request</span>):<br>    book_id = request.GET.get(<span class="hljs-string">&quot;id&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        book = Book.objects.get(<span class="hljs-built_in">id</span>=book_id)  <span class="hljs-comment"># 获取单个对象</span><br>        <span class="hljs-built_in">print</span>(book.name, book.author, book.price)<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;图书名称: <span class="hljs-subst">&#123;book.name&#125;</span>, 作者: <span class="hljs-subst">&#123;book.author&#125;</span>, 价格: <span class="hljs-subst">&#123;book.price&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> Book.DoesNotExist:<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;图书不存在&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order_book</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># books = Book.objects.order_by(&quot;-price&quot;)  # 降序</span><br>    books = Book.objects.order_by(<span class="hljs-string">&quot;price&quot;</span>)  <span class="hljs-comment"># 升序</span><br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:<br>        <span class="hljs-built_in">print</span>(book.name, book.author, book.price)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;排序图书成功&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_book</span>(<span class="hljs-params">request</span>):<br>    book = Book.objects.first()<br>    book.price = <span class="hljs-number">49.9</span><br>    book.save()<br>    <span class="hljs-built_in">print</span>(book.name, book.author, book.price)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;图书 <span class="hljs-subst">&#123;book.name&#125;</span> 更新成功，新的价格为 <span class="hljs-subst">&#123;book.price&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_book</span>(<span class="hljs-params">request</span>):<br>    book = Book.objects.first()<br>    book.delete()<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;删除图书成功&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="常见Field及其参数"><a href="#常见Field及其参数" class="headerlink" title="常见Field及其参数"></a>常见Field及其参数</h2><h3 id="一、-核心字段类型-Field-Types"><a href="#一、-核心字段类型-Field-Types" class="headerlink" title="一、 核心字段类型 (Field Types)"></a>一、 核心字段类型 (Field Types)</h3><h4 id="1-文本类"><a href="#1-文本类" class="headerlink" title="1. 文本类"></a>1. 文本类</h4><ul><li><strong><code>CharField</code></strong>: 短文本。<ul><li><strong>必填参数</strong>: <code>max_length</code> (最大长度)。</li><li><em>场景</em>: 用例名称、接口 URL、创建人姓名。</li></ul></li><li><strong><code>TextField</code></strong>: 长文本（无长度限制）。<ul><li><em>场景</em>: <strong>异常堆栈信息 (Stack Trace)</strong>、断言失败的详细日志、备注。</li></ul></li></ul><h4 id="2-数字类"><a href="#2-数字类" class="headerlink" title="2. 数字类"></a>2. 数字类</h4><ul><li><strong><code>IntegerField</code></strong>: 整数。<ul><li><em>场景</em>: 优先级 (1, 2, 3)、重试次数。</li></ul></li><li><strong><code>DecimalField</code></strong>: 高精度小数 (比 Float 更准)。<ul><li><strong>必填参数</strong>: <code>max_digits</code> (总位数), <code>decimal_places</code> (小数位)。</li><li><em>场景</em>: <strong>代码覆盖率 (85.5%)</strong>、交易金额测试。</li></ul></li></ul><h4 id="3-时间类-面试常考"><a href="#3-时间类-面试常考" class="headerlink" title="3. 时间类 (面试常考)"></a>3. 时间类 (面试常考)</h4><ul><li><strong><code>DateTimeField</code></strong>: 日期+时间 (YYYY-MM-DD HH:MM:SS)。</li><li><strong><code>DateField</code></strong>: 仅日期。<ul><li><em>关键参数区分</em>:<ul><li><code>auto_now_add=True</code>: <strong>创建时</strong>自动填当前时间（用于“创建时间”）。</li><li><code>auto_now=True</code>: <strong>每次保存(save)时</strong>自动更新为当前时间（用于“最后更新时间”）。</li></ul></li></ul></li></ul><h4 id="4-逻辑与结构类"><a href="#4-逻辑与结构类" class="headerlink" title="4. 逻辑与结构类"></a>4. 逻辑与结构类</h4><ul><li><strong><code>BooleanField</code></strong>: 布尔值 (True&#x2F;False)。<ul><li><em>场景</em>: 是否通过 (is_passed)、是否删除 (is_deleted)。</li></ul></li><li><strong><code>JSONField</code></strong>: 直接存 JSON 字典或列表。<ul><li><em>场景</em>: <strong>接口请求头 (Headers)</strong>、<strong>接口返回体 (Response Body)</strong>、配置参数。</li><li><em>注意</em>: 在 MySQL 5.7+ 和 PostgreSQL 中是原生的，性能很好；在 SQLite 中存为文本。</li></ul></li></ul><hr><h3 id="二、-通用参数-Options-——-几乎所有-Field-都能用"><a href="#二、-通用参数-Options-——-几乎所有-Field-都能用" class="headerlink" title="二、 通用参数 (Options) —— 几乎所有 Field 都能用"></a>二、 通用参数 (Options) —— 几乎所有 Field 都能用</h3><p>这是最容易混淆的地方，尤其是 <code>null</code> 和 <code>blank</code>。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>解释</strong></th><th><strong>常用值</strong></th></tr></thead><tbody><tr><td><strong><code>verbose_name</code></strong></td><td>给字段起个“人话”名字，显示在 Admin 后台。</td><td><code>verbose_name=&quot;用例优先级&quot;</code></td></tr><tr><td><strong><code>default</code></strong></td><td>默认值。</td><td><code>default=0</code> 或 <code>default=&quot;GET&quot;</code></td></tr><tr><td><strong><code>choices</code></strong></td><td><strong>枚举</strong>。把输入框变成下拉框，限制输入范围。</td><td>(见下方代码示例)</td></tr><tr><td><strong><code>unique</code></strong></td><td>唯一性约束。</td><td><code>unique=True</code> (如用例编号不能重复)</td></tr><tr><td><strong><code>null=True</code></strong></td><td><strong>数据库层面</strong>：允许存 NULL。</td><td>默认是 False (不允许空)。</td></tr><tr><td><strong><code>blank=True</code></strong></td><td><strong>表单验证层面</strong>：允许前端传空值。</td><td>默认是 False (必填)。</td></tr></tbody></table><blockquote><p><strong>经验之谈</strong>：</p><ul><li>如果是字符串 (<code>CharField</code>&#x2F;<code>TextField</code>)，通常设 <code>blank=True, default=&#39;&#39;</code>，而<strong>不要</strong>设 <code>null=True</code>（Django 惯例不推荐字符串存 NULL）。</li><li>如果是数字、外键，想留空，必须同时设 <code>null=True, blank=True</code>。</li></ul></blockquote><hr><h2 id="Meta常用配置"><a href="#Meta常用配置" class="headerlink" title="Meta常用配置"></a>Meta常用配置</h2><p>Field 定义了表里有<strong>什么数据</strong>（列），而 Meta 定义了这张表<strong>如何表现</strong>（行为）</p><h3 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h3><p>如果不写，Admin 后台会显示 <code>TestCase</code>，写了就显示 <code>测试用例</code>。</p><ul><li><strong><code>verbose_name</code></strong>: 单数名称。</li><li><strong><code>verbose_name_plural</code></strong>: 复数名称。如果不写，Django 会自动在单数后面加个 “s”（变成 <code>测试用例s</code>，很难看）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>(models.Model):<br>    <span class="hljs-comment"># ... 字段 ...</span><br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        verbose_name = <span class="hljs-string">&quot;测试用例&quot;</span><br>        verbose_name_plural = <span class="hljs-string">&quot;测试用例&quot;</span>  <span class="hljs-comment"># 通常设为和单数一样</span><br></code></pre></td></tr></table></figure><h3 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h3><p>查数据时，返回的数据顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        <span class="hljs-comment"># 负号表示倒序 (DESC)，即创建时间越晚排越前</span><br>        ordering = [<span class="hljs-string">&#x27;-created_time&#x27;</span>] <br>        <br>        <span class="hljs-comment"># 如果只想按id正序排</span><br>        <span class="hljs-comment"># ordering = [&#x27;id&#x27;]</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：排序会增加数据库开销，如果数据量极大（百万级），建议在代码里按需排序，而不是设为全局默认。</p><h3 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h3><p>联合唯一索引.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        <span class="hljs-comment"># 这是一个列表的列表（因为可以有多组联合约束）</span><br>        unique_together = [<br>            <span class="hljs-comment"># 联合约束：项目ID + 用例名称 必须唯一</span><br>            (<span class="hljs-string">&#x27;project&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>),<br>        ]<br></code></pre></td></tr></table></figure><h3 id="abstract-True"><a href="#abstract-True" class="headerlink" title="abstract &#x3D; True"></a>abstract &#x3D; True</h3><p>发现 <code>Project</code>、<code>TestCase</code>、<code>TestReport</code> 这几张表，都需要 <code>created_time</code> 和 <code>updated_time</code> 这两个字段。不想在每个类里都复制粘贴一遍代码。</p><p><strong>解决方案</strong>：创建一个公共父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义一个基类，不对应数据库表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span>(models.Model):<br>    created_time = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&quot;创建时间&quot;</span>)<br>    updated_time = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&quot;更新时间&quot;</span>)<br>    description = models.TextField(blank=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&quot;描述&quot;</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        abstract = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 关键！告诉Django不要给这个类建表，它只是用来被继承的</span><br><br><span class="hljs-comment"># 2. 其他模型直接继承它</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Project</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name = models.CharField(...)<br>    <span class="hljs-comment"># 自动拥有 created_time, updated_time, description</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name = models.CharField(...)<br>    <span class="hljs-comment"># 自动拥有 created_time, updated_time, description</span><br></code></pre></td></tr></table></figure><h3 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a>db_table</h3><p>Django 默认生成的表名是 <code>app名_model名</code>.而db_table即定义表的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        db_table = <span class="hljs-string">&quot;t_test_case&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="外键和表关系"><a href="#外键和表关系" class="headerlink" title="外键和表关系"></a>外键和表关系</h2><h3 id="1-ForeignKey-一对多"><a href="#1-ForeignKey-一对多" class="headerlink" title="1. ForeignKey (一对多)"></a>1. <code>ForeignKey</code> (一对多)</h3><p>最常用的。比如：一个用例属于一个项目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">project = models.ForeignKey(to=<span class="hljs-string">&quot;Project&quot;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><ul><li><strong>必填参数 <code>on_delete</code> (级联删除策略)</strong> <ul><li><code>models.CASCADE</code>: <strong>级联删除</strong>。项目删了，它底下的用例<strong>全删</strong>（最常用）</li><li><code>models.SET_NULL</code>: 项目删了，用例保留，但 project 字段变为 Null（需要配合 <code>null=True</code>）</li><li><code>models.PROTECT</code>: 保护模式。如果项目下有用例，<strong>禁止删除</strong>该项目（报错）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(models.Model):<br>    username = models.CharField(max_length=<span class="hljs-number">20</span>)<br>    password = models.CharField(max_length=<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>(models.Model):<br>    title = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    content = models.TextField()<br><br>    <span class="hljs-comment"># 外键关联 在数据库中字段是user_id 与User的id关联</span><br>    author = models.ForeignKey(<span class="hljs-string">&quot;User&quot;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">article_test</span>(<span class="hljs-params">request</span>):<br>    user = User(username=<span class="hljs-string">&quot;xiaoli&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>)<br>    user.save()<br>    article = Article(title=<span class="hljs-string">&quot;测试标题&quot;</span>, content=<span class="hljs-string">&quot;测试内容&quot;</span>, author=user)<br>    article.save()<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;This is article test page.&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">article_author_name</span>(<span class="hljs-params">request</span>):<br>    article = Article.objects.first()<br>    <span class="hljs-comment"># 正向查询：直接用点号 . 即可</span><br>    <span class="hljs-comment"># 关键：article.author 是一个外键关联的模型对象 是一个User对象</span><br>    <span class="hljs-built_in">print</span>(article.author.username)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;作者名称: <span class="hljs-subst">&#123;article.author.username&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_articles</span>(<span class="hljs-params">request</span>):<br>    user = User.objects.first()<br>    <span class="hljs-comment"># user.article_set</span><br>    <span class="hljs-comment"># 获取该用户的所有article信息</span><br>    articles = user.article_set.<span class="hljs-built_in">all</span>()<br>    <span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:<br>        <span class="hljs-built_in">print</span>(article.title, article.content)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;用户文章列表&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-ManyToManyField-多对多"><a href="#2-ManyToManyField-多对多" class="headerlink" title="2. ManyToManyField (多对多)"></a>2. <code>ManyToManyField</code> (多对多)</h3><p>比如：一个用例可以贴多个 <strong>Tag</strong>（标签），一个 Tag 也可以标在这个用例上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>(models.Model):<br>    title = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    content = models.TextField()<br>    tags = models.ManyToManyField(<span class="hljs-string">&quot;Tag&quot;</span>,related_name=<span class="hljs-string">&quot;articles&quot;</span>)<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>(models.Model):<br>name = models.CharField(max_length=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><ul><li>Django 会自动建一张中间表。</li></ul><h3 id="3-OneToOneField-一对一"><a href="#3-OneToOneField-一对一" class="headerlink" title="3. OneToOneField (一对一)"></a>3. <code>OneToOneField</code> (一对一)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(models.Model):<br>    username = models.CharField(max_length=<span class="hljs-number">20</span>)<br>    password = models.CharField(max_length=<span class="hljs-number">100</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserExtension</span>(models.Model):  <br>    birthday = models.DateTimeField(null=<span class="hljs-literal">True</span>)  <br>    school = models.CharField(blank=<span class="hljs-literal">True</span>,max_length=<span class="hljs-number">50</span>)  <br>    user = models.OneToOneField(<span class="hljs-string">&quot;User&quot;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><p>用得少。比如：User 表不够用了，搞个 UserProfile 表存扩展信息。</p><hr><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="基础查询与“双下划线魔法”-Field-Lookups"><a href="#基础查询与“双下划线魔法”-Field-Lookups" class="headerlink" title="基础查询与“双下划线魔法” (Field Lookups)"></a>基础查询与“双下划线魔法” (Field Lookups)</h3><p>Django 的精髓在于字段名后面接 <code>__操作符</code>。这在底层会翻译成 SQL 的 <code>WHERE</code> 子句。</p><h4 id="1-模糊匹配-LIKE"><a href="#1-模糊匹配-LIKE" class="headerlink" title="1. 模糊匹配 (LIKE)"></a>1. 模糊匹配 (<code>LIKE</code>)</h4><p>找出名字里包含 “登录” 的用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SQL: ... WHERE name LIKE &#x27;%登录%&#x27;;</span><br>cases = TestCase.objects.<span class="hljs-built_in">filter</span>(name__contains=<span class="hljs-string">&quot;登录&quot;</span>)<br><br><span class="hljs-comment"># 忽略大小写 (Case Insensitive)</span><br>cases = TestCase.objects.<span class="hljs-built_in">filter</span>(name__icontains=<span class="hljs-string">&quot;login&quot;</span>) <br></code></pre></td></tr></table></figure><h4 id="2-比较运算"><a href="#2-比较运算" class="headerlink" title="2. 比较运算 (&gt;, &lt;, IN)"></a>2. 比较运算 (<code>&gt;</code>, <code>&lt;</code>, <code>IN</code>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># id 大于 10 的</span><br>TestCase.objects.<span class="hljs-built_in">filter</span>(id__gt=<span class="hljs-number">10</span>) <span class="hljs-comment"># gt = greater than</span><br><br><span class="hljs-comment"># 优先级 小于等于 2 的 (P1和P2)</span><br>TestCase.objects.<span class="hljs-built_in">filter</span>(priority__lte=<span class="hljs-number">2</span>) <span class="hljs-comment"># lte = less than or equal</span><br><br><span class="hljs-comment"># 批量查询：id 在 [1, 3, 5] 中的</span><br>TestCase.objects.<span class="hljs-built_in">filter</span>(id__in=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><h4 id="3-日期查询-Date"><a href="#3-日期查询-Date" class="headerlink" title="3. 日期查询 (Date)"></a>3. 日期查询 (Date)</h4><p>这是测开做“测试周报”统计时最常用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找出 2024年 之后创建的数据</span><br>TestCase.objects.<span class="hljs-built_in">filter</span>(created_time__year__gte=<span class="hljs-number">2024</span>)<br><br><span class="hljs-comment"># 找出 12月 的数据</span><br>TestCase.objects.<span class="hljs-built_in">filter</span>(created_time__month=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p>……</p><hr><h3 id="Q-对象与-F-对象"><a href="#Q-对象与-F-对象" class="headerlink" title="Q 对象与 F 对象"></a>Q 对象与 F 对象</h3><h4 id="1-Q-对象-复杂逻辑-OR"><a href="#1-Q-对象-复杂逻辑-OR" class="headerlink" title="1. Q 对象 (复杂逻辑 OR)"></a>1. Q 对象 (复杂逻辑 OR)</h4><p>filter() 里的多个参数默认是 AND 关系。如果我要 OR（或）怎么办？</p><p>比如：找出 “P1级别” 或者 “失败” 的用例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Q<br><br><span class="hljs-comment"># | 代表 OR, &amp; 代表 AND, ~ 代表 NOT</span><br>cases = TestCase.objects.<span class="hljs-built_in">filter</span>(Q(priority=<span class="hljs-number">1</span>) | Q(is_passed=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><h4 id="2-F-对象-字段间比较"><a href="#2-F-对象-字段间比较" class="headerlink" title="2. F 对象 (字段间比较)"></a>2. F 对象 (字段间比较)</h4><p>filter() 通常是拿字段和常量比。如果我要拿字段和字段比呢？</p><p>场景：找出所有被修改过的用例（即 updated_time 大于 created_time）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> F<br><br><span class="hljs-comment"># F(&#x27;字段名&#x27;) 获取字段的值</span><br>cases = TestCase.objects.<span class="hljs-built_in">filter</span>(updated_time__gt=F(<span class="hljs-string">&#x27;created_time&#x27;</span>))<br></code></pre></td></tr></table></figure><hr><h3 id="查看原生-SQL"><a href="#查看原生-SQL" class="headerlink" title="查看原生 SQL"></a>查看原生 SQL</h3><p>.query知道 Django 到底执行了什么 SQL</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">qs = TestCase.objects.<span class="hljs-built_in">filter</span>(name__contains=<span class="hljs-string">&quot;登录&quot;</span>, priority=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 直接打印 query 属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(qs.query))<br></code></pre></td></tr></table></figure><p>会看到类似这样的输出：SELECT … FROM case_manager_testcase WHERE name LIKE %登录% AND priority &#x3D; 1</p><hr><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>在 Django 中，聚合主要涉及两个核心方法：</p><ol><li><strong><code>aggregate()</code></strong>: <strong>整表聚合</strong>。把一堆数据“拍扁”成一个字典（例如：算全公司的 Bug 总数）。</li><li><strong><code>annotate()</code></strong>: <strong>分组聚合 (Group By)</strong>。给每一行数据挂载一个统计值（例如：算<strong>每个</strong>项目下有多少条用例）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Count, Sum, Avg, Max, Min<br></code></pre></td></tr></table></figure><hr><h3 id="一、-aggregate-——-算总账"><a href="#一、-aggregate-——-算总账" class="headerlink" title="一、 aggregate() —— 算总账"></a>一、 <code>aggregate()</code> —— 算总账</h3><p>它的作用是对当前的 QuerySet 进行计算，返回一个<strong>字典 (Dictionary)</strong>。它不再返回模型对象列表了。</p><p><strong>场景</strong>：测试平台首页的“数据概览”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Count, Avg<br><br><span class="hljs-comment"># 1. 统计总共有多少条用例</span><br><span class="hljs-comment"># SQL: SELECT COUNT(id) FROM test_case;</span><br>res = TestCase.objects.aggregate(total_cases=Count(<span class="hljs-string">&#x27;id&#x27;</span>))<br><span class="hljs-built_in">print</span>(res) <br><span class="hljs-comment"># 输出: &#123;&#x27;total_cases&#x27;: 105&#125;</span><br><br><span class="hljs-comment"># 2. 统计所有用例优先级的平均值 (虽然这没啥业务意义，仅作演示)</span><br><span class="hljs-comment"># SQL: SELECT AVG(priority) FROM test_case;</span><br>res = TestCase.objects.aggregate(avg_priority=Avg(<span class="hljs-string">&#x27;priority&#x27;</span>))<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-comment"># 输出: &#123;&#x27;avg_priority&#x27;: 1.8&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果不给参数起名字（ <code>total_cases</code>），Django 会自动生成 <code>id__count</code> 这种名字。</p></blockquote><hr><h3 id="二、-annotate-——-给每个对象“贴标签”-Group-By"><a href="#二、-annotate-——-给每个对象“贴标签”-Group-By" class="headerlink" title="二、 annotate() —— 给每个对象“贴标签” (Group By)"></a>二、 <code>annotate()</code> —— 给每个对象“贴标签” (Group By)</h3><p>它的本质是 SQL 的 GROUP BY。它返回的依然是 QuerySet (列表)，但是列表里的每个对象多了一个属性。</p><p><strong>场景</strong>：在“项目列表”页，直接显示每个项目下面有多少条用例。</p><h4 id="1-基础用法-反向关联统计"><a href="#1-基础用法-反向关联统计" class="headerlink" title="1. 基础用法 (反向关联统计)"></a>1. 基础用法 (反向关联统计)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们查的是 Project，但我们要统计它底下的 testcase 数量</span><br>projects = Project.objects.annotate(case_count=Count(<span class="hljs-string">&#x27;testcase&#x27;</span>))<br><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> projects:<br>    <span class="hljs-comment"># 此时 p 对象多了一个属性 case_count</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;项目: <span class="hljs-subst">&#123;p.name&#125;</span>, 用例数: <span class="hljs-subst">&#123;p.case_count&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># SQL 翻译:</span><br><span class="hljs-comment"># SELECT project.*, COUNT(test_case.id) </span><br><span class="hljs-comment"># FROM project </span><br><span class="hljs-comment"># LEFT OUTER JOIN test_case ON (...) </span><br><span class="hljs-comment"># GROUP BY project.id;</span><br></code></pre></td></tr></table></figure><h4 id="2-结合-values-实现真正的-Group-By"><a href="#2-结合-values-实现真正的-Group-By" class="headerlink" title="2. 结合 values() 实现真正的 Group By"></a>2. 结合 <code>values()</code> 实现真正的 Group By</h4><p>如果你不想拿对象，只想拿“统计报表”，比如**“按优先级统计用例数量”**（有多少P1，多少P2…）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. values(&#x27;priority&#x27;): 先按 priority 字段分组</span><br><span class="hljs-comment"># 2. annotate(...): 对每一组进行统计</span><br>report = TestCase.objects.values(<span class="hljs-string">&#x27;priority&#x27;</span>).annotate(count=Count(<span class="hljs-string">&#x27;id&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(report)<br><span class="hljs-comment"># 输出 (QuerySet其实是字典列表): </span><br><span class="hljs-comment"># &lt;QuerySet [</span><br><span class="hljs-comment">#    &#123;&#x27;priority&#x27;: 1, &#x27;count&#x27;: 12&#125;, </span><br><span class="hljs-comment">#    &#123;&#x27;priority&#x27;: 2, &#x27;count&#x27;: 50&#125;, </span><br><span class="hljs-comment">#    &#123;&#x27;priority&#x27;: 3, &#x27;count&#x27;: 8&#125;</span><br><span class="hljs-comment"># ]&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="条件聚合-Conditional-Aggregation"><a href="#条件聚合-Conditional-Aggregation" class="headerlink" title="条件聚合 (Conditional Aggregation)"></a>条件聚合 (Conditional Aggregation)</h3><p>在聚合函数里加 filter。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Q<br><br><span class="hljs-comment"># 统计每个项目下的：1. 总用例数  2. 失败用例数</span><br>projects = Project.objects.annotate(<br>    total=Count(<span class="hljs-string">&#x27;testcase&#x27;</span>),<br>    failed_count=Count(<span class="hljs-string">&#x27;testcase&#x27;</span>, <span class="hljs-built_in">filter</span>=Q(testcase__is_passed=<span class="hljs-literal">False</span>))<br>)<br><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> projects:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;项目: <span class="hljs-subst">&#123;p.name&#125;</span>, 总数: <span class="hljs-subst">&#123;p.total&#125;</span>, 失败: <span class="hljs-subst">&#123;p.failed_count&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这行代码在 SQL 层面会被翻译成高级的 <code>CASE WHEN ... THEN ...</code> 语句，性能极高。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>SQL 类比</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong><code>aggregate</code></strong></td><td><strong>字典 (Dict)</strong></td><td><code>SELECT COUNT(*) ...</code></td><td>首页大盘数据，算全站总和&#x2F;平均值。</td></tr><tr><td><strong><code>annotate</code></strong></td><td><strong>QuerySet (List)</strong></td><td><code>GROUP BY</code></td><td>列表页，每一行数据都要带一个统计值（如：文章的点赞数、项目的用例数）。</td></tr></tbody></table><hr><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h3 id="一、-表单概述-Forms-Overview"><a href="#一、-表单概述-Forms-Overview" class="headerlink" title="一、 表单概述 (Forms Overview)"></a>一、 表单概述 (Forms Overview)</h3><p>Django 的表单系统主要做三件事：</p><ol><li><strong>生成 HTML</strong>：把 Python 类自动变成 HTML 代码（比如 <code>&lt;input type=&quot;text&quot;&gt;</code>）（不常用）</li><li><strong>验证数据</strong>：这是核心！检查用户填的是不是邮箱？密码够不够长？</li><li><strong>清洗数据</strong>：把用户填的纯文本 <code>&quot;1&quot;</code> 变成 Python 的整数 <code>1</code>。</li></ol><h4 id="普通表单-forms-Form"><a href="#普通表单-forms-Form" class="headerlink" title="普通表单 (forms.Form)"></a>普通表单 (<code>forms.Form</code>)</h4><p>这就像之前用 <code>JsonResponse</code> 手写 API 一样，是完全自定义的，不一定非要和数据库挂钩。</p><p><strong>场景</strong>：比如一个“运行测试用例”的表单，只需要用户填一个“运行环境”和“重试次数”，这些不需要存数据库，只是为了触发任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django <span class="hljs-keyword">import</span> forms<br><span class="hljs-keyword">from</span> django.core <span class="hljs-keyword">import</span> validators<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageBoardForm</span>(forms.Form):<br>    title = forms.CharField(min_length=<span class="hljs-number">2</span>, max_length=<span class="hljs-number">20</span>, label=<span class="hljs-string">&#x27;标题&#x27;</span>, error_messages=&#123;<br>        <span class="hljs-string">&#x27;min_length&#x27;</span>: <span class="hljs-string">&#x27;标题长度不能少于2个字符&#x27;</span>,<br>        <span class="hljs-string">&#x27;max_length&#x27;</span>: <span class="hljs-string">&#x27;标题长度不能超过20个字符&#x27;</span>,<br>    &#125;)<br>    content = forms.CharField(widget=forms.Textarea, label=<span class="hljs-string">&#x27;内容&#x27;</span>)<br>    email = forms.EmailField(label=<span class="hljs-string">&#x27;邮箱&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterForm</span>(forms.Form):<br>    telephone = forms.CharField(validators=[validators.RegexValidator(<span class="hljs-string">r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;</span>, <span class="hljs-string">&#x27;请输入正确的手机号！&#x27;</span>)], label=<span class="hljs-string">&#x27;手机号&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="二、-核心：数据验证-Validation"><a href="#二、-核心：数据验证-Validation" class="headerlink" title="二、 核心：数据验证 (Validation)"></a>二、 核心：数据验证 (Validation)</h3><p>这是 Form 最强大的地方。验证分为两层：<strong>字段级验证</strong> 和 <strong>表单级（整体）验证</strong>。</p><h4 id="1-字段级验证-clean"><a href="#1-字段级验证-clean" class="headerlink" title="1. 字段级验证 (clean_&lt;fieldname&gt;)"></a>1. 字段级验证 (<code>clean_&lt;fieldname&gt;</code>)</h4><p><strong>规则</strong>：定义方法名为 <code>clean_字段名</code>。 <strong>场景</strong>：检查“重试次数”不能是奇数（假设业务规定）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clean_retry_times</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 1. 取出该字段的值</span><br>    data = <span class="hljs-variable language_">self</span>.cleaned_data[<span class="hljs-string">&#x27;retry_times&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 2. 判断逻辑</span><br>    <span class="hljs-keyword">if</span> data % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 3. 抛出异常 -&gt; 前端会显示红色错误提示</span><br>        <span class="hljs-keyword">raise</span> forms.ValidationError(<span class="hljs-string">&quot;重试次数必须是偶数！&quot;</span>)<br>        <br>    <span class="hljs-comment"># 4. 必须返回清洗后的值</span><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><h4 id="2-表单级验证-clean"><a href="#2-表单级验证-clean" class="headerlink" title="2. 表单级验证 (clean)"></a>2. 表单级验证 (<code>clean</code>)</h4><p><strong>规则</strong>：定义方法名为 <code>clean</code>。 <strong>场景</strong>：跨字段验证。比如“如果是生产环境，重试次数必须为 0”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clean</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 1. 获取所有已通过字段级验证的数据</span><br>    cleaned_data = <span class="hljs-built_in">super</span>().clean()<br>    <br>    env = cleaned_data.get(<span class="hljs-string">&#x27;environment&#x27;</span>)<br>    retry = cleaned_data.get(<span class="hljs-string">&#x27;retry_times&#x27;</span>)<br><br>    <span class="hljs-comment"># 2. 跨字段逻辑判断</span><br>    <span class="hljs-keyword">if</span> env == <span class="hljs-string">&#x27;prod&#x27;</span> <span class="hljs-keyword">and</span> retry &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 这里的报错属于整个表单的错误，不是某个字段的</span><br>        <span class="hljs-keyword">raise</span> forms.ValidationError(<span class="hljs-string">&quot;危险操作：生产环境禁止重试！&quot;</span>)<br>        <br>    <span class="hljs-keyword">return</span> cleaned_data<br></code></pre></td></tr></table></figure><hr><h2 id="ModelForm"><a href="#ModelForm" class="headerlink" title="ModelForm"></a>ModelForm</h2><p>如果要写的表单和数据库模型（Model）几乎一模一样，手写一遍 <code>forms.Form</code> 没必要。<strong>ModelForm</strong> 直接根据 Model 生成表单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django <span class="hljs-keyword">import</span> forms<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> TestCase<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCaseForm</span>(forms.ModelForm):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        <span class="hljs-comment"># 1. 绑定模型</span><br>        model = TestCase<br>        <span class="hljs-comment"># 2. 指定要显示的字段 (&#x27;__all__&#x27; 表示所有)</span><br>        fields = [<span class="hljs-string">&#x27;project&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;method&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;priority&#x27;</span>]<br>        <span class="hljs-comment"># 3. 自定义控件样式 (比如加个 Bootstrap 的 class)</span><br>        widgets = &#123;<br>            <span class="hljs-string">&#x27;name&#x27;</span>: forms.TextInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>, <span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&#x27;请输入用例名&#x27;</span>&#125;),<br>            <span class="hljs-string">&#x27;url&#x27;</span>: forms.TextInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>&#125;),<br>        &#125;<br>        <br>    <span class="hljs-comment"># ModelForm 依然可以写自定义验证！</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clean_name</span>(<span class="hljs-params">self</span>):<br>        name = <span class="hljs-variable language_">self</span>.cleaned_data[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;搞事&quot;</span> <span class="hljs-keyword">in</span> name:<br>            <span class="hljs-keyword">raise</span> forms.ValidationError(<span class="hljs-string">&quot;用例名称包含敏感词！&quot;</span>)<br>        <span class="hljs-keyword">return</span> name<br></code></pre></td></tr></table></figure><hr><h3 id="save-方法"><a href="#save-方法" class="headerlink" title="save() 方法"></a>save() 方法</h3><p>ModelForm 最方便的是它自带 <code>save()</code> 方法。</p><ul><li><strong>Create (新增)</strong>: <code>form.save()</code> 会直接插入数据库。</li><li><strong>Update (更新)</strong>: 如果初始化时传了 <code>instance</code>，<code>save()</code> 就是更新。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render, redirect, get_object_or_404<br><span class="hljs-keyword">from</span> .forms <span class="hljs-keyword">import</span> TestCaseForm<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> TestCase<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_case</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># POST 请求：用户提交了表单</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        form = TestCaseForm(request.POST) <span class="hljs-comment"># 绑定数据</span><br>        <span class="hljs-keyword">if</span> form.is_valid(): <span class="hljs-comment"># 触发上面的 clean_... 方法</span><br>            form.save() <span class="hljs-comment"># 存入数据库！</span><br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/case/list/&#x27;</span>) <span class="hljs-comment"># 跳转</span><br>    <br>    <span class="hljs-comment"># GET 请求：用户想要看空表单</span><br>    <span class="hljs-keyword">else</span>:<br>        form = TestCaseForm()<br>    <br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;create_case.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;form&#x27;</span>: form&#125;)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_case</span>(<span class="hljs-params">request, case_id</span>):<br>    <span class="hljs-comment"># 查出旧数据</span><br>    <span class="hljs-keyword">case</span> = get_object_or_404(TestCase, pk=case_id)<br>    <br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 注意：这里传了 instance=case，表示是“更新”而不是“新建”</span><br>        form = TestCaseForm(request.POST, instance=<span class="hljs-keyword">case</span>)<br>        <span class="hljs-keyword">if</span> form.is_valid():<br>            form.save() <span class="hljs-comment"># 更新数据库</span><br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/case/list/&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># GET 请求：表单里会预先填好旧数据</span><br>        form = TestCaseForm(instance=<span class="hljs-keyword">case</span>)<br>        <br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;edit_case.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;form&#x27;</span>: form&#125;)<br></code></pre></td></tr></table></figure><hr><h1 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h1><p>在 Web 开发中，最核心的痛点是：HTTP 协议是无状态的（Stateless）。也就是说，你刚请求了“登录接口”，紧接着去请求“个人主页”，服务器根本记不住“刚才那个请求是你发的”。服务器对待每一次请求都像接待新客人一样。为了让服务器“记住你”，就诞生了 Cookie 和 Session。</p><hr><h3 id="一、-核心概念与形象比喻"><a href="#一、-核心概念与形象比喻" class="headerlink" title="一、 核心概念与形象比喻"></a>一、 核心概念与形象比喻</h3><p>我用**“去医院看病”**来比喻，非常直观：</p><h4 id="1-Cookie-就诊卡"><a href="#1-Cookie-就诊卡" class="headerlink" title="1. Cookie (就诊卡)"></a>1. Cookie (就诊卡)</h4><ul><li><strong>定义</strong>：存储在**客户端（浏览器）**的一小段文本信息。</li><li><strong>比喻</strong>：你的<strong>就诊卡</strong>。<ul><li>卡在你手里（浏览器）。</li><li>卡上只有一串编号（Session ID），或者简单的名字信息。</li><li><strong>特点</strong>：不安全（别人捡到了能冒充你），容量小（存不了CT片子），每次看病（发请求）都要递给医生。</li></ul></li></ul><h4 id="2-Session-病历档案"><a href="#2-Session-病历档案" class="headerlink" title="2. Session (病历档案)"></a>2. Session (病历档案)</h4><ul><li><strong>定义</strong>：存储在**服务端（服务器数据库&#x2F;内存）**的数据。</li><li><strong>比喻</strong>：医院电脑里的<strong>病历记录</strong>。<ul><li>数据在医院手里（服务器）。</li><li>里面详细记录了你的病情、开的药、你是谁（用户详细信息）。</li><li><strong>特点</strong>：安全（在服务器大楼里），容量大。</li></ul></li></ul><h4 id="3-它们如何配合？-核心流程"><a href="#3-它们如何配合？-核心流程" class="headerlink" title="3. 它们如何配合？ (核心流程)"></a>3. 它们如何配合？ (核心流程)</h4><ol><li><strong>挂号（登录）</strong>：你给医院信息，医院创建一个病历（Session），生成一个编号 <code>10086</code>。</li><li><strong>发卡（Set-Cookie）</strong>：医院把写着 <code>10086</code> 的卡（Cookie）给你。</li><li><strong>看病（后续请求）</strong>：你再次去找医生，不用废话，直接刷卡（发送 Cookie）。</li><li><strong>查档（Session Lookup）</strong>：医生通过卡号 <code>10086</code>，去电脑里调出你的档案（Session）</li></ol><hr><h3 id="二、-Django-中的具体实现"><a href="#二、-Django-中的具体实现" class="headerlink" title="二、 Django 中的具体实现"></a>二、 Django 中的具体实现</h3><p>Django 把这一切封装好，不需要手动操作 Cookie，只需要操作 <strong><code>request.session</code></strong> 字典即可。</p><h4 id="1-开启-Session-默认已开启"><a href="#1-开启-Session-默认已开启" class="headerlink" title="1. 开启 Session (默认已开启)"></a>1. 开启 Session (默认已开启)</h4><p>在 <code>settings.py</code> 中，确保这两行是存在的（默认就有）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    ...<br>    <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>, <span class="hljs-comment"># 负责 Session 逻辑</span><br>]<br><br>MIDDLEWARE = [<br>    ...<br>    <span class="hljs-string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>, <span class="hljs-comment"># 负责在请求和响应中植入 Cookie</span><br>]<br></code></pre></td></tr></table></figure><h4 id="2-代码实战：模拟登录与获取信息"><a href="#2-代码实战：模拟登录与获取信息" class="headerlink" title="2. 代码实战：模拟登录与获取信息"></a>2. 代码实战：模拟登录与获取信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse<br><br><span class="hljs-comment"># 1. 登录 (写入 Session)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># 假设校验账号密码成功后...</span><br>    <br>    <span class="hljs-comment"># 这一步，Django 自动做了三件事：</span><br>    <span class="hljs-comment"># 1. 生成一个随机字符串 (Session ID)</span><br>    <span class="hljs-comment"># 2. 在数据库 django_session 表里存入 key=&#x27;user_name&#x27;, value=&#x27;xiaoli&#x27;</span><br>    <span class="hljs-comment"># 3. 给浏览器发一个指令：请把 Session ID 存到 Cookie 里</span><br>    request.session[<span class="hljs-string">&#x27;user_id&#x27;</span>] = <span class="hljs-number">1001</span><br>    request.session[<span class="hljs-string">&#x27;user_name&#x27;</span>] = <span class="hljs-string">&#x27;xiaoli&#x27;</span><br>    request.session[<span class="hljs-string">&#x27;is_login&#x27;</span>] = <span class="hljs-literal">True</span><br>    <br>    <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;登录成功&quot;</span>&#125;)<br><br><span class="hljs-comment"># 2. 只有登录才能看的页面 (读取 Session)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># 从 Session 中取值 (Django 会自动根据 Cookie 里的 ID 去数据库查)</span><br>    is_login = request.session.get(<span class="hljs-string">&#x27;is_login&#x27;</span>, <span class="hljs-literal">False</span>)<br>    <br>    <span class="hljs-keyword">if</span> is_login:<br>        name = request.session.get(<span class="hljs-string">&#x27;user_name&#x27;</span>)<br>        <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">f&quot;欢迎回来，<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>&#125;)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;请先登录&quot;</span>&#125;, status=<span class="hljs-number">403</span>)<br><br><span class="hljs-comment"># 3. 退出 (清除 Session)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logout</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># 清空服务器端的记录，并告诉浏览器删除 Cookie</span><br>    request.session.flush()<br>    <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;退出成功&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><hr><h4 id="1-Session-存在哪？"><a href="#1-Session-存在哪？" class="headerlink" title="1. Session 存在哪？"></a>1. Session 存在哪？</h4><ul><li><strong>默认</strong>：存在数据库里的 <strong><code>django_session</code></strong> 表。<ul><li>可以去数据库看看，每次登录，这里就会多一行乱码一样的数据（加密的）。</li></ul></li><li><strong>优化</strong>：大厂高并发时，通常存在 <strong>Redis</strong> 里（速度更快）。<ul><li>配置：<code>SESSION_ENGINE = &#39;django.contrib.sessions.backends.cache&#39;</code></li></ul></li></ul><h4 id="2-Cookie-里的-sessionid"><a href="#2-Cookie-里的-sessionid" class="headerlink" title="2. Cookie 里的 sessionid"></a>2. Cookie 里的 <code>sessionid</code></h4><p>当登录 Django 成功后，按 F12 打开浏览器开发者工具 -&gt; Application -&gt; Cookies。</p><p>会看到一个叫 sessionid 的 Key。</p><ul><li>这就是“就诊卡号”。</li><li>如果你手动把这个 value 删了，刷新页面，你就变成“未登录”状态了。</li></ul><h4 id="3-CSRF-Token-Django-的保镖"><a href="#3-CSRF-Token-Django-的保镖" class="headerlink" title="3. CSRF Token (Django 的保镖)"></a>3. CSRF Token (Django 的保镖)</h4><p>会发现在 Cookie 里除了 sessionid，通常还有一个 csrftoken。</p><p>这是 Django 为了防止 跨站请求伪造攻击 自动生成的。</p><ul><li><strong>测试坑点</strong>：如果你用 Postman 或 Python 代码（Requests）去测 Django 的 POST 接口，往往会报 <code>403 Forbidden</code>。</li><li><strong>解决</strong>：测试时通常会在 <code>settings.py</code> 的 <code>MIDDLEWARE</code> 里暂时注释掉 <code>CsrfViewMiddleware</code>，或者在请求头里带上 Token。</li></ul><hr><h3 id="Token-vs-Session"><a href="#Token-vs-Session" class="headerlink" title="Token vs Session"></a>Token vs Session</h3><p>这是<strong>前后端分离</strong>（FastAPI&#x2F;DRF）和<strong>传统模式</strong>（Django Template）最大的区别。</p><ul><li><strong>Session 模式 (传统)</strong>：<ul><li>状态存在<strong>服务端</strong>。</li><li>依赖 Cookie（浏览器会自动带上）。</li><li>缺点：服务器压力大；如果不做特殊处理，不支持手机 App（App 没有浏览器那样的 Cookie 机制）。</li></ul></li><li><strong>Token 模式 (现代，如 JWT)</strong>：<ul><li>状态存在<strong>客户端</strong>。</li><li>登录成功后，服务器发给你一串很长的加密字符串（Token）。</li><li>以后每次请求，你都要<strong>手动</strong>在 Header 里带上 <code>Authorization: Bearer &lt;token&gt;</code>。</li><li><strong>优点</strong>：服务器不用存数据（省内存），完美支持 App 和前后端分离。</li></ul></li></ul><hr><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h3 id="一、-什么是-CSRF？（攻击原理）"><a href="#一、-什么是-CSRF？（攻击原理）" class="headerlink" title="一、 什么是 CSRF？（攻击原理）"></a>一、 什么是 CSRF？（攻击原理）</h3><p>全称：Cross-Site Request Forgery 核心逻辑：“盗用你的身份，以你的名义发送恶意请求。”</p><p>CSRF：利用浏览器**“自动携带 Cookie”**的特性，骗过服务器。</p><ol><li>用户登录受信任网站 A，并在本地生成 Cookie。</li><li>在不登出的情况下，用户访问恶意网站 B。</li><li>网站 B 的页面里隐藏了一段代码（比如一个自动提交的表单），向网站 A 发送请求（比如 <code>POST /transfer_money</code>）。</li><li>浏览器发现是发给网站 A 的，于是<strong>自动</strong>把网站 A 的 Cookie 贴上去。</li><li>网站 A 收到请求，以为是用户自愿操作的，执行成功。</li></ol><hr><h3 id="Django-如何防御？（Token-机制）"><a href="#Django-如何防御？（Token-机制）" class="headerlink" title="Django 如何防御？（Token 机制）"></a>Django 如何防御？（Token 机制）</h3><p>Django 的防御策略非常简单粗暴：<strong>“暗号（Token）”</strong>。</p><p>它不再单单信任 Cookie，而是要求每次发送 <code>POST/PUT/DELETE</code> 请求时，必须带上一个<strong>随机生成的、一次性的字符串（CSRF Token）</strong>。</p><h4 id="防御流程："><a href="#防御流程：" class="headerlink" title="防御流程："></a>防御流程：</h4><ol><li><strong>发号</strong>：当你访问表单页面时，Django 会在 HTML 里藏一个 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=&quot;随机乱码&quot;&gt;</code>。同时，Cookie 里也会存一份。</li><li><strong>核对</strong>：当你提交表单时，Django 后端会做两件事：<ul><li>拿你提交上来的 <code>value</code>。</li><li>拿 Cookie 里的 <code>secret</code>。</li><li><strong>比对</strong>：如果两者对不上，或者没带 Token，直接丢弃请求，返回 <strong>403 Forbidden</strong>。</li></ul></li></ol><p><strong>恶意网站 B 拿不到这个 Token</strong>（受限于浏览器的同源策略，它读不到网站 A 的 DOM 和 Cookie），所以它的伪造请求会失败。</p><hr><p>在写代码或测试时，会在这三种场景遇到 CSRF 问题：</p><h4 id="场景-1：传统-Django-模版-Template"><a href="#场景-1：传统-Django-模版-Template" class="headerlink" title="场景 1：传统 Django 模版 (Template)"></a>场景 1：传统 Django 模版 (Template)</h4><p>这是最标准的用法。必须在每一个 <code>form</code> 标签里手动加上 tag。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login/&quot;</span>&gt;</span><br>    &#123;% csrf_token %&#125;<br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>如果忘了加这一行，提交时必报 403。</em></p><h4 id="场景-2：前后端分离-Vue-React-Django-AJAX"><a href="#场景-2：前后端分离-Vue-React-Django-AJAX" class="headerlink" title="场景 2：前后端分离 (Vue&#x2F;React + Django) &#x2F; AJAX"></a>场景 2：前后端分离 (Vue&#x2F;React + Django) &#x2F; AJAX</h4><p>前端代码不在 Django 模版里，没法用 csrf_token。</p><p>做法：前端（JS）需要从 Cookie 里读取 csrftoken，并在发送请求（Axios&#x2F;Fetch）时，把它放到 HTTP Header 里。</p><ul><li><strong>Header Key</strong>: <code>X-CSRFToken</code></li><li><strong>Header Value</strong>: 从 Cookie <code>csrftoken</code> 字段读出来的值。</li></ul><h4 id="场景-3：DRF-接口与自动化测试"><a href="#场景-3：DRF-接口与自动化测试" class="headerlink" title="场景 3：DRF 接口与自动化测试"></a>场景 3：DRF 接口与自动化测试</h4><p><strong>“现在的 DRF 接口开发，还需要 CSRF 防御吗？”</strong></p><p><strong>答案：看认证方式。</strong></p><ol><li><strong>如果用 SessionAuthentication (Session 认证)</strong>：<ul><li><strong>需要！</strong> 因为 Session 依赖 Cookie，浏览器会自动带，所以容易被 CSRF。</li><li>DRF 会强制检查 CSRF Token。</li></ul></li><li><strong>如果用 TokenAuthentication &#x2F; JWT (Token 认证)</strong>：<ul><li><strong>不需要！</strong></li><li>因为 JWT 是放在 Header (<code>Authorization: Bearer &lt;token&gt;</code>) 里的。浏览器<strong>不会自动</strong>给恶意网站发出的请求带上 Header。恶意网站没有你的 Token，也就造不出请求。</li><li>所以，大部分纯 API 项目，通常会<strong>关闭 CSRF 检查</strong>。</li></ul></li></ol><hr><p>有时候做测试工具，或者对接第三方回调（比如微信支付回调），对方发过来请求肯定没有你的 Token，这时需要局部关闭检查。</p><p>使用装饰器 <strong><code>@csrf_exempt</code></strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.csrf <span class="hljs-keyword">import</span> csrf_exempt<br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse<br><br><span class="hljs-meta">@csrf_exempt  </span><span class="hljs-comment"># 给这个视图发“免检金牌”</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_webhook</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;即便没有Token，我也能通过！&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><hr><h3 id="自动化测试脚本怎么绕过？"><a href="#自动化测试脚本怎么绕过？" class="headerlink" title="自动化测试脚本怎么绕过？"></a>自动化测试脚本怎么绕过？</h3><p>你在写 Python 脚本（requests&#x2F;pytest）测接口时，经常被 403 拦住。解决方案有二：</p><h4 id="方法-A：做一个守规矩的“良民”"><a href="#方法-A：做一个守规矩的“良民”" class="headerlink" title="方法 A：做一个守规矩的“良民”"></a>方法 A：做一个守规矩的“良民”</h4><p>先请求一次 GET 拿到 Cookies，再从 Cookies 里提取 Token 发 POST。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>client = requests.Session()<br><br><span class="hljs-comment"># 1. 先访问首页或登录页，获取 cookie (里面包含 csrftoken)</span><br>client.get(<span class="hljs-string">&quot;http://127.0.0.1:8000/api/login/&quot;</span>)<br><br><span class="hljs-comment"># 2. 从 cookie 中提取 token</span><br>token = client.cookies[<span class="hljs-string">&#x27;csrftoken&#x27;</span>]<br><br><span class="hljs-comment"># 3. 手动带在 Header 里发送 POST</span><br>headers = &#123;<span class="hljs-string">&#x27;X-CSRFToken&#x27;</span>: token&#125;<br>resp = client.post(<span class="hljs-string">&quot;http://127.0.0.1:8000/api/cases/&quot;</span>, data=&#123;...&#125;, headers=headers)<br></code></pre></td></tr></table></figure><h4 id="方法-B：使用-Django-提供的-APIClient-推荐"><a href="#方法-B：使用-Django-提供的-APIClient-推荐" class="headerlink" title="方法 B：使用 Django 提供的 APIClient (推荐)"></a>方法 B：使用 Django 提供的 <code>APIClient</code> (推荐)</h4><p>如果是在 Django 项目内部写 <code>tests.py</code>，不要用 <code>requests</code>，用 DRF 自带的测试客户端，它会自动帮你处理 CSRF。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.test <span class="hljs-keyword">import</span> APIClient<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_case</span>():<br>    client = APIClient()<br>    <span class="hljs-comment"># APIClient 会自动忽略 CSRF 检查，或者自动填充</span><br>    resp = client.post(<span class="hljs-string">&#x27;/api/cases/&#x27;</span>, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;json&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> resp.status_code == <span class="hljs-number">201</span><br></code></pre></td></tr></table></figure><hr><h1 id="DRF"><a href="#DRF" class="headerlink" title="DRF"></a>DRF</h1><p><strong>Django REST Framework (DRF)</strong> 能在短时间内，为一个只有数据库模型的系统，生成一套标准的、带页面文档的、支持增删改查（CRUD）的 RESTful API。<strong>Serializer（序列化器）、ViewSet（视图集）、Router（路由）</strong>。</p><hr><h3 id="1-安装与注册"><a href="#1-安装与注册" class="headerlink" title="1. 安装与注册"></a>1. 安装与注册</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install djangorestframework markdown django-filter<br></code></pre></td></tr></table></figure><p>然后去 <code>TestPlatform/settings.py</code>，把 <code>rest_framework</code> 注册进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">INSTALLED_APPS = [<br>    ...<br>    <span class="hljs-string">&#x27;case_manager&#x27;</span>,<br>    <span class="hljs-string">&#x27;rest_framework&#x27;</span>, <span class="hljs-comment"># 必须加这个，否则报错</span><br>]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心组件一：Serializer-序列化器"><a href="#2-核心组件一：Serializer-序列化器" class="headerlink" title="2. 核心组件一：Serializer (序列化器)"></a>2. 核心组件一：Serializer (序列化器)</h3><p><strong>它的作用</strong>：<strong>翻译官</strong>。</p><ul><li><strong>把模型变成 JSON (序列化)</strong>：数据库查出来的 <code>TestCase</code> 对象 -&gt; 前端能懂的 JSON。</li><li><strong>把 JSON 变成模型 (反序列化)</strong>：前端发来的 JSON -&gt; 存入数据库前的数据校验和清洗。</li></ul><p><strong>类比 FastAPI</strong>：它就等于 FastAPI 里的 <strong>Pydantic Model</strong> (<code>class UserSchema(BaseModel): ...</code>)。</p><p>在 <code>case_manager</code> 下新建 <code>serializers.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> TestCase, Project<br><br><span class="hljs-comment"># 写法极其类似 ModelForm</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectSerializer</span>(serializers.ModelSerializer):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        model = Project<br>        fields = <span class="hljs-string">&#x27;__all__&#x27;</span> <span class="hljs-comment"># 偷懒写法：所有字段都序列化</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCaseSerializer</span>(serializers.ModelSerializer):<br>    <span class="hljs-comment"># 我们可以增加一些只读字段，或者嵌套显示</span><br>    <span class="hljs-comment"># 比如：我想在返回用例时，直接看到项目的名字，而不是只有一个 project_id</span><br>    project_name = serializers.CharField(source=<span class="hljs-string">&#x27;project.name&#x27;</span>, read_only=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        model = TestCase<br>        <span class="hljs-comment"># 指定我要暴露给接口的字段</span><br>        fields = [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;method&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;priority&#x27;</span>, <span class="hljs-string">&#x27;is_passed&#x27;</span>, <span class="hljs-string">&#x27;project&#x27;</span>, <span class="hljs-string">&#x27;project_name&#x27;</span>, <span class="hljs-string">&#x27;created_time&#x27;</span>]<br></code></pre></td></tr></table></figure><hr><h3 id="3-核心组件二：ViewSet-视图集"><a href="#3-核心组件二：ViewSet-视图集" class="headerlink" title="3. 核心组件二：ViewSet (视图集)"></a>3. 核心组件二：ViewSet (视图集)</h3><p>它的作用：全能管家。</p><p>ModelViewSet 一个类直接送你 5 个接口：列表(List)、详情(Retrieve)、创建(Create)、更新(Update)、删除(Destroy)。</p><p> <code>case_manager/views.py</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> viewsets<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> TestCase, Project<br><span class="hljs-keyword">from</span> .serializers <span class="hljs-keyword">import</span> TestCaseSerializer, ProjectSerializer<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectViewSet</span>(viewsets.ModelViewSet):<br>    queryset = Project.objects.<span class="hljs-built_in">all</span>()<br>    serializer_class = ProjectSerializer<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCaseViewSet</span>(viewsets.ModelViewSet):<br>    queryset = TestCase.objects.<span class="hljs-built_in">all</span>().order_by(<span class="hljs-string">&#x27;-created_time&#x27;</span>) <span class="hljs-comment"># 定义查什么数据</span><br>    serializer_class = TestCaseSerializer <span class="hljs-comment"># 定义用哪个翻译官</span><br>    <br>    <span class="hljs-comment"># 你甚至可以直接加搜索功能</span><br>    search_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>] <br></code></pre></td></tr></table></figure><hr><h3 id="4-核心组件三：Router-自动路由"><a href="#4-核心组件三：Router-自动路由" class="headerlink" title="4. 核心组件三：Router (自动路由)"></a>4. 核心组件三：Router (自动路由)</h3><p>它的作用：自动导航。</p><p>不需要再写 path(‘case&#x2F;list&#x2F;‘, …) 这种死板的路由了。Router 会自动帮你生成符合 RESTful 规范的 URL。</p><p>修改 <code>case_manager/urls.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br><span class="hljs-keyword">from</span> rest_framework.routers <span class="hljs-keyword">import</span> DefaultRouter<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br><span class="hljs-comment"># 创建一个路由器</span><br>router = DefaultRouter()<br><br><span class="hljs-comment"># 注册我们的视图集</span><br><span class="hljs-comment"># r&#x27;projects&#x27; 是 URL 前缀</span><br>router.register(<span class="hljs-string">r&#x27;projects&#x27;</span>, views.ProjectViewSet) <br>router.register(<span class="hljs-string">r&#x27;cases&#x27;</span>, views.TestCaseViewSet)<br><br>urlpatterns = [<br>    <span class="hljs-comment"># router.urls 会自动生成一堆 URL，我们把它们包进来</span><br>    path(<span class="hljs-string">&#x27;api/&#x27;</span>, include(router.urls)),<br>]<br></code></pre></td></tr></table></figure><p><em>(注：记得确保主项目 <code>TestPlatform/urls.py</code> 里包含了这个文件的路由)</em></p><hr><h3 id="对比-FastAPI"><a href="#对比-FastAPI" class="headerlink" title="对比 FastAPI"></a>对比 FastAPI</h3><table><thead><tr><th><strong>概念</strong></th><th><strong>FastAPI</strong></th><th><strong>Django DRF</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>数据校验&#x2F;定义</strong></td><td><code>Pydantic BaseModel</code></td><td><code>Serializer</code></td><td>DRF 直接跟 ORM 绑定，省代码</td></tr><tr><td><strong>路由定义</strong></td><td><code>@app.get(&quot;/items&quot;)</code></td><td><code>Router</code> + <code>urls.py</code></td><td>DRF 自动生成一套 CRUD</td></tr><tr><td><strong>依赖注入</strong></td><td><code>Depends()</code></td><td><code>Mixin</code> &#x2F; <code>Permission</code></td><td>Django 用类继承来实现复用</td></tr><tr><td><strong>文档</strong></td><td>Swagger UI (<code>/docs</code>)</td><td>Browsable API &#x2F; Swagger (需插件)</td><td>DRF 自带的界面适合调试</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Django</tag>
      
      <tag>路由</tag>
      
      <tag>模版</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytest基础学习</title>
    <link href="/2025/12/14/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/14/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Pytest基础知识"><a href="#Pytest基础知识" class="headerlink" title="Pytest基础知识"></a>Pytest基础知识</h1><p><code>pytest</code> 是 Python 技术栈的<strong>行业标准</strong>。相比于 Python 自带的 <code>unittest</code>，它更简洁、插件生态更丰富，而且能完美支持后续的 UI 自动化（Selenium&#x2F;Playwright）和接口自动化（Requests）。</p><hr><h3 id="第一阶段：Pytest-基础核心"><a href="#第一阶段：Pytest-基础核心" class="headerlink" title="第一阶段：Pytest 基础核心"></a>第一阶段：Pytest 基础核心</h3><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pytest<br></code></pre></td></tr></table></figure><h4 id="2-核心概念：pytest-如何发现测试用例"><a href="#2-核心概念：pytest-如何发现测试用例" class="headerlink" title="2. 核心概念：pytest 如何发现测试用例"></a>2. 核心概念：pytest 如何发现测试用例</h4><p>Pytest 不像 Java 的 JUnit 需要复杂的配置，它完全依靠<strong>命名规则</strong>来自动寻找测试代码。</p><ol><li><strong>文件名</strong>：必须以 <code>test_</code> 开头（推荐）或者 <code>_test</code> 结尾。例如：<code>test_login.py</code>。</li><li><strong>类名</strong>：必须以 <code>Test</code> 开头，且<strong>不能</strong>包含 <code>__init__</code> 方法。</li><li><strong>函数名</strong>：必须以 <code>test_</code> 开头。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test_demo.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><span class="hljs-comment"># 1. 正确的测试用例：以 test_ 开头</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_01</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行用例 01&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">3</span>  <span class="hljs-comment"># Python 原生 assert</span><br><br><span class="hljs-comment"># 2. 错误的测试用例：没有以 test_ 开头，pytest 会忽略它</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_test_02</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个函数不会被运行&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 3. 故意写一个失败的用例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_failed</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行用例 02&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong>断言（Assertion）：</strong> Pytest 直接使用 Python 原生的 <code>assert</code> 关键字。不需要像 Java JUnit 那样用 <code>Assert.assertEquals()</code>，也不需要 <code>self.assertEqual()</code>。Pytest 会“重写”断言，在失败时提供非常详细的变量值对比，非常方便。</li></ul><h4 id="3-运行测试（命令行参数）"><a href="#3-运行测试（命令行参数）" class="headerlink" title="3. 运行测试（命令行参数）"></a>3. 运行测试（命令行参数）</h4><p>在终端中，进入该文件所在的目录。</p><p><strong>最基础的运行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest<br></code></pre></td></tr></table></figure><p><em>会看到类似 <code>collected 2 items</code> 的提示（因为它只找到了 2 个符合命名规则的函数）。</em></p><p><strong>常用的参数：</strong></p><ol><li><p><strong><code>-v</code> (verbose)</strong>：显示详细信息，包括每个测试用例的文件名和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -v<br></code></pre></td></tr></table></figure></li><li><p><strong><code>-s</code> (show output)</strong>：默认情况下，如果用例通过，Pytest 会吞掉 <code>print()</code> 的输出。加上 <code>-s</code> 可以看到控制台打印的内容（调试时很有用）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -vs  <span class="hljs-comment"># 常用组合</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>-k &quot;keyword&quot;</code></strong>：只运行匹配名称的用例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -k <span class="hljs-string">&quot;01&quot;</span>  <span class="hljs-comment"># 只运行名字里带 01 的用例</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="4-运行结果分析"><a href="#4-运行结果分析" class="headerlink" title="4. 运行结果分析"></a>4. 运行结果分析</h4><p>运行后，你会看到几个特定的字符：</p><ul><li><strong><code>.</code> (点)</strong>：代表 <strong>PASSED</strong>（通过）。</li><li><strong><code>F</code></strong>：代表 <strong>FAILED</strong>（失败）。</li><li><strong><code>E</code></strong>：代表 <strong>ERROR</strong>（代码本身报错，而不是断言失败）。</li><li><strong><code>s</code></strong>：代表 <strong>SKIPPED</strong>（跳过）。</li></ul><hr><h3 id="5-断言的类型"><a href="#5-断言的类型" class="headerlink" title="5.断言的类型"></a>5.断言的类型</h3><p>在 <strong>pytest</strong> 中，设计哲学是 <strong>“Less is More”</strong>。它几乎废弃了所有的 <code>assertXxx</code> 方法，<strong>只用一个 Python 原生的 <code>assert</code> 关键字解决 90% 的问题</strong>，剩下的 10% 用专用辅助函数解决。</p><h3 id="1-基础断言（解决-90-的场景）"><a href="#1-基础断言（解决-90-的场景）" class="headerlink" title="1. 基础断言（解决 90% 的场景）"></a>1. 基础断言（解决 90% 的场景）</h3><p>Pytest 会在底层通过“AST 语法树重写”技术，拦截原本的 Python <code>assert</code> 语句。当断言失败时，它不只是抛出 <code>AssertionError</code>，而是会详细展示<strong>表达式两边的具体值</strong>，甚至列出列表&#x2F;字典的差异。只需要写符合 Python 语法的布尔表达式：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>unittest &#x2F; Java 风格 (旧)</strong></th><th><strong>pytest 风格 (新)</strong></th></tr></thead><tbody><tr><td><strong>值相等</strong></td><td><code>assertEqual(x, y)</code></td><td><code>assert x == y</code></td></tr><tr><td><strong>值不相等</strong></td><td><code>assertNotEqual(x, y)</code></td><td><code>assert x != y</code></td></tr><tr><td><strong>包含</strong></td><td><code>assertIn(x, list)</code></td><td><code>assert x in list</code></td></tr><tr><td><strong>不包含</strong></td><td><code>assertNotIn(x, list)</code></td><td><code>assert x not in list</code></td></tr><tr><td><strong>真&#x2F;假</strong></td><td><code>assertTrue(x)</code></td><td><code>assert x</code></td></tr><tr><td><strong>大小比较</strong></td><td><code>assertGreater(x, y)</code></td><td><code>assert x &gt; y</code></td></tr><tr><td><strong>地址相等</strong></td><td>assertSame(x, y)</td><td>assert x is y</td></tr><tr><td><strong>地址不相等</strong></td><td>assertNotSame(x, y)</td><td>assert x is not y</td></tr></tbody></table><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_basic_assertions</span>():<br>    <span class="hljs-comment"># 1. 字符串比较</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;class&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;classic&quot;</span><br><br>    <span class="hljs-comment"># 2. 列表/字典比较（非常强大，失败时会显示具体哪个元素不同）</span><br>    a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">assert</span> a == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">assert</span> a == b<br>    <span class="hljs-keyword">assert</span> a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b<br><br>    res_dict = &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>&#125;<br>    <span class="hljs-keyword">assert</span> res_dict[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">200</span><br><br>    <span class="hljs-comment"># 3. 添加自定义报错信息（可选）</span><br>    <span class="hljs-comment"># 格式：assert 表达式, &quot;报错信息&quot;</span><br>    x = <span class="hljs-number">10</span><br>    <span class="hljs-comment"># assert x &gt; 100, f&quot;x 的值 &#123;x&#125; 竟然没有大于 100！&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-浮点数断言（特殊场景）"><a href="#2-浮点数断言（特殊场景）" class="headerlink" title="2. 浮点数断言（特殊场景）"></a>2. 浮点数断言（特殊场景）</h3><p>计算机中 <code>0.1 + 0.2</code> 并不严格等于 <code>0.3</code>（精度问题）。如果做算法或金融计算，直接用 <code>==</code> 会报错。Pytest 提供了 <code>pytest.approx</code> 来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_float_compare</span>():<br>    <span class="hljs-comment"># 这在 python 中通常是 False，因为结果是 0.30000000000000004</span><br>    <span class="hljs-comment"># assert 0.1 + 0.2 == 0.3  &lt;-- 这样写会失败</span><br>    <br>    <span class="hljs-comment"># 正确写法：使用 pytest.approx</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == pytest.approx(<span class="hljs-number">0.3</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="3-异常断言（预期代码会报错）"><a href="#3-异常断言（预期代码会报错）" class="headerlink" title="3. 异常断言（预期代码会报错）"></a>3. 异常断言（预期代码会报错）</h3><p>做测试时，我们不仅要测“成功”，还要测“失败”。比如：<em>当用户输入非法参数时，程序是否按预期抛出了异常？</em> 如果程序没报错，反而是 Bug。这需要使用 <code>pytest.raises</code> 上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;除数不能为0&quot;</span>)<br>    <span class="hljs-keyword">return</span> x / y<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception</span>():<br>    <span class="hljs-comment"># 场景：我们要断言 divide(1, 0) 一定会抛出 ValueError</span><br>    <span class="hljs-comment"># 如果代码执行完没有抛出异常，这个测试用例就会 FAILED</span><br>    <span class="hljs-keyword">with</span> pytest.raises(ValueError):<br>        divide(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 进阶：断言抛出的异常信息（msg）是否正确</span><br>    <span class="hljs-keyword">with</span> pytest.raises(ValueError) <span class="hljs-keyword">as</span> excinfo:<br>        divide(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># excinfo.value 是捕获到的异常对象</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;除数不能为0&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(excinfo.value)<br></code></pre></td></tr></table></figure><ol><li><strong>绝大多数时候</strong>：直接写 <code>assert 表达式</code>。</li><li><strong>遇到小数</strong>：用 <code>assert x == pytest.approx(y)</code>。</li><li><strong>预测代码崩溃&#x2F;报错</strong>：用 <code>with pytest.raises(ErrorType):</code>。</li></ol><hr><h1 id="Fixtrue基础"><a href="#Fixtrue基础" class="headerlink" title="Fixtrue基础"></a>Fixtrue基础</h1><h3 id="什么是-Fixture？"><a href="#什么是-Fixture？" class="headerlink" title="什么是 Fixture？"></a>什么是 Fixture？</h3><p>在 <code>unittest</code> 中，如果要在测试前做准备（比如连数据库），测试后做清理（比如断开数据库），必须写固定的 <code>setUp()</code> 和 <code>tearDown()</code> 方法。两个问题：</p><ol><li><strong>太死板</strong>：所有用例都会执行它，没法挑着用。</li><li><strong>难复用</strong>：跨文件的复用很麻烦。</li></ol><p>Fixture 的本质是：依赖注入（Dependency Injection）。需要什么配置，就在测试函数的参数里写上那个 Fixture 的名字，Pytest 会自动把在这个东西准备好并“注入”进去。</p><hr><h3 id="核心知识点-1：定义与调用"><a href="#核心知识点-1：定义与调用" class="headerlink" title="核心知识点 1：定义与调用"></a>核心知识点 1：定义与调用</h3><p>使用 <code>@pytest.fixture</code> 装饰器来定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># 1. 定义一个 fixture</span><br><span class="hljs-comment"># 假设这是一个模拟登录的功能</span><br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_data</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n[Setup] 正在准备登录数据...&quot;</span>)<br>    data = &#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;abc12345&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>&#125;<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># 2. 调用 fixture</span><br><span class="hljs-comment"># 只需要把 fixture 的函数名作为参数传给测试用例即可！</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cart</span>(<span class="hljs-params">login_data</span>):<br>    <span class="hljs-comment"># Pytest 会先运行 login_data函数，把返回值赋给这里的参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在测试购物车...&quot;</span>)<br>    <span class="hljs-comment"># 可以直接使用 fixture 的返回值</span><br>    <span class="hljs-keyword">assert</span> login_data[<span class="hljs-string">&quot;user&quot;</span>] == <span class="hljs-string">&quot;admin&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_search</span>():<br>    <span class="hljs-comment"># 这个用例没有加参数，所以不会执行登录操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在测试搜索（不需要登录）...&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><ul><li><code>test_cart</code> 加上了 <code>login_data</code> 参数，Pytest 就知道：“哦，运行这个用例前，我得先去运行 <code>login_data</code> 这个函数。”</li><li><code>test_search</code> 没加，就不运行。这就是<strong>按需分配</strong>。</li></ul><hr><h3 id="核心知识点-2：-yield（前后置分离）"><a href="#核心知识点-2：-yield（前后置分离）" class="headerlink" title="核心知识点 2： yield（前后置分离）"></a>核心知识点 2： yield（前后置分离）</h3><p>问：<em>“Pytest 怎么做 Teardown（清理操作）？”</em></p><p>答案是：<strong>使用 <code>yield</code> 关键字。</strong></p><p>Fixture 函数中：</p><ul><li><code>yield</code> <strong>之前</strong>的代码：相当于 <code>setUp</code>（前置）。</li><li><code>yield</code> <strong>之后</strong>的代码：相当于 <code>tearDown</code>（后置）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():<br>    service = Service(executable_path=<span class="hljs-string">&quot;D:\\develop\\chromedriver-win64\\chromedriver.exe&quot;</span>)<br>    driver = webdriver.Chrome(service=service)<br>    driver.get(<span class="hljs-string">&quot;https://www.baidu.com/ &quot;</span>)<br>    driver.maximize_window()<br>    <span class="hljs-keyword">yield</span> driver<br>    driver.quit()<br></code></pre></td></tr></table></figure><p>在每个测试函数开始时： 启动 Chrome 浏览器。 打开百度首页并最大化窗口。 将 <code>driver</code>对象提供给测试函数使用。在每个测试函数结束后： 关闭浏览器。</p><hr><h3 id="核心知识点-3：作用域（Scope）——-性能优化的关键"><a href="#核心知识点-3：作用域（Scope）——-性能优化的关键" class="headerlink" title="核心知识点 3：作用域（Scope）—— 性能优化的关键"></a>核心知识点 3：作用域（Scope）—— 性能优化的关键</h3><p>默认情况下，Fixture 是 <code>function</code> 级别的。也就是说，<strong>每个</strong>调用它的测试用例运行前，它都会从头跑一遍。</p><p>有时候很浪费。比如“打开浏览器”或者“登录”，不希望跑 10 个用例就打开 10 次浏览器。我希望打开一次，跑完 10 个用例，再关闭。</p><p>这时就需要配置 <code>scope</code> 参数：</p><table><thead><tr><th><strong>Scope 级别</strong></th><th><strong>含义</strong></th><th><strong>生命周期</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>function</strong> (默认)</td><td>函数级</td><td>每个测试函数执行一次</td><td>需重置的数据，如计算器归零</td></tr><tr><td><strong>class</strong></td><td>类级</td><td>每个测试类执行一次</td><td>测试类中共用的简单配置</td></tr><tr><td><strong>module</strong></td><td>模块级</td><td>每个 .py 文件执行一次</td><td>单个文件内的全局配置</td></tr><tr><td><strong>session</strong></td><td>会话级</td><td><strong>整个自动化脚本只执行一次</strong></td><td><strong>最常用！</strong> 初始化数据库连接、登录获取Token、启动浏览器</td></tr></tbody></table><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一个只执行一次的 fixture</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">global_config</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; [Session Start] 读取全局配置...&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; [Session End] 清理全局资源...&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="核心知识点-4：conftest-py-——-共享之王"><a href="#核心知识点-4：conftest-py-——-共享之王" class="headerlink" title="核心知识点 4：conftest.py —— 共享之王"></a>核心知识点 4：conftest.py —— 共享之王</h3><p>如果有 10 个测试文件（<code>test_a.py</code>, <code>test_b.py</code>…）都需要用到 <code>login</code> 这个 fixture，怎么办？</p><p>不需要在每个文件里都定义一遍，也不需要 import。只需要在项目根目录下创建一个名为 conftest.py 的文件。</p><p><strong>规则：</strong></p><ol><li>文件名是 <code>conftest.py</code>。</li><li>Pytest 会自动读取它里面的 fixture。</li><li>所有测试文件都可以直接使用里面定义的 fixture，就像它们定义在本地一样。</li></ol><p><strong>项目结构示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">project/<br>├── conftest.py      &lt;-- 定义 fixture: login, db_conn<br>├── test_case1.py    &lt;-- 直接在参数里写 login<br>└── test_case2.py    &lt;-- 直接在参数里写 db_conn<br></code></pre></td></tr></table></figure><hr><h1 id="parametrize基础"><a href="#parametrize基础" class="headerlink" title="parametrize基础"></a>parametrize基础</h1><p>数据驱动（Data-Driven Testing） </p><hr><h3 id="1-核心神器：-pytest-mark-parametrize"><a href="#1-核心神器：-pytest-mark-parametrize" class="headerlink" title="1. 核心神器：@pytest.mark.parametrize"></a>1. 核心神器：@pytest.mark.parametrize</h3><p>它的作用是：<strong>参数化</strong>。它可以让同一段测试代码，根据输入数据的不同，自动生成多条测试用例。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;变量名字符串&quot;</span>, [数据列表]</span>)</span><br></code></pre></td></tr></table></figure><h4 id="实战演练：模拟登录测试"><a href="#实战演练：模拟登录测试" class="headerlink" title="实战演练：模拟登录测试"></a>实战演练：模拟登录测试</h4><p>假设有一个登录函数，我们需要测试：</p><ol><li>账号密码正确 -&gt; 成功</li><li>密码错误 -&gt; 失败</li><li>账号为空 -&gt; 失败</li></ol><p>不使用参数化（笨办法）：写 3 个函数，代码重复率极高。</p><p><strong>使用参数化（聪明办法）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># 假设的业务代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-keyword">and</span> password == <span class="hljs-string">&quot;123456&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fail&quot;</span><br><br><span class="hljs-comment"># 数据驱动测试</span><br><span class="hljs-comment"># 1. 第一个参数：变量名，用字符串表示，逗号隔开，必须和下面函数参数名一致</span><br><span class="hljs-comment"># 2. 第二个参数：一个列表，列表里的每个元素是一个元组（代表一组测试数据）</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;user, pwd, expected&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;success&quot;</span></span>),  <span class="hljs-comment"># 用例1</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;wrong&quot;</span>, <span class="hljs-string">&quot;fail&quot;</span></span>),      <span class="hljs-comment"># 用例2</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;fail&quot;</span></span>)           <span class="hljs-comment"># 用例3</span></span></span><br><span class="hljs-params"><span class="hljs-meta">]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_logic</span>(<span class="hljs-params">user, pwd, expected</span>):<br>    <span class="hljs-comment"># Pytest 会自动循环 3 次，每次提取一组数据传进来</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n测试数据: 用户=<span class="hljs-subst">&#123;user&#125;</span>, 密码=<span class="hljs-subst">&#123;pwd&#125;</span>&quot;</span>)<br>    res = login(user, pwd)<br>    <span class="hljs-keyword">assert</span> res == expected<br></code></pre></td></tr></table></figure><p>运行结果：显示 collected 3 items。即它自动把1个函数变成了3个独立的测试用例运行！</p><hr><h3 id="2-进阶技巧：笛卡尔积（组合测试）"><a href="#2-进阶技巧：笛卡尔积（组合测试）" class="headerlink" title="2. 进阶技巧：笛卡尔积（组合测试）"></a>2. 进阶技巧：笛卡尔积（组合测试）</h3><p><em>“如果我要测 3 种手机系统（iOS, Android, Harmony）搭配 2 种网络环境（WiFi, 5G），一共 6 种组合，怎么写最简单？”</em></p><p>不需要手动列出 6 个元组，只需要<strong>堆叠装饰器</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;os&quot;</span>, [<span class="hljs-string">&quot;iOS&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>, <span class="hljs-string">&quot;Harmony&quot;</span>]</span>)</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;net&quot;</span>, [<span class="hljs-string">&quot;WiFi&quot;</span>, <span class="hljs-string">&quot;5G&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_mobile_env</span>(<span class="hljs-params">os, net</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前环境: <span class="hljs-subst">&#123;os&#125;</span> + <span class="hljs-subst">&#123;net&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>结果</strong>：Pytest 会自动算出所有组合，生成 6 条用例。</p><hr><h3 id="3-全局配置文件：pytest-ini"><a href="#3-全局配置文件：pytest-ini" class="headerlink" title="3. 全局配置文件：pytest.ini"></a>3. 全局配置文件：pytest.ini</h3><p>在实际工作中，不会每次都敲 pytest -vs，也不会希望 Pytest 去扫描所有文件夹。我们需要一个“管家”。</p><p>在项目<strong>根目录</strong>下创建一个名为 <code>pytest.ini</code> 的文件（注意：Windows下文件内尽量不要出现中文注释，容易报编码错误，或者保存为 ANSI 格式）。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-comment">; 1. 默认命令行参数</span><br><span class="hljs-comment">; 以后直接敲 pytest 就行，不需要敲 pytest -vs 了</span><br><span class="hljs-attr">addopts</span> = -vs --html=./report.html<br><br><span class="hljs-comment">; 2. 指定测试用例的搜索目录</span><br><span class="hljs-comment">; 告诉 pytest 只去 testcases 目录下找，别去 venv 目录下瞎找，提升速度</span><br><span class="hljs-attr">testpaths</span> = ./testcases<br><br><span class="hljs-comment">; 3. 修改文件搜索规则（如果你非要以 check_ 开头）</span><br><span class="hljs-attr">python_files</span> = test_*.py check_*.py<br><span class="hljs-attr">python_classes</span> = Test* Check*<br><span class="hljs-attr">python_functions</span> = test_* check_*<br><br><span class="hljs-comment">; 4. 注册自定义标记（为了消除警告）</span><br><span class="hljs-attr">markers</span> =<br>    smoke: 冒烟测试<br>    user_manage: 用户管理模块<br></code></pre></td></tr></table></figure><p>有了这个文件，以后你在终端只需要输入简单的 <code>pytest</code> 四个字母，所有的配置（详细输出、生成报告、路径过滤）都会自动生效。</p><hr><h1 id="Allure基础"><a href="#Allure基础" class="headerlink" title="Allure基础"></a>Allure基础</h1><p><strong>Allure</strong> 是目前测试圈最顶级的测试报告框架。Allure 的报告支持多语言、由 Java 渲染、交互性极强，并且可以直接对接 Jenkins。</p><hr><h3 id="运行并生成报告"><a href="#运行并生成报告" class="headerlink" title="运行并生成报告"></a>运行并生成报告</h3><p>生成报告分两步走：<strong>运行</strong> -&gt; <strong>渲染</strong>。</p><h4 id="1-修改-pytest-ini（推荐）"><a href="#1-修改-pytest-ini（推荐）" class="headerlink" title="1. 修改 pytest.ini（推荐）"></a>1. 修改 pytest.ini（推荐）</h4><p>为了不用每次都敲长命令，修改你的 <code>pytest.ini</code>，加入 <code>addopts</code> 配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -vs --alluredir=./temps --clean-alluredir<br><span class="hljs-attr">testpaths</span> = ./<br><span class="hljs-attr">python_files</span> = test_*.py<br><span class="hljs-attr">python_classes</span> = Test*<br><span class="hljs-attr">python_functions</span> = test_*<br></code></pre></td></tr></table></figure><h4 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2. 运行测试"></a>2. 运行测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest<br></code></pre></td></tr></table></figure><p>运行完后，项目目录下多了一个 <code>temps</code> 文件夹，里面全是乱码一样的 <code>.json</code> 和 <code>.txt</code> 文件。<strong>这是原始数据，不是直接看的。</strong></p><h4 id="3-渲染并查看报告"><a href="#3-渲染并查看报告" class="headerlink" title="3. 渲染并查看报告"></a>3. 渲染并查看报告</h4><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">allure serve ./temps<br></code></pre></td></tr></table></figure><p>*注意：<code>serve</code> 后面跟的是临时数据目录。*执行后，它会自动启动一个临时的 Web 服务（通常是 Java 启动的 Jetty），并自动在默认浏览器打开一个网页。<strong>这就是传说中的 Allure 报告！</strong></p><hr><h3 id="定制化显示"><a href="#定制化显示" class="headerlink" title="定制化显示"></a>定制化显示</h3><p>默认的报告虽然好看，但用例名字都是 <code>test_calc[1-2-3]</code> 这种代码名。需要用装饰器给报告加“元数据”,即加入 Allure 的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> allure  <span class="hljs-comment"># 导入 allure 库</span><br><br><span class="hljs-comment"># 1. Feature: 标注这是哪个大模块</span><br><span class="hljs-meta">@allure.feature(<span class="hljs-params"><span class="hljs-string">&quot;计算器模块&quot;</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCalculator</span>:<br><br>    <span class="hljs-comment"># 2. Story: 标注这是哪个具体功能/用户故事</span><br><span class="hljs-meta">    @allure.story(<span class="hljs-params"><span class="hljs-string">&quot;除法运算功能&quot;</span></span>)</span><br>    <span class="hljs-comment"># 3. Title: 自定义用例标题（支持参数化占位符）</span><br><span class="hljs-meta">    @allure.title(<span class="hljs-params"><span class="hljs-string">&quot;测试用例：&#123;a&#125; 除以 &#123;b&#125;&quot;</span></span>)</span><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;a, b, expected&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0.3333333333</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ZeroDivisionError</span>)</span></span><br><span class="hljs-params"><span class="hljs-meta">    ]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_div</span>(<span class="hljs-params">self, a, b, expected</span>):<br>        <span class="hljs-comment"># 4. Step: 标注测试步骤，报告里会分层级显示</span><br>        <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">f&quot;步骤1：准备数据 a=<span class="hljs-subst">&#123;a&#125;</span>, b=<span class="hljs-subst">&#123;b&#125;</span>&quot;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备数据...&quot;</span>)<br>        <br>        <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">&quot;步骤2：执行计算并断言&quot;</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(expected, <span class="hljs-built_in">type</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(expected, Exception):<br>                <span class="hljs-keyword">with</span> pytest.raises(expected):<br>                    <span class="hljs-keyword">assert</span> a / b<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">assert</span> a / b == pytest.approx(expected)<br></code></pre></td></tr></table></figure><p>报告变得非常清晰：左侧菜单有了“计算器模块”，点进去能看到“除法运算功能”，右侧的步骤里有“步骤1”、“步骤2”，甚至报错时会有红色的堆栈信息。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pytest</tag>
      
      <tag>单元测试</tag>
      
      <tag>fixture</tag>
      
      <tag>allure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP测试</title>
    <link href="/2025/12/13/APP%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/12/13/APP%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="APP与Web区别"><a href="#APP与Web区别" class="headerlink" title="APP与Web区别"></a>APP与Web区别</h1><p>系统架构：APP是C&#x2F;S结构，web是B&#x2F;S结构 </p><p>C&#x2F;S（Client&#x2F;Server ） ：即客户端&#x2F;服务器，需要下载安装客户端。</p><p>B&#x2F;S（Browser&#x2F;Server ）：即浏览器&#x2F;服务器，基于浏览器访问。</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image1.png" class="" title="app测试"><hr><h1 id="APP发布"><a href="#APP发布" class="headerlink" title="APP发布"></a>APP发布</h1><h3 id="1-App-发布的完整环境流转"><a href="#1-App-发布的完整环境流转" class="headerlink" title="1. App 发布的完整环境流转"></a>1. App 发布的完整环境流转</h3><p>在 App 发布给真实用户之前，通常会经历几个不同的环境：</p><ol><li><strong>开发环境 (Dev Environment)</strong><ul><li><strong>谁在用</strong>：开发人员 (Developers)。</li><li><strong>特点</strong>：代码变动最频繁，最不稳定，功能可能只有雏形。</li></ul></li><li><strong>测试环境 (Test &#x2F; SIT - System Integration Testing)</strong><ul><li><strong>谁在用</strong>：<strong>测试&#x2F;测开</strong>。</li><li><strong>特点</strong>：比较稳定。开发提测后，在这里找 Bug。<strong>所有的自动化脚本通常也是针对这个环境编写的。</strong></li></ul></li><li><strong>预发布环境 (Pre-production &#x2F; UAT - User Acceptance Testing)</strong><ul><li><strong>谁在用</strong>：产品经理、测试人员、少部分内部种子用户。</li><li><strong>特点</strong>：<strong>数据源通常连接的是真实的线上数据库</strong>（或者经过脱敏的线上数据），但是代码是新的。这是上线前的最后一道防线，用来检查配置是否正确。</li></ul></li><li><strong>生产环境 (Production)</strong><ul><li><strong>谁在用</strong>：真实用户。</li><li><strong>特点</strong>：绝对严谨，出了问题就是“线上事故”。</li></ul></li></ol><hr><h3 id="2-核心发布策略"><a href="#2-核心发布策略" class="headerlink" title="2. 核心发布策略"></a>2. 核心发布策略</h3><p>问：“你们的 App 是怎么上线的？是一次性全量发布吗？”</p><h4 id="A-全量发布"><a href="#A-全量发布" class="headerlink" title="A. 全量发布"></a>A. 全量发布</h4><ul><li><strong>含义</strong>：设定一个时间点，所有应用商店同步上架，所有用户都能下载到新版本。</li><li><strong>风险</strong>：如果有一个严重的崩溃 Bug（Crash），所有用户都会受影响，损失巨大。</li></ul><h4 id="B-灰度发布-Gray-scale-Release-Canary-Release-——-非常重要"><a href="#B-灰度发布-Gray-scale-Release-Canary-Release-——-非常重要" class="headerlink" title="B. 灰度发布 (Gray-scale Release &#x2F; Canary Release) —— 非常重要"></a>B. 灰度发布 (Gray-scale Release &#x2F; Canary Release) —— <strong>非常重要</strong></h4><ul><li><strong>含义</strong>：先让 <strong>一小部分人</strong> 更新到新版本，如果没有问题，再慢慢扩大范围，直到全量。</li><li><strong>怎么做</strong>：<ul><li><strong>按比例</strong>：先放 5% 的用户，再放 20%，最后 100%。</li><li><strong>按地区</strong>：比如先在某个省份发布。</li><li><strong>按白名单</strong>：先让公司内部员工更新。</li></ul></li><li><strong>测试职责</strong>：在灰度期间，测试人员要通过后台监控系统（如 Bugly, Sentry）紧盯崩溃率。如果报错飙升，必须立即<strong>回滚 (Rollback)</strong>。</li></ul><h4 id="C-A-B-测试"><a href="#C-A-B-测试" class="headerlink" title="C. A&#x2F;B 测试"></a>C. A&#x2F;B 测试</h4><ul><li><strong>含义</strong>：这不是为了修 Bug，而是为了<strong>验证功能</strong>。<ul><li>A 组用户看到红色的购买按钮。</li><li>B 组用户看到蓝色的购买按钮。</li><li>看哪组下单的人多，最后决定上线哪个版本。</li></ul></li></ul><hr><h3 id="3-Android-与-iOS-发布的区别"><a href="#3-Android-与-iOS-发布的区别" class="headerlink" title="3. Android 与 iOS 发布的区别"></a>3. Android 与 iOS 发布的区别</h3><p>这也是 App 测试必须要知道的背景知识，因为审核机制完全不同。</p><table><thead><tr><th><strong>维度</strong></th><th><strong>Android (安卓)</strong></th><th><strong>iOS (苹果)</strong></th></tr></thead><tbody><tr><td><strong>应用商店</strong></td><td><strong>渠道极其分散</strong>。国内主要有：华为、小米、OPPO、VIVO、应用宝、百度手机助手等。</td><td><strong>App Store 唯一渠道</strong> (TestFlight 用于内测)。</td></tr><tr><td><strong>审核时间</strong></td><td>较快（几小时到1天），有时候甚至无需审核（企业包）。</td><td><strong>非常严格</strong>且慢（通常需要 1-3 天），甚至可能因为 UI 不符合苹果规范被拒。</td></tr><tr><td><strong>安装包格式</strong></td><td><code>.apk</code></td><td><code>.ipa</code></td></tr><tr><td><strong>测试痛点</strong></td><td>需要验证<strong>多渠道包</strong>（统计不同商店的下载量），每个商店的包签名可能不同。</td><td>需要验证审核被拒后的紧急修复流程。</td></tr></tbody></table><hr><h3 id="4-强更、弱更与热更新"><a href="#4-强更、弱更与热更新" class="headerlink" title="4. 强更、弱更与热更新"></a>4. 强更、弱更与热更新</h3><p>这是用户感知层面的更新方式，测试时需要专门覆盖这几种场景。</p><ol><li><strong>强制更新 (Force Update)</strong>：<ul><li>App 启动时弹窗，<strong>只有一个“立即更新”按钮</strong>，不更新就退步出，没法用。</li><li><em>测试点</em>：通常用于修复重大 Bug 或 API 协议变更，必须确保旧版本被完全拦截。</li></ul></li><li><strong>非强制更新&#x2F;弱更 (Optional Update)</strong>：<ul><li>弹窗有“以后再说”或“取消”按钮。</li><li><em>测试点</em>：用户点取消后，App 的核心功能（如数据接口）还能不能兼容旧版本？</li></ul></li><li><strong>热更新 (Hotfix) —— 测开必须了解的技术</strong>：<ul><li><strong>原理</strong>：用户<strong>不需要</strong>去应用商店重新下载几十 MB 的安装包。App 启动时默默下载一个小补丁（Patch），直接替换代码。</li><li><strong>优势</strong>：速度快，用户无感知。常用于游戏或修复紧急 Bug。</li><li><em>测试点</em>：补丁下载失败怎么办？补丁是否生效了？</li></ul></li></ol><hr><h3 id="📝-总结：测试人员在发布阶段要做什么？"><a href="#📝-总结：测试人员在发布阶段要做什么？" class="headerlink" title="📝 总结：测试人员在发布阶段要做什么？"></a>📝 总结：测试人员在发布阶段要做什么？</h3><ol><li><strong>回归测试 (Regression Test)</strong>：确保新功能没问题，且<strong>旧功能没有被改坏</strong>。</li><li><strong>验收测试 (UAT)</strong>：产品经理确认功能符合需求。</li><li><strong>兼容性检查</strong>：抽取目前市场上主流的 TOP 10 手机型号（测开通常会维护一个云真机平台）跑一遍安装启动。</li><li><strong>渠道包检查</strong>：如果是安卓，要检查不同应用商店的包（华为包、小米包）是否都能正常唤起支付、登录（因为不同渠道SDK可能不同）。</li></ol><hr><h1 id="APP功能测试"><a href="#APP功能测试" class="headerlink" title="APP功能测试"></a>APP功能测试</h1><p>App 的<strong>功能测试（Functional Testing）</strong>，其核心逻辑和 Web 测试、桌面软件测试是一致的。都是基于<strong>黑盒测试</strong>方法（如等价类划分、边界值分析、错误推测法），验证“<strong>输入</strong>”经过“<strong>处理</strong>”后，得到的“<strong>输出</strong>”是否符合需求文档。</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image2.png" class="" title="功能测试"><h4 id="第一部分：输入框验证（对应图中“1-输入”）"><a href="#第一部分：输入框验证（对应图中“1-输入”）" class="headerlink" title="第一部分：输入框验证（对应图中“1. 输入”）"></a>第一部分：输入框验证（对应图中“1. 输入”）</h4><p>这部分主要考察<strong>等价类划分</strong>（有效数据 vs 无效数据）和<strong>错误推测</strong>。</p><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>基础输入</strong></td><td>输入“牙膏” (汉字)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“yagao” (全拼)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“yag” 或 “gao” (部分拼音)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“toothpaste” (英文)</td><td>搜索出牙膏相关商品</td></tr><tr><td><strong>混合输入</strong></td><td>输入“牙gao” (中英混合)</td><td>搜索出牙膏相关商品</td></tr><tr><td><strong>纠错机制</strong></td><td>输入“呀高”、“牙稿” (同音错别字)</td><td><strong>纠错提示</strong>：“您是否要找‘牙膏’？”，或直接展示牙膏结果，但顶部提示“已为您显示‘牙膏’的搜索结果”</td></tr><tr><td><strong>同音&#x2F;数字</strong></td><td>输入“yinle”</td><td>搜索出“音乐”相关商品</td></tr><tr><td></td><td>输入“12”</td><td>搜索结果包含带“12”的商品，也包含带“十二”的商品</td></tr><tr><td><strong>符号处理</strong></td><td>输入“牙 膏】” (含空格和特殊符号)</td><td>忽略干扰符号，搜索结果等同于“牙膏”</td></tr><tr><td><strong>自动补全</strong></td><td>输入“手机”</td><td>下拉联想框出现“手机壳”、“手机膜”、“手机支架”等高频词</td></tr><tr><td></td><td>删除输入框内容</td><td>联想框消失，恢复初始状态（如显示搜索历史）</td></tr></tbody></table><h4 id="第二部分：匹配逻辑验证（对应图中“2-匹配”）"><a href="#第二部分：匹配逻辑验证（对应图中“2-匹配”）" class="headerlink" title="第二部分：匹配逻辑验证（对应图中“2. 匹配”）"></a>第二部分：匹配逻辑验证（对应图中“2. 匹配”）</h4><p>这部分是搜索的核心算法逻辑，主要验证<strong>后端逻辑</strong>。</p><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>多维度匹配</strong></td><td>输入“华为” (品牌)</td><td>列表展示华为手机、华为电脑、华为数据线等</td></tr><tr><td></td><td>输入某一具体商品标题</td><td>精确匹配到该商品</td></tr><tr><td></td><td>输入商品分类 (如“零食”)</td><td>展示该分类下的所有商品</td></tr><tr><td><strong>分词匹配</strong></td><td>输入“康师傅饮料”</td><td><strong>分词逻辑</strong>：搜索结果应包含“康师傅”品牌且属于“饮料”类的商品 (即 A 且 B)</td></tr><tr><td><strong>为空匹配</strong></td><td>不输入任何内容，直接点击搜索</td><td><strong>需求规定</strong>：展示“推荐内容” (这里要确认是热门推荐还是个性化推荐)</td></tr><tr><td><strong>无结果处理</strong></td><td>输入乱码或数据库不存在的词 (如“@#￥%”)</td><td>展示“未找到相关商品”，并推荐相似商品或热门商品 (依据图中“联想相近词”的需求)</td></tr></tbody></table><h4 id="第三部分：排序与结果展示（对应图中“3-排序”）"><a href="#第三部分：排序与结果展示（对应图中“3-排序”）" class="headerlink" title="第三部分：排序与结果展示（对应图中“3. 排序”）"></a>第三部分：排序与结果展示（对应图中“3. 排序”）</h4><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>默认排序</strong></td><td>搜索任意关键词</td><td>列表第一页商品默认按<strong>销量</strong>降序排列</td></tr><tr><td><strong>手动排序</strong></td><td>点击“价格”</td><td>第一次点击按价格升序，再次点击按价格降序</td></tr><tr><td></td><td>点击“最新”</td><td>按商品上架时间倒序排列</td></tr><tr><td></td><td>点击“人气&#x2F;收藏”</td><td>按收藏量或浏览量排序</td></tr><tr><td><strong>分页加载</strong></td><td>上滑列表到底部</td><td>自动加载下一页数据（通常每页 10-20 条）</td></tr></tbody></table><hr><h3 id="🔥-第四部分：App-特有的功能测试点"><a href="#🔥-第四部分：App-特有的功能测试点" class="headerlink" title="🔥 第四部分：App 特有的功能测试点"></a>🔥 第四部分：App 特有的功能测试点</h3><p><strong>针对 App 搜索，补充以下场景：</strong></p><h4 id="1-软键盘交互-Interaction"><a href="#1-软键盘交互-Interaction" class="headerlink" title="1. 软键盘交互 (Interaction)"></a>1. 软键盘交互 (Interaction)</h4><ul><li><strong>键盘唤起</strong>：点击输入框，手机软键盘是否正常弹出？会不会遮挡输入框？</li><li><strong>搜索键触发</strong>：点击软键盘右下角的“搜索”&#x2F;“Go”&#x2F;“回车”按钮，是否能触发搜索？（<strong>这个非常重要，很多 Bug 出在这里</strong>）</li><li><strong>键盘收起</strong>：开始滚动搜索结果列表时，软键盘是否自动收起？</li></ul><h4 id="2-搜索历史-Search-History"><a href="#2-搜索历史-Search-History" class="headerlink" title="2. 搜索历史 (Search History)"></a>2. 搜索历史 (Search History)</h4><ul><li><strong>历史记录</strong>：搜索成功后，该词条是否存入“历史记录”？</li><li><strong>历史点击</strong>：点击历史记录中的词，是否直接发起搜索？</li><li><strong>历史清除</strong>：是否有“清空历史”的按钮？</li></ul><h4 id="3-语音搜索-Voice-Input"><a href="#3-语音搜索-Voice-Input" class="headerlink" title="3. 语音搜索 (Voice Input)"></a>3. 语音搜索 (Voice Input)</h4><ul><li>如果输入框有麦克风图标，点击能否唤起语音输入？识别的文字是否自动填入输入框？</li></ul><h4 id="4-特殊场景-Interruptions-Network"><a href="#4-特殊场景-Interruptions-Network" class="headerlink" title="4. 特殊场景 (Interruptions &amp; Network)"></a>4. 特殊场景 (Interruptions &amp; Network)</h4><ul><li><strong>网络延迟</strong>：在网络极差（弱网）时，输入“手”，联想词“手机”还没加载出来，用户这时候快速输入了“表”，联想结果会不会乱跳？（比如突然跳出“手”的联想结果覆盖了“手表”的结果）。</li><li><strong>前后台切换</strong>：在搜索结果页切到后台（比如回微信消息），再切回来，页面是否保持原样？还是被刷新了？</li></ul><hr><h1 id="APP专项测试"><a href="#APP专项测试" class="headerlink" title="APP专项测试"></a>APP专项测试</h1><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image8.png" class="" title="专项测试"><h2 id="安装、卸载、升级"><a href="#安装、卸载、升级" class="headerlink" title="安装、卸载、升级"></a>安装、卸载、升级</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image3.png" class="" title="安装测试"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image4.png" class="" title="卸载升级测试"><p>挑几个测试点写测试用例：</p><table><thead><tr><th><strong>模块</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>安装</strong></td><td><strong>P0</strong></td><td><strong>正常安装流程验证</strong></td><td>手机空间充足，网络正常</td><td>1. 获取最新 APK 安装包 2. 点击安装</td><td>1. 安装过程流畅无报错 2. 桌面出现正确图标 3. 点击图标能正常启动</td></tr><tr><td><strong>安装</strong></td><td>P1</td><td><strong>存储空间不足时的安装处理</strong></td><td>手机剩余存储空间 <strong>小于</strong> 安装包大小</td><td>1. 点击 APK 进行安装 2. 观察系统提示</td><td>1. 安装被终止，无 Crash 2. 弹出“存储空间不足”提示</td></tr><tr><td><strong>安装</strong></td><td>P2</td><td><strong>安装过程中断网&#x2F;断电测试</strong></td><td>手机处于安装进度条约 50% 时</td><td>1. 突然断开网络或强制关机 2. 重启手机检查环境</td><td>1. 安装失败 2. 系统无残留不可用的垃圾文件 3. 再次安装能正常进行</td></tr><tr><td><strong>安装</strong></td><td>P2</td><td><strong>低版本覆盖安装高版本（降级）</strong></td><td>手机已安装 V2.0 版本</td><td>1. 尝试覆盖安装 V1.0 版本</td><td>1. 系统提示安装失败（禁止降级） 2. 原有 V2.0 版本不受影响</td></tr><tr><td><strong>卸载</strong></td><td><strong>P0</strong></td><td><strong>正常卸载及数据清理</strong></td><td>App 已登录并产生缓存数据</td><td>1. 长按图标卸载 2. 检查文件管理器</td><td>1. 图标消失 2. 应用私有目录下的缓存文件被彻底删除</td></tr><tr><td><strong>卸载</strong></td><td>P1</td><td><strong>App 运行时强制卸载</strong></td><td>App 正在后台播放音频或下载</td><td>1. 进入系统设置强制卸载该 App</td><td>1. 后台进程立即终止（声音&#x2F;下载停止） 2. 卸载成功，无报错</td></tr><tr><td><strong>卸载</strong></td><td>P2</td><td><strong>取消卸载操作</strong></td><td>无</td><td>1. 点击卸载 2. 在确认弹窗点“取消”</td><td>1. App 未被卸载 2. 点击 App 能正常进入，账号未登出</td></tr><tr><td><strong>升级</strong></td><td><strong>P0</strong></td><td><strong>跨版本升级数据兼容性</strong></td><td>安装 V1.0 并保存了本地数据（如购物车）</td><td>1. 直接覆盖安装 V3.0（跳过 V2.0） 2. 启动 App 检查数据</td><td>1. 启动正常 2. <strong>V1.0 的购物车数据在 V3.0 中完整保留</strong></td></tr><tr><td><strong>升级</strong></td><td>P1</td><td><strong>非 WiFi 环境下应用内升级提醒</strong></td><td>手机使用 4G&#x2F;5G 网络</td><td>1. App 内点击“检查更新” 2. 点击“下载”</td><td>1. 弹出流量消耗提示框 2. 只有用户确认后才开始下载</td></tr><tr><td><strong>升级</strong></td><td>P1</td><td><strong>强制更新策略验证</strong></td><td>服务端配置该版本为“强更”</td><td>1. 启动旧版本 App</td><td>1. 弹出更新弹窗，且<strong>无</strong>关闭&#x2F;取消按钮 2. 不更新无法使用 App 任何功能</td></tr></tbody></table><h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image5.png" class="" title="兼容性测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image6.png" class="" title="兼容性测试2"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>屏幕适配</strong></td><td><strong>P0</strong></td><td><strong>异形屏（刘海&#x2F;挖孔&#x2F;灵动岛）UI 适配验证</strong></td><td>选取一台刘海屏或挖孔屏手机（如 iPhone 14 Pro 或部分安卓机）</td><td>1. 启动 App 进入首页 2. 观察顶部导航栏和状态栏区域 3. 旋转屏幕（横屏模式）</td><td>1. 核心内容未被“刘海”遮挡 2. 按钮可点击，未错位 3. 底部操作栏未被系统手势条覆盖</td></tr><tr><td><strong>系统版本</strong></td><td><strong>P0</strong></td><td><strong>高低版本系统权限兼容性测试</strong></td><td>准备两台手机： A: Android 13&#x2F;14 (高版本) B: Android 6.0&#x2F;8.0 (低版本)</td><td>1. 在两台手机安装 App 2. 首次启动，触发需要权限的功能（如拍照、定位）</td><td>1. <strong>高版本</strong>：必须弹出运行时权限申请框（Runtime Permission），拒绝后 App 不崩溃 2. <strong>低版本</strong>：功能正常运行，无闪退</td></tr><tr><td><strong>应用共存</strong></td><td>P1</td><td><strong>后台音频播放冲突测试</strong></td><td>1. 手机后台正在使用网易云&#x2F;QQ音乐播放歌曲 2. 手机未静音</td><td>1. 打开被测 App 2. 进入播放视频或音频的页面 3. 点击播放</td><td>1. <strong>音频焦点抢占</strong>：后台音乐应自动暂停或音量降低（Duck） 2. App 内视频声音正常播出 3. 退出 App 视频后，后台音乐恢复（可选，视需求而定）</td></tr><tr><td><strong>硬件兼容</strong></td><td>P2</td><td><strong>蓝牙外设连接切换测试</strong></td><td>1. 手机蓝牙开启 2. 准备一副蓝牙耳机</td><td>1. App 正在外放播放视频 2. 连接蓝牙耳机 3. 断开蓝牙耳机</td><td>1. 连接时：声音无缝切换到耳机，且无杂音 2. 断开时：视频自动暂停（防止在公共场合突然外放尴尬）或切换回扬声器</td></tr><tr><td><strong>分辨率</strong></td><td>P1</td><td><strong>低分辨率小屏机型显示测试</strong></td><td>选取老旧机型或设置模拟器为 720*1280 分辨率</td><td>1. 打开 App 包含长文本或列表的页面 2. 调整字体大小（如系统设置了大字体）</td><td>1. 文字未重叠、未溢出边界 2. 底部按钮依然可见，未被挤出屏幕外</td></tr></tbody></table><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image7.png" class="" title="兼容性测试3"><p>问：“市面上手机好几千款，不可能把这些用例在每一台手机上都跑一遍吧？”</p><p>标准的工业级解决方案是：</p><ol><li><strong>Top N 策略</strong>：<ul><li>查看线上的用户数据（比如通过百度统计、Umeng），找出你们 App 用户量最大的 <strong>Top 20 - Top 50</strong> 款机型进行覆盖。</li></ul></li><li><strong>云测平台 (Cloud Testing)</strong>：<ul><li>使用 <strong>Testin (云测)</strong>、<strong>腾讯 WeTest</strong> 等平台。</li><li><strong>怎么做</strong>：只需要把打包好的 APK 上传到网页上，选择“兼容性测试”，勾选 100 台热门手机。</li><li><strong>结果</strong>：云平台会自动安装、启动、运行 Monkey（随机乱点），然后给一份报告，哪款手机安装失败，哪款手机 UI 错位（带截图）。</li></ul></li></ol><h2 id="push消息推送"><a href="#push消息推送" class="headerlink" title="push消息推送"></a>push消息推送</h2><p>Push消息是APP推送的各种通知。 如：点赞、评论、关注</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image9.png" class="" title="push消息推送测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image10.png" class="" title="push消息推送测试2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image11.png" class="" title="push消息推送测试3"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>状态场景</strong></td><td><strong>P0</strong></td><td><strong>App 后台运行时的消息接收与展示</strong></td><td>1. 手机网络正常 2. App 登录并切换至后台（Home 键）</td><td>1. 通过推送平台发送一条标准通知 2. 观察手机通知栏</td><td>1. 手机震动&#x2F;响铃（视系统设置而定） 2. 通知栏弹出消息，标题内容无误 3. 收到消息时 App <strong>不应</strong>被系统唤醒至前台（保持后台状态）</td></tr><tr><td><strong>状态场景</strong></td><td>P1</td><td><strong>App 前台运行时的消息提示</strong></td><td>App 正在当前屏幕运行（用户正在使用）</td><td>1. 发送一条推送消息</td><td>1. <strong>UI 体验检查</strong>：通常不应直接弹出系统通知栏打断用户操作 2. 常见逻辑是：App 顶部出现应用内横幅提醒，或仅在图标上显示小红点（Badging）</td></tr><tr><td><strong>状态场景</strong></td><td>P1</td><td><strong>App 离线&#x2F;进程被杀后的接收能力</strong></td><td>手动划掉 App 进程，确保 App 未运行</td><td>1. 发送推送消息 2. 等待 1-2 分钟</td><td>1. <strong>安卓</strong>：取决于推送通道（厂商通道如华为&#x2F;小米应能收到；第三方 App 通道可能收不到） 2. <strong>iOS</strong>：必须能收到（走 APNs 系统通道）</td></tr><tr><td><strong>交互跳转</strong></td><td><strong>P0</strong></td><td><strong>点击推送消息跳转至指定详情页 (Deep Link)</strong></td><td>手机通知栏已收到一条关于“商品 A 降价”的推送</td><td>1. 点击该条通知消息</td><td>1. 自动启动 App 2. <strong>直接跳转</strong>到“商品 A”的详情页，而不是 App 首页 3. 如果 App 未登录，应先跳登录页，登录后自动跳回商品页</td></tr><tr><td><strong>精准推送</strong></td><td>P1</td><td><strong>特定用户定向推送验证</strong></td><td>准备两台手机： A 手机登录用户 User1 B 手机登录用户 User2</td><td>1. 后台配置仅向 User1 发送优惠券通知 2. 观察两台手机</td><td>1. <strong>A 手机</strong>：收到推送 2. <strong>B 手机</strong>：<strong>未</strong>收到推送（验证身份匹配逻辑）</td></tr><tr><td><strong>用户设置</strong></td><td>P2</td><td><strong>客户端关闭推送权限验证</strong></td><td>在 App 的“设置”或手机系统设置中，<strong>关闭</strong>“接收通知”开关</td><td>1. 后台发送全量推送消息</td><td>1. 手机通知栏<strong>没有任何反应</strong> 2. App 启动后，消息中心（站内信）可能依然有红点（视需求而定，但系统级通知必须屏蔽）</td></tr><tr><td><strong>过期逻辑</strong></td><td>P2</td><td><strong>消息过期&#x2F;TTL 测试</strong></td><td>手机开启飞行模式（断网）</td><td>1. 后台发送一条有效期为 5 分钟的限时抢购消息 2. 等待 10 分钟后 3. 手机关闭飞行模式（恢复网络）</td><td>1. 手机<strong>不应</strong>收到该条消息（因为已过期，服务器应丢弃该消息，避免用户点进去发现活动结束了）</td></tr></tbody></table><p>问：“为什么有时候安卓手机收不到推送，苹果却能收到？” 你可以用图中的知识点回答：</p><ol><li><strong>机制不同</strong>：<ul><li>根据 <code>image_cd349e.png</code>，Push 本质是<strong>长连接</strong>。</li><li><strong>iOS</strong>：统一走苹果官方的 <strong>APNs</strong> (Apple Push Notification service)。只要苹果服务器不崩，手机有网就能收到。</li><li><strong>Android</strong>：虽然谷歌有 GCM&#x2F;FCM，但在国内无法使用。所以各家 App 只能自己搭建或者用第三方（极光、友盟）。</li></ul></li><li><strong>保活问题</strong>：<ul><li>安卓为了省电，系统经常杀后台进程。进程一死，长连接就断了，消息就推不进来了。</li><li><strong>解决方案</strong>：这就是为什么现在的 App 都要接入 <strong>厂商通道</strong>（华为推送、小米推送等）。因为厂商的推送服务是系统级的，杀不掉。</li></ul></li></ol><h2 id="交叉测试"><a href="#交叉测试" class="headerlink" title="交叉测试"></a>交叉测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image12.png" class="" title="交叉测试"><p>一个功能正在执行过程中，另外一个事件或操作对该过程进行干扰</p><table><thead><tr><th><strong>干扰类型</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>电话干扰</strong></td><td><strong>P0</strong></td><td><strong>App 核心操作中接听电话验证</strong></td><td>1. 手机插入 SIM 卡 2. App 正在进行核心操作（如：正在支付输入密码、正在播放视频、正在录入表单）</td><td>1. 使用另一台手机呼叫测试机 2. 测试机<strong>接通</strong>电话，通话 5 秒 3. 挂断电话，自动返回 App</td><td>1. <strong>来电时</strong>：App 自动暂停（视频&#x2F;音乐暂停），不应有异响 2. <strong>挂断后</strong>：App 页面恢复原状，<strong>输入框内的文字不消失</strong>，支付流程可继续，无 Crash</td></tr><tr><td><strong>电话干扰</strong></td><td>P1</td><td><strong>App 运行时拒接&#x2F;挂断电话</strong></td><td>同上</td><td>1. 呼叫测试机 2. 测试机直接点击**“挂断”**</td><td>1. 电话提示框消失 2. App 画面无缝恢复，操作流畅，无卡顿</td></tr><tr><td><strong>网络干扰</strong></td><td><strong>P0</strong></td><td><strong>WiFi 与 4G&#x2F;5G 网络动态切换</strong></td><td>手机连接 WiFi，且已开启 4G 数据流量</td><td>1. App 正在加载列表或下载文件 2. 突然关闭 WiFi 开关（切换到 4G） 3. 等待 10 秒后再打开 WiFi</td><td>1. <strong>切 4G 时</strong>：如下载大文件，应暂停并提示“正在使用流量”；如仅浏览资讯，应自动平滑切换无感知 2. <strong>切回 WiFi 时</strong>：自动恢复下载或数据加载 3. 全程无闪退、无“网络异常”死循环提示</td></tr><tr><td><strong>系统弹窗</strong></td><td>P1</td><td><strong>低电量&#x2F;闹钟弹窗干扰</strong></td><td>1. 设置闹钟为 1 分钟后响铃 2. 或模拟低电量（部分手机可用 ADB 模拟）</td><td>1. 在 App 内滑动浏览 2. 等待闹钟响铃或低电量弹窗弹出</td><td>1. 系统弹窗&#x2F;闹钟画面覆盖在 App 之上 2. <strong>App 进程不被杀掉</strong> 3. 关闭弹窗后，App 页面状态保持不变</td></tr><tr><td><strong>硬件干扰</strong></td><td>P2</td><td><strong>蓝牙设备连接与断开</strong></td><td>App 正在播放音频&#x2F;视频</td><td>1. 打开蓝牙耳机充电仓（自动连接） 2. 听一会儿后，关闭蓝牙（断开）</td><td>1. <strong>连接时</strong>：声音自动切到耳机 2. <strong>断开时</strong>：App 视频应<strong>自动暂停</strong>（防止公共场合外放尴尬），或者切回扬声器但用户需手动继续播放</td></tr><tr><td><strong>屏幕旋转</strong></td><td>P2</td><td><strong>横竖屏切换的数据保持</strong></td><td>手机开启“自动旋转”，App 支持横屏</td><td>1. 在输入框输入一段文字 2. 旋转手机 90 度（竖屏变横屏） 3. 再转回来</td><td>1. UI 布局适配正常（按钮没飞出屏幕） 2. <strong>关键点</strong>：输入框里的<strong>文字没有被清空</strong></td></tr></tbody></table><p>问交叉测试，可以补充以下两个核心观点：</p><ol><li><strong>资源抢占（Resource Preemption）</strong>：<ul><li>电话和闹钟属于<strong>系统级最高优先级</strong>事件。当它们发生时，App 必须乖乖让出音频焦点（Audio Focus）和屏幕焦点。如果 App “死皮赖脸”还要播放声音，就会出现 Bug（比如电话里依然听到游戏背景音）。</li></ul></li><li><strong>生命周期（Lifecycle）管理</strong>：<ul><li>当电话进来时，App 会经历 <code>onPause()</code> -&gt; <code>onStop()</code>。</li><li>电话挂断后，App 会经历 <code>onRestart()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code>。</li><li>交叉测试本质上就是在测<strong>开发人员有没有在 <code>onPause</code> 里保存数据，在 <code>onResume</code> 里恢复数据</strong>。</li></ul></li></ol><h2 id="用户体验测试"><a href="#用户体验测试" class="headerlink" title="用户体验测试"></a>用户体验测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image13.png" class="" title="用户体验测试"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>易用性</strong></td><td><strong>P0</strong></td><td><strong>空数据状态下的引导页验证</strong></td><td>1. 新注册账号 2. 进入“我的订单”页面</td><td>1. 查看页面显示内容</td><td>1. <strong>不可留白</strong> 2. 显示友好的插图（如箱子图标） 3. 提供“去首页逛逛”的跳转按钮</td></tr><tr><td><strong>易用性</strong></td><td>P1</td><td><strong>按钮点击热区（点击范围）测试</strong></td><td>App 首页右上角有“消息”小图标</td><td>1. 不点击图标中心，点击图标边缘或略微偏离的位置</td><td>1. <strong>能成功触发点击</strong>（实际响应区域应比图标视觉区域大，防止误触或点不中）</td></tr><tr><td><strong>UI</strong></td><td>P1</td><td><strong>加载过程中的反馈提示</strong></td><td>网络设为慢速（弱网）</td><td>1. 点击“提交订单” 2. 等待服务器响应</td><td>1. 必须出现 <code>Loading</code> 转圈动画或进度条 2. 按钮置灰，<strong>禁止用户重复点击</strong>提交</td></tr><tr><td><strong>横竖屏</strong></td><td>P2</td><td><strong>横屏状态下的表格显示</strong></td><td>手机开启自动旋转，进入“股票行情”列表</td><td>1. 旋转手机至横屏</td><td>1. 列表自动适配宽度 2. <strong>显示更多列的信息</strong>（如原本只显示价格，现在显示涨跌幅），而不是单纯拉伸文字</td></tr><tr><td><strong>辅助功能</strong></td><td>P2</td><td><strong>系统超大字体适配测试</strong></td><td>1. 在手机系统设置中，将字体调至<strong>最大</strong> 2. 启动 App</td><td>1. 查看首页新闻标题 2. 查看底部导航栏文字</td><td>1. App 文字随系统变大 2. <strong>文字未重叠、未被遮挡</strong>（这是很多 App 的重灾区）</td></tr><tr><td><strong>易用性</strong></td><td>P2</td><td><strong>操作步骤层级深度检查</strong></td><td>无</td><td>1. 尝试找到“修改密码”功能 2. 计数点击次数</td><td>1. 路径清晰 2. 点击层级不宜过深（建议不超过 4 层菜单）</td></tr></tbody></table><hr><h1 id="APP性能测试"><a href="#APP性能测试" class="headerlink" title="APP性能测试"></a>APP性能测试</h1><p>测试app使用期间占用硬件资源（cpu、内存、流量、电量）使用情况.分类 ① App程序运行时占用手机硬件资源情况 ② App稳定性</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image14.png" class="" title="app性能测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image15.png" class="" title="app性能测试2"><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image16.png" class="" title="内存1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image17.png" class="" title="内存2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image18.png" class="" title="内存3"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>MEM_001</strong></td><td><strong>P0</strong></td><td><strong>App 首页静态内存占用基准测试</strong></td><td>1. 手机安装 SoloPi 和被测 App (如 tpshop) 2. 杀掉后台其他无关进程</td><td>1. 打开 SoloPi，勾选 <strong>Memory (PSS)</strong> 监控指标，开启悬浮窗。 2. 启动被测 App，进入首页。 3. <strong>静置 1 分钟</strong>，不要进行任何操作。</td><td>1. PSS 曲线应保持相对平稳，无明显持续上升趋势。 2. 记录一个平均值（例如 200MB）作为<strong>基准线 (Baseline)</strong>。</td></tr><tr><td><strong>MEM_002</strong></td><td><strong>P0</strong></td><td><strong>重复进出页面检测内存泄漏 (核心用例)</strong></td><td>1. SoloPi 悬浮窗已开启 2. 处于 App 首页</td><td>1. 点击进入一个<strong>内容丰富</strong>的二级页面（如“商品详情页”，包含大图&#x2F;视频）。 2. 待加载完成后，点击“返回”回到首页。 3. <strong>重复上述“进入-返回”操作 20 次</strong>。 4. 观察 SoloPi 的曲线变化。</td><td>1. <strong>正常</strong>：内存曲线呈锯齿状（进详情页升高，退回首页降低），最终回到基准线附近。 2. <strong>异常（内存泄漏）</strong>：曲线呈<strong>阶梯状上升</strong>（如 <code>image_c1e1f7.png</code> 所示），每次返回首页后，内存都比上一次高，无法回落到基准线。</td></tr><tr><td><strong>MEM_003</strong></td><td>P1</td><td><strong>长时间滑动列表的内存稳定性测试</strong></td><td>1. SoloPi 悬浮窗已开启 2. 进入“商品列表”或“信息流”页面</td><td>1. 快速向下滑动屏幕，不断加载新图片和数据。 2. 持续滑动 3-5 分钟。 3. 停止滑动，静置 1 分钟。</td><td>1. 滑动过程中内存会上升（正常缓存）。 2. <strong>关键点</strong>：停止滑动后，内存应有明显的<strong>回落</strong>机制（释放离开屏幕的图片资源），不能一直维持在最高点。</td></tr></tbody></table><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image19.png" class="" title="CPU1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image20.png" class="" title="CPU2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image21.png" class="" title="CPU3"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>CPU_001</strong></td><td><strong>P0</strong></td><td><strong>App 静默&#x2F;待机状态 CPU 占用测试</strong></td><td>1. 启动 SoloPi 监控 CPU 2. 手机无后台下载任务</td><td>1. 启动被测 App，进入首页。 2. <strong>不进行任何操作</strong>，静置 1 分钟。 3. 观察“应用进程 CPU”曲线。</td><td>1. CPU 占用率应极低（通常 &lt; 5%）。 2. 曲线应为一条接近 0 的直线。 3. <strong>如果不为 0</strong>：说明代码里有死循环或无效的轮询（Polling）在空转。</td></tr><tr><td><strong>CPU_002</strong></td><td><strong>P0</strong></td><td><strong>高频滑动&#x2F;复杂动效下的 CPU 峰值测试</strong></td><td>1. 进入 App 内容最密集的页面（如商品瀑布流、朋友圈）</td><td>1. 快速上下滑动屏幕，持续 1 分钟。 2. 或者进入直播间&#x2F;播放高清视频。 3. 观察 CPU 峰值。</td><td>1. 允许有瞬间峰值（如加载时飙到 60%-80%）。 2. <strong>严禁</strong>长时间维持在 90% 以上。 3. 操作停止后，CPU 应迅速回落到低水平。</td></tr><tr><td><strong>CPU_003</strong></td><td>P1</td><td><strong>后台运行时的 CPU 占用（防偷跑）</strong></td><td>1. App 正在运行</td><td>1. 按 Home 键将 App 切到后台。 2. 锁屏，静置 5 分钟。 3. 解锁查看 SoloPi 记录的数据。</td><td>1. <strong>应用进程 CPU 必须接近 0%</strong>。 2. 如果在后台 CPU 依然很高，说明 App 在偷偷挖矿、死循环或者滥用定位，必须报 Bug。</td></tr></tbody></table><p>问：“发现 CPU 占用高，怎么分析？” </p><blockquote><p>“先看 SoloPi 的 <strong>应用进程 CPU</strong> 和 <strong>全局占用 CPU</strong>。 如果是<strong>全局高、应用低</strong>，可能是手机后台有系统更新或别的程序在跑，属于环境干扰。 如果是<strong>应用高</strong>，结合场景：</p><ol><li>如果是<strong>静止</strong>时高，多半是<strong>死循环</strong>或者<strong>定时器</strong>没关。</li><li>如果是<strong>滑动</strong>时高且卡顿，可能是<strong>UI 渲染</strong>太复杂（主线程阻塞），这往往就是导致 <strong>ANR</strong> 的元凶。”</li></ol></blockquote><h2 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image22.png" class="" title="流量1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image23.png" class="" title="流量2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>NET_001</strong></td><td><strong>P0</strong></td><td><strong>App 首次启动与页面加载流量消耗</strong></td><td>1. 手机连接 4G&#x2F;5G 网络（模拟真实环境） 2. 清除 App 缓存（确保是冷启动）</td><td>1. 打开 SoloPi，勾选 <strong>网络 (Network)</strong> 监控。 2. 启动 App，进入首页，等待加载完成。 3. 记录消耗的流量。</td><td>1. 首页加载流量应在合理范围内（如纯文本+缩略图页不应超过 2MB）。 2. 图片资源应经过压缩，不应直接加载原图。</td></tr><tr><td><strong>NET_002</strong></td><td><strong>P0</strong></td><td><strong>二次加载缓存机制验证 (省流测试)</strong></td><td>1. 已完成 NET_001 的操作（首页已加载过） 2. <strong>不清除缓存</strong></td><td>1. 杀掉进程，重新启动 App。 2. 再次进入同一个首页。 3. 对比本次流量与 NET_001 的流量。</td><td>1. <strong>本次流量应显著低于首次加载</strong>。 2. 说明 App 成功利用了本地缓存（Cache），没有重复向服务器请求相同的图片资源。</td></tr><tr><td><strong>NET_003</strong></td><td>P1</td><td><strong>后台静默流量偷跑检测</strong></td><td>1. App 处于运行状态</td><td>1. 按 Home 键切入后台。 2. 观察 SoloPi 的流量数据，持续 5 分钟。</td><td>1. <strong>Process Downlink Traffic (进程下行流量)</strong> 应接近 0KB。 2. 如果后台还在持续跑流量，说明有未关闭的长连接或轮询，属于 Bug。</td></tr><tr><td><strong>NET_004</strong></td><td>P2</td><td><strong>特定业务场景流量评估</strong></td><td>SoloPi 开启</td><td>1. 打开 App 首页。 2. <strong>上下滑动浏览动态 20秒</strong>。 3. 停止滑动。</td><td>1. 记录这 20秒消耗的总流量（例如 5MB）。 2. 与竞品（如淘宝&#x2F;京东）进行对比，如果远高于竞品，说明代码优化不足。</td></tr></tbody></table><p>“如果发现流量消耗过大，建议开发怎么改？” </p><ol><li><strong>图片压缩</strong>：缩略图用小图，点击大图再加载原图。</li><li><strong>数据缓存</strong>：加载过的数据存本地数据库，下次别再请求了。</li><li><strong>增量更新</strong>：刷新列表时，只请求最新的几条数据，而不是把整个列表重新拉一遍。</li><li><strong>数据压缩</strong>：接口传输的 JSON 数据进行 Gzip 压缩。</li></ol><h2 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h2><p>APP应用使用时对电池电量的平均消耗 常见的耗电量大的场景： 定位 网络传输 屏幕亮度 wake_locker（锁屏-解锁）</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image24.png" class="" title="电量1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image25.png" class="" title="电量2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>BAT_001</strong></td><td><strong>P0</strong></td><td><strong>高频操作场景下的电量消耗测试</strong></td><td>1. 手机电量充足（&gt;30%） 2. 屏幕亮度固定（如 50%） 3. 关闭蓝牙&#x2F;GPS（减少干扰）</td><td>1. 打开 SoloPi，勾选 <strong>电池 (Battery)</strong> 监控指标。 2. 启动 App 进入首页。 3. <strong>上下滑动浏览动态 2 分钟</strong>（模拟用户逛淘宝）。 4. 停止操作，查看消耗的电量值（mAh）。</td><td>1. 记录 2 分钟内的耗电量（例如 15mAh）。 2. <strong>横向对比</strong>：不能比竞品（如京东）高出太多。 3. 手机背部无异常发烫。</td></tr><tr><td><strong>BAT_002</strong></td><td>P1</td><td><strong>后台静默耗电测试（待机测试）</strong></td><td>1. App 保持后台运行 2. 手机锁屏</td><td>1. SoloPi 开启监控。 2. 将 App 切到后台，锁屏静置 <strong>30 分钟</strong>。 3. 唤醒手机看数据。</td><td>1. 耗电量应极低（接近系统待机水平）。 2. 如果 30 分钟掉了 5% 电，说明 App 唤醒了 GPS 或在该休眠时不休眠（WakeLock 锁死）。</td></tr><tr><td><strong>BAT_003</strong></td><td>P2</td><td><strong>硬件调用场景耗电测试</strong></td><td>1. 开启 GPS 或 摄像头</td><td>1. 使用 App 的地图导航或直播功能 10 分钟。 2. 记录耗电曲线。</td><td>1. 耗电会明显增加（这是正常的）。 2. 但不应导致手机温度触发“过热保护”而降频卡顿。</td></tr></tbody></table><h2 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image26.png" class="" title="流畅度1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image27.png" class="" title="流畅度2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>FPS_001</strong></td><td><strong>P0</strong></td><td><strong>长列表快速滑动流畅度测试</strong></td><td>1. 手机开启 60Hz 或更高刷新率 2. SoloPi 勾选 <strong>帧率 (FPS)</strong></td><td>1. 打开 App，进入内容丰富的首页（如商品流）。 2. <strong>快速上下滑动屏幕</strong>，持续 <strong>2分钟</strong>，不要停。 3. 观察 SoloPi 记录的 FPS 均值。</td><td>1. 平均 FPS 应保持在 <strong>50帧以上</strong>（针对 60Hz 屏幕）。 2. 过程中无明显的<strong>冻结帧 (Jank)</strong>（即 FPS 突然掉到 0 这种卡死现象）。</td></tr><tr><td><strong>FPS_002</strong></td><td>P1</td><td><strong>复杂动画转场流畅度测试</strong></td><td>1. SoloPi 监控开启</td><td>1. 点击进入一个带有复杂转场动画的页面（如直播间、送礼物特效）。 2. 反复进出该页面 10 次。</td><td>1. 动画播放过程中 FPS 不应低于 24帧。 2. 画面无撕裂、无掉帧。</td></tr><tr><td><strong>FPS_003</strong></td><td>P2</td><td><strong>静态页面 FPS 校验 (反向测试)</strong></td><td>1. SoloPi 监控开启</td><td>1. 进入一个纯文字详情页。 2. <strong>手指离开屏幕，完全静止不动</strong> 30秒。</td><td>1. <strong>FPS 极低（甚至为 0）是正常的</strong>。 2. 这不是 Bug，而是系统为了省电停止了 GPU 绘制（SurfaceFlinger 休眠）。</td></tr></tbody></table><hr><h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-什么是-ADB？-What-is-ADB"><a href="#1-什么是-ADB？-What-is-ADB" class="headerlink" title="1. 什么是 ADB？(What is ADB?)"></a>1. 什么是 ADB？(What is ADB?)</h3><p>全称 <strong>Android Debug Bridge</strong>（安卓调试桥）。</p><ul><li><strong>通俗理解</strong>：它是一座 <strong>“桥”</strong>，或者说是一个 <strong>“翻译官”</strong>。</li><li><strong>作用</strong>：它连接了 <strong>电脑 (PC&#x2F;Mac)</strong> 和 <strong>手机 (Android Device)</strong>。<ul><li>电脑不懂手机的内部指令，手机也不听电脑的鼠标点击。</li><li>ADB 的作用就是：在电脑的黑窗口（CMD）里输入一行命令，ADB 把它翻译给手机，手机执行后，再把结果（比如日志、截图）传回给电脑。</li></ul></li></ul><hr><h3 id="2-ADB-的工作原理（架构）"><a href="#2-ADB-的工作原理（架构）" class="headerlink" title="2. ADB 的工作原理（架构）"></a>2. ADB 的工作原理（架构）</h3><p>ADB 采用的是 <strong>C&#x2F;S 架构 (Client-Server)</strong>，由三部分组成：</p><ol><li><strong>Client (客户端)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>电脑</strong> 上。</li><li><strong>是谁</strong>：就是你敲命令的那个黑窗口（CMD &#x2F; Terminal）。当你输入 <code>adb devices</code> 时，就是 Client 在发号施令。</li></ul></li><li><strong>Server (服务端)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>电脑</strong> 后台运行。</li><li><strong>作用</strong>：它是一个管家。它负责管理 Client 和手机之间的通信。如果 ADB 挂了，通常重启这个 Server 就能好 (<code>adb kill-server</code> &#x2F; <code>adb start-server</code>)。</li></ul></li><li><strong>Daemon (守护进程 adbd)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>手机</strong> 上。</li><li><strong>作用</strong>：它是手机里的执行者。你发出的命令，最终都是由它在手机后台默默执行的。</li></ul></li></ol><hr><h3 id="3-为什么学-ADB？"><a href="#3-为什么学-ADB？" class="headerlink" title="3. 为什么学 ADB？"></a>3. 为什么学 ADB？</h3><ul><li><strong>自动化测试的灵魂</strong>：<ul><li>Appium等自动化工具，底层全是调用的 ADB 命令。<strong>没有 ADB，就没有自动化。</strong></li></ul></li><li><strong>抓取崩溃日志 (Logcat)</strong>：<ul><li>App 闪退了，界面上什么都不显示。开发会问：“日志呢？” 这时候你需要用 <code>adb logcat</code> 把手机肚子里的报错信息抓出来。</li></ul></li><li><strong>模拟特殊场景</strong>：<ul><li>怎么模拟“低电量”？怎么模拟“弱网”？怎么在不碰手机的情况下“模拟点击屏幕”？全靠 ADB。</li></ul></li></ul><hr><h3 id="4-ADB常用功能预览"><a href="#4-ADB常用功能预览" class="headerlink" title="4. ADB常用功能预览"></a>4. ADB常用功能预览</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>能帮你做什么？</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td><strong>设备连接</strong></td><td>查看手机连没连上</td><td><code>adb devices</code></td></tr><tr><td><strong>应用管理</strong></td><td>电脑上一键安装&#x2F;卸载 App</td><td><code>adb install xxx.apk</code></td></tr><tr><td><strong>文件传输</strong></td><td>把电脑的电影传到手机，或把手机截图传到电脑</td><td><code>adb push</code> &#x2F; <code>adb pull</code></td></tr><tr><td><strong>日志获取</strong></td><td>抓取 Crash 报错信息</td><td><code>adb logcat</code></td></tr><tr><td><strong>模拟操作</strong></td><td>模拟点击、滑动、按键（Home&#x2F;返回）</td><td><code>adb shell input tap ...</code></td></tr><tr><td><strong>性能监控</strong></td><td>查看 CPU、内存、启动时间</td><td><code>adb shell dumpsys ...</code></td></tr></tbody></table><hr><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h4 id="1-检查设备连接"><a href="#1-检查设备连接" class="headerlink" title="1. 检查设备连接"></a>1. 检查设备连接</h4><p>这是每天工作的第一件事。不连上设备，后面什么都做不了。</p><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb devices<br></code></pre></td></tr></table></figure></li><li><p><strong>可能看到的结果</strong>：</p><ul><li><p><strong>成功</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">List of devices attached<br>HT75W020xxxx    device  &lt;-- 看到这个 <span class="hljs-string">&quot;device&quot;</span> 才算真正成功<br></code></pre></td></tr></table></figure></li><li><p><strong>失败 1 (Unauthorized)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HT75W020xxxx    unauthorized<br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：手机上没点“允许”。<strong>解决</strong>：看手机屏幕，会有一个弹窗“允许 USB 调试吗？”，勾选“始终允许”并点击确认。</li></ul></li><li><p><strong>失败 2 (Offline)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HT75W020xxxx    offline<br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：连接线接触不良或 ADB 服务卡死。<strong>解决</strong>：拔掉线重插，或者输入 <code>adb kill-server</code> 然后再 <code>adb start-server</code>。</li></ul></li></ul></li></ul><h4 id="2-安装与卸载-App"><a href="#2-安装与卸载-App" class="headerlink" title="2. 安装与卸载 App"></a>2. 安装与卸载 App</h4><ul><li><p><strong>安装 App</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb install 路径\安装包.apk<br><span class="hljs-comment"># 技巧：输入 &quot;adb install &quot; (有个空格)，然后直接把 apk 文件拖进黑窗口，路径会自动生成！</span><br></code></pre></td></tr></table></figure><ul><li><em>覆盖安装（保留数据）</em>：<code>adb install -r 路径\安装包.apk</code></li></ul></li><li><p>卸载 App：注意：卸载不能用“应用名”（比如微信），必须用 “包名” (Package Name)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb uninstall 包名<br><span class="hljs-comment"># 例如：adb uninstall com.tencent.mm</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-查找包名"><a href="#3-查找包名" class="headerlink" title="3. 查找包名"></a>3. 查找包名</h4><p><strong>查看手机里所有的 App</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell pm list packages<br></code></pre></td></tr></table></figure><ul><li><strong>查看当前正在运行的 App 包名</strong><ol><li>在手机上打开你想测的 App（比如淘宝）。</li><li>在电脑输入：<ul><li><strong>Windows</strong>: <code>adb shell dumpsys window | findstr mCurrentFocus</code></li><li><strong>Mac</strong>: <code>adb shell dumpsys window | grep mCurrentFocus</code></li></ul></li><li>输出结果中，<code>&#123;&#125;</code> 里的内容，斜杠 <code>/</code> 前面的就是包名。<ul><li>例如：<code>u0a205 com.taobao.taobao/com.taobao.tao.TBMainActivity...</code></li><li>包名就是：<code>com.taobao.taobao</code></li></ul></li></ol></li></ul><hr><h3 id="靶场App"><a href="#靶场App" class="headerlink" title="靶场App"></a>靶场App</h3><h4 id="1-Sauce-Labs-Demo-App-Swag-Labs-——-强烈推荐"><a href="#1-Sauce-Labs-Demo-App-Swag-Labs-——-强烈推荐" class="headerlink" title="1. Sauce Labs Demo App (Swag Labs) —— 强烈推荐"></a>1. Sauce Labs Demo App (Swag Labs) —— <strong>强烈推荐</strong></h4><ul><li><strong>特点</strong>：包含标准的登录页、商品列表、拖拽操作、WebView 混合页面、绘图板等，专门为了刁难自动化工具而设计的。</li><li><strong>下载地址 (GitHub)</strong>：<a href="https://github.com/saucelabs/my-demo-app-android/releases">Sauce Labs My Demo App Android Releases</a></li></ul><h4 id="2-ApiDemos-官方-API-演示"><a href="#2-ApiDemos-官方-API-演示" class="headerlink" title="2. ApiDemos (官方 API 演示)"></a>2. ApiDemos (官方 API 演示)</h4><p>这是 Google 官方提供的“安卓字典”。</p><ul><li><strong>特点</strong>：它没有任何商业逻辑，但包含了安卓系统里<strong>所有的</strong>控件（按钮、下拉框、弹窗、通知栏等）。</li><li><strong>下载地址 (GitHub)</strong>：<a href="https://github.com/appium/android-apidemos/releases">ApiDemos-debug.apk</a></li></ul><hr><h2 id="文件管理与日志操作"><a href="#文件管理与日志操作" class="headerlink" title="文件管理与日志操作"></a>文件管理与日志操作</h2><p>三条命令：<code>push</code>、<code>pull</code> 和 <code>logcat</code>。</p><h3 id="📂-Part-1：文件搬运工-Push-Pull"><a href="#📂-Part-1：文件搬运工-Push-Pull" class="headerlink" title="📂 Part 1：文件搬运工 (Push &amp; Pull)"></a>📂 Part 1：文件搬运工 (Push &amp; Pull)</h3><p>安卓手机的文件系统和 Windows 不太一样，记住一个“万能路径”：<strong><code>/sdcard/</code></strong>。这通常是手机的内部存储根目录</p><h4 id="1-adb-push：电脑-➔-手机"><a href="#1-adb-push：电脑-➔-手机" class="headerlink" title="1. adb push：电脑 ➔ 手机"></a>1. <code>adb push</code>：电脑 ➔ 手机</h4><ul><li><p><strong>场景</strong>：测“上传头像”功能，需要往手机里放一张图片；或者要测“导入文档”功能。</p></li><li><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb push &lt;电脑上的文件路径&gt; &lt;手机上的目标路径&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>👉 实操任务 A：把一个文件推送到手机</strong></p><ol><li><p><strong>准备</strong>：在你的电脑桌面上新建一个文本文档，命名为 <code>test.txt</code>，里面随便写点字（比如 “Hello ADB”）。</p></li><li><p><strong>执行</strong>：在 CMD 里输入以下命令（配合拖拽大法）：</p><ul><li><p>输入 <code>adb push </code> (注意空格)</p></li><li><p>把桌面的 <code>test.txt</code> <strong>拖进</strong> CMD 窗口。</p></li><li><p>接着输入手机路径 <code> /sdcard/</code> (注意前面有个空格)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb push C:\Users\LilPear2002\Desktop\test.txt /sdcard/<br>C:\Users\LilPear2002\Desktop\test.txt: 1 file pushed. 0.0 MB/s (9 bytes <span class="hljs-keyword">in</span> 0.028s)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>看到 <code>1 file pushed</code>，成功！</p></li></ol><h4 id="2-adb-pull：手机-➔-电脑"><a href="#2-adb-pull：手机-➔-电脑" class="headerlink" title="2. adb pull：手机 ➔ 电脑"></a>2. <code>adb pull</code>：手机 ➔ 电脑</h4><ul><li><p><strong>场景</strong>：手机截图了 Bug，或者录屏了，需要把文件拉到电脑上发给开发；或者把手机里的数据库拉出来分析。</p></li><li><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb pull &lt;手机上的文件路径&gt; &lt;电脑上的目标路径&gt;<br></code></pre></td></tr></table></figure></li></ul><p>👉 实操任务 B：把刚才的文件拉回来</p><p>我们把刚才推过去的 test.txt 拉回到电脑的 C盘根目录（或者其他盘），并改个名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb pull /sdcard/test.txt C:\Users\LilPear2002\Desktop\test_back.txt<br>/sdcard/test.txt: 1 file pulled. 0.0 MB/s (9 bytes <span class="hljs-keyword">in</span> 0.008s)<br></code></pre></td></tr></table></figure><hr><h3 id="📝-Part-2：日志侦探-Logcat-——-重点中的重点"><a href="#📝-Part-2：日志侦探-Logcat-——-重点中的重点" class="headerlink" title="📝 Part 2：日志侦探 (Logcat) —— 重点中的重点"></a>📝 Part 2：日志侦探 (Logcat) —— 重点中的重点</h3><p>当 App 闪退（Crash）或者报错时，界面上往往什么都不说。开发问：“Log 呢？” 这时候就要用 adb logcat 把手机报错信息全倒出来。</p><h4 id="1-体验“刷屏”"><a href="#1-体验“刷屏”" class="headerlink" title="1. 体验“刷屏”"></a>1. 体验“刷屏”</h4><p>在 CMD 里直接输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb logcat<br></code></pre></td></tr></table></figure><ul><li><strong>现象</strong>：会看到屏幕疯狂滚动，像黑客帝国一样。这是手机系统和所有 App 正在产生的实时日志。</li><li><strong>停止</strong>：按键盘上的 <strong><code>Ctrl + C</code></strong> 终止。</li></ul><h4 id="2-“抓”日志到文件-最常用"><a href="#2-“抓”日志到文件-最常用" class="headerlink" title="2. “抓”日志到文件 (最常用)"></a>2. “抓”日志到文件 (最常用)</h4><p>直接看屏幕是看不清的，需要把日志<strong>保存</strong>到电脑的一个 <code>.txt</code> 或 <code>.log</code> 文件里。</p><p><strong>👉 实操任务 C：抓取一段日志</strong></p><ol><li><p><strong>清理缓存</strong>（好习惯）：先清空旧的日志，只抓新的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb logcat -c<br></code></pre></td></tr></table></figure></li><li><p><strong>开始抓取</strong>：输入命令，<strong>把日志“重定向”到桌面</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb logcat &gt; C:\Users\LilPear2002\Desktop\test.log<br></code></pre></td></tr></table></figure></li><li><p><strong>制造场景</strong>：</p><ul><li>现在 CMD 看起来像“卡死”了一样（其实它在后台默默记录）。</li><li>拿起手机，打开刚才安装的 <strong>Sauce Labs</strong> 或 <strong>ApiDemos</strong>，随便点两下。</li></ul></li><li><p><strong>结束抓取</strong>：</p><ul><li>回到 CMD，按 <strong><code>Ctrl + C</code></strong> 结束。</li></ul></li><li><p><strong>查看战果</strong>：</p><ul><li>桌面看看crash.log,里面就是刚才操作手机时产生的所有系统日志！</li></ul></li></ol><hr><h2 id="模拟用户操作"><a href="#模拟用户操作" class="headerlink" title="模拟用户操作"></a>模拟用户操作</h2><p>自动化测试工具（Appium）的底层原理，其实就是把这些命令封装起来了。</p><p>主要使用 <code>adb shell input</code> 这个命令集。</p><hr><h3 id="🎮-Part-1：物理按键-Key-Events"><a href="#🎮-Part-1：物理按键-Key-Events" class="headerlink" title="🎮 Part 1：物理按键 (Key Events)"></a>🎮 Part 1：物理按键 (Key Events)</h3><p>这是最简单也是最稳定的命令。就算不知道屏幕坐标，也能控制手机。</p><p>比如：手机的 Home 键、返回键、电源键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input keyevent &lt;按键代码&gt;<br></code></pre></td></tr></table></figure><h4 id="常用代码速查表"><a href="#常用代码速查表" class="headerlink" title="常用代码速查表"></a>常用代码速查表</h4><table><thead><tr><th><strong>按键</strong></th><th><strong>代码 (Code)</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Home</strong></td><td><code>3</code></td><td>回到桌面</td></tr><tr><td><strong>Back</strong></td><td><code>4</code></td><td>返回上一页</td></tr><tr><td><strong>Enter</strong></td><td><code>66</code></td><td>回车&#x2F;确认</td></tr></tbody></table><p><strong>👉 实操任务 A：</strong></p><ol><li>打开刚才安装的 <strong>Sauce Labs</strong> 或 <strong>ApiDemos</strong> 应用。</li><li>在 CMD 输入：<code>adb shell input keyevent 3</code></li><li><strong>结果</strong>：手机瞬间回到桌面了</li><li>再输入：<code>adb shell input keyevent 4</code></li></ol><hr><h3 id="👆-Part-2：触摸操作-Tap-Swipe"><a href="#👆-Part-2：触摸操作-Tap-Swipe" class="headerlink" title="👆 Part 2：触摸操作 (Tap &amp; Swipe)"></a>👆 Part 2：触摸操作 (Tap &amp; Swipe)</h3><p>想要像手指一样点击屏幕，你必须告诉 ADB <strong>“点哪里”</strong>。这就涉及到 <strong>X, Y 坐标</strong>。</p><h4 id="🔧-开启“上帝之眼”：指针位置"><a href="#🔧-开启“上帝之眼”：指针位置" class="headerlink" title="🔧 开启“上帝之眼”：指针位置"></a>🔧 开启“上帝之眼”：指针位置</h4><p>为了知道坐标，我们需要去手机开启一个开发者设置：</p><ol><li>打开手机 <strong>“设置” -&gt; “开发者选项”</strong>。</li><li>找到并开启 <strong>“指针位置” (Pointer Location)</strong>。</li><li><strong>效果</strong>：现在你触摸屏幕，屏幕顶部会显示当前手指的 <strong>X:xxx Y:xxx</strong> 坐标。</li></ol><h4 id="1-点击-Tap"><a href="#1-点击-Tap" class="headerlink" title="1. 点击 (Tap)"></a>1. 点击 (Tap)</h4><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input tap &lt;X&gt; &lt;Y&gt;<br></code></pre></td></tr></table></figure></li><li><p>例子：假设你现在的 App 图标在屏幕中间，坐标大概是 500 1000。</p></li></ul><h4 id="2-滑动-Swipe"><a href="#2-滑动-Swipe" class="headerlink" title="2. 滑动 (Swipe)"></a>2. 滑动 (Swipe)</h4><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input swipe &lt;起点X&gt; &lt;起点Y&gt; &lt;终点X&gt; &lt;终点Y&gt; [耗时毫秒]<br></code></pre></td></tr></table></figure></li><li><p><strong>场景</strong>：刷抖音（上滑）、解锁屏幕。</p></li></ul><p>自动刷抖音脚本：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">chcp</span> <span class="hljs-number">65001</span> &gt;<span class="hljs-built_in">nul</span><br><span class="hljs-built_in">title</span> 抖音自动刷 - 按Ctrl+C停止<br><span class="hljs-built_in">echo</span> 抖音自动刷脚本启动...<br><span class="hljs-built_in">echo</span> 按 Ctrl+C 停止程序<br><span class="hljs-built_in">echo</span>.<br><br>:loop<br><span class="hljs-comment">REM 上滑操作（从屏幕下方滑到上方）</span><br>adb shell input swipe <span class="hljs-number">500</span> <span class="hljs-number">1600</span> <span class="hljs-number">500</span> <span class="hljs-number">600</span> <span class="hljs-number">350</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">%time%</span> 上滑一次<br><span class="hljs-comment"></span><br><span class="hljs-comment">REM 随机等待时间（3-6秒，更像真人）</span><br><span class="hljs-built_in">set</span> /a waitTime=<span class="hljs-variable">%random%</span> %% <span class="hljs-number">4</span> + <span class="hljs-number">3</span><br>timeout /t <span class="hljs-variable">%waitTime%</span> /nobreak &gt;<span class="hljs-built_in">nul</span><br><span class="hljs-keyword">goto</span> loop<br></code></pre></td></tr></table></figure><hr><h3 id="⌨️-Part-3：输入文本-Text"><a href="#⌨️-Part-3：输入文本-Text" class="headerlink" title="⌨️ Part 3：输入文本 (Text)"></a>⌨️ Part 3：输入文本 (Text)</h3><p>可以帮你自动输入账号密码。</p><ul><li><p><strong>注意</strong>：<code>adb shell input text</code> <strong>只能输入英文和数字</strong>，不支持中文（除非安装特殊的 ADB 键盘）。</p></li><li><p><strong>注意</strong>：输入前，必须先保证<strong>光标已经在输入框里了</strong>（也就是你需要先点一下输入框）。</p></li><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input text &lt;内容&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🔥-终极实战任务：自动化登录"><a href="#🔥-终极实战任务：自动化登录" class="headerlink" title="🔥 终极实战任务：自动化登录"></a>🔥 终极实战任务：自动化登录</h3><p>结合刚才学的，我们要用纯命令完成 <strong>Sauce Labs</strong> App 的登录操作。</p><p><strong>请一步步跟着做：</strong></p><ol><li><p><strong>启动 App</strong>：手动点击打开 <strong>Sauce Labs</strong> App（那个红色的 Swag Labs）。</p></li><li><p><strong>获取坐标</strong>：</p><ul><li>看一眼屏幕上 <strong>“Username”</strong> 输入框的位置，记下它的 X, Y（例如 X&#x3D;500, Y&#x3D;400）。</li><li>看一眼 <strong>“LOGIN”</strong> 按钮的位置，记下它的 X, Y（例如 X&#x3D;500, Y&#x3D;1000）。</li></ul></li><li><p><strong>执行自动化脚本</strong>（在 CMD 依次输入）：</p><ul><li><p>步骤 1 (聚焦)：点击输入框</p><p>adb shell input tap 500 400 (把这里的坐标换成你刚才记下的)</p></li><li><p>步骤 2 (输入)：输入用户名</p><p>adb shell input text standard_user</p></li><li><p>步骤 3 (收起键盘)：有时候键盘挡住按钮了，按一下返回键收起键盘</p><p>adb shell input keyevent 4</p></li><li><p>步骤 4 (登录)：点击登录按钮</p><p>adb shell input tap 500 1000 (换成你记下的按钮坐标)</p></li></ul></li></ol><hr><p>如果这个时候要测 100 台 不同型号的手机，每台手机分辨率不一样，按钮坐标肯定也不一样。</p><p>这时候用 ADB 写死坐标 tap 500 400 还有用吗？</p><p><em>(这就是为什么需要 Appium —— 它能通过“控件名”而不是“死坐标”来点击。)</em></p><hr><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><h2 id="1-Appium-是什么？"><a href="#1-Appium-是什么？" class="headerlink" title="1. Appium 是什么？"></a>1. Appium 是什么？</h2><p>用一句话定义：<strong>Appium 是移动端自动化测试的“世界通用语”。</strong></p><ul><li><strong>跨平台 (Cross-Platform)</strong>：<ul><li>学会了一套代码，既能测 <strong>Android</strong>（安卓），也能测 <strong>iOS</strong>（苹果）。</li><li><em>注：ADB 只能测安卓。</em></li></ul></li><li><strong>多语言支持</strong>：<ul><li><strong>Python</strong> 写</li><li><strong>Java</strong></li><li>JavaScript、Ruby… 都支持。</li></ul></li><li><strong>黑盒测试</strong>：<ul><li>不需要 App 的源代码，只要有个安装包就能测。</li></ul></li></ul><h3 id="Appium-的核心原理（C-S-架构）"><a href="#Appium-的核心原理（C-S-架构）" class="headerlink" title="Appium 的核心原理（C&#x2F;S 架构）"></a>Appium 的核心原理（C&#x2F;S 架构）</h3><p>这是面试必考题，也是理解后续安装步骤的关键。请看下面这个流程：</p><blockquote><p><strong>你的代码 (Client) ↔ Appium Server ↔ 手机 (Driver)</strong></p></blockquote><ol><li><strong>Client (客户端)</strong>：<ul><li>这就是你写的 Python 代码。写了一句 <code>driver.click()</code>。</li></ul></li><li><strong>Appium Server (服务端)</strong>：<ul><li>这是一个运行在电脑上的程序（基于 Node.js）。</li><li>它像个**“翻译官”**。它收到 Python 代码，把它翻译成手机能听懂的 JSON 指令。</li></ul></li><li><strong>Driver (驱动)</strong>：<ul><li>在安卓上，Appium 会在手机里装一个叫 <code>UiAutomator2</code> 的东西。</li><li>这个驱动接收“翻译官”的指令，然后指挥手机去点击按钮。</li></ul></li></ol><hr><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li><strong>Node.js</strong>：因为 Appium Server 是用 JS 写的，必须装它才能运行 Server。</li><li><strong>Appium Server</strong>：核心服务程序。</li><li><strong>Appium Inspector</strong>：一个<strong>可视化工具</strong>。<ul><li><em>它的作用</em>：你可以像在网页上“审查元素”一样，用鼠标点一下手机屏幕上的按钮，它就会告诉你这个按钮的 ID 是什么，XPath 是什么。<strong>这是写脚本的神器。</strong></li></ul></li><li><strong>Appium-Python-Client</strong>：Python 的第三方库（<code>pip install</code> 即可）。</li></ol><hr><h2 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h2><p>主要使用 <strong><code>AppiumBy</code></strong> 这个类（需要导入：<code>from appium.webdriver.common.appiumby import AppiumBy</code>）。</p><hr><h3 id="🏆-第一梯队：最推荐"><a href="#🏆-第一梯队：最推荐" class="headerlink" title="🏆 第一梯队：最推荐"></a>🏆 第一梯队：最推荐</h3><h4 id="1-ID-定位-AppiumBy-ID"><a href="#1-ID-定位-AppiumBy-ID" class="headerlink" title="1. ID 定位 (AppiumBy.ID)"></a>1. ID 定位 (<code>AppiumBy.ID</code>)</h4><ul><li><p><strong>对应属性</strong>：<strong><code>resource-id</code></strong></p></li><li><p><strong>Selenium 对比</strong>：等同于 Web 的 <code>id</code>。</p></li><li><p><strong>特点</strong>：通常是唯一的，也是最快的。</p></li><li><p>B站例子：</p><p>B站首页搜索框的 resource-id 通常长这样：tv.danmaku.bili:id&#x2F;expand_search。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/expand_search&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Accessibility-ID-定位-AppiumBy-ACCESSIBILITY-ID-——-移动端特有"><a href="#2-Accessibility-ID-定位-AppiumBy-ACCESSIBILITY-ID-——-移动端特有" class="headerlink" title="2. Accessibility ID 定位 (AppiumBy.ACCESSIBILITY_ID) —— 移动端特有"></a>2. Accessibility ID 定位 (<code>AppiumBy.ACCESSIBILITY_ID</code>) —— <strong>移动端特有</strong></h4><ul><li><p><strong>对应属性</strong>：<strong><code>content-desc</code></strong> (Android) &#x2F; <strong><code>accessibility-id</code></strong> (iOS)</p></li><li><p><strong>特点</strong>：这是 Appium 的<strong>王牌</strong>。</p><ul><li>它原本是给盲人读屏软件用的（比如“这是一个搜索按钮”）。</li><li><strong>跨平台神器</strong>：如果你将来测 iOS，这招也通用。</li><li><strong>B站例子</strong>：很多图片按钮没有文字，但开发会加 <code>content-desc</code>。比如“更多”按钮。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;更多&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🥈-第二梯队：万能但慢（兜底方案）"><a href="#🥈-第二梯队：万能但慢（兜底方案）" class="headerlink" title="🥈 第二梯队：万能但慢（兜底方案）"></a>🥈 第二梯队：万能但慢（兜底方案）</h3><h4 id="3-XPath-定位-AppiumBy-XPATH"><a href="#3-XPath-定位-AppiumBy-XPATH" class="headerlink" title="3. XPath 定位 (AppiumBy.XPATH)"></a>3. XPath 定位 (<code>AppiumBy.XPATH</code>)</h4><ul><li><p><strong>对应属性</strong>：可以使用任何属性组合（text, class, index…）。</p></li><li><p><strong>Selenium 对比</strong>：语法基本一样，但<strong>标签名变了</strong>。</p><ul><li>Web 标签是 <code>div</code>, <code>input</code>, <code>a</code>。</li><li>Android 标签是 <strong>完整的类名</strong>，比如 <code>android.widget.TextView</code>, <code>android.widget.EditText</code>。</li></ul></li><li><p>B站例子：</p><p>定位那个写着“Python”的搜索建议：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语法：//类名[@属性=&#x27;值&#x27;]</span><br>driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.TextView[@text=&#x27;Python自动化&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>包含匹配 (contains)</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.TextView[contains(@text, &#x27;Python&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🥉-第三梯队：安卓原生黑科技（进阶）"><a href="#🥉-第三梯队：安卓原生黑科技（进阶）" class="headerlink" title="🥉 第三梯队：安卓原生黑科技（进阶）"></a>🥉 第三梯队：安卓原生黑科技（进阶）</h3><h4 id="4-Android-UIAutomator-AppiumBy-ANDROID-UIAUTOMATOR"><a href="#4-Android-UIAutomator-AppiumBy-ANDROID-UIAUTOMATOR" class="headerlink" title="4. Android UIAutomator (AppiumBy.ANDROID_UIAUTOMATOR)"></a>4. Android UIAutomator (<code>AppiumBy.ANDROID_UIAUTOMATOR</code>)</h4><ul><li><p><strong>原理</strong>：这是绕过 Appium，直接用安卓底层的 Java 代码去查元素。<strong>速度极快</strong>，特别适合滚动查找。</p></li><li><p><strong>语法</strong>：里面写的是 <strong>Java 字符串</strong>。</p></li><li><p><strong>B站例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相当于：new UiSelector().text(&quot;推荐&quot;)</span><br>driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, <span class="hljs-string">&#x27;new UiSelector().text(&quot;推荐&quot;)&#x27;</span>)<br><br><span class="hljs-comment"># 组合定位：找一个 resource-id 是 xxx 且 text 是 &quot;搜索&quot; 的元素</span><br>driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, <span class="hljs-string">&#x27;new UiSelector().resourceId(&quot;xxx&quot;).text(&quot;搜索&quot;)&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🚫-避坑指南：不再推荐的方式"><a href="#🚫-避坑指南：不再推荐的方式" class="headerlink" title="🚫 避坑指南：不再推荐的方式"></a>🚫 避坑指南：不再推荐的方式</h3><ol><li><strong><code>By.NAME</code></strong>：在 Appium 1.x 早期版本可以用，但在 Appium 2.x 和高版本安卓中基本<strong>废弃</strong>了，不要用。</li><li><strong><code>By.TAG_NAME</code></strong>（Class Name）：<ul><li>在 Web 里，<code>TAG_NAME</code> 是 <code>input</code>，这很明确。</li><li>在 App 里，页面上可能有 100 个 <code>android.widget.TextView</code>。你用这个定位，肯定不准。</li></ul></li></ol><hr><h3 id="🛠️-实战演练：如何在-Inspector-里挑"><a href="#🛠️-实战演练：如何在-Inspector-里挑" class="headerlink" title="🛠️ 实战演练：如何在 Inspector 里挑"></a>🛠️ 实战演练：如何在 Inspector 里挑</h3><p>当你用 Appium Inspector 点击 B站的一个图标时，右侧会显示一大堆属性。<strong>选谁？请按这个顺序：</strong></p><ol><li>先看 <strong><code>accessibility-id</code> (content-desc)</strong>：如果有值，<strong>首选它</strong>！</li><li>再看 <strong><code>resource-id</code></strong>：如果有值，用 <code>AppiumBy.ID</code>。</li><li>如果前两个都没有，或者都不唯一：<ul><li>看 <strong><code>text</code></strong>：如果有文字，用 XPath <code>//...[@text=&#39;文字&#39;]</code>。</li><li>如果连文字都没有（只是个纯图标）：只能靠 XPath 的层级关系（找它爸爸）或者坐标了。</li></ul></li></ol><hr><h3 id="📝-总结表"><a href="#📝-总结表" class="headerlink" title="📝 总结表"></a>📝 总结表</h3><table><thead><tr><th><strong>定位方式</strong></th><th><strong>代码写法 (AppiumBy.xxx)</strong></th><th><strong>依赖属性 (Inspector里看)</strong></th><th><strong>推荐指数</strong></th><th><strong>评价</strong></th></tr></thead><tbody><tr><td><strong>ID</strong></td><td><code>ID</code></td><td><code>resource-id</code></td><td>⭐⭐⭐⭐⭐</td><td><strong>首选</strong>，最快最稳。</td></tr><tr><td><strong>Accessibility ID</strong></td><td><code>ACCESSIBILITY_ID</code></td><td><code>content-desc</code></td><td>⭐⭐⭐⭐⭐</td><td><strong>首选</strong>，跨平台，语义清晰。</td></tr><tr><td><strong>XPath</strong></td><td><code>XPATH</code></td><td>任意 (text, class…)</td><td>⭐⭐⭐</td><td><strong>万能</strong>，但性能较差，语法繁琐。</td></tr><tr><td><strong>UIAutomator</strong></td><td><code>ANDROID_UIAUTOMATOR</code></td><td>任意 (Java语法)</td><td>⭐⭐⭐⭐</td><td><strong>安卓特供</strong>，速度快，适合复杂场景（如滚动）。</td></tr><tr><td><strong>Class Name</strong></td><td><code>CLASS_NAME</code></td><td><code>class</code></td><td>⭐</td><td><strong>不推荐</strong>，重复率太高。</td></tr></tbody></table><hr><p>案例：打开B站搜索Python自动化测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.appiumby <span class="hljs-keyword">import</span> AppiumBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># --- 配置参数 ---</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&#x27;platformName&#x27;</span>: <span class="hljs-string">&#x27;Android&#x27;</span>,<br>    <span class="hljs-string">&#x27;platformVersion&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>,<br>    <span class="hljs-string">&#x27;deviceName&#x27;</span>: <span class="hljs-string">&#x27;V4YHB6XS6DSSQ89L&#x27;</span>,<br>    <span class="hljs-string">&#x27;appPackage&#x27;</span>: <span class="hljs-string">&#x27;tv.danmaku.bili&#x27;</span>,<br>    <span class="hljs-string">&#x27;appActivity&#x27;</span>: <span class="hljs-string">&#x27;.MainActivityV2&#x27;</span>,<br>    <span class="hljs-string">&#x27;automationName&#x27;</span>: <span class="hljs-string">&#x27;UiAutomator2&#x27;</span>,<br>    <span class="hljs-comment"># 关键参数：不重置应用（保留你的登录状态，避免每次都弹隐私协议）</span><br>    <span class="hljs-string">&#x27;noReset&#x27;</span>: <span class="hljs-literal">True</span><br>&#125;<br><br>driver = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在连接 Appium...&quot;</span>)<br>    driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723&#x27;</span>, desired_caps)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;强制唤醒 B站...&quot;</span>)<br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    <span class="hljs-comment"># 设置全局隐式等待 10秒（给B站启动一点缓冲时间）</span><br>    driver.implicitly_wait(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B站启动成功！&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># --- 1. 处理“青少年模式”弹窗 (B站特有) ---</span><br>    <span class="hljs-comment"># 这是一个“可能出现，也可能不出现”的弹窗，所以我们要用 try-except</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检查是否有青少年模式弹窗...&quot;</span>)<br>        <span class="hljs-comment"># 这里需要你填入你在 Inspector 里抓到的“我知道了”按钮的 ID</span><br>        <span class="hljs-comment"># B站通常的 ID 可能是 text_view 或者 close_button，下面是示例 ID，你需要替换！</span><br>        teenager_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/text_ok&quot;</span>)<br>        teenager_btn.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭青少年模式弹窗&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未检测到弹窗，继续执行...&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 点击首页顶部的“搜索框” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在寻找搜索框...&quot;</span>)<br>    <span class="hljs-comment"># 这里的 ID 是 B站首页顶部搜索框的典型 ID (expand_search)</span><br>    <span class="hljs-comment"># 如果报错，请用 Inspector 确认一下是不是这个</span><br>    search_box = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_text&quot;</span>)<br><br>    search_box.click()<br><br>    <span class="hljs-comment"># --- 3. 输入关键字 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入搜索页，输入关键字...&quot;</span>)<br>    <span class="hljs-comment"># 点击搜索框后，会跳转到一个新页面，这里有一个真正的输入框</span><br>    <span class="hljs-comment"># 这里的 ID 通常是 search_src_text</span><br>    <span class="hljs-comment"># input_field = driver.find_element(AppiumBy.ID, &quot;tv.danmaku.bili:id/search_src_text&quot;)</span><br>    input_field = driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;搜索查询&quot;</span>)<br>    input_field.send_keys(<span class="hljs-string">&quot;Python自动化测试&quot;</span>)<br><br>    <span class="hljs-comment"># --- 4. 点击“搜索”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击搜索按钮...&quot;</span>)<br>    <span class="hljs-comment"># 这是一个 text 属性为“搜索”的 TextView</span><br>    search_btn = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&#x27;//android.widget.TextView[@resource-id=&quot;tv.danmaku.bili:id/action_search&quot;]&#x27;</span>)<br>    search_btn.click()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 搜索动作完成！请看手机屏幕效果&quot;</span>)<br><br>    <span class="hljs-comment"># 停留一会让你看结果</span><br>    time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> driver:<br>        driver.quit()<br></code></pre></td></tr></table></figure><hr><h2 id="3-操作"><a href="#3-操作" class="headerlink" title="3.操作"></a>3.操作</h2><p>因为手机和浏览器不一样（手机有实体按键、手指触摸），所以常用方法分为两类：</p><ol><li><strong>“老朋友”</strong>：和 Selenium 一模一样的（点击、输入）。</li><li><strong>“新面孔”</strong>：移动端特有的（按键、触摸、属性获取）。</li></ol><hr><h3 id="🕹️-Part-1-元素操作-和-Selenium-对标"><a href="#🕹️-Part-1-元素操作-和-Selenium-对标" class="headerlink" title="🕹️ Part 1: 元素操作 (和 Selenium 对标)"></a>🕹️ Part 1: 元素操作 (和 Selenium 对标)</h3><h4 id="1-点击与输入-完全一致"><a href="#1-点击与输入-完全一致" class="headerlink" title="1. 点击与输入 (完全一致)"></a>1. 点击与输入 (完全一致)</h4><ul><li><code>element.click()</code>：点击。</li><li><code>element.send_keys(&quot;...&quot;)</code>：输入。</li><li><code>element.clear()</code>：清空输入框。</li></ul><h4 id="2-获取属性-Get-Attribute-——-有差异！"><a href="#2-获取属性-Get-Attribute-——-有差异！" class="headerlink" title="2. 获取属性 (Get Attribute) —— 有差异！"></a>2. 获取属性 (Get Attribute) —— <strong>有差异！</strong></h4><p>在 Appium 里，属性名变了：</p><table><thead><tr><th><strong>想要获取什么？</strong></th><th><strong>Selenium (Web)</strong></th><th><strong>Appium (Android)</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>显示的文字</strong></td><td><code>element.text</code></td><td><code>element.text</code></td><td><strong>通用</strong>。优先用这个。</td></tr><tr><td><strong>是否被选中</strong></td><td><code>get_attribute(&quot;checked&quot;)</code></td><td><code>get_attribute(&quot;checked&quot;)</code></td><td>复选框&#x2F;单选框常用（返回 “true”&#x2F;“false” 字符串）。</td></tr><tr><td><strong>是否可用</strong></td><td><code>is_enabled()</code></td><td><code>get_attribute(&quot;enabled&quot;)</code></td><td>按钮是否变灰。</td></tr><tr><td><strong>无障碍描述</strong></td><td>(无)</td><td><strong><code>get_attribute(&quot;content-desc&quot;)</code></strong></td><td><strong>重点！</strong> 很多图片按钮没文字，只能靠这个断言。</td></tr><tr><td><strong>包名</strong></td><td>(无)</td><td><code>get_attribute(&quot;package&quot;)</code></td><td>验证是否跳到了别的 App。</td></tr></tbody></table><p>👉 实战场景：</p><p>你搜索完“Python”后，想验证搜索框里的字是不是“Python”？或者想获取某个视频的标题。</p><hr><h3 id="📱-Part-2-手机硬按键-Hardware-Keys-——-Appium-特有"><a href="#📱-Part-2-手机硬按键-Hardware-Keys-——-Appium-特有" class="headerlink" title="📱 Part 2: 手机硬按键 (Hardware Keys) —— Appium 特有"></a>📱 Part 2: 手机硬按键 (Hardware Keys) —— <strong>Appium 特有</strong></h3><p>做 App 测试经常需要：返回上一页、回到桌面、调节音量。使用 driver.press_keycode(代码) 方法。</p><h4 id="常用按键代码-KeyCodes"><a href="#常用按键代码-KeyCodes" class="headerlink" title="常用按键代码 (KeyCodes)"></a>常用按键代码 (KeyCodes)</h4><ul><li><strong>返回键 (Back)</strong>: <code>4</code> (最常用！)</li><li><strong>Home 键</strong>: <code>3</code></li><li><strong>音量加</strong>: <code>24</code></li><li><strong>音量减</strong>: <code>25</code></li><li><strong>回车 (Enter)</strong>: <code>66</code> (搜索时除了点搜索按钮，也可以按这个)</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模拟手指按手机侧面的“返回”键</span><br>driver.press_keycode(<span class="hljs-number">4</span>) <br></code></pre></td></tr></table></figure><hr><h3 id="👆-Part-3-滑动操作-Swipe-——-重头戏"><a href="#👆-Part-3-滑动操作-Swipe-——-重头戏" class="headerlink" title="👆 Part 3: 滑动操作 (Swipe) —— 重头戏"></a>👆 Part 3: 滑动操作 (Swipe) —— <strong>重头戏</strong></h3><p>这是 Web 和 App 最大的区别。</p><p>Web 页面长了有滚动条，Selenium 可以用 JS window.scrollTo。App 没有滚动条，全靠手指滑。Appium 提供了简单的滑动 API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.swipe(start_x, start_y, end_x, end_y, duration)<br></code></pre></td></tr></table></figure><ul><li><code>start_x</code>, <code>start_y</code>: 起点坐标。</li><li><code>end_x</code>, <code>end_y</code>: 终点坐标。</li><li><code>duration</code>: 滑动耗时（毫秒）。<strong>越短滑得越快（惯性大），越长越精准。</strong></li></ul><p>📐 坐标怎么算？</p><p>不要写死 500, 1000！因为不同手机屏幕大小不一样。</p><p>通用公式：先获取屏幕尺寸，然后按百分比滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取屏幕宽高</span><br>size = driver.get_window_size()<br>width = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>height = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br><br><span class="hljs-comment"># 向上滑动 (手指从下往上，浏览下面的内容)</span><br><span class="hljs-comment"># x 轴不变（屏幕中间），y 轴从 90% 处滑到 10% 处</span><br>driver.swipe(width * <span class="hljs-number">0.5</span>, height * <span class="hljs-number">0.9</span>, width * <span class="hljs-number">0.5</span>, height * <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚔️-实战任务：B-站搜索-滑动-返回"><a href="#⚔️-实战任务：B-站搜索-滑动-返回" class="headerlink" title="⚔️ 实战任务：B 站搜索 + 滑动 + 返回"></a>⚔️ 实战任务：B 站搜索 + 滑动 + 返回</h3><p>任务目标：</p><ol><li>启动 B 站，搜“Python自动化”。</li><li><strong>断言</strong>：验证搜索结果页的输入框里确实填着“Python自动化”（练习 <code>text</code> 属性）。</li><li><strong>滑动</strong>：向下滑动两下，浏览下面的视频（练习 <code>swipe</code>）。</li><li><strong>返回</strong>：按两次物理返回键，回到 B 站首页（练习 <code>keycode</code>）。</li></ol><p>请更新你的脚本（保留前面的 setup 部分）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前面的配置和启动代码保持不变) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 1. --- 之前的搜索流程 (略，保留你写的) ---</span><br>    <span class="hljs-comment"># ... (点击搜索框 -&gt; 输入&quot;Python自动化&quot; -&gt; 点击搜索按钮) ...</span><br>    <span class="hljs-comment"># 假设你已经点完搜索按钮了，现在在结果页</span><br><br>    time.sleep(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等结果加载</span><br><br>    <span class="hljs-comment"># 2. --- 练习：获取属性与断言 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在验证搜索结果...&quot;</span>)<br>    <span class="hljs-comment"># 重新定位结果页顶部的搜索框 (ID 通常和首页不一样，或者是同一个，视 B 站版本而定)</span><br>    <span class="hljs-comment"># B 站结果页输入框 ID 通常还是: tv.danmaku.bili:id/search_src_text</span><br>    result_input = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_src_text&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取它显示的文字</span><br>    actual_text = result_input.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;搜索框里的文字是: <span class="hljs-subst">&#123;actual_text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 断言</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Python&quot;</span> <span class="hljs-keyword">in</span> actual_text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 断言成功：搜索词正确&quot;</span>)<br><br>    <span class="hljs-comment"># 3. --- 练习：屏幕滑动 (Swipe) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备向下滑动浏览视频...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取屏幕尺寸</span><br>    size = driver.get_window_size()<br>    w = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>    h = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 滑动两次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span> 次滑动...&quot;</span>)<br>        <span class="hljs-comment"># 从下(70%) 往上(30%) 滑，模拟手指上滑</span><br>        driver.swipe(w * <span class="hljs-number">0.5</span>, h * <span class="hljs-number">0.7</span>, w * <span class="hljs-number">0.5</span>, h * <span class="hljs-number">0.3</span>, <span class="hljs-number">1000</span>)<br>        time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 滑完停顿一下，像真人在看</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 滑动完成&quot;</span>)<br><br>    <span class="hljs-comment"># 4. --- 练习：物理按键 (Back) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备按物理返回键回到首页...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 按一次返回 (可能只是收起键盘，或者退回上一步)</span><br>    driver.press_keycode(<span class="hljs-number">4</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 再按一次返回 (彻底退回首页)</span><br>    driver.press_keycode(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已执行返回操作&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    time.sleep(<span class="hljs-number">3</span>)<br>    driver.quit()<br></code></pre></td></tr></table></figure><hr><h2 id="4-窗口和标签页操作"><a href="#4-窗口和标签页操作" class="headerlink" title="4.窗口和标签页操作"></a>4.窗口和标签页操作</h2><p>这里有一个 <strong>巨大的思维转换</strong> 需要注意：</p><h3 id="🤯-核心概念：Appium-vs-Selenium-的“窗口”区别"><a href="#🤯-核心概念：Appium-vs-Selenium-的“窗口”区别" class="headerlink" title="🤯 核心概念：Appium vs Selenium 的“窗口”区别"></a>🤯 核心概念：Appium vs Selenium 的“窗口”区别</h3><p>在 Selenium（Web）中，点击一个链接，可能会弹出一个新的浏览器标签页（Tab）或窗口（Window），此时必须用 <code>driver.switch_to.window(handle)</code> 才能控制新页面。</p><p><strong>但在 Appium（原生 App）中，逻辑完全不同：</strong></p><ol><li><strong>没有“多窗口”概念</strong>：<ul><li>手机屏幕一次只能显示一个 App 的页面。</li><li>当点击一个按钮跳到新页面时（比如从“搜索列表”跳到“视频详情页”），<strong>Appium 会自动跟随过去</strong>。</li><li><strong>结论</strong>：<strong>不需要</strong>写 <code>switch_to.window</code>！焦点永远在当前显示的屏幕上。</li></ul></li><li><strong>“Activity” 代替了 “Window”</strong>：<ul><li>Web 里的“页面 URL”，在安卓里叫 <strong><code>Activity</code></strong>（活动）。</li><li>可以通过检查 <code>driver.current_activity</code> 来判断当前是在“首页”还是“详情页”。</li></ul></li><li><strong>唯一的“特殊情况” —— WebView (H5)</strong>：<ul><li>如果在 B站里点了一个广告，打开了一个<strong>网页</strong>，这时候才涉及到类似 Selenium 的“切换框架”操作（这叫 <strong>Context 切换</strong>，它是高级内容）。</li></ul></li></ol><hr><h3 id="🎬-实战案例：B站“视频详情页”进出测试"><a href="#🎬-实战案例：B站“视频详情页”进出测试" class="headerlink" title="🎬 实战案例：B站“视频详情页”进出测试"></a>🎬 实战案例：B站“视频详情页”进出测试</h3><p>既然不用切换窗口，那我们怎么测“页面跳转”呢？</p><p>逻辑是： 记录当前 Activity -&gt; 点击跳转 -&gt; 等待新页面 -&gt; 验证新 Activity -&gt; 按返回键“关闭”页面。</p><p><strong>任务目标</strong>：</p><ol><li>在搜索结果页，点击<strong>第一个视频</strong>。</li><li><strong>验证</strong>：是否成功进入了“视频播放页”（检测 Activity 变了没）。</li><li><strong>操作</strong>：在播放页停留 5 秒（模拟看视频）。</li><li><strong>返回</strong>：按返回键，回到搜索结果页。</li></ol><h4 id="💻-代码实战"><a href="#💻-代码实战" class="headerlink" title="💻 代码实战"></a>💻 代码实战</h4><p>请在之前的搜索脚本后面，续写以下内容（注意看注释里的 Activity 变化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前面是搜索代码：输入关键字 -&gt; 点击搜索按钮 -&gt; 验证结果页文字) ...</span><br><span class="hljs-comment"># 假设现在代码运行到了搜索结果页</span><br><br>    <span class="hljs-comment"># --- 5. 进阶：页面跳转与 Activity 验证 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 开始测试页面跳转 ---&quot;</span>)<br>    <br>    <span class="hljs-comment"># A. 打印当前的 Activity (应该是搜索结果页)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;跳转前 Activity: <span class="hljs-subst">&#123;driver.current_activity&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># B. 点击第一个视频</span><br>    <span class="hljs-comment"># B站搜索结果通常是一个列表，我们用 XPath 找第一个包含“Python”的标题</span><br>    <span class="hljs-comment"># 注意：这里可能会点到广告，为了简单，我们尝试点列表里的第一个项</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击第一个视频...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 这个 XPath 意思是：找当前页面所有包含文本的 TextView，选第2个或第3个(因为第1个可能是搜索框里的字)</span><br>    <span class="hljs-comment"># 更好的方式是用 Inspector 抓取视频封面的 ID，这里演示通用逻辑</span><br>    video_item = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;(//android.widget.TextView[contains(@text, &#x27;Python&#x27;)])[3]&quot;</span>)<br>    video_item.click()<br>    <br>    <span class="hljs-comment"># C. 等待跳转 (页面切换需要时间)</span><br>    time.sleep(<span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment"># D. 验证是否进入了新页面 (Activity 应该变了)</span><br>    current_act = driver.current_activity<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;跳转后 Activity: <span class="hljs-subst">&#123;current_act&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># B站的视频播放页 Activity 通常包含 &quot;VideoDetails&quot; 或 &quot;Bangumi&quot;</span><br>    <span class="hljs-comment"># 如果 Activity 名字变了，就说明跳转成功</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Details&quot;</span> <span class="hljs-keyword">in</span> current_act <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;Video&quot;</span> <span class="hljs-keyword">in</span> current_act:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 成功进入视频详情页！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;⚠️ Activity 名字好像没变，当前是: <span class="hljs-subst">&#123;current_act&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># E. 模拟看视频 5秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在假装看视频...&quot;</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <br>    <span class="hljs-comment"># F. 退出页面 (相当于 Selenium 的 close window)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看完啦，按返回键退出...&quot;</span>)<br>    driver.press_keycode(<span class="hljs-number">4</span>) <span class="hljs-comment"># Back 键</span><br>    <br>    <span class="hljs-comment"># 验证是否回到了搜索页</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;返回后 Activity: <span class="hljs-subst">&#123;driver.current_activity&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># ... (后面的 quit 代码) ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="🕵️‍♂️-真正的“Tab”操作：底部导航栏"><a href="#🕵️‍♂️-真正的“Tab”操作：底部导航栏" class="headerlink" title="🕵️‍♂️ 真正的“Tab”操作：底部导航栏"></a>🕵️‍♂️ 真正的“Tab”操作：底部导航栏</h3><p>标签页（Tab）在 App 里通常指的是<strong>底部的导航栏</strong>（首页 | 动态 | 会员购 | 我的）。</p><p>测这个非常简单，就是点点点。</p><p><strong>实战任务 B：底部 Tab 切换测试</strong></p><ol><li>启动 B 站。</li><li>点击底部的 <strong>“我的”</strong>。</li><li>检查是否到了个人中心。</li><li>点击底部的 <strong>“首页”</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这段代码可以单独运行，或者放在搜索之前</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># ... (连接 Appium 代码) ...</span><br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 开始测试底部 Tab 切换 ---&quot;</span>)<br>    <br>    <span class="hljs-comment"># 1. 寻找底部的“我的”按钮</span><br>    <span class="hljs-comment"># 这种固定按钮，通常 text 是固定的，用 XPath 或者 Accessibility ID 找</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击 &#x27;我的&#x27;...&quot;</span>)<br>    <span class="hljs-comment"># 尝试用 XPath 文本定位</span><br>    me_tab = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;我的&#x27;]&quot;</span>)<br>    me_tab.click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 2. 验证 (比如找一下页面上有没有“历史记录”这个按钮)</span><br>    <span class="hljs-comment"># 注意：如果你没登录，可能看到的是“点击登录”</span><br>    <span class="hljs-keyword">try</span>:<br>        driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;历史记录&#x27; or @text=&#x27;点击登录&#x27;]&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已切换到个人中心&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 切换失败&quot;</span>)<br>        <br>    <span class="hljs-comment"># 3. 切回首页</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击 &#x27;首页&#x27;...&quot;</span>)<br>    home_tab = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;首页&#x27;]&quot;</span>)<br>    home_tab.click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已回到首页&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚠️-高级预警：WebView-H5-——-真正的“切窗口”"><a href="#⚠️-高级预警：WebView-H5-——-真正的“切窗口”" class="headerlink" title="⚠️ 高级预警：WebView (H5) —— 真正的“切窗口”"></a>⚠️ 高级预警：WebView (H5) —— 真正的“切窗口”</h3><p>在 App 里，如果嵌入了一个网页（比如 B站的“会员购”页面，或者活动页面），那个东西叫 WebView。</p><ul><li><strong>Native (原生)</strong>：按钮、图片都是安卓控件。</li><li><strong>WebView (H5)</strong>：里面是 HTML 代码。</li></ul><p><strong>如果你想在 Appium 里控制 WebView 里的元素（比如点击 H5 里的链接）：</strong></p><ol><li><p>你必须像 Selenium 切换 iframe 一样，切换 <strong>Context</strong>。</p></li><li><p>代码长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 获取所有上下文</span><br>contexts = driver.contexts  <span class="hljs-comment"># 返回 [&#x27;NATIVE_APP&#x27;, &#x27;WEBVIEW_com.bilibili&#x27;]</span><br><br><span class="hljs-comment"># 2. 切换到 WebView (相当于 switch_to.window/frame)</span><br>driver.switch_to.context(contexts[-<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 3. 现在可以用 Selenium 的方式找 div/a 标签了</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;div.banner&quot;</span>).click()<br><br><span class="hljs-comment"># 4. 切回原生</span><br>driver.switch_to.context(<span class="hljs-string">&quot;NATIVE_APP&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>🛑 劝退警告：绝大多数市面上的 App（包括 B站 release 版），都关闭了 WebView 的调试权限。这意味着 driver.contexts 只能读到 NATIVE_APP，读不到 WEBVIEW。除非你有 B站的内部开发包，或者手机 Root 了。现阶段，把 App 当作纯 Native 应用来测（Activity 跳转 + 底部 Tab 切换），这涵盖了 95% 的工作场景。</p><hr><h2 id="三大等待"><a href="#三大等待" class="headerlink" title="三大等待"></a>三大等待</h2><p>这部分和selenium基本一样：</p><ol><li><strong>强制等待</strong>：<code>time.sleep(3)</code><ul><li><em>场景</em>：调试时用，或者有些顽固的动画（比如 B 站开屏广告）实在没法定位时，硬等。</li></ul></li><li><strong>隐式等待</strong>：<code>driver.implicitly_wait(10)</code><ul><li><em>场景</em>：全局兜底。脚本一上来就设好，管 ID&#x2F;XPath 找不找得到。</li></ul></li><li><strong>显式等待</strong> (WebDriverWait)：<strong>王牌</strong>。<ul><li><em>场景</em>：等元素<strong>可点击</strong>、等<strong>文字出现</strong>、等<strong>Toast 消失</strong>。</li></ul></li></ol><hr><h3 id="🔥-Appium-独有的难点：Toast-消息捕获"><a href="#🔥-Appium-独有的难点：Toast-消息捕获" class="headerlink" title="🔥 Appium 独有的难点：Toast 消息捕获"></a>🔥 Appium 独有的难点：Toast 消息捕获</h3><ul><li><p>什么是 Toast？</p><p>就是点赞后，屏幕下方弹出的那个黑底白字小气泡：“已点赞” 或 “登录失败”。</p></li><li><p><strong>难点在哪？</strong></p><ol><li><strong>它消失得很快</strong>（通常 2-3 秒），手慢无。</li><li><strong>它不属于 App 的页面结构</strong>，而是属于 <strong>安卓系统</strong> 的。用普通的 Inspector 截图很难截到它（因为它一闪而过）。</li></ol></li></ul><h4 id="🛠️-怎么抓-Toast？"><a href="#🛠️-怎么抓-Toast？" class="headerlink" title="🛠️ 怎么抓 Toast？"></a>🛠️ 怎么抓 Toast？</h4><p>虽然很难截到，但它的 <strong>XPath</strong> 是固定的！(标准安卓 Toast)</p><ul><li><p><strong>万能 XPath</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 记住这个类名，这是安卓系统级的 Toast 控件</span><br>toast_xpath = <span class="hljs-string">&quot;//android.widget.Toast&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>必须使用显式等待：</p><p>因为 Toast 可能是第 0.5 秒出现，第 2 秒消失。如果不用显式等待去“守株待兔”，很难抓到。</p></li></ul><hr><h3 id="💻-实战任务：B站“点赞-取消点赞”的-Toast-捕获"><a href="#💻-实战任务：B站“点赞-取消点赞”的-Toast-捕获" class="headerlink" title="💻 实战任务：B站“点赞&#x2F;取消点赞”的 Toast 捕获"></a>💻 实战任务：B站“点赞&#x2F;取消点赞”的 Toast 捕获</h3><p>我们要验证：点击视频的点赞按钮后，是否弹出了“点赞成功”或“取消点赞”的提示。</p><p><strong>脚本逻辑：</strong></p><ol><li>搜 BV 号进视频（用之前的代码）。</li><li>点击视频画面（唤起控制条）。</li><li>点击“点赞”图标。</li><li><strong>【关键】使用显式等待捕获包含“点赞”字样的 Toast</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.appiumby <span class="hljs-keyword">import</span> AppiumBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># --- 配置参数 ---</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&#x27;platformName&#x27;</span>: <span class="hljs-string">&#x27;Android&#x27;</span>,<br>    <span class="hljs-string">&#x27;platformVersion&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>,<br>    <span class="hljs-string">&#x27;deviceName&#x27;</span>: <span class="hljs-string">&#x27;V4YHB6XS6DSSQ89L&#x27;</span>,<br>    <span class="hljs-string">&#x27;appPackage&#x27;</span>: <span class="hljs-string">&#x27;tv.danmaku.bili&#x27;</span>,<br>    <span class="hljs-string">&#x27;appActivity&#x27;</span>: <span class="hljs-string">&#x27;.MainActivityV2&#x27;</span>,<br>    <span class="hljs-string">&#x27;automationName&#x27;</span>: <span class="hljs-string">&#x27;UiAutomator2&#x27;</span>,<br>    <span class="hljs-comment"># 关键参数：不重置应用（保留你的登录状态，避免每次都弹隐私协议）</span><br>    <span class="hljs-string">&#x27;noReset&#x27;</span>: <span class="hljs-literal">True</span><br>&#125;<br><br>driver = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在连接 Appium...&quot;</span>)<br>    driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723&#x27;</span>, desired_caps)<br><br>    bv_id = <span class="hljs-string">&quot;BV1Qm2DBLEYk&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;强制唤醒 B站...&quot;</span>)<br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    <span class="hljs-comment"># 设置全局隐式等待 10秒（给B站启动一点缓冲时间）</span><br>    driver.implicitly_wait(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B站启动成功！&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># --- 1. 处理“青少年模式”弹窗 (B站特有) ---</span><br>    <span class="hljs-comment"># 这是一个“可能出现，也可能不出现”的弹窗，所以我们要用 try-except</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检查是否有青少年模式弹窗...&quot;</span>)<br>        <span class="hljs-comment"># 这里需要你填入你在 Inspector 里抓到的“我知道了”按钮的 ID</span><br>        <span class="hljs-comment"># B站通常的 ID 可能是 text_view 或者 close_button，下面是示例 ID，你需要替换！</span><br>        teenager_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/text_ok&quot;</span>)<br>        teenager_btn.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭青少年模式弹窗&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未检测到弹窗，继续执行...&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 点击首页顶部的“搜索框” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在寻找搜索框...&quot;</span>)<br>    <span class="hljs-comment"># 这里的 ID 是 B站首页顶部搜索框的典型 ID (expand_search)</span><br>    <span class="hljs-comment"># 如果报错，请用 Inspector 确认一下是不是这个</span><br>    search_box = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_text&quot;</span>)<br><br>    search_box.click()<br><br>    <span class="hljs-comment"># --- 3. 输入关键字 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入搜索页，输入关键字...&quot;</span>)<br>    <span class="hljs-comment"># 点击搜索框后，会跳转到一个新页面，这里有一个真正的输入框</span><br>    <span class="hljs-comment"># 这里的 ID 通常是 search_src_text</span><br>    <span class="hljs-comment"># input_field = driver.find_element(AppiumBy.ID, &quot;tv.danmaku.bili:id/search_src_text&quot;)</span><br>    input_field = driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;搜索查询&quot;</span>)<br>    input_field.send_keys(bv_id)<br><br>    <span class="hljs-comment"># --- 4. 点击“搜索”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击搜索按钮...&quot;</span>)<br>    <span class="hljs-comment"># 这是一个 text 属性为“搜索”的 TextView</span><br>    search_btn = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&#x27;//android.widget.TextView[@resource-id=&quot;tv.danmaku.bili:id/action_search&quot;]&#x27;</span>)<br>    search_btn.click()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 搜索动作完成！请看手机屏幕效果&quot;</span>)<br><br>    <span class="hljs-comment"># 停留一会让你看结果</span><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 2. 点击点赞 (难点：B站的点赞按钮 ID)</span><br>    <span class="hljs-comment"># B站播放页结构很复杂，点赞通常叫 &quot;love&quot; 或 &quot;like&quot;</span><br>    <span class="hljs-comment"># 我们先暂停一下视频，防止干扰</span><br>    time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 等广告过</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;尝试点击点赞...&quot;</span>)<br>    <span class="hljs-comment"># 注意：B站的点赞按钮 id 经常是 tv.danmaku.bili:id/recommend_icon 或者是类似的</span><br>    <span class="hljs-comment"># 如果你找不到 ID，可以用 xpath 找那个“大拇指”图标</span><br>    <span class="hljs-comment"># 点赞按钮 ID 通常是 tv.danmaku.bili:id/follow</span><br>    follow_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/frame_like&quot;</span>)<br>    follow_btn.click()<br><br>    <span class="hljs-comment"># --- 🔥 核心：捕获 Toast (显式等待) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待 Toast 出现...&quot;</span>)<br><br>    <span class="hljs-comment"># 写法：等待 text 包含 &quot;关注&quot; 的 Toast 元素出现</span><br>    <span class="hljs-comment"># 注意：presence_of_element_located 是判断元素在不在 DOM 里，这对 Toast 最有效</span><br>    toast_element = WebDriverWait(driver, <span class="hljs-number">5</span>, poll_frequency=<span class="hljs-number">0.1</span>).until(<br>        EC.presence_of_element_located((AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.Toast[contains(@text, &#x27;点赞&#x27;)]&quot;</span>))<br>    )<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功捕获 Toast 内容: <span class="hljs-subst">&#123;toast_element.text&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> driver:<br>        driver.quit()<br></code></pre></td></tr></table></figure><hr><p>特别注意：现在的 App越来越花哨，很多提示不再使用安卓原生的 Toast (android.widget.Toast)，而是开发自己画的一个 TextView 飘在上面。</p><ul><li><strong>怎么分辨？</strong><ul><li><strong>原生 Toast</strong>：不能被点击，Inspector 很难选中。</li><li><strong>伪造 Toast (自定义 View)</strong>：Inspector 能选中，它就是一个普通的 TextView。</li></ul></li></ul><p>如果上面的代码抓不到，说明用的是自定义 View。需要把 XPath 改成普通的文本查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 针对自定义 UI 的 Toast</span><br>xpath = <span class="hljs-string">&quot;//*[contains(@text, &#x27;关注成功&#x27;)]&quot;</span> <br>WebDriverWait(driver, <span class="hljs-number">5</span>).until(EC.visibility_of_element_located((AppiumBy.XPATH, xpath)))<br></code></pre></td></tr></table></figure><hr><h2 id="5-手势操作"><a href="#5-手势操作" class="headerlink" title="5.手势操作"></a>5.手势操作</h2><p>在 Appium 里，我们依然使用 ActionChains，但底层的逻辑从“鼠标”变成了 “手指 (Touch)”。Appium 现在全面拥抱 <strong>W3C Actions</strong> 标准。这意味着可以像剪辑视频一样，一帧一帧地“编排”手指动作。</p><p>看两个 B 站的高频场景：</p><ol><li><strong>长按 (Long Press)</strong>：长按视频封面，弹出“不感兴趣&#x2F;稍后再看”菜单。</li><li><strong>精准拖拽 (Drag &amp; Drop)</strong>：在这个视频上发弹幕，或者拖动进度条。</li></ol><hr><h3 id="👆-核心武器：ActionChains"><a href="#👆-核心武器：ActionChains" class="headerlink" title="👆 核心武器：ActionChains"></a>👆 核心武器：ActionChains</h3><p>需要引入这个老朋友：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions.action_builder <span class="hljs-keyword">import</span> ActionBuilder<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions.pointer_input <span class="hljs-keyword">import</span> PointerInput<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions <span class="hljs-keyword">import</span> interaction<br></code></pre></td></tr></table></figure><p><em>(其实通常只引入 <code>ActionChains</code> 就够用了，Appium 封装好了)</em></p><hr><h3 id="场景一：长按-Long-Press-——-呼出菜单"><a href="#场景一：长按-Long-Press-——-呼出菜单" class="headerlink" title="场景一：长按 (Long Press) —— 呼出菜单"></a>场景一：长按 (Long Press) —— 呼出菜单</h3><p>在 B 站首页或搜索列表，<strong>长按</strong>一个视频封面，通常会弹出一个预览窗口或者快捷菜单。</p><p><strong>动作分解</strong>：</p><ol><li>移动到元素中心。</li><li>按下 (click_and_hold)。</li><li><strong>停顿 (pause)</strong> —— 关键！不停顿就是普通点击。</li><li>松开 (release)。</li><li>执行 (perform)。</li></ol><h4 id="💻-代码实战-1"><a href="#💻-代码实战-1" class="headerlink" title="💻 代码实战"></a>💻 代码实战</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前置代码：启动 B 站，进入搜索结果页) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备测试长按手势...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 1. 定位目标元素 (找列表里的第一个视频封面或标题)</span><br>    <span class="hljs-comment"># B站的视频容器 ID 通常包含 &#x27;card&#x27; 或 &#x27;cover&#x27;</span><br>    target_element = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;(//android.widget.TextView[contains(@text, &#x27;Python&#x27;)])[2]&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 构建动作链</span><br>    actions = ActionChains(driver)<br>    <br>    <span class="hljs-comment"># 链式写法：</span><br>    <span class="hljs-comment"># click_and_hold(元素) -&gt; pause(秒) -&gt; release()</span><br>    actions.click_and_hold(target_element)\<br>           .pause(<span class="hljs-number">2</span>)\<br>           .release()<br>           <br>    <span class="hljs-comment"># 3. 执行动作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行长按...&quot;</span>)<br>    actions.perform()<br>    <br>    <span class="hljs-comment"># 4. 验证效果 (长按后通常会震动，或者弹窗)</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;长按结束，请看手机屏幕是否有变化&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 长按失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="场景二：精准拖拽-Drag-Scroll-——-下拉刷新"><a href="#场景二：精准拖拽-Drag-Scroll-——-下拉刷新" class="headerlink" title="场景二：精准拖拽 (Drag &#x2F; Scroll) —— 下拉刷新"></a>场景二：精准拖拽 (Drag &#x2F; Scroll) —— 下拉刷新</h3><p>虽然我们之前学过 <code>driver.swipe</code>，但 <code>ActionChains</code> 能做更细腻的**“慢速滑动”**（比如下拉刷新，滑太快可能触发不了）。</p><p><strong>动作分解</strong>：</p><ol><li>手指按下 (比如屏幕中间 <code>x=500, y=500</code>)。</li><li>移动手指 (移动到 <code>x=500, y=1500</code>)。</li><li>松开。</li></ol><h4 id="💻-代码实战：首页下拉刷新"><a href="#💻-代码实战：首页下拉刷新" class="headerlink" title="💻 代码实战：首页下拉刷新"></a>💻 代码实战：首页下拉刷新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (在 B 站首页) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备测试下拉刷新...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取屏幕尺寸，为了通用性</span><br>    size = driver.get_window_size()<br>    w = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>    h = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 起点：屏幕上方 20% 处</span><br>    start_x = w * <span class="hljs-number">0.5</span><br>    start_y = h * <span class="hljs-number">0.2</span><br>    <br>    <span class="hljs-comment"># 终点：屏幕下方 80% 处</span><br>    end_x = w * <span class="hljs-number">0.5</span><br>    end_y = h * <span class="hljs-number">0.8</span><br>    <br>    <span class="hljs-comment"># 构建动作</span><br>    actions = ActionChains(driver)<br>    <br>    <span class="hljs-comment"># pointer_action 是更底层的写法，click_and_hold 默认是点元素</span><br>    <span class="hljs-comment"># 如果要按“坐标”点，建议用 w3c_actions 的写法，或者如下技巧：</span><br>    <br>    <span class="hljs-comment"># --- 技巧：使用 move_to_location 移动到坐标 ---</span><br>    actions.w3c_actions.pointer_action.move_to_location(start_x, start_y)<br>    actions.w3c_actions.pointer_action.pointer_down() <span class="hljs-comment"># 按下</span><br>    actions.w3c_actions.pointer_action.pause(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 稍微停顿</span><br>    actions.w3c_actions.pointer_action.move_to_location(end_x, end_y) <span class="hljs-comment"># 拖到下面</span><br>    actions.w3c_actions.pointer_action.pause(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 停顿看效果</span><br>    actions.w3c_actions.pointer_action.pointer_up() <span class="hljs-comment"># 松开</span><br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行下拉...&quot;</span>)<br>    actions.perform()<br>    <br>    <span class="hljs-comment"># 验证：下拉后通常会出现“正在刷新”的 loading 图标</span><br>    time.sleep(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 下拉失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>APP测试理论基础</tag>
      
      <tag>Appium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试基础功能测试小案例</title>
    <link href="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
    <url>/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>前台地址： <a href="https://hmshop-test.itheima.net/">https://hmshop-test.itheima.net/</a></p><p>后台地址： <a href="https://hmshop-test.itheima.net/admin">https://hmshop-test.itheima.net/admin</a></p><p>本次目标： 1. 核心业务：下单业务 2. 核心模块：选择商品、购物车、注册登录、下单、支付</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image1.png" class="" title="测试流程"><h1 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h1><p>首先熟悉需求-流程：选择商品-&gt;立即购买-&gt;登录成功-&gt;提交订单成功-&gt;支付成功</p><p>并对下单业务绘制流程图</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image2.png" class="" title="流程图"><p><strong>分析出测试点：</strong></p><ul><li><strong>下单成功</strong></li><li><strong>下单失败（购物车添加失败）</strong></li><li><strong>下单失败（登录失败）</strong></li><li><strong>下单失败（提交订单失败）</strong></li><li><strong>下单失败（支付失败）</strong></li></ul><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">order_001</td><td align="center">下单成功（购物车）</td><td align="center">下单业务</td><td align="center">P0</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息</td><td align="center">1、选择商品           2、添加购物车       3、登录成功           4、提交订单成功     5、支付</td><td align="center">商品：001        商品购买数量：1            支付方式：货到付款</td><td align="center">下单成功，订单状态为待发货。     商品001库存数量减少1</td><td align="center">不通过，原因：下单成功后库存数量未减少</td></tr><tr><td align="center">order_002</td><td align="center">下单失败（添加购物车失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品002已上架且库存0</td><td align="center">1、选择商品     2、添加购物车</td><td align="center">商品：002</td><td align="center">下单失败，添加购物车按钮置灰不可点。</td><td align="center">通过</td></tr><tr><td align="center">order_003</td><td align="center">下单失败（登录失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品003已上架且库存200</td><td align="center">1、选择商品     2、添加购物车     3、登录操作</td><td align="center">商品：003     商品购买数量：1     登录操作：不登录</td><td align="center">下单失败，跳转到登录页面。</td><td align="center">通过</td></tr><tr><td align="center">order_004</td><td align="center">下单失败（提交订单失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、未添加收货人信息</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单操作</td><td align="center">商品：001     商品购买数量：1     提交订单：未选择收货人信息</td><td align="center">下单失败，提示：请填写收货人信息</td><td align="center">不通过，原因：未选择收货人信息，下单成功。</td></tr><tr><td align="center">order_005</td><td align="center">下单失败（支付失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息     4、微信余额为0     5、商品001售价大于0</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单成功     5、支付</td><td align="center">商品：001     商品购买数量：1     支付方式：微信</td><td align="center">下单失败，提示：余额不足，请更换其他支付方式。</td><td align="center">不通过，原因：返回错误信息不友好（{“return_code”:”FAIL”,”return_msg”:”mch_id参数格式错误”}）</td></tr></tbody></table><p>为这三个bug写报告：</p><hr><h3 id="🐛-Bug-报告-1：严重的数据逻辑错误"><a href="#🐛-Bug-报告-1：严重的数据逻辑错误" class="headerlink" title="🐛 Bug 报告 1：严重的数据逻辑错误"></a>🐛 Bug 报告 1：严重的数据逻辑错误</h3><p>问题来源： 用例 order_001</p><p>缺陷类型： 数据一致性 (严重程度高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 用户下单支付成功后，后台商品库存数量未自动扣减</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (严重)</strong> - <em>涉及核心库存数据，会导致超卖，属于重大事故。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 库存管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001已上架，后台库存显示为 200。 2. 用户账号已注册并登录，且已添加收货地址。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入商品详情页，选择商品001，数量为 1。 2. 点击“加入购物车”并进入结算页。 3. 点击“提交订单”并完成支付（货到付款）。 4. 登录后台管理系统，查看商品001的剩余库存。</td></tr><tr><td><strong>预期结果</strong></td><td>前台提示下单成功；<strong>后台商品001的库存数量应减少1（变为199）。</strong></td></tr><tr><td><strong>实际结果</strong></td><td>前台提示下单成功；<strong>但后台商品001的库存数量仍显示为 200（未扣减）。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：校验逻辑缺失"><a href="#🐛-Bug-报告-2：校验逻辑缺失" class="headerlink" title="🐛 Bug 报告 2：校验逻辑缺失"></a>🐛 Bug 报告 2：校验逻辑缺失</h3><p>问题来源： 用例 order_004</p><p>缺陷类型： 功能逻辑错误 (严重程度中等偏高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 结算页未选择&#x2F;未填写收货人信息，仍能成功提交订单</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (重要)</strong> - <em>导致产生无效订单，后续无法发货。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 订单提交</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001库存充足。 2. 用户已注册账号，<strong>但账号下未添加任何收货人信息</strong>。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 登录该无收货信息的账号。 2. 将商品001加入购物车。 3. 进入结算页面（此时收货人信息栏为空）。 4. 直接点击“提交订单”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td>订单提交失败，页面应弹出提示框：<strong>“请填写收货人信息”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行拦截，直接提示“下单成功”，生成了无地址的异常订单。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露"><a href="#🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露" class="headerlink" title="🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)"></a>🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)</h3><p>问题来源： 用例 order_005</p><p>缺陷类型： 用户体验 (UI&#x2F;UX)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 余额不足导致支付失败时，页面直接展示原始代码报错信息</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S3 (一般)</strong> - <em>功能逻辑是正确的（拦截了），但体验很差。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P2 (中)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 支付接口</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已下单待支付。 2. 选择“微信支付”，且模拟微信余额为 0。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 在支付页面选择“微信支付”。 2. 点击“确认支付”。 3. 观察页面返回的错误提示。</td></tr><tr><td><strong>预期结果</strong></td><td>页面应弹出友好提示：<strong>“余额不足，请更换其他支付方式”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td>页面弹窗显示后端原始 JSON 代码：<code>&#123;“return_code”:“FAIL”, “return_msg”:“mch_id参数格式错误”&#125;</code>，用户无法理解。</td></tr></tbody></table><hr><h1 id="单模块测试"><a href="#单模块测试" class="headerlink" title="单模块测试"></a>单模块测试</h1><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image3.png" class="" title="登录功能"><table><thead><tr><th align="center"><strong>输入项</strong></th><th align="center"><strong>有效等价类 (合法 - 预期成功)</strong></th><th align="center"><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td align="center">1.用户名</td><td align="center">手机号已注册</td><td align="center">用户名为空</td></tr><tr><td align="center"></td><td align="center">邮箱已注册</td><td align="center">格式错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">未注册</td></tr><tr><td align="center">2.密码</td><td align="center">密码正确</td><td align="center">密码为空</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">密码错误</td></tr><tr><td align="center">3.验证码</td><td align="center">完全匹配</td><td align="center">为空</td></tr><tr><td align="center"></td><td align="center">不限制大小写</td><td align="center">验证码错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">已失效或过期的验证码</td></tr></tbody></table><p>设计测试用例：</p><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">shop_login_001</td><td align="center">手机号登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册手机号 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.手机号：已注册的手机号 2.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_002</td><td align="center">邮箱登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册邮箱 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.验证码打乱大小写 4.点击登录</td><td align="center">1.邮箱：已注册的邮箱 2.验证码：大小写打乱 3.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_003</td><td align="center">用户名为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名为空 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名为空 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_004</td><td align="center">用户名格式错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名格式错误 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名格式错误 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号格式不匹配！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_005</td><td align="center">用户名未注册登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.未注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：未注册的用户名 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不存在！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_006</td><td align="center">密码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：错误密码 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_007</td><td align="center">密码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入验证码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：空 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_008</td><td align="center">验证码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：空</td><td align="center">登陆失败，弹窗提示：“验证码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_009</td><td align="center">验证码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：错误的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_0010</td><td align="center">验证码过期登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：过期的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr></tbody></table><hr><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image4.png" class="" title="购物车1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image5.png" class="" title="购物车2"><p>重点分析 <strong>“购物车添加商品数量”</strong> 和 <strong>“商品种类限制”</strong> 这两个核心规则。</p><h3 id="1-核心分析对象：商品数量-添加-修改"><a href="#1-核心分析对象：商品数量-添加-修改" class="headerlink" title="1. 核心分析对象：商品数量 (添加&#x2F;修改)"></a>1. 核心分析对象：商品数量 (添加&#x2F;修改)</h3><p>需求明确指出：</p><ul><li><strong>库存充足 (&gt;&#x3D;200) 时：</strong> 数量取值为 <code>[1, 200]</code>。</li><li><strong>库存不足 (&lt;200) 时：</strong> 数量取值为 <code>[1, 库存量]</code>。</li></ul><p>这意味着需要设计 <strong>两套</strong> 边界值方案。</p><h4 id="📊-分析表：商品数量输入框"><a href="#📊-分析表：商品数量输入框" class="headerlink" title="📊 分析表：商品数量输入框"></a>📊 分析表：商品数量输入框</h4><p>假设现在有一款商品 A。</p><table><thead><tr><th><strong>测试场景</strong></th><th><strong>前置条件 (环境)</strong></th><th><strong>有效等价类 (合法)</strong></th><th><strong>边界值 (BVA) - 重点！</strong></th><th><strong>无效等价类 (非法)</strong></th></tr></thead><tbody><tr><td><strong>场景 A：库存充足</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>500</strong></td><td>1 ~ 200 之间的整数</td><td><strong>上点 (有效):</strong> 1, 200 <strong>离点 (无效):</strong> 0, 201</td><td>1. 大于 200 的数 (如 201) 2. 小于 1 的数 (如 0, -1) 3. 非整数 (如 1.5) 4. 非数字 (如 abc)</td></tr><tr><td><strong>场景 B：库存紧张</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>5</strong></td><td>1 ~ 5 之间的整数</td><td><strong>上点 (有效):</strong> 1, 5 <strong>离点 (无效):</strong> 0, 6</td><td>1. 大于 5 的数 (如 6) 2. 小于 1 的数 (如 0) … (同上)</td></tr></tbody></table><h3 id="2-核心分析对象：商品种类限制"><a href="#2-核心分析对象：商品种类限制" class="headerlink" title="2. 核心分析对象：商品种类限制"></a>2. 核心分析对象：商品种类限制</h3><p>需求指出：“商品种类不能大于 20 种”。</p><p>(注意：是“种类”，不是“总数量”。买了 100 个苹果 + 1 个梨，这是 2 种)。</p><h4 id="📊-分析表：购物车种类上限"><a href="#📊-分析表：购物车种类上限" class="headerlink" title="📊 分析表：购物车种类上限"></a>📊 分析表：购物车种类上限</h4><table><thead><tr><th><strong>规则</strong></th><th><strong>有效等价类</strong></th><th><strong>边界值 (BVA)</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td><strong>种类 &lt;&#x3D; 20</strong></td><td>购物车内已有 1~19 种商品</td><td><strong>上点 (能加):</strong> 已有 19 种，再加第 20 种 -&gt; <strong>成功</strong> <strong>离点 (报错):</strong> 已有 20 种，再加第 21 种 -&gt; <strong>失败&#x2F;提示</strong></td><td>已有 20 种以上 (如数据库脏数据导致有25种)，再操作添加</td></tr></tbody></table><hr><h3 id="3-核心分析对象：修改方式-号与输入框"><a href="#3-核心分析对象：修改方式-号与输入框" class="headerlink" title="3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)"></a>3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)</h3><p>需求提到可以使用 <strong>【+】</strong> 和 <strong>【-】</strong> 调节，也可以 <strong>直接修改数字</strong>。</p><p>这里主要用 <strong>等价类划分</strong> 来覆盖交互逻辑：</p><table><thead><tr><th><strong>输入方式</strong></th><th><strong>正常类 (Happy Path)</strong></th><th><strong>异常类 (Exception)</strong></th></tr></thead><tbody><tr><td><strong>点击【+】号</strong></td><td>当前数量 &lt; 最大限制 (如库存或200)，点击后数量+1</td><td>当前数量 &#x3D; 最大限制，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (UI测试点)</td></tr><tr><td><strong>点击【-】号</strong></td><td>当前数量 &gt; 1，点击后数量-1</td><td>当前数量 &#x3D; 1，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (有些设计是弹出删除提示，需确认需求)</td></tr><tr><td><strong>直接输入框</strong></td><td>输入正常整数</td><td>输入 <strong>空格</strong>、<strong>中文</strong>、<strong>特殊符号</strong>、<strong>超长数字</strong>、<strong>负数</strong></td></tr></tbody></table><hr><h3 id="🛒-购物车功能测试用例"><a href="#🛒-购物车功能测试用例" class="headerlink" title="🛒 购物车功能测试用例"></a>🛒 购物车功能测试用例</h3><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>CART_001</strong></td><td><strong>添加商品-库存充足边界值 (Max)</strong></td><td><strong>P0</strong></td><td>1. 商品A库存为 <strong>500</strong> 2. 购物车无该商品</td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>200</strong></td><td>添加成功，购物车中显示商品A数量为 200</td></tr><tr><td><strong>CART_002</strong></td><td><strong>添加商品-超过最大购买限制</strong></td><td>P1</td><td>1. 商品A库存为 <strong>500</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>201</strong></td><td>添加失败，提示“最多只能购买200件”或自动变为200</td></tr><tr><td><strong>CART_003</strong></td><td><strong>添加商品-动态库存边界 (全部库存)</strong></td><td><strong>P0</strong></td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>5</strong></td><td>添加成功，购物车中显示商品B数量为 5</td></tr><tr><td><strong>CART_004</strong></td><td><strong>添加商品-超过动态库存</strong></td><td>P1</td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>6</strong></td><td>添加失败，提示“库存不足”或自动修正为5</td></tr><tr><td><strong>CART_005</strong></td><td><strong>修改数量-最小边界值 (Min)</strong></td><td>P1</td><td>1. 购物车中有 2 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td>数量变为 <strong>1</strong>，且【-】号按钮变灰或不可点击</td></tr><tr><td><strong>CART_006</strong></td><td><strong>修改数量-下限溢出保护</strong></td><td>P2</td><td>1. 购物车中有 1 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td><strong>数量保持为 1</strong> (或弹出删除确认框，视具体交互而定)，不能变为 0 或负数</td></tr><tr><td><strong>CART_007</strong></td><td><strong>直接输入非法字符</strong></td><td>P2</td><td>1. 购物车中有商品A</td><td>1. 点击数量输入框 2. 输入非法字符</td><td>数量: <code>abc</code> 或 <code>1.5</code></td><td>输入框不接受非法字符，或自动恢复为修改前的数字</td></tr><tr><td><strong>CART_008</strong></td><td><strong>商品种类上限-有效边界</strong></td><td>P1</td><td>1. 购物车已添加 <strong>19</strong> 种不同商品</td><td>1. 去添加第 <strong>20</strong> 种新商品</td><td>商品T (新种类)</td><td>添加成功，购物车内显示 20 种商品</td></tr><tr><td><strong>CART_009</strong></td><td><strong>商品种类上限-无效边界</strong></td><td>P2</td><td>1. 购物车已添加 <strong>20</strong> 种不同商品</td><td>1. 去添加第 <strong>21</strong> 种新商品</td><td>商品U (新种类)</td><td>添加失败，提示“购物车商品种类已达上限(20种)”</td></tr><tr><td><strong>CART_010</strong></td><td><strong>删除功能-批量删除</strong></td><td>P1</td><td>1. 购物车有商品A, B, C</td><td>1. 勾选商品A和B 2. 点击【删除选中商品】</td><td>&#x2F;</td><td>商品A和B消失，商品C保留，总价自动重新计算</td></tr><tr><td><strong>CART_011</strong></td><td><strong>空状态显示 (已登录)</strong></td><td>P2</td><td>1. 用户已登录 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车空空的哦<del>，去看看心仪的商品吧</del>”</td></tr><tr><td><strong>CART_012</strong></td><td><strong>空状态显示 (未登录)</strong></td><td>P2</td><td>1. 用户<strong>未登录</strong> 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车内暂时没有商品，登录后将显示您之前加入的商品”</td></tr></tbody></table><hr><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image6.png" class="" title="支付1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image7.png" class="" title="支付2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>PAY_001</strong></td><td><strong>最小金额支付 (边界值)</strong></td><td><strong>P0</strong></td><td>订单金额为 <strong>0.01</strong> 元</td><td>选择支付方式，点击确认支付</td><td>金额: 0.01</td><td>成功发起支付，跳转第三方或显示支付成功</td></tr><tr><td><strong>PAY_002</strong></td><td><strong>零金额支付限制 (边界值)</strong></td><td>P1</td><td>订单金额为 <strong>0.00</strong> 元 (需后台造数据)</td><td>尝试点击确认支付</td><td>金额: 0.00</td><td><strong>支付按钮置灰</strong> 或 提示“支付金额不能为0”</td></tr><tr><td><strong>PAY_003</strong></td><td><strong>支付倒计时有效性</strong></td><td>P1</td><td>订单已生成 <strong>29分50秒</strong></td><td>等待至 30分01秒，刷新页面或点击支付</td><td>&#x2F;</td><td>提示“订单已超时&#x2F;已关闭”，无法继续支付</td></tr><tr><td><strong>PAY_004</strong></td><td><strong>支付方式互斥性 (UI)</strong></td><td>P2</td><td>&#x2F;</td><td>1. 默认“货到付款”被选中 2. 点击“支付宝”</td><td>&#x2F;</td><td>“货到付款”自动取消选中，“支付宝”变为选中状态</td></tr><tr><td><strong>PAY_005</strong></td><td><strong>余额不足支付失败</strong></td><td>P1</td><td>选择微信支付</td><td>1. 扫码 2. 使用余额为0的微信账号支付</td><td>&#x2F;</td><td>微信端提示余额不足，商城页面保持在“待支付”状态</td></tr><tr><td><strong>PAY_006</strong></td><td><strong>重复支付拦截 (幂等性)</strong></td><td><strong>P0</strong></td><td>订单已在另一个窗口支付成功</td><td>1. 在当前窗口（旧状态）再次点击“支付”</td><td>&#x2F;</td><td>系统拦截，提示“该订单已支付”，并自动刷新状态为已支付</td></tr><tr><td><strong>PAY_007</strong></td><td><strong>支付时价格变动 (高风险)</strong></td><td><strong>P1</strong></td><td>1. 下单时商品 100元 2. <strong>后台将商品改价为 200元</strong></td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td><strong>页面刷新显示最新价格 200元</strong>，并提示“商品价格已变动，请重新确认”</td></tr><tr><td><strong>PAY_008</strong></td><td><strong>密码错误重试</strong></td><td>P2</td><td>选择银行卡支付</td><td>1. 输错密码 2. 再次输入正确密码</td><td>&#x2F;</td><td>第一次提示错误，第二次支付成功</td></tr><tr><td><strong>PAY_009</strong></td><td><strong>合并支付</strong></td><td>P2</td><td>购物车有商品A和商品B</td><td>1. 勾选A和B 2. 提交订单并支付</td><td>&#x2F;</td><td>支付金额为 A+B 的总和，支付一次即可</td></tr></tbody></table><p>太棒了！我们就挑选支付模块中**“含金量”最高**（也是面试官最爱听）的两个场景来写 Bug 报告。</p><p>这两个 Bug 分别对应了 <strong>严重的功能逻辑漏洞（让公司亏钱）</strong> 和 <strong>边界值校验缺失</strong>。</p><p>请按照下面的格式，直接把这两个单子录入到你的缺陷管理系统里。</p><hr><h3 id="🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）"><a href="#🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）" class="headerlink" title="🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）"></a>🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）</h3><p>这个 Bug 非常经典，直接违反了需求文档中“支付时刻会获取当前订单的最新价格进行显示支付” 这一条风控规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单生成后后台修改商品价格，前台支付时未同步最新价格，导致用户可低价购买</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (致命)</strong> - <em>直接导致资金损失，属于核心业务逻辑错误。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心 &#x2F; 订单管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已登录，且购物车中有商品A（单价 100元）。 2. 拥有后台管理系统权限的账号已登录。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户在前台提交包含商品A的订单，订单金额显示 100元，状态为“待支付”。 2. <strong>(关键步骤)</strong> 管理员在后台将商品A的单价修改为 <strong>200元</strong>。 3. 用户在支付页面（不刷新）或订单列表点击“去支付”。 4. 观察支付网关显示的应付金额。</td></tr><tr><td><strong>预期结果</strong></td><td>系统应拦截旧价格支付，提示**“商品价格已变动，请重新确认”**，并刷新支付金额为 <strong>200元</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行价格二次校验，支付网关仍显示应付金额 100元，用户成功以旧价格完成支付。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：零金额支付漏洞（边界值校验）"><a href="#🐛-Bug-报告-2：零金额支付漏洞（边界值校验）" class="headerlink" title="🐛 Bug 报告 2：零金额支付漏洞（边界值校验）"></a>🐛 Bug 报告 2：零金额支付漏洞（边界值校验）</h3><p>这个 Bug 对应需求文档中“待支付的订单金额为0.00时，无法进行确认支付” 这一条规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单金额为 0.00 元时，未限制“确认支付”操作，可直接发起支付</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (严重)</strong> - <em>虽然不涉及亏钱，但违反了明确的业务规则，可能导致下游财务系统账单异常。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 后台创建一个价格为 0.00 元的测试商品（或使用优惠券抵扣至0元）。 2. 用户下单该商品，生成金额为 0.00 的待支付订单。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入该订单的支付页面。 2. 保持默认支付方式（如货到付款或在线支付）。 3. 点击“确认支付”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td><strong>“确认支付”按钮应置灰不可点击</strong>，或点击后弹出提示“订单金额为0，无法进行支付”。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>按钮可点击，系统提示“支付成功”或跳转到了第三方支付页面（报错参数错误），未能正确拦截。</strong></td></tr></tbody></table><hr><h3 id="💡-为什么选这两个写报告？"><a href="#💡-为什么选这两个写报告？" class="headerlink" title="💡 为什么选这两个写报告？"></a>💡 为什么选这两个写报告？</h3><p>问：“在项目中发现过什么印象深刻的 Bug？”</p><blockquote><p>“我在测试支付模块时，发现了一个 <strong>数据一致性</strong> 的严重 Bug。需求要求支付时必须获取最新价格，但我模拟了‘下单后后台改价’的场景，发现前端传给支付接口的还是旧价格。这会导致用户能‘薅羊毛’，造成公司资损。后来我提了 P0 级的 Bug，开发加了支付前的二次校验逻辑才修复。”</p></blockquote><hr><h1 id="非功能性测试"><a href="#非功能性测试" class="headerlink" title="非功能性测试"></a>非功能性测试</h1><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目&#x2F;模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>tpshop_not_function_001</td><td>项目所有功能显示和操作正常（谷歌）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新谷歌浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_002</td><td>项目所有功能显示和操作正常（火狐）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新火狐浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_003</td><td>项目所有功能显示和操作正常（Edge）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新Edge浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_004</td><td>项目所有功能显示和操作正常（苹果）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新苹果浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_005</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr><tr><td>tpshop_not_function_006</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_PERF_001</strong></td><td><strong>提交订单接口响应时间测试</strong></td><td><strong>P1</strong></td><td>1. 模拟 50 个用户并发在线 2. 数据库中有充足库存</td><td>1. 使用 JMeter 或 LoadRunner 模拟并发点击“提交订单”</td><td>并发数: 50</td><td>1. 平均响应时间 &lt; <strong>3秒</strong> 2. 成功率 100% 3. 服务器 CPU&#x2F;内存占用率 &lt; 80%</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_SEC_001</strong></td><td><strong>商品搜索框 SQL 注入漏洞测试</strong></td><td><strong>P0</strong></td><td>打开商城首页</td><td>1. 在搜索框输入 SQL 注入脚本 2. 点击搜索</td><td><code>&#39; OR 1=1 --</code></td><td>系统拦截特殊字符或提示“未找到商品”，<strong>严禁</strong> 显示数据库报错信息或列出所有商品数据</td></tr><tr><td><strong>NON_FUNC_SEC_002</strong></td><td><strong>XSS 跨站脚本攻击 (评论区)</strong></td><td>P1</td><td>用户已登录</td><td>1. 在商品评价输入框填入 JS 脚本 2. 提交评价 3. 换个账号查看该评价</td><td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td><td>脚本被转义显示为普通文本，<strong>不会</strong> 弹出浏览器弹窗 (Alert)</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_NET_001</strong></td><td><strong>弱网环境支付测试 (丢包&#x2F;延迟)</strong></td><td>P2</td><td>1. 使用 Fiddler&#x2F;Charles 开启弱网模拟 (上行 2kb&#x2F;s) 2. 处于支付确认页</td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td>1. 页面出现 Loading 动画，而不是假死 2. 若超时，提示“网络不给力，请重试” 3. <strong>不会</strong> 出现崩溃或白屏</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试基础</tag>
      
      <tag>功能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Playwright学习</title>
    <link href="/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><p>在 Playwright 中，定位元素主要分为<strong>两派</strong>：</p><ol><li><strong>传统派（兼容 Selenium 思维）</strong>：使用 CSS 和 XPath。</li><li><strong>新潮派（官方推荐）</strong>：使用“用户看到什么就找什么”的方式。</li></ol><hr><h3 id="第一步：传统派-——-page-locator"><a href="#第一步：传统派-——-page-locator" class="headerlink" title="第一步：传统派 —— page.locator()"></a>第一步：传统派 —— <code>page.locator()</code></h3><p>在 Playwright 里，不需要像 Selenium 那样记 By.ID, By.XPATH, By.CSS_SELECTOR 这么多分类。</p><p>你只需要记住一个万能方法：page.locator(“写在这里”)。</p><p>它会自动识别你写的是 CSS 还是 XPath。</p><h4 id="1-ID-定位"><a href="#1-ID-定位" class="headerlink" title="1. ID 定位"></a>1. ID 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.ID, &quot;kw&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>#</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Class-定位"><a href="#2-Class-定位" class="headerlink" title="2. Class 定位"></a>2. Class 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CLASS_NAME, &quot;s_ipt&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>.</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;.s_ipt&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-XPath-定位"><a href="#3-XPath-定位" class="headerlink" title="3. XPath 定位"></a>3. XPath 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.XPATH, &quot;//input[@id=&#39;kw&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>: 直接写 XPath 字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-CSS-选择器-最常用"><a href="#4-CSS-选择器-最常用" class="headerlink" title="4. CSS 选择器 (最常用)"></a>4. CSS 选择器 (最常用)</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CSS_SELECTOR, &quot;input[name=&#39;wd&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;input[name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>🟢 总结：</strong> 只要会写 CSS 或 XPath，直接往 <code>page.locator()</code> 里塞就行了，不需要指定类型。</p></blockquote><hr><h3 id="第二步：新潮派-——-官方推荐的“语义化定位”"><a href="#第二步：新潮派-——-官方推荐的“语义化定位”" class="headerlink" title="第二步：新潮派 —— 官方推荐的“语义化定位”"></a>第二步：新潮派 —— 官方推荐的“语义化定位”</h3><p>Playwright 认为：CSS 和 XPath 是给程序员看的，不是给用户看的。</p><p>如果程序员改了代码（比如把 id&#x3D;”submit-btn” 改成了 id&#x3D;”login-btn”），CSS 定位就挂了。但**按钮上的文字“登录”**通常不会变。</p><p>所以，Playwright 推出了一套<strong>根据页面内容</strong>定位的方法。</p><h4 id="1-找文字-——-get-by-text"><a href="#1-找文字-——-get-by-text" class="headerlink" title="1. 找文字 —— get_by_text()"></a>1. 找文字 —— <code>get_by_text()</code></h4><p>对应 Selenium 的 <code>By.LINK_TEXT</code> 或 XPath 的 <code>text()=</code>。</p><ul><li><p><strong>场景</strong>：页面上有个 <code>&lt;span&gt;欢迎回来&lt;/span&gt;</code> 或 <code>&lt;a&gt;新闻&lt;/a&gt;</code>。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模糊匹配（包含即可）</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎&quot;</span>) <br><br><span class="hljs-comment"># 精确匹配</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎回来&quot;</span>, exact=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-找表单输入框-——-get-by-placeholder"><a href="#2-找表单输入框-——-get-by-placeholder" class="headerlink" title="2. 找表单输入框 —— get_by_placeholder()"></a>2. 找表单输入框 —— <code>get_by_placeholder()</code></h4><ul><li><p><strong>场景</strong>：输入框里灰色的提示字（Placeholder）。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要输入框里写着 &quot;请输入密码&quot;，就能找到</span><br>page.get_by_placeholder(<span class="hljs-string">&quot;请输入密码&quot;</span>).fill(<span class="hljs-string">&quot;123456&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-找角色（按钮-链接-标题）——-get-by-role-最核心"><a href="#3-找角色（按钮-链接-标题）——-get-by-role-最核心" class="headerlink" title="3. 找角色（按钮&#x2F;链接&#x2F;标题）—— get_by_role() (最核心)"></a>3. 找角色（按钮&#x2F;链接&#x2F;标题）—— <code>get_by_role()</code> <strong>(最核心)</strong></h4><p>这是 Playwright 最强大的地方，它通过 HTML 的<strong>语义</strong>来找。</p><ul><li><p><strong>找按钮</strong> (<code>&lt;button&gt;</code> 或 <code>input type=&quot;submit&quot;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;登录&quot; 的按钮</span><br>page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;登录&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找链接</strong> (<code>&lt;a&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;首页&quot; 的链接</span><br>page.get_by_role(<span class="hljs-string">&quot;link&quot;</span>, name=<span class="hljs-string">&quot;首页&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找标题</strong> (<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找内容是 &quot;用户注册&quot; 的一级标题</span><br>page.get_by_role(<span class="hljs-string">&quot;heading&quot;</span>, name=<span class="hljs-string">&quot;用户注册&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="第三步：实战练习（通过高亮来验证）"><a href="#第三步：实战练习（通过高亮来验证）" class="headerlink" title="第三步：实战练习（通过高亮来验证）"></a>第三步：实战练习（通过高亮来验证）</h3><p>为了让你直观地看到定位对不对，我们不执行点击，而是用 <strong><code>.highlight()</code></strong> 方法。这会在浏览器里给元素画个红框，非常适合学习！</p><p>我们以 <strong>百度 (baidu.com)</strong> 为例。</p><p>请新建一个 <code>demo_locator.py</code>，把下面的代码复制进去运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># --- 练习 1: 使用 CSS ID 定位搜索框 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在高亮搜索框 (CSS ID)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.ID &quot;kw&quot;</span><br>    page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿 2 秒让你看清楚红框</span><br><br>    <span class="hljs-comment"># --- 练习 2: 使用 XPath 定位“百度一下”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2. 正在高亮按钮 (XPath)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.XPATH</span><br>    page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;su&#x27;]&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 3: 使用新潮的 get_by_text 定位右上角的“新闻” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3. 正在高亮链接 (Text)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.LINK_TEXT &quot;新闻&quot;</span><br>    page.get_by_text(<span class="hljs-string">&quot;新闻&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 4: 使用新潮的 get_by_role 定位“百度一下”按钮 ---</span><br>    <span class="hljs-comment"># 注意：百度的按钮有时候识别有点怪，这里作为进阶尝试</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;4. 尝试用 Role 定位按钮...&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;百度一下&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h1><p>Playwright 的操作逻辑更简洁，而且解决了一个 Selenium 的大痛点：<strong>它会自动等待元素准备好</strong>。</p><hr><h3 id="1-导航操作-Browser-Actions"><a href="#1-导航操作-Browser-Actions" class="headerlink" title="1. 导航操作 (Browser Actions)"></a>1. 导航操作 (Browser Actions)</h3><p>Playwright 的导航方法和 Selenium 非常像，只是名字稍微变了一点点。</p><table><thead><tr><th><strong>操作</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>打开网页</td><td><code>driver.get(url)</code></td><td><code>page.goto(url)</code></td><td>Playwright 默认会等待页面加载完成(load状态)</td></tr><tr><td>后退</td><td><code>driver.back()</code></td><td><code>page.go_back()</code></td><td>-</td></tr><tr><td>前进</td><td><code>driver.forward()</code></td><td><code>page.go_forward()</code></td><td>-</td></tr><tr><td>刷新</td><td><code>driver.refresh()</code></td><td><code>page.reload()</code></td><td>-</td></tr><tr><td>获取标题</td><td><code>driver.title</code> (属性)</td><td><code>page.title()</code> (方法)</td><td>注意 Playwright 是方法，要加括号 <code>()</code></td></tr><tr><td>获取URL</td><td><code>driver.current_url</code></td><td><code>page.url</code> (属性)</td><td>这个是属性，<strong>不加</strong>括号</td></tr></tbody></table><hr><h3 id="2-元素核心操作-Interaction"><a href="#2-元素核心操作-Interaction" class="headerlink" title="2. 元素核心操作 (Interaction)"></a>2. 元素核心操作 (Interaction)</h3><p>这是自动化测试最高频的操作：输入和点击。</p><h4 id="A-输入框：fill-vs-send-keys"><a href="#A-输入框：fill-vs-send-keys" class="headerlink" title="A. 输入框：fill vs send_keys"></a>A. 输入框：<code>fill</code> vs <code>send_keys</code></h4><ul><li><p>Selenium:</p><p>你需要先 clear() 清空，再 send_keys()。</p></li><li><p>Playwright:</p><p>只有一个神器 fill(“内容”)。它会自动先清空输入框，再输入内容。一步到位。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Selenium</span><br>ele.clear()<br>ele.send_keys(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (推荐)</span><br>page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (如果你想模拟逐个按键，比如测试搜索联想)</span><br>page.locator(<span class="hljs-string">&quot;#search&quot;</span>).press_sequentially(<span class="hljs-string">&quot;test&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h4 id="B-点击：click"><a href="#B-点击：click" class="headerlink" title="B. 点击：click"></a>B. 点击：<code>click</code></h4><ul><li><p>Playwright: page.locator(“…”).click()。</p><p>最大优势：它自带智能等待。它会检查元素是否可见、是否停止移动、是否被遮挡。如果被遮挡，它会等待遮挡物消失再点。</p></li></ul><hr><h3 id="3-获取元素信息-Get-Info"><a href="#3-获取元素信息-Get-Info" class="headerlink" title="3. 获取元素信息 (Get Info)"></a>3. 获取元素信息 (Get Info)</h3><p>用于做断言（Assert），验证测试结果。</p><table><thead><tr><th><strong>获取内容</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>获取文本</strong></td><td><code>ele.text</code></td><td><code>locator.inner_text()</code> (可见文本) <code>locator.text_content()</code> (包含隐藏文本)</td></tr><tr><td><strong>获取属性</strong></td><td><code>ele.get_attribute(&quot;type&quot;)</code></td><td><code>locator.get_attribute(&quot;type&quot;)</code></td></tr><tr><td><strong>是否可见</strong></td><td><code>ele.is_displayed()</code></td><td><code>locator.is_visible()</code></td></tr><tr><td><strong>是否可用</strong></td><td><code>ele.is_enabled()</code></td><td><code>locator.is_enabled()</code></td></tr></tbody></table><hr><h3 id="💻-实战演练"><a href="#💻-实战演练" class="headerlink" title="💻 实战演练"></a>💻 实战演练</h3><p>场景：网站 the-internet.herokuapp.com。</p><ol><li>打开登录页。</li><li>输入用户名和密码（使用 <code>fill</code>）。</li><li>点击登录。</li><li>获取提示文字（使用 <code>inner_text</code>）。</li><li>刷新页面。</li></ol><p>新建文件 <code>demo_action.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">1000</span>) <span class="hljs-comment"># slow_mo 让你看清操作</span><br>    page = browser.new_page()<br><br>    <span class="hljs-comment"># 2. 导航</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在打开网页...&quot;</span>)<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span>)<br>    <br>    <span class="hljs-comment"># 打印当前标题</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 3. 元素操作：输入 (使用 fill，自动清空 + 输入)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在输入账号密码...&quot;</span>)<br>    <span class="hljs-comment"># 这里演示用 CSS 选择器定位</span><br>    page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br>    page.locator(<span class="hljs-string">&quot;#password&quot;</span>).fill(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br>    <span class="hljs-comment"># 4. 元素操作：点击</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 点击登录按钮...&quot;</span>)<br>    <span class="hljs-comment"># 使用语义化定位：找一个 type=&quot;submit&quot; 的按钮 (或者用 class=&quot;radius&quot;)</span><br>    page.locator(<span class="hljs-string">&quot;button[type=&#x27;submit&#x27;]&quot;</span>).click()<br><br>    <span class="hljs-comment"># 5. 获取信息：断言</span><br>    <span class="hljs-comment"># 登录成功后会出现一个 id=&quot;flash&quot; 的提示条</span><br>    flash_message = page.locator(<span class="hljs-string">&quot;#flash&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 获取到的提示信息: \n<span class="hljs-subst">&#123;flash_message&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 简单断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> flash_message:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 测试通过：登录成功！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 测试失败&quot;</span>)<br><br>    <span class="hljs-comment"># 6. 额外操作：刷新</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 刷新页面...&quot;</span>)<br>    page.reload()<br><br>    <span class="hljs-comment"># 截图留念 (Selenium 是 get_screenshot_as_file)</span><br>    page.screenshot(path=<span class="hljs-string">&quot;login_result.png&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已截图保存为 login_result.png&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h1><p>这部分是 Playwright 对比 Selenium <strong>最爽</strong>的改进之一！🤯</p><p>在你的 Selenium 笔记中，处理新窗口（Tab）非常痛苦：</p><ol><li>先获取 <code>window_handles</code>（一堆看不懂的字符串 ID）。</li><li>必须写个循环判断哪个是新窗口。</li><li><strong>核心痛点</strong>：Driver 是“单线程”的，必须 <code>switch_to</code> 过去才能操作新窗口，操作完还得 <code>switch_to</code> 回来。一旦忘了切回来，代码立马报错。</li></ol><h3 id="Playwright-的逻辑：多线操作"><a href="#Playwright-的逻辑：多线操作" class="headerlink" title="Playwright 的逻辑：多线操作"></a>Playwright 的逻辑：多线操作</h3><p>Playwright 不需要切换句柄（Switch）。</p><p>它把每一个标签页都看作一个独立的对象 (Page Object)。</p><ul><li>主窗口是 <code>page1</code>。</li><li>新窗口是 <code>page2</code>。</li><li>手里拿着两个遥控器，<strong>同时</strong>控制两个窗口，完全不需要切来切去！</li></ul><hr><h3 id="1-捕获新窗口"><a href="#1-捕获新窗口" class="headerlink" title="1. 捕获新窗口"></a>1. 捕获新窗口</h3><p>在 Selenium 里是“点击 -&gt; 然后找窗口”。</p><p>在 Playwright 里是“设置陷阱 (监听器) -&gt; 点击 -&gt; 捕获窗口”。</p><p>我们使用 Python 的 <code>with</code> 语法来捕获弹出的新页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置监听器：当有新页面弹出(popup)时，把信息存到 popup_info 里</span><br><span class="hljs-keyword">with</span> page.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>    page.get_by_text(<span class="hljs-string">&quot;打开新窗口&quot;</span>).click()<br><br><span class="hljs-comment"># 拿到新窗口对象，命名为 page2</span><br>page2 = popup_info.value<br></code></pre></td></tr></table></figure><p>现在，<code>page</code> 变量控制老窗口，<code>page2</code> 变量控制新窗口。就这么简单。</p><hr><h3 id="💻-实战演示"><a href="#💻-实战演示" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h3><p>我们继续使用你笔记里的 <strong>The Internet</strong> 靶场 进行演示。</p><p>新建文件 <code>demo_window.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    context = browser.new_context()<br>    <br>    <span class="hljs-comment"># page1 代表主窗口 (老家)</span><br>    page1 = context.new_page()<br>    page1.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;page1.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：点击链接并捕获新窗口 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 准备点击链接...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 语法含义：在这个代码块执行期间，如果弹出了新窗口，就抓给我！</span><br>    <span class="hljs-keyword">with</span> page1.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>        page1.get_by_text(<span class="hljs-string">&quot;Click Here&quot;</span>).click()<br>    <br>    <span class="hljs-comment"># 获取新窗口对象，这才是我们要操作的新页面</span><br>    page2 = popup_info.value<br>    <br>    <span class="hljs-comment"># 等待新页面加载完成 (Playwright 自动处理，但显式等一下更稳)</span><br>    page2.wait_for_load_state()<br><br>    <span class="hljs-comment"># --- 3. 同时操作两个窗口 (无需 Switch!) ---</span><br>    <br>    <span class="hljs-comment"># 操作新窗口</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口标题: <span class="hljs-subst">&#123;page2.title()&#125;</span>&quot;</span>)<br>    heading_text = page2.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口内容: <span class="hljs-subst">&#123;heading_text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 操作老窗口 (直接用 page1 即可，完全不用切回去)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回去操作老窗口 (没切句柄哦)...&quot;</span>)<br>    original_heading = page1.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;老窗口内容: <span class="hljs-subst">&#123;original_heading&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 4. 关闭 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭新窗口&quot;</span>)<br>    page2.close()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭主窗口&quot;</span>)<br>    page1.close()<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="2-Iframe"><a href="#2-Iframe" class="headerlink" title="2. Iframe"></a>2. Iframe</h3><p>你笔记里也提到了 <strong>Iframe</strong> 的痛点：需要 <code>switch_to.frame()</code> 进去，操作完必须 <code>switch_to.default_content()</code> 出来。</p><p>Playwright 同样不需要切进切出！它引入了一个 frame_locator 的概念。</p><p>你就把它当成是“路径”的一部分，一层层点下去就行。</p><p><strong>语法对比：</strong></p><ul><li><p><strong>Selenium (切进切出):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;frame_id&quot;</span>)<br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br>driver.switch_to.default_content() <span class="hljs-comment"># 必须记得出来！</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Playwright (直接钻取):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 意思是：找到 id 为 frame_id 的框，再在里面找 id 为 btn 的按钮，点击。</span><br>page.frame_locator(<span class="hljs-string">&quot;#frame_id&quot;</span>).locator(<span class="hljs-string">&quot;#btn&quot;</span>).click()<br></code></pre></td></tr></table></figure><p><em>它只是定位链条变长了，不需要改变上下文状态。</em></p></li></ul><hr><h1 id="等待机制"><a href="#等待机制" class="headerlink" title="等待机制"></a>等待机制</h1><p>这是 Playwright 对比 Selenium <strong>降维打击</strong>最狠的地方。</p><hr><h3 id="1-强制等待-Forced-Wait"><a href="#1-强制等待-Forced-Wait" class="headerlink" title="1. 强制等待 (Forced Wait)"></a>1. 强制等待 (Forced Wait)</h3><ul><li><strong>Selenium</strong>: <code>time.sleep(3)</code> (单位：秒)</li><li><strong>Playwright</strong>: <code>page.wait_for_timeout(3000)</code> (单位：<strong>毫秒</strong>)<ul><li><strong>注意</strong>: 和 Selenium 一样，官方<strong>强烈不推荐</strong>在生产代码里用。它只适合在调试时想让浏览器停下看一眼。</li></ul></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait"><a href="#2-隐式等待-Implicit-Wait" class="headerlink" title="2. 隐式等待 (Implicit Wait)"></a>2. 隐式等待 (Implicit Wait)</h3><ul><li><strong>Selenium</strong>: <code>driver.implicitly_wait(10)</code><ul><li>设置一个全局查找超时时间。</li></ul></li><li><strong>Playwright</strong>: <strong>全局超时 (Global Timeout)</strong><ul><li>Playwright 默认就有 <strong>30秒</strong> 的超时时间。</li><li>不需要像 Selenium 那样手动写一行代码去开启它。</li><li>如果想改，可以用 <code>page.set_default_timeout(5000)</code>。</li></ul></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-核心区别！"><a href="#3-显式等待-Explicit-Wait-——-核心区别！" class="headerlink" title="3. 显式等待 (Explicit Wait) —— 核心区别！"></a>3. 显式等待 (Explicit Wait) —— 核心区别！</h3><p>这是重点。在 Selenium 里，必须手动写 <code>WebDriverWait</code> + <code>EC.element_to_be_clickable</code>。</p><p><strong>在 Playwright 中，显式等待融入到了每一个操作里。</strong></p><h4 id="A-动作自动等待-Auto-Wait-for-Actions"><a href="#A-动作自动等待-Auto-Wait-for-Actions" class="headerlink" title="A. 动作自动等待 (Auto-Wait for Actions)"></a>A. 动作自动等待 (Auto-Wait for Actions)</h4><p>当你执行 <code>.click()</code>, <code>.fill()</code>, <code>.check()</code> 等操作时，Playwright 会<strong>自动</strong>执行一系列检查（相当于内置了最严格的显式等待）：</p><ol><li><strong>Attached</strong>: 元素是否已经连接到 DOM？</li><li><strong>Visible</strong>: 元素是否可见（没有 <code>display: none</code>）？</li><li><strong>Stable</strong>: 元素是否停止了动画（位置不再飘移）？</li><li><strong>Receives Events</strong>: 元素是否被其他层（比如遮罩）挡住了？</li><li><strong>Enabled</strong>: 元素是否可用（没有 <code>disabled</code> 属性）？</li></ol><p><strong>结论：</strong> 再也不用写 <code>wait_until_clickable</code> 了。直接 <code>click()</code>，如果不满足条件，它自己会等。</p><h4 id="B-断言自动等待-Web-First-Assertions"><a href="#B-断言自动等待-Web-First-Assertions" class="headerlink" title="B. 断言自动等待 (Web-First Assertions)"></a>B. 断言自动等待 (Web-First Assertions)</h4><p>对应 Selenium 的 WebDriverWait(driver).until(EC.visibility_of(…))。</p><p>Playwright 使用 expect 断言库来实现智能等待。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这一行代码会自动重试（默认 5 秒），直到文字变成 &quot;Success&quot;</span><br><span class="hljs-comment"># 如果 5 秒后还不是这个字，才会报错</span><br>expect(page.locator(<span class="hljs-string">&quot;#status&quot;</span>)).to_have_text(<span class="hljs-string">&quot;Success&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚔️-实战：动态加载页面-VS-Selenium"><a href="#⚔️-实战：动态加载页面-VS-Selenium" class="headerlink" title="⚔️ 实战：动态加载页面 (VS Selenium)"></a>⚔️ 实战：动态加载页面 (VS Selenium)</h3><p>The Internet - Dynamic Loading。</p><p>场景：点击 “Start” 按钮，等 5 秒 loading 条消失，出现 “Hello World!”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    <br>    <span class="hljs-comment"># 1. 打开动态加载页面</span><br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 点击 Start</span><br>    <span class="hljs-comment"># Playwright 会自动等待按钮准备好再点</span><br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Start&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已点击 Start，正在等待 Hello World 出现...&quot;</span>)<br>    <br>    <span class="hljs-comment"># --- 核心对比 ---</span><br>    <br>    <span class="hljs-comment"># Selenium 需要写: </span><br>    <span class="hljs-comment"># WebDriverWait(driver, 10).until(EC.visibility_of_element_located(...))</span><br>    <br>    <span class="hljs-comment"># Playwright 只需要写断言:</span><br>    <span class="hljs-comment"># expect 会自动等待(默认5秒)直到元素可见。</span><br>    <span class="hljs-comment"># 注意：这个网页加载特别慢(超5秒)，我们可以单独给这一步加长超时时间</span><br>    target_text = page.get_by_text(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    expect(target_text).to_be_visible(timeout=<span class="hljs-number">10000</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 成功！文字出现了。&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_text.inner_text()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><h3 id="🧠-如果非要等呢？"><a href="#🧠-如果非要等呢？" class="headerlink" title="🧠 如果非要等呢？"></a>🧠 如果非要等呢？</h3><p>虽然 <code>expect</code> 和 <code>auto-wait</code> 覆盖了 99% 的场景，但有时候你就是想单纯地“等某个元素出现，但不操作它，也不断言它”。</p><p>Playwright 提供了类似 Selenium <code>EC</code> 的手动等待方法：</p><table><thead><tr><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><code>wait.until(EC.visibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;visible&quot;)</code></td></tr><tr><td><code>wait.until(EC.invisibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;hidden&quot;)</code></td></tr><tr><td><code>wait.until(EC.presence_of(...))</code></td><td><code>locator.wait_for(state=&quot;attached&quot;)</code></td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 等待 loading 条消失 (detached / hidden)</span><br>page.locator(<span class="hljs-string">&quot;#loading&quot;</span>).wait_for(state=<span class="hljs-string">&quot;hidden&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><p>下拉框被分为了“标准”和“非标准”两类。Playwright 对这两类的处理方式和 Selenium 逻辑一致，但在 API 上做到了<strong>极简</strong>。</p><hr><h3 id="第一类：标准下拉框-标签"><a href="#第一类：标准下拉框-标签" class="headerlink" title="第一类：标准下拉框 (&lt;select&gt; 标签)"></a>第一类：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>在 Selenium 中，必须引入 <code>Select</code> 类，实例化它，然后调用 <code>select_by_visible_text</code> 等方法。</p><p>Playwright 不需要引入额外的类。它直接在 locator 上提供了一个 select_option() 方法，把 Selenium 的三种选择方式合三为一了。</p><h4 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 通过 value 属性选 (对应 select_by_value)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(value=<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-comment"># 2. 通过可见文本选 (对应 select_by_visible_text) —— 最常用</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br><br><span class="hljs-comment"># 3. 通过索引选 (对应 select_by_index)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(index=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="💻-实战演示-1"><a href="#💻-实战演示-1" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h4><p><code>the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># 定位到 select 元素</span><br>    dropdown = page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方式 1: 通过 Label (文本) 选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 1 (by Label)...&quot;</span>)<br>    <span class="hljs-comment"># 这相当于 Selenium 的 select_by_visible_text(&quot;Option 1&quot;)</span><br>    dropdown.select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># --- 方式 2: 通过 Value 属性选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 2 (by Value)...&quot;</span>)<br>    <span class="hljs-comment"># HTML: &lt;option value=&quot;2&quot;&gt;Option 2&lt;/option&gt;</span><br>    dropdown.select_option(value=<span class="hljs-string">&quot;2&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># --- 验证结果 ---</span><br>    <span class="hljs-comment"># 怎么获取当前选中的值？</span><br>    <span class="hljs-comment"># 在 Playwright 中，直接看 value 属性即可</span><br>    current_value = dropdown.input_value()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中的 value 是: <span class="hljs-subst">&#123;current_value&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="第二类：非标准下拉框-Div-Ul-模拟"><a href="#第二类：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二类：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二类：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>这是现在前端框架（React, Vue）最喜欢的写法。它们看起来像下拉框，但 HTML 里根本没有 <code>&lt;select&gt;</code> 标签，全是一堆 <code>&lt;div&gt;</code> 和 <code>&lt;li&gt;</code>。</p><p>Playwright 的处理逻辑：把它当成普通的点击操作。</p><p>假设有一个用 Div 做的下拉框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 点击下拉框，让它展开</span><br>page.locator(<span class="hljs-string">&quot;#custom-dropdown-trigger&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 点击里面的选项</span><br><span class="hljs-comment"># Playwright 会自动等待 &quot;高级教程&quot; 这个选项出现在屏幕上再点击</span><br>page.get_by_text(<span class="hljs-string">&quot;高级教程&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="💡-模糊匹配选项"><a href="#💡-模糊匹配选项" class="headerlink" title="💡 模糊匹配选项"></a>💡 模糊匹配选项</h3><p>有时候下拉框里的字很长，或者有空格，比如 “ Option 1 “。</p><p>在 Selenium 里如果你用 select_by_visible_text，差一个空格都会报错。</p><p>在 Playwright 中，可以结合 <code>match</code> 参数（支持正则）或 <code>contains</code> 逻辑来选：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要包含 &quot;Option 1&quot; 就能选中，不用管有没有空格</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>) <br></code></pre></td></tr></table></figure><hr><h1 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h1><h3 id="核心区别：监听器-Event-Listener"><a href="#核心区别：监听器-Event-Listener" class="headerlink" title="核心区别：监听器 (Event Listener)"></a>核心区别：监听器 (Event Listener)</h3><ul><li><strong>Selenium</strong>: “出了事再处理”。（必须等弹窗出来，脚本才能去切换、操作）。</li><li><strong>Playwright</strong>: “先立好规矩”。（在点击按钮<strong>之前</strong>，先告诉浏览器：“待会儿如果有弹窗出来，你就帮我点确定”）。</li></ul><blockquote><p><strong>⚠️ 默认行为：</strong> 如果你不写任何监听代码，Playwright 会<strong>自动关闭 (Dismiss)</strong> 所有弹出的 Dialog，防止脚本卡死。这虽然安全，但如果你想测试“点击确定后的效果”，就必须手动设置监听器。</p></blockquote><hr><h3 id="1-怎么写监听器？"><a href="#1-怎么写监听器？" class="headerlink" title="1. 怎么写监听器？"></a>1. 怎么写监听器？</h3><p>需要使用 <strong><code>page.on(&quot;dialog&quot;, 处理函数)</code></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个处理函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_dialog</span>(<span class="hljs-params">dialog</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;弹窗内容: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>    dialog.accept() <span class="hljs-comment"># 点击确定</span><br><br><span class="hljs-comment"># 1. 先注册监听器 (埋伏好)</span><br>page.on(<span class="hljs-string">&quot;dialog&quot;</span>, handle_dialog)<br><br><span class="hljs-comment"># 2. 再触发弹窗 (踩雷)</span><br>page.get_by_text(<span class="hljs-string">&quot;点击弹出Alert&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="2-实战演练：Alert-Confirm-Prompt"><a href="#2-实战演练：Alert-Confirm-Prompt" class="headerlink" title="2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt"></a>2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt</h3><p>the-internet.herokuapp.com&#x2F;javascript_alerts。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>        browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>        page = browser.new_page()<br>        page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 1: Alert (只有确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 1. 测试 JS Alert&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这里的 lambda d: d.accept() 意思是：只要有弹窗，就点确定</span><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, <span class="hljs-keyword">lambda</span> d: d.accept()) <br>        <br>        <span class="hljs-comment"># 步骤 B: 点击按钮触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Alert&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证结果</span><br>        result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 应该是 You successfully clicked an alert</span><br><br>        <span class="hljs-comment"># --- 场景 2: Confirm (确定/取消) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 2. 测试 JS Confirm (点击取消)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这次我们定义稍微复杂点的逻辑：打印内容并点击取消</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_confirm</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到弹窗: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.dismiss() <span class="hljs-comment"># 点击取消 (Selenium 的 dismiss)</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_confirm)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Confirm&quot;</span>).click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;page.locator(<span class="hljs-string">&#x27;#result&#x27;</span>).inner_text()&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 3: Prompt (输入 + 确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 3. 测试 JS Prompt (输入内容)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 在 Playwright 中，accept() 可以直接传参数用来输入！</span><br>        <span class="hljs-comment"># Selenium 需要先 send_keys 再 accept，Playwright 合二为一了</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_prompt</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到 Prompt: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.accept(<span class="hljs-string">&quot;Playwright 练习生&quot;</span>) <span class="hljs-comment"># 输入并确定</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_prompt)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Prompt&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证</span><br>        final_result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终结果: <span class="hljs-subst">&#123;final_result&#125;</span>&quot;</span>)<br>        <br>        time.sleep(<span class="hljs-number">2</span>)<br>        browser.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run()<br></code></pre></td></tr></table></figure><h3 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3. 代码解析"></a>3. 代码解析</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>切换</strong></td><td><code>driver.switch_to.alert</code></td><td><code>page.on(&quot;dialog&quot;, handler)</code></td></tr><tr><td><strong>点确定</strong></td><td><code>alert.accept()</code></td><td><code>dialog.accept()</code></td></tr><tr><td><strong>点取消</strong></td><td><code>alert.dismiss()</code></td><td><code>dialog.dismiss()</code></td></tr><tr><td><strong>输入</strong></td><td><code>alert.send_keys(&quot;abc&quot;)</code></td><td><code>dialog.accept(&quot;abc&quot;)</code> <strong>(注意区别)</strong></td></tr><tr><td><strong>获取文字</strong></td><td><code>alert.text</code></td><td><code>dialog.message</code></td></tr></tbody></table><blockquote><ul><li><code>page.on</code>: <strong>永久</strong>监听。只要有弹窗，一直用这个逻辑处理。</li><li><code>page.once</code>: <strong>一次性</strong>监听。处理完这一个弹窗后，监听器就失效了。</li><li>在测试中，通常用 <code>once</code>，因为每个测试用例对弹窗的处理要求可能不一样（有的要点确定，有的要点取消）。</li></ul></blockquote><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><h3 id="1-鼠标操作-Mouse"><a href="#1-鼠标操作-Mouse" class="headerlink" title="1. 鼠标操作 (Mouse)"></a>1. 鼠标操作 (Mouse)</h3><p>不需要初始化 <code>ActionChains</code>，直接调用方法即可。</p><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium (ActionChains)</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>悬停 (Hover)</strong></td><td><code>.move_to_element(ele).perform()</code></td><td><strong><code>locator.hover()</code></strong></td></tr><tr><td><strong>双击</strong></td><td><code>.double_click(ele).perform()</code></td><td><strong><code>locator.dblclick()</code></strong></td></tr><tr><td><strong>右键</strong></td><td><code>.context_click(ele).perform()</code></td><td><strong><code>locator.click(button=&quot;right&quot;)</code></strong></td></tr><tr><td><strong>拖拽</strong></td><td><code>.drag_and_drop(src, dst).perform()</code></td><td><strong><code>page.drag_and_drop(src, dst)</code></strong></td></tr></tbody></table><h4 id="💻-实战-A：鼠标悬停-Baidu-Settings"><a href="#💻-实战-A：鼠标悬停-Baidu-Settings" class="headerlink" title="💻 实战 A：鼠标悬停 (Baidu Settings)"></a>💻 实战 A：鼠标悬停 (Baidu Settings)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 定位“设置”</span><br>    settings_btn = page.locator(<span class="hljs-string">&quot;#s-usersetting-top&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 鼠标悬停 (Selenium 需要 ActionChains，这里直接 hover)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在悬停鼠标...&quot;</span>)<br>    settings_btn.hover()<br>    <br>    <span class="hljs-comment"># 3. 悬停后，菜单浮现，点击“高级搜索”</span><br>    <span class="hljs-comment"># 注意：Playwright 会自动等待菜单变成可见状态再点击</span><br>    page.get_by_text(<span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已点击高级搜索&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><h4 id="💻-实战-B：拖拽-Drag-and-Drop"><a href="#💻-实战-B：拖拽-Drag-and-Drop" class="headerlink" title="💻 实战 B：拖拽 (Drag and Drop)"></a>💻 实战 B：拖拽 (Drag and Drop)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># page.drag_and_drop(源元素选择器, 目标元素选择器)</span><br>page.drag_and_drop(<span class="hljs-string">&quot;#column-a&quot;</span>, <span class="hljs-string">&quot;#column-b&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-键盘操作-Keyboard"><a href="#2-键盘操作-Keyboard" class="headerlink" title="2. 键盘操作 (Keyboard)"></a>2. 键盘操作 (Keyboard)</h3><p>在 Selenium 中，你需要 Keys 类 (Keys.ENTER, Keys.CONTROL)。Playwright 用字符串来表示按键，更加直观。</p><h4 id="核心方法：press-按键名"><a href="#核心方法：press-按键名" class="headerlink" title="核心方法：press(&quot;按键名&quot;)"></a>核心方法：<code>press(&quot;按键名&quot;)</code></h4><ul><li><strong>单键</strong>：<code>press(&quot;Enter&quot;)</code>, <code>press(&quot;ArrowDown&quot;)</code>, <code>press(&quot;Backspace&quot;)</code></li><li><strong>组合键</strong>：用 <code>+</code> 连接。<ul><li><code>press(&quot;Control+A&quot;)</code> (全选)</li><li><code>press(&quot;Control+C&quot;)</code> (复制)</li><li><code>press(&quot;Shift+ArrowLeft&quot;)</code> (选中左边文字)</li></ul></li></ul><h4 id="💻-实战-C：键盘组合键-Baidu-Search"><a href="#💻-实战-C：键盘组合键-Baidu-Search" class="headerlink" title="💻 实战 C：键盘组合键 (Baidu Search)"></a>💻 实战 C：键盘组合键 (Baidu Search)</h4><p><strong>百度搜索组合键</strong> 案例：输入 -&gt; 全选 -&gt; 剪切 -&gt; 粘贴 -&gt; 回车。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">500</span>) <span class="hljs-comment"># 慢放动作</span><br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    search_input = page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 输入内容</span><br>    search_input.fill(<span class="hljs-string">&quot;Playwright&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 模拟全选 (Ctrl+A / Mac上是 Meta+A)</span><br>    <span class="hljs-comment"># Playwright 智能之处：它知道你是什么系统，可以用 &quot;Control+A&quot; 通杀</span><br>    <span class="hljs-comment"># 或者显式写 &quot;Meta+A&quot; (Mac Command键)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 全选...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+A&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 模拟剪切 (Ctrl+X)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 剪切...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+X&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 模拟粘贴 (Ctrl+V)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 粘贴...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+V&quot;</span>)<br>    <br>    <span class="hljs-comment"># 5. 模拟回车 (Enter) 提交搜索</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回车搜索...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Enter&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证是否跳转</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="3-特殊：逐字输入-模拟人工打字"><a href="#3-特殊：逐字输入-模拟人工打字" class="headerlink" title="3. 特殊：逐字输入 (模拟人工打字)"></a>3. 特殊：逐字输入 (模拟人工打字)</h3><p>自动化测试有时候输入太快，触发不了页面上的联想搜索（Suggest）。</p><p>Playwright 提供了一个神器：press_sequentially (旧版本叫 type)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每个字符间隔 100 毫秒，模拟真人打字</span><br>page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).press_sequentially(<span class="hljs-string">&quot;Selenium&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这对应 Selenium 里 <strong>联想输入框</strong> 的难点。</p><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="1-标准上传"><a href="#1-标准上传" class="headerlink" title="1. 标准上传"></a>1. 标准上传</h3><p>如果页面上有一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签（哪怕它是隐藏的），可以直接把文件路径“填”进去。</p><ul><li><strong>Selenium</strong>: <code>ele.send_keys(&quot;路径&quot;)</code></li><li><strong>Playwright</strong>: <strong><code>locator.set_input_files(&quot;路径&quot;)</code></strong></li></ul><h4 id="💻-实战代码"><a href="#💻-实战代码" class="headerlink" title="💻 实战代码"></a>💻 实战代码</h4><p><code>the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 准备一个测试文件 (在当前目录下创建 test.txt)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;Hello Playwright Upload!&quot;</span>)<br><br><span class="hljs-comment"># 获取绝对路径 (和 Selenium 笔记里一样，推荐用绝对路径)</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 准备上传文件: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方法 1: 直接设置文件 (最稳) ---</span><br>    <span class="hljs-comment"># 找到 input 标签，直接塞入文件</span><br>    <span class="hljs-comment"># 注意：不要点击那个 &quot;Choose File&quot; 按钮，直接操作 input</span><br>    page.locator(<span class="hljs-string">&quot;#file-upload&quot;</span>).set_input_files(file_path)<br><br>    <span class="hljs-comment"># 点击上传按钮</span><br>    page.locator(<span class="hljs-string">&quot;#file-submit&quot;</span>).click()<br><br>    <span class="hljs-comment"># 断言结果</span><br>    expect(page.locator(<span class="hljs-string">&quot;#uploaded-files&quot;</span>)).to_have_text(<span class="hljs-string">&quot;test.txt&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 标准上传成功！&quot;</span>)<br><br>    page.wait_for_timeout(<span class="hljs-number">2000</span>)<br>    browser.close()<br><br><span class="hljs-comment"># 清理测试文件</span><br>os.remove(<span class="hljs-string">&quot;test.txt&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-高级上传-拦截文件选择器"><a href="#2-高级上传-拦截文件选择器" class="headerlink" title="2. 高级上传 (拦截文件选择器)"></a>2. 高级上传 (拦截文件选择器)</h3><p>这是 Playwright 的<strong>杀手锏</strong>。在 Selenium 中，如果必须点击按钮才能上传（比如 input 标签被复杂的 JS 逻辑移除了），你会遇到系统弹窗，Selenium 就束手无策了。Playwright 的逻辑：它不管系统弹窗（它是“无头”的思维），它拦截的是**“浏览器请求选择文件”**这个事件。</p><p><strong>步骤：</strong></p><ol><li>设置监听器：<code>expect_file_chooser()</code> (这就好比刚才学的监听弹窗 <code>expect_popup</code>)。</li><li>点击按钮：触发事件。</li><li>在拦截到的“选择器对象”中设置文件。</li></ol><h4 id="💻-实战演示-即使是标准按钮也能用这招"><a href="#💻-实战演示-即使是标准按钮也能用这招" class="headerlink" title="💻 实战演示 (即使是标准按钮也能用这招)"></a>💻 实战演示 (即使是标准按钮也能用这招)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面代码一样 ...</span><br><br><span class="hljs-comment"># --- 方法 2: 点击按钮触发上传 (Selenium 做不到，Playwright 能做) ---</span><br><br><span class="hljs-comment"># 1. 设置监听器 (当文件选择器弹出时...)</span><br><span class="hljs-keyword">with</span> page.expect_file_chooser() <span class="hljs-keyword">as</span> fc_info:<br>    <span class="hljs-comment"># 2. 点击那个会触发弹窗的按钮 (甚至是普通的 div 或 span)</span><br>    page.locator(<span class="hljs-string">&quot;#drag-drop-upload&quot;</span>).click() <span class="hljs-comment"># 这里假设有个点击上传区域</span><br><br><span class="hljs-comment"># 3. 拿到拦截到的选择器</span><br>file_chooser = fc_info.value<br><br><span class="hljs-comment"># 4. 设置文件</span><br>file_chooser.set_files(file_path)<br><br><span class="hljs-comment"># ... 后面一样 ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th><strong>场景</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>标准 Input</strong></td><td><code>send_keys(&quot;path&quot;)</code></td><td><code>locator.set_input_files(&quot;path&quot;)</code></td></tr><tr><td><strong>清除文件</strong></td><td><code>clear</code></td><td><code>locator.set_input_files([])</code> (传空列表)</td></tr><tr><td><strong>多文件上传</strong></td><td><code>send_keys(&quot;a.txt \n b.txt&quot;)</code> (看浏览器)</td><td><code>set_input_files([&quot;a.txt&quot;, &quot;b.txt&quot;])</code> (原生支持列表)</td></tr><tr><td><strong>非标准&#x2F;必须点击</strong></td><td><strong>PyAutoGUI &#x2F; AutoIt</strong></td><td><strong><code>expect_file_chooser()</code></strong> (原生支持，无需外挂)</td></tr></tbody></table><hr><h1 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h1><p><strong>页面（Page）与测试（Test）分离</strong>。</p><hr><h3 id="1-核心区别：BasePage-还需要吗？"><a href="#1-核心区别：BasePage-还需要吗？" class="headerlink" title="1. 核心区别：BasePage 还需要吗？"></a>1. 核心区别：BasePage 还需要吗？</h3><p>在Selenium 笔记中，<code>BasePage</code> 非常重要，因为你需要封装 <code>find_element</code> 来实现显式等待，防止报错。</p><p>但在 Playwright 中：由于它自带自动等待（Auto-wait），不需要再封装一个复杂的 find() 方法去写 WebDriverWait。</p><ul><li><strong>Selenium BasePage</strong>: 必须有。用来“保命”（防报错）。</li><li><strong>Playwright BasePage</strong>: 可选。主要用来存放公共业务逻辑（比如“回到首页”、“截图”、“处理通用弹窗”），而不是为了封装底层 API。</li></ul><hr><h3 id="2-项目结构搭建"><a href="#2-项目结构搭建" class="headerlink" title="2. 项目结构搭建"></a>2. 项目结构搭建</h3><p>按照标准的 Python 工程结构来建立文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Playwright_PO/<br>├── pages/              # 【菜单】存放页面对象<br>│   ├── base_page.py    # 父类 (通用方法)<br>│   └── login_page.py   # 登录页<br>├── tests/              # 【顾客】存放测试用例<br>│   └── test_login.py   <br>├── conftest.py         # 【厨房管家】Pytest 的配置文件 (核心！)<br>└── main.py             # 运行入口<br></code></pre></td></tr></table></figure><hr><h3 id="3-第一步：编写-BasePage-父类"><a href="#3-第一步：编写-BasePage-父类" class="headerlink" title="3. 第一步：编写 BasePage (父类)"></a>3. 第一步：编写 BasePage (父类)</h3><p>虽然 Playwright 不需要封装等待，但为了代码规范，还是写一个轻量级的父类。</p><p>新建 <code>pages/base_page.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page: Page</span>):<br>        <span class="hljs-variable language_">self</span>.page = page<br><br>    <span class="hljs-comment"># 封装一个通用的打开网址方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-variable language_">self</span>.page.goto(url)<br><br>    <span class="hljs-comment"># 封装通用的获取标题</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_title</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.page.title()<br>        <br>    <span class="hljs-comment"># 如果有通用的弹窗处理、Cookie保存，都可以写在这里</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-第二步：编写-LoginPage-页面层"><a href="#4-第二步：编写-LoginPage-页面层" class="headerlink" title="4. 第二步：编写 LoginPage (页面层)"></a>4. 第二步：编写 LoginPage (页面层)</h3><p>注意变化： 在 <strong>init</strong> 里直接定义好 Locator，动作方法里直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pages.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 定义 Locator (写在构造函数里，清晰明了) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br>        <span class="hljs-variable language_">self</span>.url = <span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span><br>        <span class="hljs-comment"># 这里的 locator 只是定义，不会立即查找，所以不用担心页面没加载</span><br>        <span class="hljs-variable language_">self</span>.username_input = page.locator(<span class="hljs-string">&quot;#user-name&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.password_input = page.locator(<span class="hljs-string">&quot;#password&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.login_btn = page.locator(<span class="hljs-string">&quot;#login-button&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.error_msg = page.locator(<span class="hljs-string">&quot;[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 定义动作 (Action) ---</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">navigate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username, password</span>):<br>        <span class="hljs-comment"># Playwright 的 fill 和 click 自带等待，直接写逻辑，极其干净</span><br>        <span class="hljs-variable language_">self</span>.username_input.fill(username)<br>        <span class="hljs-variable language_">self</span>.password_input.fill(password)<br>        <span class="hljs-variable language_">self</span>.login_btn.click()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_text</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.error_msg.inner_text()<br></code></pre></td></tr></table></figure><hr><h3 id="5-第三步：编写测试用例-结合-Pytest"><a href="#5-第三步：编写测试用例-结合-Pytest" class="headerlink" title="5. 第三步：编写测试用例 (结合 Pytest)"></a>5. 第三步：编写测试用例 (结合 Pytest)</h3><p>这里是 Playwright 最舒服的地方。使用 pytest-playwright 插件。不需要手动创建 browser 和 page，Pytest 会自动生成一个 page 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page, expect<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># Pytest 会自动把 page 夹具注入进来，不需要我们自己 launch browser</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">page: Page</span>):<br>    <span class="hljs-comment"># 1. 实例化页面对象</span><br>    login_page = LoginPage(page)<br>    <br>    <span class="hljs-comment"># 2. 调用页面方法 (业务逻辑)</span><br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 断言 (Test层负责断言，Page层不要有 expect)</span><br>    expect(page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_failed</span>(<span class="hljs-params">page: Page</span>):<br>    login_page = LoginPage(page)<br>    <br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_pwd&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证错误提示</span><br>    error_text = login_page.get_error_text()<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text<br></code></pre></td></tr></table></figure><hr><h3 id="6-进阶优化：使用-conftest-py-管理对象"><a href="#6-进阶优化：使用-conftest-py-管理对象" class="headerlink" title="6. 进阶优化：使用 conftest.py 管理对象"></a>6. 进阶优化：使用 <code>conftest.py</code> 管理对象</h3><p>上面的测试代码里，每个用例都要写一句 login_page &#x3D; LoginPage(page)，有点啰嗦。可以用 Pytest 的 fixture 把页面对象的初始化也提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 定义一个 fixture，名字就叫 login</span><br><span class="hljs-comment"># 只要测试用例参数里写了 login，就会自动执行这个函数</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">page</span>):<br>    <span class="hljs-keyword">return</span> LoginPage(page)<br></code></pre></td></tr></table></figure><p><strong>优化后的测试用例 (<code>tests/test_login.py</code>)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> expect<br><br><span class="hljs-comment"># 注意参数变成了 login (对应上面的 fixture)，page 都不用传了</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">login</span>): <br>    <span class="hljs-comment"># login 已经是实例化好的 LoginPage 对象了</span><br>    login.navigate()<br>    login.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 这里的 login.page 是我们在 BasePage 里存的 self.page</span><br>    expect(login.page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="7-怎么运行？"><a href="#7-怎么运行？" class="headerlink" title="7. 怎么运行？"></a>7. 怎么运行？</h3><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行所有测试</span><br>pytest<br><br><span class="hljs-comment"># 运行特定文件并显示浏览器 (headed) 和慢放 (slowmo)</span><br>pytest tests/test_login.py --headed --slowmo 1000<br></code></pre></td></tr></table></figure><hr><h3 id="总结：Selenium-PO-vs-Playwright-PO"><a href="#总结：Selenium-PO-vs-Playwright-PO" class="headerlink" title="总结：Selenium PO vs Playwright PO"></a>总结：Selenium PO vs Playwright PO</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Selenium PO</strong></th><th><strong>Playwright PO</strong></th></tr></thead><tbody><tr><td><strong>BasePage</strong></td><td><strong>必须且厚重</strong> (封装 WebDriverWait)</td><td><strong>可选且轻量</strong> (仅存公共逻辑)</td></tr><tr><td><strong>Locator 定义</strong></td><td><code>(By.ID, &quot;val&quot;)</code> 元组</td><td><code>page.locator(&quot;#val&quot;)</code> 对象</td></tr><tr><td><strong>操作方法</strong></td><td><code>find(*loc).click()</code></td><td><code>self.btn.click()</code></td></tr><tr><td><strong>Driver 传递</strong></td><td>手动初始化 Driver 并传递</td><td>Pytest <code>page</code> fixture 自动注入</td></tr><tr><td><strong>代码量</strong></td><td>多，容易出错</td><td>少，逻辑清晰</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web自动化测试</tag>
      
      <tag>playwright</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium学习</title>
    <link href="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Selenium特点"><a href="#Selenium特点" class="headerlink" title="Selenium特点"></a>Selenium特点</h1><ul><li><strong>跨浏览器支持</strong>：Selenium 支持多种主流浏览器，如 Chrome、Firefox、Safari、Internet Explorer 等，可以在不同浏览器中执行相同的测试脚本。</li><li><strong>多语言支持</strong>：Selenium 支持多种编程语言，开发者可以用自己熟悉的语言来编写测试脚本。</li><li><strong>灵活性</strong>：Selenium 可以与各种测试框架结合使用，如 TestNG、JUnit、PyTest 等，提供了丰富的测试功能。</li><li><strong>与 CI&#x2F;CD 集成</strong>：Selenium 可以与 Jenkins 等持续集成工具集成，帮助实现自动化测试和持续交付。</li><li><strong>自动化Web交互</strong>：Selenium 可以模拟真实用户的操作，如点击、滚动、键盘输入等</li></ul><hr><h1 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h1><p>Selenium WebDriver 是 Selenium 的核心组件，它提供了与浏览器交互的 API，允许开发者通过编程语言控制浏览器并执行各种操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所需模块</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br><span class="hljs-comment"># 使用 get() 方法打开指定的 URL</span><br>driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>)<br><br><span class="hljs-comment"># 最大化窗口</span><br>driver.maximize_window()<br><br><span class="hljs-comment"># 获取页面标题和 URL</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;页面标题:&quot;</span>, driver.title)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前 URL:&quot;</span>, driver.current_url)<br><br><span class="hljs-comment"># 导航到另一个页面</span><br>driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>)<br><br><span class="hljs-comment"># 返回上一个页面</span><br>driver.back()<br><br><span class="hljs-comment"># 刷新页面</span><br>driver.refresh()<br><br><span class="hljs-comment"># 关闭浏览器</span><br>driver.quit()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openqa.selenium.WebDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeleniumExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置 ChromeDriver 路径（方式1：通过系统属性）</span><br>        System.setProperty(<span class="hljs-string">&quot;webdriver.chrome.driver&quot;</span>, <span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>);<br>        <br>        <span class="hljs-comment">// 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>        <span class="hljs-type">ChromeOptions</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeOptions</span>();<br>        <br>        <span class="hljs-comment">// 创建 ChromeDriver 对象，启动 Chrome 浏览器</span><br>        <span class="hljs-type">WebDriver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeDriver</span>(options);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用 get() 方法打开指定的 URL</span><br>            driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 最大化窗口</span><br>            driver.manage().window().maximize();<br>            <br>            <span class="hljs-comment">// 获取页面标题和 URL</span><br>            System.out.println(<span class="hljs-string">&quot;页面标题: &quot;</span> + driver.getTitle());<br>            System.out.println(<span class="hljs-string">&quot;当前 URL: &quot;</span> + driver.getCurrentUrl());<br>            <br>            <span class="hljs-comment">// 导航到另一个页面</span><br>            driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 返回上一个页面</span><br>            driver.navigate().back();<br>            <br>            <span class="hljs-comment">// 刷新页面</span><br>            driver.navigate().refresh();<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭浏览器</span><br>            driver.quit();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><h2 id="1-ID定位"><a href="#1-ID定位" class="headerlink" title="1.ID定位"></a>1.ID定位</h2><p>id是标签的唯一属性,可以通过id属性来唯一定位一个元素(唯一且最快，如果有ID先用ID)</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image1.png" class="" title="ID定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.ID,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.id(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="2-name定位"><a href="#2-name定位" class="headerlink" title="2.name定位"></a>2.name定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image2.png" class="" title="name定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.Name,<span class="hljs-string">&quot; &quot;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.name(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="3-ClassName定位"><a href="#3-ClassName定位" class="headerlink" title="3.ClassName定位"></a>3.ClassName定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image3.png" class="" title="ClassName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.CLASS_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.className(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><p>坑：如果 HTML 是 <code>button class=&quot;btn btn-primary&quot;</code>，你不能直接写 “btn btn-primary”。因为中间有空格，Selenium 会认为这是两个类名，会报错。所以只取其中一个唯一的类名，或者改用 CSS Selector。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ❌ 错误写法</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn btn-primary&quot;</span>)<br><br><span class="hljs-comment"># ✅ 正确写法 (只取其中一段)</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn-primary&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-tagName定位"><a href="#4-tagName定位" class="headerlink" title="4.tagName定位"></a>4.<strong>tagName</strong>定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image4.png" class="" title="tagName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.TAG_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.tagName(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="5-cssSelector定位"><a href="#5-cssSelector定位" class="headerlink" title="5.cssSelector定位"></a>5.<strong>cssSelector</strong>定位</h2><p>语法简洁，渲染速度比 XPath 快，适合没有 ID 但有特定属性的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.CSS_SELECTOR,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.cssSelector(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）id选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#kw&quot;</span>)<br><br><span class="hljs-comment"># 2）类选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;.s_ipt&quot;</span>)<br><br><span class="hljs-comment"># 3）标签选择器</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;input&quot;</span>)  <span class="hljs-comment"># 查找第一个`input`标签</span><br></code></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）单个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 2）多个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[rows=&#x27;1&#x27;][autocomplete=&#x27;off&#x27;][id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 3）标签名+属性选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 4）通过标签名+ID选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea#chat-textarea&quot;</span>)<br><br><span class="hljs-comment"># 5）通过标签名+类选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea.chat-input-textarea&quot;</span>)<br><br><span class="hljs-comment"># 6）通过标签层级定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;form&gt;span&gt;input&quot;</span>)<br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;div&gt;div:nth-child(2)&gt;div:nth-child(2)&gt;a:nth-child(3)&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-link-text定位"><a href="#6-link-text定位" class="headerlink" title="6.link_text定位"></a>6.<strong>link_text</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image5.png" class="" title="link_text定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.linkText(<span class="hljs-string">&quot;地图&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="7-partialLinkText定位"><a href="#7-partialLinkText定位" class="headerlink" title="7.partialLinkText定位"></a>7.<strong>partialLinkText</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image6.png" class="" title="partialLinkText定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.PARTIAL_LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.partialLinkText(<span class="hljs-string">&quot;更&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="8-Xpath定位"><a href="#8-Xpath定位" class="headerlink" title="8.Xpath定位"></a>8.Xpath定位</h2><p><strong>功能最强（能通过文本定位、能找父节点），但速度稍慢，语法啰嗦</strong>。但Xpath是万能的</p><h3 id="绝对路径定位"><a href="#绝对路径定位" class="headerlink" title="绝对路径定位"></a>绝对路径定位</h3><p><strong>特点：</strong> 从 HTML 根节点一层层往下找，极其脆弱。前端稍微加个 <code>div</code> 你的代码就挂了。 <strong>语法：</strong> 单斜杠 <code>/</code> 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非常不建议用</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;/html/body/div[1]/div[2]/div/div[1]/input&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="相对路径定位"><a href="#相对路径定位" class="headerlink" title="相对路径定位"></a>相对路径定位</h3><p><strong>特点：</strong> 忽略层级，在整个页面中查找。 <strong>语法：</strong> 双斜杠 <code>//</code> 开头 + 标签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在整个页面找 input 标签（如果有很多 input，默认返回第一个）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input&quot;</span>) <br><br><span class="hljs-comment"># 找页面所有的 div 下面的 form 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div//form&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="元素属性定位"><a href="#元素属性定位" class="headerlink" title="元素属性定位"></a>元素属性定位</h3><p><strong>特点：</strong> 结合 <code>@属性名</code> 精准定位。 <strong>语法：</strong> <code>//标签名[@属性=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过 id 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 name 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 class 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 结合标签层级：找到 form 标签下的 input 标签，且该 input 有 id=&#x27;kw&#x27;</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//form//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="逻辑运算符定位"><a href="#逻辑运算符定位" class="headerlink" title="逻辑运算符定位"></a>逻辑运算符定位</h3><p><strong>特点：</strong> 当一个属性无法唯一定位时，用 <code>and</code> 或 <code>or</code> 组合多个属性。 <strong>语法：</strong> <code>[@属性1=&#39;值&#39; and @属性2=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同时满足 name=&#x27;wd&#x27; 且 class=&#x27;s_ipt&#x27; 的 input 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27; and @class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 只要满足 id=&#x27;kw&#x27; 或者 name=&#x27;wd&#x27; 任意一个即可</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27; or @name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="文本内容定位"><a href="#文本内容定位" class="headerlink" title="文本内容定位"></a>文本内容定位</h3><p><strong>特点：</strong> 很多链接或按钮没有 ID，只有文字。 <strong>语法：</strong> <code>text()=&#39;完整文字&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定位文本完全等于 &quot;新闻&quot; 的 a 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[text()=&#x27;新闻&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 定位文本完全等于 &quot;登录&quot; 的 button 按钮</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;登录&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="部分文本-属性定位-模糊匹配"><a href="#部分文本-属性定位-模糊匹配" class="headerlink" title="部分文本&#x2F;属性定位-模糊匹配"></a>部分文本&#x2F;属性定位-模糊匹配</h3><p><strong>特点：</strong> 处理动态变化的元素（例如：<code>id=&quot;user_123&quot;</code>, <code>id=&quot;user_456&quot;</code>）或长文本。 <strong>语法：</strong> <code>contains(@属性或text(), &#39;部分值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文本包含 &quot;百度&quot; 的所有链接（能匹配 &quot;百度一下&quot;、&quot;关于百度&quot; 等）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[contains(text(), &#x27;百度&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># id 属性中包含 &quot;user_name&quot; 的 input (能匹配 id=&quot;my_user_name_input&quot;)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[contains(@id, &#x27;user_name&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用函数定位"><a href="#使用函数定位" class="headerlink" title="使用函数定位"></a>使用函数定位</h3><p><strong>特点：</strong> 匹配以特定字符开头的内容。 <strong>语法：</strong> <code>starts-with(@属性, &#39;开头值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配 id 以 &quot;ctrl_7&quot; 开头的 input 元素 (常用于 ExtJS 等自动生成 ID 的框架)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[starts-with(@id, &#x27;ctrl_7&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># 匹配文本以 &quot;欢迎&quot; 开头的 div</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[starts-with(text(), &#x27;欢迎&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><p>问：遇到一个非常难定位的元素，你会怎么写 XPath？</p><p>如果是静态属性，我优先用 <strong>属性定位</strong> (&#x2F;&#x2F;tag[@id&#x3D;’…’])；如果是链接或按钮，我会用 <strong>文本定位</strong> (&#x2F;&#x2F;a[text()&#x3D;’…’])；如果是动态 ID 或复杂场景，我会用 <strong>contains 模糊匹配</strong> (&#x2F;&#x2F;div[contains(@class, ‘…’)])，或者结合 <strong>父子层级关系</strong> 来写</p><h2 id="基础定位练习-SauceDemo"><a href="#基础定位练习-SauceDemo" class="headerlink" title="基础定位练习-SauceDemo"></a>基础定位练习-<strong>SauceDemo</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;D:\\develop\\chromedriver-win64\\chromedriver.exe&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>driver.maximize_window()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>user_input = driver.find_element(By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>user_input.send_keys(<span class="hljs-string">&quot;standard_user&quot;</span>)<br>password_input = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;password&#x27;]&quot;</span>)<br>password_input.send_keys(<span class="hljs-string">&quot;secret_sauce&quot;</span>)<br><br><span class="hljs-comment"># login_btn = driver.find_element(By.CSS_SELECTOR, &quot;input.btn_action&quot;)</span><br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#login-button&quot;</span>)<br>login_btn.click()<br><br><span class="hljs-comment"># 断言是否登录成功</span><br><span class="hljs-comment"># time.sleep(2)</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url<br><span class="hljs-comment"># 判断Swag Labs是否预期</span><br>page_title = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[@class=&#x27;app_logo&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> page_title == <span class="hljs-string">&quot;Swag Labs&quot;</span><br><br><span class="hljs-comment"># time.sleep(1)</span><br><br><span class="hljs-comment"># add_to_cart_btn = driver.find_element(By.XPATH, &quot;//button[text()=&#x27;Add to cart&#x27;]&quot;)</span><br>add_to_cart_btn = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[contains(text(),&#x27;Add to cart&#x27;)]&quot;</span>)<br>add_to_cart_btn.click()<br><br><span class="hljs-comment"># time.sleep(1)</span><br><span class="hljs-comment"># 验证购物车图标上的数量是否为1</span><br>cart_badge = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//span[@class=&#x27;shopping_cart_badge&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> cart_badge == <span class="hljs-string">&quot;1&quot;</span><br><br><span class="hljs-comment"># driver.close()</span><br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素定位不到"><a href="#元素定位不到" class="headerlink" title="元素定位不到"></a>元素定位不到</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image7.png" class="" title="元素定位不到"><hr><h1 id="WebDriver常用方法"><a href="#WebDriver常用方法" class="headerlink" title="WebDriver常用方法"></a>WebDriver常用方法</h1><h2 id="导航方法"><a href="#导航方法" class="headerlink" title="导航方法"></a>导航方法</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image8.png" class="" title="导航方法"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 加上隐式等待</span><br><br><span class="hljs-comment"># --- 动作 1: 打开第一个网页 (百度) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在打开百度...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 强制等待是为了看清效果 实际最好别用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前URL: <span class="hljs-subst">&#123;driver.current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 2: 打开第二个网页 (B站) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 正在跳转到 Bilibili...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 3: 后退 (Back) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 执行后退操作 (回到百度)...&quot;</span>)<br>driver.back()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 验证一下是不是回到了百度</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 后退成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 4: 前进 (Forward) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n4. 执行前进操作 (回到 Bilibili)...&quot;</span>)<br>driver.forward()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;哔哩哔哩&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 前进成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 5: 刷新 (Refresh) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n5. 执行刷新当前页面...&quot;</span>)<br>driver.refresh()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 页面刷新完毕&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image9.png" class="" title="元素操作"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>) <span class="hljs-comment"># 全局隐式等待</span><br><br><span class="hljs-comment"># 2. 打开练习靶场</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在打开: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>driver.get(url)<br><br><span class="hljs-comment"># --- 定位元素 ---</span><br>username_input = driver.find_element(By.ID, <span class="hljs-string">&quot;username&quot;</span>)<br>password_input = driver.find_element(By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;button.radius&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 1: 状态判断 (is_displayed) ---</span><br><span class="hljs-keyword">if</span> username_input.is_displayed():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用户名输入框可见，准备操作...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找不到输入框！&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 2: 输入与清空 (send_keys + clear) ---</span><br><span class="hljs-comment"># 模拟手误：输入了错误的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;wrong_user_123&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到输入了错误的内容</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入错误用户名&quot;</span>)<br><br><span class="hljs-comment"># 发现错了，清空！</span><br>username_input.clear()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到清空的效果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已清空输入框&quot;</span>)<br><br><span class="hljs-comment"># 输入正确的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入正确用户名: tomsmith&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 3: 获取属性 (get_attribute) —— 安全测试常用 ---</span><br><br><span class="hljs-comment"># 面试题：你怎么验证密码框里的密码是掩码显示的（即显示为圆点或星号）？</span><br><span class="hljs-comment"># 答案：获取它的 type 属性，看是不是等于 &quot;password&quot;</span><br><span class="hljs-comment"># type_attr = password_input.get_attribute(&quot;type&quot;)</span><br>type_attr = password_input.get_dom_attribute(<span class="hljs-string">&quot;type&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;密码框的 type 属性是: <span class="hljs-subst">&#123;type_attr&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> type_attr == <span class="hljs-string">&quot;password&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 安全检查通过：密码框是加密显示的&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 安全漏洞：密码框是明文显示的！&quot;</span>)<br><br><span class="hljs-comment"># 输入密码</span><br>password_input.send_keys(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 4: 点击登录 (click) ---</span><br>login_btn.click()<br><br><span class="hljs-comment"># --- 验证结果 ---</span><br><span class="hljs-comment"># 登录成功后，页面会出现一个绿色的提示条</span><br>success_msg = driver.find_element(By.ID, <span class="hljs-string">&quot;flash&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面提示信息: <span class="hljs-subst">&#123;success_msg&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 断言：验证提示信息里包含 &#x27;You logged into a secure area&#x27;</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> success_msg<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🎉 测试通过！成功登录。&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的URL</span><br>current_url = driver.current_url<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面URL: <span class="hljs-subst">&#123;current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的标题</span><br>current_title = driver.title<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面标题: <span class="hljs-subst">&#123;current_title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的HTML源代码</span><br>page_source = driver.page_source<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面HTML源代码长度: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(page_source)&#125;</span> 字符&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><ul><li><strong>get_dom_attribute(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>HTML 源代码里写死的属性</strong>。</li><li><strong>场景</strong>：获取 id、name、type、href、class。</li><li><strong>例子</strong>：<code>input value=&quot;123&quot;</code> -&gt; 永远返回 “123”。</li></ul></li><li><strong>get_property(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>浏览器运行时产生的属性</strong>（即用户操作后的状态）。</li><li><strong>场景</strong>：获取用户<strong>输入框里敲进去的字</strong> (value)、复选框是否被勾选 (checked)。</li><li><strong>例子</strong>：<code>input value=&quot;123&quot;</code>，用户删掉 123 输入了 abc -&gt; get_property(‘value’) 返回 “abc”。</li></ul></li></ul><h2 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image10.png" class="" title="窗口和标签页操作"><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>把句柄想象成<strong>窗口的身份证号</strong>。</p><ul><li>每个标签页（Tab）或窗口都有一个唯一的字符串 ID。</li><li>Selenium 通过这个 ID 来决定控制哪个窗口。</li></ul><p><strong>核心方法 ：</strong></p><ol><li>driver.current_window_handle: 获取<strong>当前</strong>窗口的句柄。</li><li>driver.window_handles: 获取浏览器里<strong>所有</strong>窗口的句柄（返回一个列表 List）。</li><li>driver.switch_to.window(handle): 切换到指定句柄的窗口。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开主页面</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span><br>driver.get(url)<br><br><span class="hljs-comment"># 获取当前主窗口的句柄 (相当于记下：这是&quot;老家&quot;)</span><br>original_window = driver.current_window_handle<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口句柄: <span class="hljs-subst">&#123;original_window&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 点击链接，打开新窗口</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;Click Here&quot;</span>).click()<br><br><span class="hljs-comment"># --- 关键时刻：切换窗口 ---</span><br><br><span class="hljs-comment"># 此时虽然新窗口弹出来了，但 driver 还在老窗口</span><br><span class="hljs-comment"># 我们获取所有窗口的句柄列表</span><br>all_handles = driver.window_handles<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前所有句柄: <span class="hljs-subst">&#123;all_handles&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 遍历列表，找到那个“不是老家”的句柄，就是新窗口</span><br><span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> all_handles:<br>    <span class="hljs-keyword">if</span> handle != original_window:<br>        <span class="hljs-comment"># 找到了新窗口，切换过去！</span><br>        driver.switch_to.window(handle)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🔀 已切换到新窗口！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># --- 3. 在新窗口操作 ---</span><br><span class="hljs-comment"># 只有切换成功了，这行代码才能找到元素，否则会报错</span><br>new_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口里的文字是: <span class="hljs-subst">&#123;new_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> new_text == <span class="hljs-string">&quot;New Window&quot;</span><br><br><span class="hljs-comment"># --- 4. 关闭新窗口，切回主窗口 ---</span><br><span class="hljs-comment"># close() 只关闭当前标签页</span><br>driver.close() <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭新窗口&quot;</span>)<br><br><span class="hljs-comment"># ⚠️ 注意：关掉新窗口后，driver 此时处于“失重”状态，谁也没控制</span><br><span class="hljs-comment"># 必须立刻切回主窗口，否则后续操作会报错</span><br>driver.switch_to.window(original_window)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔀 已切回主窗口: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 验证一下是不是真的回来了</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;The Internet&quot;</span> <span class="hljs-keyword">in</span> driver.title<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><h4 id="1-什么是-Iframe？"><a href="#1-什么是-Iframe？" class="headerlink" title="1. 什么是 Iframe？"></a>1. 什么是 Iframe？</h4><p>简单来说，就是<strong>网页里套网页</strong>。<br>想象一下，走进一个大房子（主页面），墙上挂着一台电视机（Iframe）。电视机里在播放另一个画面。</p><ul><li>Selenium 默认只能操作“大房子”里的东西。</li><li>如果你想操作“电视机”里的菜单，你必须先<strong>把遥控器对准电视机</strong>（切换进去）。</li><li>操作完后，必须<strong>把视线移回大房子</strong>（切换出来），否则找不到房子里的其他家具。</li></ul><p><strong>症状</strong>：<br>在开发者工具（F12）里明明能看到这个元素，XPath 写得也对，但代码运行就是报 NoSuchElementException。这时候，<strong>99% 是因为元素在 Iframe 里</strong>。</p><hr><h4 id="2-怎么识别-Iframe？"><a href="#2-怎么识别-Iframe？" class="headerlink" title="2. 怎么识别 Iframe？"></a>2. 怎么识别 Iframe？</h4><p>在 F12 开发者工具里，如果你看到元素的父级标签有 <code>iframe</code> 或 <code>frame</code>，那就是它了。</p><hr><h4 id="3-核心操作方法"><a href="#3-核心操作方法" class="headerlink" title="3. 核心操作方法"></a>3. 核心操作方法</h4><h5 id="A-切换进去-switch-to-frame"><a href="#A-切换进去-switch-to-frame" class="headerlink" title="A. 切换进去 (switch_to.frame)"></a>A. 切换进去 (switch_to.frame)</h5><p>有 3 种方式可以切换进去：</p><ol><li><p><strong>通过 ID 或 Name (最简单)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;iframe_id&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;iframe_name&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过 WebElement 对象 (最稳，推荐)</strong>：<br>如果 Iframe 没有 ID，或者 ID 是动态的。你可以先用 find_element 找到这个 iframe 标签，再切进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">iframe_element = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//iframe[@class=&#x27;...&#x27;]&quot;</span>)<br>driver.switch_to.frame(iframe_element)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过索引 (Index)</strong>：<br>driver.switch_to.frame(0) (切到第1个 iframe)。<em>不推荐，因为页面变动容易挂。</em></p></li></ol><h4 id="B-切换出来-switch-to-default-content"><a href="#B-切换出来-switch-to-default-content" class="headerlink" title="B. 切换出来 (switch_to.default_content)"></a>B. 切换出来 (switch_to.default_content)</h4><p>操作完 Iframe 里的东西，<strong>一定要切回来！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回到最外层的主页面</span><br>driver.switch_to.default_content()<br><span class="hljs-comment"># (选学) 如果是嵌套 Iframe (A套B，B套C)，想从 C 回到 B：</span><br>driver.switch_to.parent_frame()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开页面</span><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/iframe&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换进 Iframe ---</span><br><span class="hljs-comment"># 这里的 iframe 有个 id 叫 &#x27;mce_0_ifr&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在切换进 Iframe...&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;mce_0_ifr&quot;</span>)<br><br><span class="hljs-comment"># --- 2. 在 Iframe 内部操作 ---</span><br><span class="hljs-comment"># 注意：切进来后，我们找的是 iframe 里面的 body 标签</span><br>editor_body = driver.find_element(By.ID, <span class="hljs-string">&quot;tinymce&quot;</span>)<br><br><span class="hljs-comment"># 清空原有内容</span><br>editor_body.clear()<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 输入新内容</span><br>editor_body.send_keys(<span class="hljs-string">&quot;你好，我是 Selenium 练习生！&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已在编辑器中输入内容&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换回主页面 ---</span><br><span class="hljs-comment"># 如果不写这句，下面找标题会报错，因为标题在 iframe 外面</span><br>driver.switch_to.default_content()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已切回主页面&quot;</span>)<br><br><span class="hljs-comment"># --- 3. 在主页面操作 ---</span><br><span class="hljs-comment"># 获取页面上方的大标题</span><br>h3_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主页面标题: <span class="hljs-subst">&#123;h3_text&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">assert</span> h3_text == <span class="hljs-string">&quot;An iFrame containing the TinyMCE WYSIWYG Editor&quot;</span><br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="浏览器管理与执行JS"><a href="#浏览器管理与执行JS" class="headerlink" title="浏览器管理与执行JS"></a>浏览器管理与执行JS</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image11.png" class="" title="浏览器管理"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image12.png" class="" title="执行JS"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 打开京东</span><br>driver.get(<span class="hljs-string">&quot;https://www.jd.com&quot;</span>)<br><br><span class="hljs-comment"># --- 浏览器管理演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在最大化窗口...&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># --- JS 执行演示：滚动条 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备滚动到底部...&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿一下让你看清</span><br><br><span class="hljs-comment"># 执行 JS 滚动到底部</span><br><span class="hljs-comment"># document.body.scrollHeight 是获取页面总高度</span><br>driver.execute_script(<span class="hljs-string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已滚动到底部，等待图片懒加载...&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等待页面加载更多内容</span><br><br><span class="hljs-comment"># --- 截图演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在截图...&quot;</span>)<br><span class="hljs-comment"># 截图会保存在当前代码的目录下</span><br>driver.get_screenshot_as_file(<span class="hljs-string">&quot;jd_bottom.png&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 截图已保存为 jd_bottom.png&quot;</span>)<br><br><span class="hljs-comment"># --- Cookie 演示 ---</span><br>cookies = driver.get_cookies()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前获取到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(cookies)&#125;</span> 个 Cookie&quot;</span>)<br><span class="hljs-comment"># 随便打印第一个看看长什么样</span><br><span class="hljs-keyword">if</span> cookies:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一个 Cookie: <span class="hljs-subst">&#123;cookies[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- JS 进阶：修改页面标题 (好玩的操作) ---</span><br><span class="hljs-comment"># 你甚至可以用 JS 修改网页显示的内容</span><br>driver.execute_script(<span class="hljs-string">&quot;document.title = &#x27;这是我用 Selenium 改的标题！&#x27;;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;修改后的标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><p><strong>Q1: 自动化测试中，如何处理页面滚动？</strong></p><blockquote><p><strong>答</strong>：Selenium 原生没有滚动方法，我通常使用 execute_script 执行 JavaScript。<br>比如 window.scrollTo(0, document.body.scrollHeight) 滚动到底部，或者使用 arguments[0].scrollIntoView() 滚动到特定元素。</p></blockquote><p><strong>Q2: 遇到一个日期控件，无法直接输入，怎么处理？</strong></p><blockquote><p><strong>答</strong>：通常是因为 input 标签有 readonly 属性。我会先用 JS 移除这个属性 (removeAttribute(‘readonly’))，然后就可以直接用 send_keys 输入日期了，这样比通过 UI 选日历更稳定。</p></blockquote><p><strong>Q3: 自动化测试执行失败了，怎么排查？</strong></p><blockquote><p><strong>答</strong>：我会配置测试框架，在用例失败（Fail）或报错（Error）时，自动调用 driver.get_screenshot_as_file 进行截图，并把截图嵌入到测试报告（如 Allure）中，方便后续分析。</p></blockquote><hr><h1 id="三大等待"><a href="#三大等待" class="headerlink" title="三大等待"></a>三大等待</h1><hr><h3 id="1-强制等待-Forced-Wait-——-time-sleep"><a href="#1-强制等待-Forced-Wait-——-time-sleep" class="headerlink" title="1. 强制等待 (Forced Wait) —— time.sleep()"></a>1. 强制等待 (Forced Wait) —— <code>time.sleep()</code></h3><p>这是 Python 自带的库，不是 Selenium 的功能。</p><ul><li><p><strong>原理</strong>：不管网页加载完没，不管元素出来没，我就死等指定的秒数。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.sleep(<span class="hljs-number">5</span>) <span class="hljs-comment"># 睡 5 秒</span><br></code></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：简单，粗暴，调试（Debug）时最好用。</p></li><li><p><strong>缺点</strong>：</p><ul><li><strong>浪费时间</strong>：网页 1秒加载完，你睡 5秒，浪费 4秒。</li><li><strong>不稳定</strong>：网页 6秒加载完，你睡 5秒，脚本报错。</li></ul></li><li><p><strong>结论</strong>：<strong>写作业、调试可以用，但上线运行的代码里尽量别用。</strong></p></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait-——-driver-implicitly-wait"><a href="#2-隐式等待-Implicit-Wait-——-driver-implicitly-wait" class="headerlink" title="2. 隐式等待 (Implicit Wait) —— driver.implicitly_wait()"></a>2. 隐式等待 (Implicit Wait) —— <code>driver.implicitly_wait()</code></h3><p>这是 Selenium 的全局设置。</p><ul><li><p><strong>原理</strong>：设置一个<strong>最长等待时间</strong>。在找元素（<code>find_element</code>）时，如果元素没立刻出现，Selenium 会不断轮询（每隔 0.5秒看一眼），直到元素出现<strong>或者</strong>超时报错。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只需要在启动浏览器后写一次，全局生效</span><br>driver.implicitly_wait(<span class="hljs-number">10</span>) <br></code></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：写一行代码，管所有元素，省事。</p></li><li><p><strong>缺点 (面试考点)</strong>：</p><ul><li>它只能判断元素<strong>是否在 HTML (DOM) 里</strong>。</li><li><strong>致命伤</strong>：如果元素在 HTML 里了，但是是<strong>不可见</strong>的（比如 loading 遮罩层还没消失），或者<strong>不可点击</strong>的，隐式等待会认为“找到了”，立刻去点，结果报错 <code>ElementNotInteractableException</code>。</li></ul></li><li><p><strong>结论</strong>：<strong>作为保底手段，每个脚本都加上，但不能完全依赖它。</strong></p></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-WebDriverWait"><a href="#3-显式等待-Explicit-Wait-——-WebDriverWait" class="headerlink" title="3. 显式等待 (Explicit Wait) —— WebDriverWait"></a>3. 显式等待 (Explicit Wait) —— <code>WebDriverWait</code></h3><p>这是<strong>最智能、最推荐</strong>的等待方式。</p><ul><li><p><strong>原理</strong>：专门等待<strong>某个条件</strong>成立（比如：等这个按钮变成“可点击”状态，或者等这段文字“可见”）。</p></li><li><p><strong>代码结构</strong>：<br>需要引入三个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br></code></pre></td></tr></table></figure></li><li><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># WebDriverWait(driver, 超时时间, 轮询频率).until(等待条件)</span><br>element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.element_to_be_clickable((By.ID, <span class="hljs-string">&quot;login_btn&quot;</span>))<br>)<br>element.click()<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="⚔️-核心实战：常用-EC-Expected-Conditions-条件"><a href="#⚔️-核心实战：常用-EC-Expected-Conditions-条件" class="headerlink" title="⚔️ 核心实战：常用 EC (Expected Conditions) 条件"></a>⚔️ 核心实战：常用 EC (Expected Conditions) 条件</h3><p><code>expected_conditions</code> (简称 EC) 提供了很多判断标准，面试和工作中<strong>最常用</strong>的是这三个：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>presence_of_element_located</code></strong></td><td align="left">元素存在于 HTML 中</td><td align="left">等同于隐式等待，只要代码里有这个标签就行，不管你看没看见。</td></tr><tr><td align="left"><strong><code>visibility_of_element_located</code></strong></td><td align="left"><strong>元素可见</strong></td><td align="left"><strong>最常用！</strong> 元素不仅在 HTML 里，而且长宽大于 0，肉眼能看见。</td></tr><tr><td align="left"><strong><code>element_to_be_clickable</code></strong></td><td align="left"><strong>元素可点击</strong></td><td align="left"><strong>最稳！</strong> 元素可见且可用（没有 disable）。点按钮前必用这个。</td></tr></tbody></table><hr><h3 id="💻-代码实战：显式等待演示"><a href="#💻-代码实战：显式等待演示" class="headerlink" title="💻 代码实战：显式等待演示"></a>💻 代码实战：显式等待演示</h3><p>去<strong>The Internet</strong> 的动态加载页面。<br><strong>场景</strong>：点击 “Start” 按钮，页面会出现一个 loading 条，过 5 秒后才会出现 “Hello World!” 文字。</p><ul><li>如果用隐式等待，可能会因为 loading 条还在就去抓文字，导致失败。</li><li>我们要用显式等待，直到文字<strong>可见</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br><span class="hljs-comment"># 虽然有显式等待，加个隐式等待做保底也是好习惯</span><br>driver.implicitly_wait(<span class="hljs-number">5</span>) <br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br><br><span class="hljs-comment"># 1. 点击 Start 按钮</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;button&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 等待结果</span><br><span class="hljs-comment"># 此时页面上有一个 loading 进度条，&quot;Hello World&quot; 其实已经在 HTML 里了(hidden)，但不可见。</span><br><span class="hljs-comment"># 如果直接 find_element，隐式等待会立刻找到它（因为在 HTML 里），然后去获取 text，</span><br><span class="hljs-comment"># 结果获取到的是空字符串（因为没显示出来），导致断言失败。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待 Hello World 出现...&quot;</span>)<br><br><span class="hljs-comment"># --- 使用显式等待 ---</span><br><span class="hljs-comment"># 意思：最多等 10 秒，直到 ID 为 &#x27;finish&#x27; 的元素变成【可见】状态</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.visibility_of_element_located((By.ID, <span class="hljs-string">&quot;finish&quot;</span>))<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_element.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> target_element.text == <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试通过！&quot;</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问</strong>：我既设置了 <code>implicitly_wait(10)</code>，又在代码里写了 <code>WebDriverWait(driver, 10)</code>，会有什么问题？</p><p><strong>答</strong>：</p><blockquote><p><strong>尽量不要混用，或者要非常小心。</strong><br>因为 Selenium 的机制原因，当两者混用时，超时时间可能会出现<strong>不可预测的叠加</strong>。<br>比如你本意是等 10 秒，结果它俩互相影响，可能导致脚本卡死 20 秒甚至更久才报错。<br><strong>最佳实践</strong>：设置一个较短的全局隐式等待（如 5秒），关键步骤（如点击、断言）使用显式等待。</p></blockquote><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a>🚀 总结</h3><ol><li><strong><code>time.sleep</code></strong>：调试用，死等。</li><li><strong><code>implicitly_wait</code></strong>：全局设置，只管元素在不在 HTML 里，不管能不能点。</li><li><strong><code>WebDriverWait</code></strong>：<strong>王牌</strong>。精准等待元素可见、可点击。</li></ol><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image13.png" class="" title="下拉框"><ol><li><strong>标准下拉框</strong>：HTML 标签是 <code>&lt;select&gt;</code> + <code>&lt;option&gt;</code>。Selenium 提供了专门的 <code>Select</code> 类来处理，非常简单。</li><li><strong>非标准下拉框</strong>：HTML 标签是 <code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code> 模拟的（现在的前端框架如 Vue&#x2F;React 常用这种）。这种<strong>不能</strong>用 <code>Select</code> 类，必须把它当成普通的元素，用“点击 -&gt; 等待 -&gt; 点击”的方式处理。</li></ol><hr><h3 id="第一种：标准下拉框-标签"><a href="#第一种：标准下拉框-标签" class="headerlink" title="第一种：标准下拉框 (&lt;select&gt; 标签)"></a>第一种：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>Selenium 专门提供了一个 <code>Select</code> 类，专门治这种元素。</p><p><strong>核心步骤</strong>：</p><ol><li>引入：<code>from selenium.webdriver.support.ui import Select</code></li><li>定位：先找到那个 <code>&lt;select&gt;</code> 元素。</li><li>初始化：<code>select = Select(元素对象)</code></li><li>选择：使用三大方法选你想要的。</li></ol><p>**三大选择方法 ：</p><ul><li><code>select_by_visible_text(&quot;文字&quot;)</code>：<strong>最常用</strong>。根据用户看到的文字选，比如 “Option 1”。</li><li><code>select_by_value(&quot;值&quot;)</code>：根据 HTML 里的 <code>value</code> 属性选，比如 <code>value=&quot;1&quot;</code>。</li><li><code>select_by_index(索引)</code>：根据顺序选，从 0 开始。<strong>不推荐</strong>，因为选项顺序容易变。</li></ul><h4 id="💻-代码实战：标准下拉框"><a href="#💻-代码实战：标准下拉框" class="headerlink" title="💻 代码实战：标准下拉框"></a>💻 代码实战：标准下拉框</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-comment"># 1. 引入 Select 类</span><br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> Select<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br><span class="hljs-comment"># 2. 先定位到 select 标签本身</span><br>dropdown_element = driver.find_element(By.ID, <span class="hljs-string">&quot;dropdown&quot;</span>)<br><br><span class="hljs-comment"># 3. 初始化 Select 对象</span><br>select = Select(dropdown_element)<br><br><span class="hljs-comment"># --- 方法 A: 通过可见文本选择 (最推荐) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 1...&quot;</span>)<br>select.select_by_visible_text(<span class="hljs-string">&quot;Option 1&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 验证一下选上了没 (获取当前选中的选项)</span><br><span class="hljs-comment"># first_selected_option 是获取当前显示的那个元素</span><br>current_val = select.first_selected_option.text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中: <span class="hljs-subst">&#123;current_val&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> current_val == <span class="hljs-string">&quot;Option 1&quot;</span><br><br><span class="hljs-comment"># --- 方法 B: 通过 value 属性选择 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 2 (通过 value)...&quot;</span>)<br>select.select_by_value(<span class="hljs-string">&quot;2&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># --- 方法 C: 通过索引选择 (不推荐) ---</span><br><span class="hljs-comment"># 索引 1 对应 Option 1 (因为索引 0 是那个 &quot;Please select an option&quot; 的提示语)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择索引 1...&quot;</span>)<br>select.select_by_index(<span class="hljs-number">1</span>) <br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二种：非标准下拉框-Div-Ul-模拟"><a href="#第二种：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二种：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二种：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>如果对着一个 <code>&lt;div&gt;</code> 标签用 <code>Select()</code> 类，Selenium 会直接报错：<br><code>UnexpectedTagNameException: Select only works on &lt;select&gt; elements</code>。</p><p><strong>处理逻辑</strong>：<br>把它当成普通的点击操作</p><hr><p><strong>问：</strong> “你在自动化测试中遇到过下拉框吗？怎么处理的？”</p><blockquote><p>“遇到过，我通常会先看它的 HTML 标签。</p><ol><li>如果是标准的 <strong><code>&lt;select&gt;</code></strong> 标签，我会直接用 Selenium 的 <strong><code>Select</code> 类</strong>，通过 <code>select_by_visible_text</code> 来选择，这样代码最简洁。</li><li>如果是前端框架（如 Vue&#x2F;React）生成的 <strong><code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code></strong> 模拟的下拉框，<code>Select</code> 类是用不了的。我会把它当成普通元素，<strong>分两步处理</strong>：先点击下拉框弹出列表，再定位并点击具体的选项。为了稳定性，我通常会在第二步加上<strong>显式等待</strong>，确保选项可见后再点击。”</li></ol></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Select 类</strong>：只给 <code>&lt;select&gt;</code> 标签用。</li><li><strong>非 Select</strong>：点击框 -&gt; 等待 -&gt; 点击选项。</li></ul><hr><h1 id="Alert、Prompt、Confirm弹出框"><a href="#Alert、Prompt、Confirm弹出框" class="headerlink" title="Alert、Prompt、Confirm弹出框"></a>Alert、Prompt、Confirm弹出框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image14.png" class="" title="弹框"><h3 id="1-什么是-Alert-Confirm-Prompt？"><a href="#1-什么是-Alert-Confirm-Prompt？" class="headerlink" title="1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？"></a>1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？</h3><p>这些是浏览器<strong>原生</strong>的弹窗（JavaScript 触发的）。</p><ul><li><strong>特点</strong>：它们<strong>不是</strong> HTML 元素！你<strong>无法</strong>用 F12 审查元素，也<strong>无法</strong>用 <code>find_element</code> 定位。</li><li><strong>表现</strong>：弹出来的时候，浏览器会被“冻结”，你必须处理掉它（点确定或取消），才能继续操作页面。</li></ul><h3 id="2-核心操作方法"><a href="#2-核心操作方法" class="headerlink" title="2. 核心操作方法"></a>2. 核心操作方法</h3><p>Selenium 提供了一个 <code>Alert</code> 类来专门处理它们。</p><p><strong>第一步：切换控制权</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alert = driver.switch_to.alert<br></code></pre></td></tr></table></figure><p><strong>第二步：操作弹窗 (4 个方法背下来)</strong></p><ol><li><strong><code>alert.accept()</code></strong>：点击“确定” (OK)。</li><li><strong><code>alert.dismiss()</code></strong>：点击“取消” (Cancel)。</li><li><strong><code>alert.text</code></strong>：获取弹窗里的文字 (用来做断言)。</li><li><strong><code>alert.send_keys(&quot;内容&quot;)</code></strong>：在弹窗里输入文字 (仅针对 Prompt)。</li></ol><hr><h3 id="3-三种弹窗的区别"><a href="#3-三种弹窗的区别" class="headerlink" title="3. 三种弹窗的区别"></a>3. 三种弹窗的区别</h3><ol><li><strong>Alert (警告框)</strong>：只有一个“确定”按钮。</li><li><strong>Confirm (确认框)</strong>：有“确定”和“取消”两个按钮。</li><li><strong>Prompt (提示框)</strong>：有个输入框，加上“确定”和“取消”。</li></ol><hr><h3 id="代码实战：全套演练"><a href="#代码实战：全套演练" class="headerlink" title="代码实战：全套演练"></a>代码实战：全套演练</h3><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/javascript_alerts</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br><span class="hljs-comment"># --- 场景 1: 处理 Alert (只有确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 点击 Alert 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Alert&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿让你看清楚弹窗出来了</span><br><br><span class="hljs-comment"># 切换到弹窗</span><br>alert = driver.switch_to.alert<br><br><span class="hljs-comment"># 获取文字并断言</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Alert 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> alert.text == <span class="hljs-string">&quot;I am a JS Alert&quot;</span><br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Alert 已处理&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 2: 处理 Confirm (确定/取消) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 点击 Confirm 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Confirm&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Confirm 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 这次我们点“取消”试试</span><br>alert.dismiss()<br><br><span class="hljs-comment"># 验证页面结果 (页面会显示 You clicked: Cancel)</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Cancel&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Confirm 已取消&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 3: 处理 Prompt (输入 + 确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 点击 Prompt 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Prompt&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Prompt 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 输入内容</span><br><span class="hljs-comment"># 注意：在 Chrome 中，你可能看不到字打进去的动画，但实际上已经输入了</span><br>alert.send_keys(<span class="hljs-string">&quot;Selenium 练习生&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><br><span class="hljs-comment"># 验证结果</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Selenium 练习生&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Prompt 输入并确认成功&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问：</strong> “页面上弹出了一个框，你用 <code>switch_to.alert</code> 报错说 <code>NoAlertPresentException</code>，为什么？”</p><p><strong>答：</strong></p><blockquote><p>“这说明那个弹窗<strong>不是</strong>浏览器原生的 Alert，而是前端用 HTML&#x2F;CSS（比如 Bootstrap 的 Modal）画出来的<strong>伪弹窗</strong>。</p><p><strong>怎么区分？</strong></p><ul><li><strong>原生 Alert</strong>：右键点击弹窗，<strong>没有</strong>‘检查&#x2F;Inspect’选项，且弹窗出现时浏览器无法操作其他地方。</li><li><strong>HTML 模态框</strong>：右键可以‘检查’，本质上就是个 <code>div</code>。</li></ul><p><strong>处理方法</strong>：</p><ul><li>如果是原生的：用 <code>driver.switch_to.alert</code>。</li><li>如果是 HTML 的：直接用 <code>driver.find_element</code> 定位上面的按钮，然后 <code>click()</code> 即可。”</li></ul></blockquote><hr><h3 id="进阶技巧：显式等待处理-Alert"><a href="#进阶技巧：显式等待处理-Alert" class="headerlink" title="进阶技巧：显式等待处理 Alert"></a>进阶技巧：显式等待处理 Alert</h3><p>有时候点击按钮后，Alert 弹窗不是立刻出来的（比如要请求服务器）。这时候直接 <code>switch_to.alert</code> 会报错。</p><p><strong>解决方案</strong>：使用 <code>EC.alert_is_present()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-comment"># 点击按钮</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br><br><span class="hljs-comment"># 显式等待：直到弹窗出现，并自动切换过去返回 alert 对象</span><br>alert = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.alert_is_present())<br><br><span class="hljs-comment"># 直接操作</span><br>alert.accept()<br></code></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Alert 处理非常简单，记住：</p><ol><li><code>switch_to.alert</code></li><li><code>accept()</code> &#x2F; <code>dismiss()</code></li><li><code>send_keys()</code></li></ol><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image15.png" class="" title="鼠标操作"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image16.png" class="" title="键盘操作"><p>普通的 <code>click()</code> 和 <code>send_keys()</code> 只能处理简单的交互。遇到以下场景，就必须请出 <strong><code>ActionChains</code></strong> 类：</p><ol><li><strong>鼠标悬停 (Hover)</strong>：鼠标移上去才显示下拉菜单（如京东&#x2F;淘宝的商品分类）。</li><li><strong>拖拽 (Drag &amp; Drop)</strong>：滑块验证码、拖动文件上传。</li><li><strong>右键&#x2F;双击</strong>：网页游戏或复杂的后台管理系统。</li><li><strong>键盘组合键</strong>：Ctrl+C, Ctrl+V, 按 Enter 提交。</li></ol><hr><h3 id="核心概念：动作链-Chain"><a href="#核心概念：动作链-Chain" class="headerlink" title="核心概念：动作链 (Chain)"></a>核心概念：动作链 (Chain)</h3><p><code>ActionChains</code> 的工作原理像<strong>录像机</strong>：</p><ol><li>先把一连串的动作（移动、点击、按键）<strong>排队</strong>放进队列里。</li><li>最后必须调用 <strong><code>.perform()</code></strong> 方法，Selenium 才会真正去执行这些动作。</li></ol><hr><h3 id="第一部分：鼠标操作-Mouse-Actions"><a href="#第一部分：鼠标操作-Mouse-Actions" class="headerlink" title="第一部分：鼠标操作 (Mouse Actions)"></a>第一部分：鼠标操作 (Mouse Actions)</h3><h4 id="实战-1：鼠标悬停-Hover-——-百度设置"><a href="#实战-1：鼠标悬停-Hover-——-百度设置" class="headerlink" title="实战 1：鼠标悬停 (Hover) —— 百度设置"></a>实战 1：鼠标悬停 (Hover) —— 百度设置</h4><p><strong>场景</strong>：<br>在百度首页，鼠标如果不移到右上角的“设置”上，下拉菜单是不会出来的，你也点不到里面的“高级搜索”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains <span class="hljs-comment"># 1. 引入 ActionChains</span><br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># 定位“设置”元素</span><br>settings_btn = driver.find_element(By.ID, <span class="hljs-string">&quot;s-usersetting-top&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤 ---</span><br><span class="hljs-comment"># 链式写法：初始化 -&gt; 移动鼠标 -&gt; 执行</span><br><span class="hljs-comment"># 翻译：把鼠标移到 settings_btn 上，然后执行！</span><br>ActionChains(driver).move_to_element(settings_btn).perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;鼠标已悬停，菜单应该出来了&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿一下让你看清楚</span><br><br><span class="hljs-comment"># 现在菜单出来了，可以点击里面的“高级搜索”了</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已点击高级搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h4 id="实战-2：拖拽-Drag-and-Drop"><a href="#实战-2：拖拽-Drag-and-Drop" class="headerlink" title="实战 2：拖拽 (Drag and Drop)"></a>实战 2：拖拽 (Drag and Drop)</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/drag_and_drop</code><br><strong>任务</strong>：把方块 A 拖到 方块 B 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/drag_and_drop&quot;</span>)<br><br><span class="hljs-comment"># 1. 定位源元素 (A) 和 目标元素 (B)</span><br>source_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-a&quot;</span>)<br>target_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-b&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备拖拽 A 到 B...&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 执行拖拽</span><br>actions = ActionChains(driver)<br>actions.drag_and_drop(source_ele, target_ele).perform()<br><br><span class="hljs-comment"># 验证：检查 A 的文字是不是变了（这个网页拖拽成功后 header 会互换）</span><br><span class="hljs-comment"># 注意：DOM 里的 ID 不会变，但里面的 text 会变</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;拖拽完成！&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二部分：键盘操作-Keyboard-Actions"><a href="#第二部分：键盘操作-Keyboard-Actions" class="headerlink" title="第二部分：键盘操作 (Keyboard Actions)"></a>第二部分：键盘操作 (Keyboard Actions)</h3><h4 id="实战-3：组合键操作-Ctrl-A-Ctrl-C"><a href="#实战-3：组合键操作-Ctrl-A-Ctrl-C" class="headerlink" title="实战 3：组合键操作 (Ctrl+A, Ctrl+C)"></a>实战 3：组合键操作 (Ctrl+A, Ctrl+C)</h4><p><strong>场景</strong>：</p><ol><li>在百度搜索框输入 “Python”。</li><li><strong>Ctrl + A</strong> 全选。</li><li><strong>Ctrl + X</strong> 剪切。</li><li><strong>Ctrl + V</strong> 粘贴。</li><li><strong>Enter</strong> 回车搜索（不点按钮）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys <span class="hljs-comment"># 引入 Keys</span><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br><span class="hljs-comment"># 定位搜索框</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br><br><span class="hljs-comment"># 1. 正常输入</span><br>search_input.send_keys(<span class="hljs-string">&quot;Python&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 模拟组合键：Ctrl + A (全选)</span><br><span class="hljs-comment"># key_down(按下) -&gt; send_keys(A) -&gt; key_up(松开)</span><br>ActionChains(driver)\<br>    .key_down(Keys.CONTROL)\<br>    .send_keys(<span class="hljs-string">&quot;a&quot;</span>)\<br>    .key_up(Keys.CONTROL)\<br>    .perform()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已全选&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 模拟组合键：Ctrl + X (剪切)</span><br><span class="hljs-comment"># 其实 send_keys 也可以直接传组合键，不用 ActionChains 也可以，这是简便写法：</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已剪切&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 4. 模拟组合键：Ctrl + V (粘贴)</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;v&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已粘贴&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 5. 模拟回车键 (提交搜索)</span><br><span class="hljs-comment"># 很多时候不用去找“百度一下”按钮，直接回车更稳</span><br>search_input.send_keys(Keys.ENTER)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已回车搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传分为两种情况，处理方式天差地别：</p><ol><li><strong>标准控件 (<code>&lt;input type=&quot;file&quot;&gt;</code>)</strong>：Selenium 可以轻松搞定。</li><li><strong>非标准控件 (Flash&#x2F;JS&#x2F;Div)</strong>：Selenium <strong>无能为力</strong>，必须借助外挂。</li></ol><hr><h3 id="情况一：标准-Input-标签-90-的情况"><a href="#情况一：标准-Input-标签-90-的情况" class="headerlink" title="情况一：标准 Input 标签 (90% 的情况)"></a>情况一：标准 Input 标签 (90% 的情况)</h3><p>如果网页上的上传按钮对应的 HTML 标签是 <code>&lt;input type=&quot;file&quot; ...&gt;</code>，这是最简单的情况。</p><p><strong>核心秘诀：千万不要点击上传按钮！</strong></p><ul><li><strong>错误做法</strong>：你点击按钮 -&gt; 操作系统弹出一个“文件选择框” -&gt; Selenium 傻眼了（因为它控制不了操作系统窗口）。</li><li><strong>正确做法</strong>：直接把<strong>文件路径</strong> <code>send_keys</code> 给那个 input 元素。</li></ul><h4 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br><span class="hljs-comment"># 1. 准备文件路径</span><br><span class="hljs-comment"># 建议使用绝对路径，防止因为运行目录不同找不到文件</span><br><span class="hljs-comment"># 假设当前目录下有一个 test.txt</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;准备上传的文件路径: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 定位上传控件</span><br><span class="hljs-comment"># 注意：我们要找的是那个 input 标签，而不是那个漂亮的“Choose File”按钮</span><br><span class="hljs-comment"># 哪怕 input 是隐藏的，只要能定位到就行</span><br>upload_input = driver.find_element(By.ID, <span class="hljs-string">&quot;file-upload&quot;</span>)<br><br><span class="hljs-comment"># 3. 核心步骤：直接发送路径</span><br><span class="hljs-comment"># 这一步相当于：Selenium 帮你把路径填进去，并自动触发了文件选择</span><br>upload_input.send_keys(file_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已发送文件路径&quot;</span>)<br><br><span class="hljs-comment"># 4. 点击“Upload”按钮 (提交表单)</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;file-submit&quot;</span>).click()<br><br><span class="hljs-comment"># 5. 验证结果</span><br>uploaded_text = driver.find_element(By.ID, <span class="hljs-string">&quot;uploaded-files&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面显示已上传: <span class="hljs-subst">&#123;uploaded_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;test.txt&quot;</span> <span class="hljs-keyword">in</span> uploaded_text<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="情况二：非标准控件-面试难点"><a href="#情况二：非标准控件-面试难点" class="headerlink" title="情况二：非标准控件 (面试难点)"></a>情况二：非标准控件 (面试难点)</h3><p>有些网站（比如花哨的图片上传插件），找不到 <code>&lt;input&gt;</code> 标签，或者那个标签被复杂的 JS 逻辑包裹，<code>send_keys</code> 不生效。必须点击按钮，弹出 Windows&#x2F;Mac 的文件选择框才能上传。</p><p><strong>Selenium 的局限性</strong>：Selenium 只能控制浏览器，<strong>控制不了操作系统的弹窗</strong>。</p><p><strong>解决方案</strong>：<br>需要引入“外援”来控制鼠标和键盘。</p><h4 id="1-PyAutoGUI-Python-库，推荐"><a href="#1-PyAutoGUI-Python-库，推荐" class="headerlink" title="1. PyAutoGUI (Python 库，推荐)"></a>1. PyAutoGUI (Python 库，推荐)</h4><p>这是一个能控制鼠标键盘的 Python 库。</p><ul><li><strong>思路</strong>：Selenium 点击按钮 -&gt; 弹窗出现 -&gt; PyAutoGUI 输入路径 -&gt; PyAutoGUI 按回车。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要先安装: pip install pyautogui</span><br><span class="hljs-keyword">import</span> pyautogui<br><br><span class="hljs-comment"># ... Selenium 点击按钮的代码 ...</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;upload_btn&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等弹窗出来</span><br><br><span class="hljs-comment"># 使用 PyAutoGUI 操作 Windows 弹窗</span><br>pyautogui.write(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>) <span class="hljs-comment"># 输入路径</span><br>pyautogui.press(<span class="hljs-string">&quot;enter&quot;</span>)        <span class="hljs-comment"># 按回车</span><br></code></pre></td></tr></table></figure><ul><li><strong>缺点</strong>：脚本运行时，<strong>鼠标焦点必须在浏览器上</strong>，你不能去干别的事，否则会输错地方。而且在“无头模式”（Headless，后台运行）下无法使用。</li></ul><h4 id="2-AutoIt-Windows-老牌工具"><a href="#2-AutoIt-Windows-老牌工具" class="headerlink" title="2. AutoIt (Windows 老牌工具)"></a>2. AutoIt (Windows 老牌工具)</h4><p>写一个 <code>.exe</code> 脚本来处理弹窗，Python 调用这个 exe。</p><ul><li><strong>缺点</strong>：学习成本高，只能在 Windows 上用，现在用的人越来越少了。</li></ul><hr><p><strong>问：</strong> “如果上传按钮不是 input 标签，或者 input 标签是 hidden（隐藏）的，怎么处理？”</p><p><strong>答：</strong></p><blockquote><p>“如果是 <code>input</code> 标签被 <code>hidden</code> 隐藏了：</p><ol><li>我会先尝试用 JS (<code>execute_script</code>) 把它的 <code>style.display</code> 改为 <code>block</code> 让它显示出来。</li><li>然后直接用 <code>send_keys</code> 上传，这是最稳的。</li></ol><p>如果根本没有 <code>input</code> 标签，必须操作 OS 弹窗：</p><ul><li>我会使用 <strong>PyAutoGUI</strong> 这样的第三方库来模拟键盘输入路径并回车。</li><li>但在 CI&#x2F;CD 流水线（无界面环境）中这会失效，所以我会尽量和开发沟通，让他们提供一个可供自动化调用的上传接口。”</li></ul></blockquote><hr><h1 id="日期选择"><a href="#日期选择" class="headerlink" title="日期选择"></a>日期选择</h1><ol><li><strong>结构复杂</strong>：通常是嵌套了无数层 <code>div</code>、<code>table</code> 的控件。</li><li><strong>只读限制</strong>：很多输入框有 <code>readonly=&quot;readonly&quot;</code> 属性，禁止你直接输入，强制你点日历。</li><li><strong>翻页麻烦</strong>：如果要选“去年”或者“下个月”，你得写循环去点“上一页&#x2F;下一页”，非常容易出错。</li></ol><hr><h3 id="中策：直接输入-send-keys"><a href="#中策：直接输入-send-keys" class="headerlink" title="中策：直接输入 (send_keys)"></a>中策：直接输入 (send_keys)</h3><p>如果开发比较“仁慈”，没有给输入框加 <code>readonly</code> 属性，或者允许键盘输入。</p><ul><li><p><strong>做法</strong>：</p><ol><li><code>clear()</code> 清空（或者 Ctrl+A -&gt; Delete）。</li><li><code>send_keys(&quot;2023-12-12&quot;)</code>。</li><li>按 <code>Keys.TAB</code> 或点击空白处让日历收起来。</li></ol></li><li><p><strong>注意</strong>：要注意日期的格式（是 <code>yyyy-mm-dd</code> 还是 <code>yyyy/mm/dd</code>），输错了网页会报错。</p></li></ul><hr><h3 id="上策：JS-强行祛除“只读”属性-The-Killer-Move"><a href="#上策：JS-强行祛除“只读”属性-The-Killer-Move" class="headerlink" title="上策：JS 强行祛除“只读”属性 (The Killer Move)"></a>上策：JS 强行祛除“只读”属性 (The Killer Move)</h3><p><strong>原理</strong>：<br>既然 Selenium 控制不了日历控件，那我就用 JS 把输入框的 <code>readonly</code> 属性撕掉！把它变成一个普通的输入框，然后直接填值。</p><h4 id="JS-暴力填单"><a href="#JS-暴力填单" class="headerlink" title="JS 暴力填单"></a>JS 暴力填单</h4><p>假设 HTML 长这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有 readonly，不让你直接输 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;train_date&quot;</span> <span class="hljs-attr">readonly</span>=<span class="hljs-string">&quot;readonly&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.12306.cn/index/&quot;</span>) <span class="hljs-comment"># 以 12306 为例</span><br><br><span class="hljs-comment"># 1. 定位日期输入框</span><br><span class="hljs-comment"># 12306 的出发日期 id 是 &#x27;train_date&#x27;</span><br>date_input = driver.find_element(By.ID, <span class="hljs-string">&quot;train_date&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：JS 祛除 readonly ---</span><br><br><span class="hljs-comment"># 这段 JS 的意思是：找到这个元素(arguments[0])，移除它的 readonly 属性</span><br>js_remove_readonly = <span class="hljs-string">&quot;arguments[0].removeAttribute(&#x27;readonly&#x27;);&quot;</span><br>driver.execute_script(js_remove_readonly, date_input)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已移除只读属性&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：清空并输入 ---</span><br><br><span class="hljs-comment"># 2. 清空原有的日期</span><br>date_input.clear()<br><br><span class="hljs-comment"># 3. 输入你想去的日期</span><br><span class="hljs-comment"># 注意：12306 这种网站对格式要求很严，必须是 yyyy-mm-dd</span><br>date_input.send_keys(<span class="hljs-string">&quot;2025-01-01&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入日期: 2025-01-01&quot;</span>)<br><br><span class="hljs-comment"># 4. (可选) 有时候输入完日历还在遮挡视线，可以点一下别的地方</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>).click()<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="进阶坑点：Vue-React-框架的日期控件"><a href="#进阶坑点：Vue-React-框架的日期控件" class="headerlink" title="进阶坑点：Vue&#x2F;React 框架的日期控件"></a>进阶坑点：Vue&#x2F;React 框架的日期控件</h3><p>现在的网站很多是用 Vue 或 React 写的。<br>可能会发现：<strong>用上面的方法 <code>send_keys</code> 填进去了，但一点“查询”，日期又变回去了！</strong></p><p><strong>原因</strong>：<br>这些前端框架是“双向绑定”的。光改了 HTML 里的 value，但没有触发网页的 <code>input</code> 或 <code>change</code> 事件，框架不知道改了值。</p><p><strong>解决方案 (JS 直接赋值)</strong>：<br>不要用 <code>send_keys</code>，直接用 JS 修改 value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 针对 Vue/React 等难搞的控件</span><br><span class="hljs-comment"># 直接把 value 改掉，一步到位</span><br>js_value = <span class="hljs-string">&quot;arguments[0].value = &#x27;2025-01-01&#x27;;&quot;</span><br>driver.execute_script(js_value, date_input)<br></code></pre></td></tr></table></figure><hr><h1 id="联想输入框"><a href="#联想输入框" class="headerlink" title="联想输入框"></a>联想输入框</h1><p>它的难点在于：<strong>选项是动态加载的</strong>。</p><ol><li>输入“电脑”。</li><li>浏览器发送请求给服务器。</li><li>服务器返回数据，前端再渲染出一个下拉列表（通常是 <code>&lt;ul&gt;&lt;li&gt;</code> 或 <code>&lt;div&gt;</code> 结构）。</li><li>这个过程有<strong>延迟</strong>，必须处理好等待。</li></ol><hr><h3 id="方法一：XPath-文本定位"><a href="#方法一：XPath-文本定位" class="headerlink" title="方法一：XPath 文本定位"></a>方法一：XPath 文本定位</h3><p>如果明确知道想选哪一个（比如输入 “selenium”，你想选 “selenium教程”），直接用 XPath 的文本匹配去点。</p><p><strong>核心逻辑</strong>：<br>输入 -&gt; <strong>显式等待</strong>列表出现 -&gt; <strong>XPath 定位包含特定文字的元素</strong> -&gt; 点击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.zhihu.com/&quot;</span>)<br>driver.maximize_window()<br><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 输入关键词</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;Popover1-toggle&quot;</span>).send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br><br><span class="hljs-comment"># 2. 【关键】显式等待联想框出现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待联想选项出现...&quot;</span>)<br><br>target_text = <span class="hljs-string">&quot;selenium被淘汰了吗&quot;</span><br><br><span class="hljs-comment"># XPath 解析：在所有 span 标签中，找到文本包含 &#x27;selenium被淘汰了吗&#x27; 的那个</span><br><span class="hljs-comment"># 注意：联想词通常在 li 标签或者 div 标签或者 span里</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.XPATH, <span class="hljs-string">f&quot;//span[contains(., &#x27;<span class="hljs-subst">&#123;target_text&#125;</span>&#x27;)]&quot;</span>))<br>)<br><br><span class="hljs-comment"># 3. 点击它</span><br>target_element.click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已点击选项: <span class="hljs-subst">&#123;target_text&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="方法二：循环遍历法"><a href="#方法二：循环遍历法" class="headerlink" title="方法二：循环遍历法"></a>方法二：循环遍历法</h3><p>有时候 XPath 文本匹配可能会因为空格、换行符导致定位失败。或者想打印出所有联想词看看。这时候可以用<strong>遍历法</strong>。</p><p><strong>核心逻辑</strong>：</p><ol><li>找到所有的选项元素（返回一个 List）。</li><li>用 <code>for</code> 循环一个一个看。</li><li>如果文字对上了，就点击，然后 <code>break</code> 跳出循环。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面输入代码一样 ...</span><br><br><span class="hljs-comment"># 1. 等待任意一个选项出现，确保列表加载了</span><br>WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>))<br>)<br><br><span class="hljs-comment"># 2. 获取所有选项列表</span><br><span class="hljs-comment"># 百度联想项的 CSS 通常是 .bdsug li (具体要按 F12 确认)</span><br>options = driver.find_elements(By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;一共找到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(options)&#125;</span> 个联想词&quot;</span>)<br><br><span class="hljs-comment"># 3. 循环遍历</span><br>want_to_click = <span class="hljs-string">&quot;selenium安装教程&quot;</span><br><br><span class="hljs-keyword">for</span> option <span class="hljs-keyword">in</span> options:<br>    <span class="hljs-comment"># 获取当前选项的文本</span><br>    text = option.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发现选项: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 模糊匹配：如果我想点的词在选项里</span><br>    <span class="hljs-keyword">if</span> want_to_click <span class="hljs-keyword">in</span> text:<br>        option.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功点击: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找了一圈没找到你要的词&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="方法三：键盘操作法"><a href="#方法三：键盘操作法" class="headerlink" title="方法三：键盘操作法"></a>方法三：键盘操作法</h3><p>如果你不在乎具体选哪个，或者列表结构太复杂（比如嵌套了无数层 div），你可以模拟键盘的 <strong>“向下箭头” + “回车”</strong>。</p><p><strong>场景</strong>：输入后，默认选第一个联想词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<br><br><span class="hljs-comment"># 1. 输入文本</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br>search_input.send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等一下列表出来</span><br><br><span class="hljs-comment"># 2. 模拟按键：向下箭头 -&gt; 向下箭头 -&gt; 回车</span><br><span class="hljs-comment"># 选第二个联想词</span><br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ENTER)<br></code></pre></td></tr></table></figure><hr><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><h2 id="1-基本交互方法"><a href="#1-基本交互方法" class="headerlink" title="1. 基本交互方法"></a>1. <strong>基本交互方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/challenging_dom&quot;</span>) <span class="hljs-comment"># 这里只是举例，找个有 canvas 的网页很难，假设页面有个 id=&#x27;myCanvas&#x27;</span><br><br><span class="hljs-comment"># 1. 定位 Canvas 元素本身</span><br><span class="hljs-comment"># canvas = driver.find_element(By.ID, &quot;myCanvas&quot;) </span><br><span class="hljs-comment"># 为了演示代码不报错，我用 body 代替 canvas 演示动作</span><br>canvas = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义裁剪的动作</span><br><span class="hljs-comment"># 假设：裁剪框的起始点在画布 (100, 100) 的位置</span><br><span class="hljs-comment"># 假设：我们要向右下角拖拽，宽 200，高 150</span><br><br>action = ActionChains(driver)<br><br><span class="hljs-comment"># 步骤分解：</span><br><span class="hljs-comment"># A. 移动鼠标到画布的 (100, 100) 位置</span><br><span class="hljs-comment"># 注意：move_to_element_with_offset 是相对于元素的左上角</span><br>action.move_to_element_with_offset(canvas, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># B. 按下鼠标左键 (不松开)</span><br>action.click_and_hold()<br><br><span class="hljs-comment"># C. 拖拽鼠标 (相对移动)</span><br><span class="hljs-comment"># 向右移动 200px，向下移动 150px</span><br>action.move_by_offset(<span class="hljs-number">200</span>, <span class="hljs-number">150</span>)<br><br><span class="hljs-comment"># D. 松开鼠标</span><br>action.release()<br><br><span class="hljs-comment"># E. 执行！</span><br>action.perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已完成 Canvas 上的拖拽操作&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-JavaScript-执行方法"><a href="#2-JavaScript-执行方法" class="headerlink" title="2. JavaScript 执行方法"></a>2. <strong>JavaScript 执行方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取像素数据</span><br>script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);</span><br><span class="hljs-string">return Array.from(imageData.data);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>pixel_data = driver.execute_script(script, canvas)<br><br><span class="hljs-comment"># 在 Canvas 上绘制</span><br>draw_script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">ctx.fillStyle = &#x27;red&#x27;;</span><br><span class="hljs-string">ctx.fillRect(10, 10, 50, 50);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>driver.execute_script(draw_script, canvas)<br></code></pre></td></tr></table></figure><hr><h1 id="PO模式"><a href="#PO模式" class="headerlink" title="PO模式"></a>PO模式</h1><h3 id="1-什么是-PO-模式？"><a href="#1-什么是-PO-模式？" class="headerlink" title="1. 什么是 PO 模式？"></a>1. 什么是 PO 模式？</h3><p><strong>核心思想</strong>：<strong>页面（Page）与测试逻辑（Test）分离</strong>。</p><ul><li><strong>没有 PO 模式</strong>：想吃宫保鸡丁，直接冲进厨房，自己切鸡肉、自己炒菜、自己吃。（测试脚本里混杂了定位元素、点击操作、断言逻辑）。</li><li><strong>用了 PO 模式</strong>：<ul><li><strong>Page (菜单)</strong>：厨房封装好了“宫保鸡丁”这道菜（封装了定位和操作）。</li><li><strong>Test (顾客)</strong>：只需要对着菜单喊一声“我要一份宫保鸡丁”（调用方法），不需要知道厨房里是怎么切菜的。</li></ul></li></ul><hr><h3 id="2-为什么要用它"><a href="#2-为什么要用它" class="headerlink" title="2. 为什么要用它"></a>2. 为什么要用它</h3><p>假设有 50 条测试用例都涉及“登录”。<br>有一天，前端开发把登录按钮的 <code>id=&quot;login-btn&quot;</code> 改成了 <code>id=&quot;submit-btn&quot;</code>。</p><ul><li><strong>惨状（无 PO）</strong>：需要打开 50 个测试文件，一个一个查找替换。</li><li><strong>优雅（有 PO）</strong>：只需要打开 <code>LoginPage.py</code> 这<strong>一个</strong>文件，修改一行代码。50 条用例自动修复。</li></ul><hr><h3 id="3-PO-模式的三层架构"><a href="#3-PO-模式的三层架构" class="headerlink" title="3. PO 模式的三层架构"></a>3. PO 模式的三层架构</h3><p>把代码拆分成三个文件夹（层级）：</p><ol><li><strong><code>base/</code> (基类层)</strong>：<strong>地基</strong>。封装 Selenium 最底层的 <code>find_element</code>、<code>click</code> 等方法，加上显式等待。</li><li><strong><code>pages/</code> (页面层)</strong>：<strong>菜单</strong>。每个页面写一个类（如 <code>LoginPage</code>），只存放<strong>元素定位</strong>和<strong>页面操作</strong>。</li><li><strong><code>test_cases/</code> (测试层)</strong>：<strong>顾客</strong>。只写<strong>业务逻辑</strong>和<strong>断言</strong>。</li></ol><hr><h3 id="4-手把手代码实战"><a href="#4-手把手代码实战" class="headerlink" title="4. 手把手代码实战"></a>4. 手把手代码实战</h3><p>我们以 <strong>SauceDemo</strong> 登录为例。</p><h4 id="第一步：搭建项目结构"><a href="#第一步：搭建项目结构" class="headerlink" title="第一步：搭建项目结构"></a>第一步：搭建项目结构</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">AutoTestProject/<br>├── base/<br>│   └── base_page.py      # 封装底层 Selenium<br>├── pages/<br>│   └── login_page.py     # 登录页面的元素和操作<br>└── test_cases/<br>    └── test_login.py     # 具体的测试脚本<br></code></pre></td></tr></table></figure><h4 id="第二步：编写基类-base-base-page-py"><a href="#第二步：编写基类-base-base-page-py" class="headerlink" title="第二步：编写基类 (base/base_page.py)"></a>第二步：编写基类 (<code>base/base_page.py</code>)</h4><p>这一层的目的是：<strong>让页面层不需要直接接触 <code>driver</code> 的原生 API，而是用我们封装好的更稳定的方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, driver</span>):<br>        <span class="hljs-variable language_">self</span>.driver = driver<br><br>    <span class="hljs-comment"># 封装 find_element，加入显式等待，从此告别 NoSuchElementException</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-comment"># locator 比如是 (By.ID, &quot;user-name&quot;)</span><br>        <span class="hljs-keyword">return</span> WebDriverWait(<span class="hljs-variable language_">self</span>.driver, <span class="hljs-number">10</span>).until(<br>            EC.visibility_of_element_located(locator)<br>        )<br><br>    <span class="hljs-comment"># 封装输入</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_keys</span>(<span class="hljs-params">self, locator, text</span>):<br>        ele = <span class="hljs-variable language_">self</span>.find(locator)<br>        ele.clear() <span class="hljs-comment"># 输入前先清空，好习惯</span><br>        ele.send_keys(text)<br><br>    <span class="hljs-comment"># 封装点击</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-variable language_">self</span>.find(locator).click()<br>        <br>    <span class="hljs-comment"># 封装获取文本（用于断言）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_text</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.find(locator).text<br></code></pre></td></tr></table></figure><h4 id="第三步：编写页面层-pages-login-page-py"><a href="#第三步：编写页面层-pages-login-page-py" class="headerlink" title="第三步：编写页面层 (pages/login_page.py)"></a>第三步：编写页面层 (<code>pages/login_page.py</code>)</h4><p>这一层<strong>严禁出现断言（assert）</strong>，只负责描述页面长什么样、能干什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> base.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 核心：元素定位 (Locators) ---</span><br>    <span class="hljs-comment"># 把页面上用到的元素 ID 都写在这里，以后改 ID 只要改这里</span><br>    _USERNAME_INPUT = (By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>    _PASSWORD_INPUT = (By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>    _LOGIN_BTN = (By.ID, <span class="hljs-string">&quot;login-button&quot;</span>)<br>    _ERROR_MSG = (By.CSS_SELECTOR, <span class="hljs-string">&quot;h3[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：页面操作 (Actions) ---</span><br>    <br>    <span class="hljs-comment"># 定义一个登录动作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, user, pwd</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在登录账号: <span class="hljs-subst">&#123;user&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 调用父类 BasePage 的方法，而不是直接用 driver</span><br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._USERNAME_INPUT, user)<br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._PASSWORD_INPUT, pwd)<br>        <span class="hljs-variable language_">self</span>.click(<span class="hljs-variable language_">self</span>._LOGIN_BTN)<br><br>    <span class="hljs-comment"># 获取错误提示文字</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_msg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.get_text(<span class="hljs-variable language_">self</span>._ERROR_MSG)<br></code></pre></td></tr></table></figure><h4 id="第四步：编写测试层-test-cases-test-login-py"><a href="#第四步：编写测试层-test-cases-test-login-py" class="headerlink" title="第四步：编写测试层 (test_cases/test_login.py)"></a>第四步：编写测试层 (<code>test_cases/test_login.py</code>)</h4><p>这一层只能调用 Page 对象的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 模拟一个测试用例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_logic</span>():<br>    <span class="hljs-comment"># 1. 启动浏览器 (这一步以后会交给 Pytest fixture 做)</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 初始化页面对象</span><br>    <span class="hljs-comment"># 把 driver 传给 LoginPage，这样 LoginPage 才能操作浏览器</span><br>    login_page = LoginPage(driver)<br><br>    <span class="hljs-comment"># --- 用例 1: 登录成功 ---</span><br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 断言：判断 URL 是否跳转</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例1通过：登录成功&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 用例1失败&quot;</span>)<br><br>    <span class="hljs-comment"># --- 准备测下一个用例，先退出或重启浏览器 ---</span><br>    <span class="hljs-comment"># 这里为了演示简单，我们直接重启</span><br>    driver.quit()<br>    <br>    <span class="hljs-comment"># --- 用例 2: 登录失败 ---</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>    login_page = LoginPage(driver)<br>    <br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_password&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取页面上的错误提示</span><br>    error_text = login_page.get_error_msg()<br>    <br>    <span class="hljs-comment"># 断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例2通过：错误提示正确&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 用例2失败，实际提示: <span class="hljs-subst">&#123;error_text&#125;</span>&quot;</span>)<br>        <br>    driver.quit()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    test_login_logic()<br></code></pre></td></tr></table></figure><hr><h3 id="5-PO-模式的“六大原则”-面试加分项"><a href="#5-PO-模式的“六大原则”-面试加分项" class="headerlink" title="5. PO 模式的“六大原则” (面试加分项)"></a>5. PO 模式的“六大原则” (面试加分项)</h3><p>你在设计 PO 模式时遵循什么原则？</p><ol><li><strong>公共方法封装在 BasePage</strong>：不要在每个 Page 里重复写显式等待。</li><li><strong>页面元素与测试数据分离</strong>：Page 类里不要写死 “standard_user”，数据要从 Test 层传进来。</li><li><strong>Page 层不写断言</strong>：Page 层只负责“做动作”和“返回结果”，断言（判断对错）是 Test 层的事。</li><li><strong>方法名要有业务含义</strong>：用 <code>login()</code> 而不是 <code>type_username_and_click()</code>。</li><li><strong>不要暴露内部元素</strong>：Test 层不应该能访问到 <code>By.ID</code>，只能调用方法。</li><li><strong>返回新页面对象 (进阶)</strong>：点击登录后，<code>login()</code> 方法最好返回一个 <code>InventoryPage</code> 对象（链式调用）。</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web自动化测试</tag>
      
      <tag>python</tag>
      
      <tag>java</tag>
      
      <tag>selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/2025/12/10/Python%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/12/10/Python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: 演示定义汽车类 及  使用类中的成员.</span><br><span class="hljs-string"></span><br><span class="hljs-string">面向对象核心概念:</span><br><span class="hljs-string">    类: 抽象的概念, 看不见, 摸不着, 是 属性(名词) 和 行为(动词)的集合.</span><br><span class="hljs-string">    对象: 类的具体体现, 实现.</span><br><span class="hljs-string">    属性(名词): 用来描述事物的外在特征的, 例如: 姓名, 年龄...</span><br><span class="hljs-string">        格式: 和以前定义变量一样.</span><br><span class="hljs-string">    行为(动词): 用来描述事物能够做什么的, 例如: 吃, 喝...</span><br><span class="hljs-string">        格式: 和以前定义函数一样.</span><br><span class="hljs-string"></span><br><span class="hljs-string">定义类的格式:</span><br><span class="hljs-string">    class 类名:</span><br><span class="hljs-string">        # 属性</span><br><span class="hljs-string">        # 行为</span><br><span class="hljs-string"></span><br><span class="hljs-string">如何访问类中的成员?</span><br><span class="hljs-string">    step1: 创建该类的对象.</span><br><span class="hljs-string">        对象名 = 类名()</span><br><span class="hljs-string">    step2: 通过 对象名. 的方式调用.</span><br><span class="hljs-string">        对象性.属性名</span><br><span class="hljs-string">        对象名.行为名()</span><br><span class="hljs-string"></span><br><span class="hljs-string">需求: 定义汽车类, 有跑的行为.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 1.定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:      <span class="hljs-comment"># 类名遵循 大驼峰命名法.</span><br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><br><span class="hljs-comment"># 3. 调用Car类的run()函数, 简写版: 调用Car#run()</span><br>c1.run()<br></code></pre></td></tr></table></figure><hr><h2 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: self关键字介绍.</span><br><span class="hljs-string"></span><br><span class="hljs-string">self介绍:</span><br><span class="hljs-string">    概述:</span><br><span class="hljs-string">        它是Python内置的关键字, 用于表示 本类当前对象的引用.</span><br><span class="hljs-string">    作用:</span><br><span class="hljs-string">        1个类是可以有多个对象的, 这多个对象都可以通过 对象名. 的方式访问类中的行为(函数)</span><br><span class="hljs-string">        函数默认有self属性, 函数通过self来区分到底是哪个对象调用的该函数.</span><br><span class="hljs-string">    大白话:</span><br><span class="hljs-string">        谁调用函数, self就代表哪个对象.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 需求: 定义汽车类, 创建多个该类的对象, 看看打印结果.</span><br><span class="hljs-comment"># 1. 定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为, 跑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是run函数, self的值是: <span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1对象: <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c1.run()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">34</span>)<br><br><span class="hljs-comment"># 3.继续创建汽车类的对象.</span><br>c2 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2对象: <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c2.run()<br></code></pre></td></tr></table></figure><hr><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/self.png" class="" title="self"><p>这张图非常生动地展示了 <strong>Python 面向对象编程（OOP）中的内存管理机制</strong>，特别是<strong>对象（Object）与引用（Reference）的关系，以及实例属性</strong>是如何存储的。</p><p>这张图主要分为三个部分：<strong>代码区（左侧）</strong>、<strong>内存结构示意图（右侧，包含栈、堆、方法区）</strong>。</p><p>我将为你详细拆解这张图背后的逻辑：</p><h3 id="1-核心概念：内存的三大区域"><a href="#1-核心概念：内存的三大区域" class="headerlink" title="1. 核心概念：内存的三大区域"></a>1. 核心概念：内存的三大区域</h3><ul><li><strong>栈 (Stack)</strong>：<ul><li>图中的左侧竖条。</li><li><strong>作用</strong>：存储局部变量（即变量名）。在这里存储的是 <code>c1</code> 和 <code>c2</code>。</li><li><strong>本质</strong>：它们只是**引用（Reference）**或者说是“标签”，它们本身不存数据，而是指向堆内存中的具体地址（如 <code>0x01</code> 和 <code>0x02</code>）。</li></ul></li><li><strong>堆 (Heap)</strong>：<ul><li>图中的右侧蓝色大框。</li><li><strong>作用</strong>：存储真正的<strong>对象实例</strong>。</li><li><strong>内容</strong>：这里有两个 <code>Car()</code> 对象。每个对象都有自己独立的内存空间（地址 <code>0x01</code> 和 <code>0x02</code>）。对象内部存储该对象的具体数据（属性）。</li></ul></li><li><strong>方法区 (Method Area)</strong>：<ul><li>图中的右下角红色框。</li><li><strong>作用</strong>：存储类的定义和方法的代码。</li><li><strong>关键点</strong>：<code>run(self)</code> 这个方法只有一份代码（地址 <code>0x03</code>）。无论你创建多少个 <code>Car</code> 对象，它们调用的 <code>run</code> 方法都是同一个，不需要为每个对象复制一份代码。</li></ul></li></ul><h3 id="2-代码执行流程与内存变化"><a href="#2-代码执行流程与内存变化" class="headerlink" title="2. 代码执行流程与内存变化"></a>2. 代码执行流程与内存变化</h3><p>让我们跟随左侧的代码，看看内存里发生了什么：</p><h4 id="第一步：创建-c1-对象"><a href="#第一步：创建-c1-对象" class="headerlink" title="第一步：创建 c1 对象"></a>第一步：创建 c1 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c1</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块空间（假设地址 <code>0x01</code>）生成一个 <code>Car</code> 对象。</li><li>在<strong>栈</strong>中创建一个变量 <code>c1</code>。</li><li>将 <code>c1</code> 指向 <code>0x01</code>（图中绿色的箭头）。</li></ol></li><li>此时，<code>c1</code> 对象内部包含一个指向方法区的指针 <code>0x03</code>，以便能调用 <code>run()</code> 方法。</li></ul><h4 id="第二步：给-c1-添加属性（动态属性）"><a href="#第二步：给-c1-添加属性（动态属性）" class="headerlink" title="第二步：给 c1 添加属性（动态属性）"></a>第二步：给 c1 添加属性（动态属性）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">c1.color</span> = <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-attr">c1.number</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ul><li>Python 是动态语言，允许在对象创建后随意添加属性。</li><li>图中的 <code>c1</code> 对象（<code>0x01</code> 盒子）里，现在多了两行数据：<code>color=&#39;红色&#39;</code> 和 <code>number=4</code>。</li><li><strong>注意</strong>：这些数据是<strong>独属于</strong> <code>c1</code> 这个对象的。</li></ul></li></ul><h4 id="第三步：创建-c2-对象"><a href="#第三步：创建-c2-对象" class="headerlink" title="第三步：创建 c2 对象"></a>第三步：创建 c2 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c2</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块<strong>新的</strong>空间（地址 <code>0x02</code>）。</li><li>在<strong>栈</strong>中创建变量 <code>c2</code>。</li><li>将 <code>c2</code> 指向 <code>0x02</code>（图中深红色的箭头）。</li></ol></li><li><strong>关键区别</strong>：<code>c2</code> 是一个全新的对象。虽然它也是 <code>Car</code>，但因为它刚出生，还没有人给它赋值 <code>color</code> 和 <code>number</code>，所以图中的 <code>c2</code> 盒子（<code>0x02</code>）里是<strong>空的</strong>（只有指向方法的 <code>0x03</code>）。</li></ul><h4 id="第四步：代码中的注释细节-细节-3"><a href="#第四步：代码中的注释细节-细节-3" class="headerlink" title="第四步：代码中的注释细节 (细节 3)"></a>第四步：代码中的注释细节 (细节 3)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;颜色: &#123;c2.color&#125;...&#x27;</span>)</span><br></code></pre></td></tr></table></figure><ul><li>这行代码被注释掉了，因为如果运行它会<strong>报错</strong>（AttributeError）。</li><li><strong>原因</strong>：看堆内存图就很清楚，<code>c2</code> 指向的 <code>0x02</code> 盒子里并没有 <code>color</code> 和 <code>number</code> 数据。属性不会自动从 <code>c1</code> 传染给 <code>c2</code>。</li></ul><h3 id="3-图解总结-Key-Takeaways"><a href="#3-图解总结-Key-Takeaways" class="headerlink" title="3. 图解总结 (Key Takeaways)"></a>3. 图解总结 (Key Takeaways)</h3><ol><li><strong>同类不同命</strong>：<code>c1</code> 和 <code>c2</code> 虽然都是 <code>Car</code> 类造出来的，但它们是两个独立的个体。修改 <code>c1</code> 的属性不会影响 <code>c2</code>。</li><li><strong>方法共享，数据独享</strong>：<ul><li><strong>数据（属性）</strong>：存在<strong>堆</strong>里各自的对象中（<code>c1</code> 有颜色，<code>c2</code> 没有）。</li><li><strong>行为（方法）</strong>：存在<strong>方法区</strong>里，大家共用同一个（地址 <code>0x03</code>）。</li></ul></li><li><strong>引用传递</strong>：变量名（<code>c1</code>）只是一个遥控器，它通过内存地址控制真正的对象。</li></ol><hr><p>**问：**如果每个对象调用的方法都指向同一个地址，那假如这个方法中有修改对象属性的逻辑，那岂不是一个对象调用之后，别的对象的属性也被修改了？</p><p>答案是：<strong>完全不会。</strong></p><p>其中的关键就在于 Python 方法中的第一个参数 —— <strong><code>self</code></strong>。</p><p>虽然代码（指令）只有一份，存在方法区里（比如地址 <code>0x03</code>），但<strong>执行这份代码时操作的数据对象</strong>是不同的。</p><h3 id="核心机制：self-就是那个“定位器”"><a href="#核心机制：self-就是那个“定位器”" class="headerlink" title="核心机制：self 就是那个“定位器”"></a>核心机制：<code>self</code> 就是那个“定位器”</h3><p>你可以把方法区里的代码看作是一本**“公用操作手册”**。</p><p>假如 <code>run</code> 方法里有一句代码是修改颜色的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 修改属性</span><br></code></pre></td></tr></table></figure><p>当你调用方法时，Python 在后台做了一个**“隐式传递”**的操作：</p><h4 id="1-当-c1-调用时"><a href="#1-当-c1-调用时" class="headerlink" title="1. 当 c1 调用时"></a>1. 当 <code>c1</code> 调用时</h4><p>你写的是：c1.run()</p><p>Python 实际执行的是：Car.run(c1)  &lt;– 看这里！</p><ul><li>它把 <code>c1</code> 的地址（<code>0x01</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c1.color = &#39;黑色&#39;</code>。</li><li>于是，只有 <strong>堆内存中 0x01 号盒子</strong> 里的 <code>color</code> 变成了黑色。</li></ul><h4 id="2-当-c2-调用时"><a href="#2-当-c2-调用时" class="headerlink" title="2. 当 c2 调用时"></a>2. 当 <code>c2</code> 调用时</h4><p>你写的是：c2.run()</p><p>Python 实际执行的是：Car.run(c2)</p><ul><li>这次它把 <code>c2</code> 的地址（<code>0x02</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c2.color = &#39;黑色&#39;</code>。</li><li>于是，是 <strong>堆内存中 0x02 号盒子</strong> 里的数据被修改了。</li></ul><hr><h2 id="魔术方法init"><a href="#魔术方法init" class="headerlink" title="魔术方法init"></a>魔术方法init</h2><p><strong>init</strong>()魔法方法, 在创建对象的时候, 会被自动调用, 一般用于给该类对象 的属性进行初始化.</p><p>无参版 init -&gt;  默认上的有底色, 你需要重新涂色(覆盖底色)<br>有参版 init -&gt;  默认没有涂色的石膏娃娃, 我们根据喜好自由涂色即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时不需要参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br>        <span class="hljs-variable language_">self</span>.number = <span class="hljs-number">3</span>      <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br><br><span class="hljs-comment"># 情况 A：c2 (保留默认)</span><br>c2 = Car()<br><span class="hljs-comment"># 此时内存里是：黑色, 3</span><br><br><span class="hljs-comment"># 情况 B：c1 (后期改装)</span><br>c1 = Car()          <br><span class="hljs-comment"># 1. 此时内存里也是：黑色, 3</span><br>c1.color = <span class="hljs-string">&#x27;红色&#x27;</span>   <br><span class="hljs-comment"># 2. 【覆盖动作】：找到内存里的&#x27;黑色&#x27;，把它擦掉，换成&#x27;红色&#x27;</span><br>c1.number = <span class="hljs-number">6</span>       <br><span class="hljs-comment"># 3. 【覆盖动作】：找到内存里的3，把它擦掉，换成6</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c2: <span class="hljs-subst">&#123;c2.color&#125;</span>, <span class="hljs-subst">&#123;c2.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：黑色, 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：红色, 6</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时，强制要求传入颜色和数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color    <span class="hljs-comment"># 直接赋值为传入的参数</span><br>        <span class="hljs-variable language_">self</span>.number = number<br><br><span class="hljs-comment"># 【内存动作】：</span><br><span class="hljs-comment"># 在堆内存创建对象时，直接写入 &#x27;红色&#x27; 和 6。</span><br><span class="hljs-comment"># 不需要先写入默认值再擦除。</span><br>c1 = Car(<span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-number">6</span>) <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：c1: 红色, 6</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法str"><a href="#魔术方法str" class="headerlink" title="魔术方法str"></a>魔术方法str</h2><p>当用print()函数 打印对象的时候, 会自动调用该对象(所在类)的 str魔法方法.该魔法方法默认打印的是对象的地址值, 无意义, 一般都会重写, 改为打印对象的各个属性值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-comment"># 输出结果类似：&lt;__main__.Car object at 0x000001&gt;  (看不懂，只知道是个Car对象)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br>        <span class="hljs-variable language_">self</span>.number = number<br><br>    <span class="hljs-comment"># 定义对象的字符串表现形式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 必须返回一个字符串！</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;【车辆信息】颜色：<span class="hljs-subst">&#123;self.color&#125;</span>，轮胎数：<span class="hljs-subst">&#123;self.number&#125;</span>&quot;</span><br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 此时 print 内部会自动调用 c1.__str__()</span><br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-comment"># 输出结果：【车辆信息】颜色：红色，轮胎数：4</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法del"><a href="#魔术方法del" class="headerlink" title="魔术方法del"></a>魔术方法del</h2><p>当.py文件执行结束, 或者 手动 del 释放对象资源, 会自动调用该函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【出生】<span class="hljs-subst">&#123;self.name&#125;</span> 被制造出来了！&quot;</span>)<br><br>    <span class="hljs-comment"># 定义对象销毁时要执行的逻辑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【消亡】<span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了，送去回收站。&quot;</span>)<br><br><span class="hljs-comment"># 1. 创建对象</span><br>c1 = Car(<span class="hljs-string">&quot;宝马&quot;</span>)<br><br><span class="hljs-comment"># 2. 模拟一些操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 正在开车中 ---&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 手动删除对象（或者当程序运行结束时，也会自动触发）</span><br><span class="hljs-keyword">del</span> c1 <br><span class="hljs-comment"># 此时，c1 的引用计数变为0，Python 自动调用 __del__ 【消亡】宝马 被销毁了，送去回收站。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="模数方法lt-le-eq"><a href="#模数方法lt-le-eq" class="headerlink" title="模数方法lt&#x2F;le&#x2F;eq"></a>模数方法lt&#x2F;le&#x2F;eq</h2><p>这三个魔术方法让你的对象可以使用 <strong>比较运算符</strong>（<code>&lt;</code>, <code>&lt;=</code>, <code>==</code>）进行 PK。如果不写这些方法，Python 不知道怎么比较两个自定义对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-comment"># __lt__ 对应 &lt; (Less Than)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt; other.score<br><br>    <span class="hljs-comment"># __le__ 对应 &lt;= (Less Than or Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt;= other.score<br><br>    <span class="hljs-comment"># __eq__ 对应 == (Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score == other.score<br><br><span class="hljs-comment"># 创建学生对象</span><br>s1 = Student(<span class="hljs-number">80</span>)<br>s2 = Student(<span class="hljs-number">90</span>)<br>s3 = Student(<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># Python 会自动调用对应的方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt; s2 : <span class="hljs-subst">&#123;s1 &lt; s2&#125;</span>&quot;</span>)   <span class="hljs-comment"># 调用 s1.__lt__(s2)，80 &lt; 90，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt;= s3: <span class="hljs-subst">&#123;s1 &lt;= s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__le__(s3)，80 &lt;= 80，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 == s3: <span class="hljs-subst">&#123;s1 == s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__eq__(s3)，80 == 80，结果 True</span><br><br><span class="hljs-comment"># 甚至可以直接用在列表中排序（主要依赖 __lt__）</span><br>students = [s2, s1]<br>students.sort() <span class="hljs-comment"># 此时 Python 知道按分数排</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一名分数: <span class="hljs-subst">&#123;students[-<span class="hljs-number">1</span>].score&#125;</span>&quot;</span>) <span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure><hr><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>是一种编程思想, 强调的是以 <strong>对象</strong> 为基础完成各种操作，其三大特性：</p><ul><li>封装：大白话：把属性和方法封装在一起，仅提供对外的方法让别人去访问。好处： 简化编程</li><li>继承：大白话：孩子可使用老爹的东西。好处：代码复用</li><li>多态：大白话：同样一个函数（消息）在不同场景下表现出不同形态。 好处：解耦合，可拓展</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装 (Encapsulation)</strong> 的核心思想是：<strong>把重要的数据锁在保险箱里，只留一个小窗口（方法）对外办事。</strong></p><p>这样做可以防止外部随意修改内部数据，保证数据的安全性。在 Python 中，在属性名前加 <strong>两个下划线 <code>__</code></strong>，就可以把它变成**私有（Private）**的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, money</span>):<br>        <span class="hljs-variable language_">self</span>.name = name          <span class="hljs-comment"># 公有属性：大家都能看</span><br>        <span class="hljs-variable language_">self</span>.__balance = money    <span class="hljs-comment"># 私有属性：加了__，只有自己能看/改</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来查看余额 (Getter)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_balance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;用户 <span class="hljs-subst">&#123;self.name&#125;</span> 当前余额：<span class="hljs-subst">&#123;self.__balance&#125;</span> 元&quot;</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来修改余额 (Setter)，可以在这里加安全判断</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_money</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.__balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功存入 <span class="hljs-subst">&#123;amount&#125;</span> 元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存钱金额必须大于0！&quot;</span>)<br><br>acc = Account(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 1. 正常操作：通过方法访问</span><br>acc.save_money(<span class="hljs-number">500</span>)<br><span class="hljs-built_in">print</span>(acc.check_balance())<br><br><span class="hljs-comment"># 2. 违规操作：尝试直接访问私有属性</span><br><span class="hljs-comment"># print(acc.__balance)  </span><br><span class="hljs-comment"># 报错：AttributeError（Python 会假装在这个对象里找不到 __balance）</span><br><br><span class="hljs-comment"># 3. 绕过封装（虽然不推荐，但原理要知道）</span><br><span class="hljs-comment"># Python 实际上是把名字改成了 _类名__属性名</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;强行偷看：<span class="hljs-subst">&#123;acc._Account__balance&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类可以继承父类的属性和行为</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大口干饭...&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义子类，括号里写父类的名字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-comment"># 3. 使用</span><br>wangcai = Dog()<br>wangcai.bark()  <span class="hljs-comment"># 调用自己的方法</span><br>wangcai.eat()   <span class="hljs-comment"># 【关键】调用父类的方法（虽然Dog里没写eat，但它继承下来了）</span><br></code></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会飞高高&quot;</span>)<br><br><span class="hljs-comment"># 父类 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会跑得快&quot;</span>)<br><br><span class="hljs-comment"># 子类：括号里写多个父类，用逗号隔开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Flyer, Mammal):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bite</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我还咬人！&quot;</span>)<br><br><span class="hljs-comment"># 使用</span><br>bianfu = Bat()<br>bianfu.fly()   <span class="hljs-comment"># 继承自 Flyer</span><br>bianfu.run()   <span class="hljs-comment"># 继承自 Mammal</span><br>bianfu.bite()  <span class="hljs-comment"># 自己的</span><br></code></pre></td></tr></table></figure><h3 id="子类重写父类的功能"><a href="#子类重写父类的功能" class="headerlink" title="子类重写父类的功能"></a>子类重写父类的功能</h3><p>有两种常见的重写方式：</p><ol><li><strong>完全覆盖</strong>：彻底抛弃父类的做法，另起炉灶。</li><li><strong>功能扩展</strong>：保留父类的核心逻辑（用 <code>super()</code>），然后增加新功能。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 父类：普通的狗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！(普通叫声)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;也就是个慢跑...&quot;</span>)<br><br><span class="hljs-comment"># 2. 子类A：哈士奇 (完全覆盖)</span><br><span class="hljs-comment"># 哈士奇不想“汪汪汪”，它想“嗷呜”，所以它彻底改写了 bark 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;嗷呜~~~~ (狼嚎)&quot;</span>)<br><br><span class="hljs-comment"># 3. 子类B：警犬 (功能扩展)</span><br><span class="hljs-comment"># 警犬也得先像普通狗一样叫，但叫完之后还得抓坏人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoliceDog</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 【关键步骤】super() 代表父类</span><br>        <span class="hljs-comment"># 先执行父类的 bark (输出“汪汪汪”)</span><br>        <span class="hljs-built_in">super</span>().bark() <br>        <span class="hljs-comment"># 然后再执行自己的特殊逻辑</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 发现坏人，猛扑上去！&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br>h = Husky()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 哈士奇 ---&quot;</span>)<br>h.bark() <br><span class="hljs-comment"># 输出：嗷呜~~~~ (父类的逻辑完全不见了)</span><br><br>p = PoliceDog()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 警犬 ---&quot;</span>)<br>p.bark()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 汪汪汪！(普通叫声)  &lt;-- 来自 super().bark()</span><br><span class="hljs-comment"># &gt;&gt;&gt; 发现坏人，猛扑上去！</span><br></code></pre></td></tr></table></figure><hr><h3 id="子类访问父类功能"><a href="#子类访问父类功能" class="headerlink" title="子类访问父类功能"></a>子类访问父类功能</h3><p>子类重写父类功能后, 继续访问父类功能 </p><ol><li>父类名.父类函数名(self)      精准访问, 想找哪个父类, 就调哪个父类.</li><li>super().父类函数名()        只能访问最近的那个父类, 有就用, 没有就往后继续查找.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👴 父亲的技能：编程 (Python)&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👩 母亲的技能：画画 (Painting)&quot;</span>)<br><br><span class="hljs-comment"># 注意继承顺序：Father 在前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Father, Mother):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是孩子，开始展示技能...&quot;</span>)<br><br>        <span class="hljs-comment"># --- 方式 1: super() (自动挡) ---</span><br>        <span class="hljs-comment"># 规则：只找 MRO 列表里的“下一个”。</span><br>        <span class="hljs-comment"># 因为 class Child(Father, Mother)，Father 排前面，</span><br>        <span class="hljs-comment"># 所以 super() 只能调到 Father，直接忽略了 Mother。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 1: super().skill()】&quot;</span>)<br>        <span class="hljs-built_in">super</span>().skill()<br><br>        <span class="hljs-comment"># --- 方式 2: 类名.方法(self) (手动挡) ---</span><br>        <span class="hljs-comment"># 规则：指哪打哪。</span><br>        <span class="hljs-comment"># 即使 Mother 排在后面，super() 够不着，</span><br>        <span class="hljs-comment"># 我依然可以通过“类名”强行调用她。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 2: Mother.skill(self)】&quot;</span>)<br>        Mother.skill(<span class="hljs-variable language_">self</span>)<br><br><span class="hljs-comment"># 运行测试</span><br>c = Child()<br>c.skill()<br><span class="hljs-comment"># 我是孩子，开始展示技能...</span><br><br><span class="hljs-comment"># 【方式 1: super().skill()】</span><br><span class="hljs-comment"># 👴 父亲的技能：编程 (Python)</span><br><br><span class="hljs-comment"># 【方式 2: Mother.skill(self)】</span><br><span class="hljs-comment"># 👩 母亲的技能：画画 (Painting)</span><br></code></pre></td></tr></table></figure><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个函数, 接收不同的参数, 有不同的效果。即同一个指令，不同的对象去做，会有不同的行为。</p><p>多态的一般前提条件:1.要有继承.2.有方法重写, 不然多态无意义.3.要有父类引用指向子类对象.但在 Python 中，多态更加灵活，归因于Python 动态语言灵活性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 必须有继承 (条件1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Charger</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-comment"># 2. 必须重写 (条件2)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 Type-C 充电...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lightning_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 苹果头 充电...&quot;</span>)<br><br><span class="hljs-comment"># 函数定义必须暗示接收父类类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">charger_obj: Charger</span>): <span class="hljs-comment"># 类型提示只是提示，不强制</span><br>    charger_obj.charge()<br><br><span class="hljs-comment"># 3. 父类引用指向子类 (在Python里变量没有类型，所以这一步是隐式的)</span><br>c1 = TypeC_Charger()<br>power_up(c1)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>:<br>    <span class="hljs-comment"># 没有继承任何父类！</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Type-C 充电中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span>:<br>    <span class="hljs-comment"># 这是一个汉堡，跟充电器没半毛钱关系</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是一个汉堡，但我居然也有 charge 方法！充能中（热量+100）&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-comment"># Python 不管你是什么类，只管你有没有 charge 方法</span><br>    obj.charge() <br><br>t = TypeC_Charger()<br>b = Burger()<br><br>power_up(t) <span class="hljs-comment"># 正常工作</span><br>power_up(b) <span class="hljs-comment"># 居然也正常工作！这就是鸭子类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类解释:<br>        抽象类一般充当父类, 用于指定行业规范, 准则, 具体的实现交由 子类 来完成.</p><h3 id="父类制定标准，子类去实现-思想"><a href="#父类制定标准，子类去实现-思想" class="headerlink" title="父类制定标准，子类去实现(思想)"></a>父类制定标准，子类去实现(思想)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义抽象类, 空调类, 设定: 空调的规则.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC</span>:<br>    <span class="hljs-comment"># 1.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 2. 定义子类(小米空调), 实现父类(空调类)中的所有抽象方法.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-comment"># 2.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制冷技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制热技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米空调 静音左右摆风 技术!&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 4.1 小米空调</span><br>    xm = XiaoMi()<br>    xm.cool_wind()<br>    xm.hot_wind()<br>    xm.swing_l_r()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><h3 id="引入-abc-模块（Abstract-Base-Class）-严谨"><a href="#引入-abc-模块（Abstract-Base-Class）-严谨" class="headerlink" title="引入 abc 模块（Abstract Base Class）(严谨)"></a>引入 <code>abc</code> 模块（Abstract Base Class）(严谨)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 1. 定义抽象类：必须继承 ABC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义抽象方法：加上装饰器 @abstractmethod</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 这里不写具体逻辑，因为不知道怎么付，只占个位</span><br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># ❌ 错误演示：尝试直接创建抽象类对象</span><br><span class="hljs-comment"># p = Payment() </span><br><span class="hljs-comment"># 报错：TypeError: Can&#x27;t instantiate abstract class Payment...</span><br><span class="hljs-comment"># (意思：Payment 是抽象的，是个半成品，不能直接用)</span><br><br><br><span class="hljs-comment"># ✅ 正确演示：子类继承并实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-comment"># 【必须重写】如果不写这个方法，AliPay 也会报错</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;支付宝支付中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;微信支付中...&quot;</span>)<br><br><span class="hljs-comment"># 3. 正常使用</span><br>ali = AliPay()<br>ali.pay()<br></code></pre></td></tr></table></figure><p>在python中，<strong>抽象类（ABC）和接口（Interface）在语法上是同一个东西</strong>。如果你把一个抽象类里的方法全写成空（只有定义没实现），它就是接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 用法 A：当作【接口】用 (全都是抽象方法，没有具体实现)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USBInterface</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 用法 B：当作【抽象类】用 (有一部分共用的代码)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭眼睡觉...&quot;</span>)  <span class="hljs-comment"># 这是一个具体功能</span><br>    <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><hr><h2 id="类属性和对象属性"><a href="#类属性和对象属性" class="headerlink" title="类属性和对象属性"></a>类属性和对象属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># --- 这里是【类属性】 ---</span><br>    <span class="hljs-comment"># 定义在方法外面，这是大家共享的</span><br>    school = <span class="hljs-string">&quot;霍格沃茨魔法学校&quot;</span><br>    count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用来记录一共招生了多少人</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># --- 这里是【实例属性】 ---</span><br>        <span class="hljs-comment"># 定义在 __init__ 里，绑定在 self 上，是个人的</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <br>        <span class="hljs-comment"># 每创建一个学生，班级总人数就 +1</span><br>        <span class="hljs-comment"># 注意：要修改类属性，最好用 类名.属性</span><br>        Student.count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 1. 创建两个学生</span><br>s1 = Student(<span class="hljs-string">&quot;哈利波特&quot;</span>, <span class="hljs-number">11</span>)<br>s2 = Student(<span class="hljs-string">&quot;罗恩&quot;</span>, <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 2. 访问实例属性 (每个人不一样) 只能通过对象访问</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的名字: <span class="hljs-subst">&#123;s1.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 哈利波特</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的名字: <span class="hljs-subst">&#123;s2.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 罗恩</span><br><br><span class="hljs-comment"># 3. 访问类属性 (大家都一样)</span><br><span class="hljs-comment"># 可以通过对象访问，也可以通过类名访问(推荐)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的学校: <span class="hljs-subst">&#123;s1.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的学校: <span class="hljs-subst">&#123;s2.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目前招生人数: <span class="hljs-subst">&#123;Student.count&#125;</span>&quot;</span>) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><hr><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>    属于类的方法, 可以通过类名. 还可以通过对象名. 的方式来调用.<br>    定义类方法的时候, 必须使用装饰器 @classmethod, 且第1个参数必须表示类对象.</p><p>静态方法:<br>    属于该类下所有对象所共享的方法, 可以通过类名. 还可以通过 对象名.的方式来调用.<br>    定义静态方法的时候, 必须使用装饰器 @staticmethod, 且参数传不传都可以.</p><p>区别:<br>       1. 类方法的第1个参数必须是类对象, 静态方法无参数的特殊要求<br>       2. 你可以理解为: 如果函数中要用类对象, 就定义成类方法, 否则定义成静态方法, 除此外并无任何区别.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义学生类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># 2. 定义类属性.</span><br>    school = <span class="hljs-string">&#x27;黑马程序员&#x27;</span><br><br>    <span class="hljs-comment"># 3. 定义类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show1</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cls: <span class="hljs-subst">&#123;cls&#125;</span>&#x27;</span>)        <span class="hljs-comment"># &lt;class &#x27;__main__.Student&#x27;&gt;</span><br>        <span class="hljs-built_in">print</span>(cls.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是类方法&#x27;</span>)<br><br>    <span class="hljs-comment"># 4. 定义静态方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show2</span>():<br>        <span class="hljs-built_in">print</span>(Student.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是静态方法&#x27;</span>)<br><br><span class="hljs-comment"># 5. 测试.</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s1 = Student()<br>    s1.show1()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br>    s1.show2()<br></code></pre></td></tr></table></figure><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包入门"><a href="#闭包入门" class="headerlink" title="闭包入门"></a>闭包入门</h2><p>通常情况下，函数内部的变量是“临时工”，函数执行完，变量就被销毁（内存释放）了。</p><p>但是<strong>闭包</strong>不同，它可以让一个函数<strong>把外部的变量“打包带走”</strong>。即使外部函数已经执行完了，内部函数依然能访问并使用那个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 外部函数 (工厂)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">config_greeting</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-comment"># msg 是外部函数的变量 (零件)</span><br>    <br>    <span class="hljs-comment"># 2. 内部函数 (工人)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-comment"># 3. 内部使用了外部变量 msg</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;msg&#125;</span>, <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 返回内部函数 (工人背着零件走了)</span><br>    <span class="hljs-keyword">return</span> printer<br><br><span class="hljs-comment"># --- 关键看这里 ---</span><br><br><span class="hljs-comment"># 创建一个闭包实例：配置为 &quot;Hello&quot;</span><br>say_hello = config_greeting(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-comment"># 此时，config_greeting 函数其实已经运行结束了！</span><br><span class="hljs-comment"># 按理说变量 &quot;Hello&quot; 应该从内存消失，但它被 printer 抓住了。</span><br><br><span class="hljs-comment"># 创建另一个闭包实例：配置为 &quot;你好&quot;</span><br>say_nihao = config_greeting(<span class="hljs-string">&quot;你好&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br>say_hello(<span class="hljs-string">&quot;张三&quot;</span>)  <span class="hljs-comment"># 输出：Hello, 张三</span><br>say_nihao(<span class="hljs-string">&quot;李四&quot;</span>)  <span class="hljs-comment"># 输出：你好, 李四</span><br></code></pre></td></tr></table></figure><h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><p><code>nonlocal</code> 的作用是：<strong>允许内部函数修改外部函数（闭包）中的变量</strong>。</p><p>Python 有一个保护机制：如果你在函数内部给一个变量赋值（比如 <code>a = 10</code>），Python 默认会认为这只是一个<strong>全新的局部变量</strong>，跟外面的那个 <code>a</code> 没关系。</p><p>这就导致了一个问题：如果想<strong>修改</strong>外面的变量，而不是<strong>新建</strong>一个，程序会报错或者不符合预期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>        <span class="hljs-comment"># 【关键】声明：我要修改外面的那个 count！</span><br>        <span class="hljs-keyword">nonlocal</span> count <br>        <br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前计数: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>        <br>    <span class="hljs-keyword">return</span> adder<br><br>c = make_counter()<br>c()  <span class="hljs-comment"># 输出：当前计数: 1</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 2</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 3</span><br></code></pre></td></tr></table></figure><p>问：<code>nonlocal</code> vs <code>global</code> 的区别？</p><p><strong><code>global</code></strong>：</p><ul><li>用于修改<strong>全局变量</strong>（整个模块级别的）。</li><li>它是去<strong>最外层</strong>找变量。</li></ul><p><strong><code>nonlocal</code></strong>：</p><ul><li>用于修改<strong>嵌套函数中的变量</strong>（闭包里的）。</li><li>它是去<strong>上一层（或上上层）函数找变量，但绝不</strong>去全局找。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全局变量</span><br>score = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_score</span>():<br>    <span class="hljs-comment"># 【声明】：我要用的这个 score 是全局那个！不是新建的！</span><br>    <span class="hljs-keyword">global</span> score<br>    <br>    score += <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;游戏得分！&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 0</span><br><br>add_score()<br>add_score()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 200 (真的被改掉了)</span><br></code></pre></td></tr></table></figure><hr><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><p><strong>装饰器本质上就是一个闭包，它的作用是在不修改原函数代码的前提下，给原函数“增加新功能”</strong></p><p><strong>核心原则：开放封闭原则 (Open-Closed Principle)</strong></p><ul><li><strong>封闭</strong>：对修改源代码封闭（不要动原来的代码）</li><li><strong>开放</strong>：对扩展功能开放（想加日志、想加权限验证，随便加）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 接收一个函数作为参数 (外部函数)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_gift</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义内部函数 (包装纸)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 🎁 正在包装礼物...&quot;</span>)<br>        <span class="hljs-comment"># 3. 调用原函数 (放入礼物)</span><br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; ✅ 礼物已发出！&quot;</span>)<br>        <br>    <span class="hljs-comment"># 4. 返回内部函数</span><br>    <span class="hljs-keyword">return</span> wrapper<br>    <br>    <br><span class="hljs-comment"># 写法 A：原函数</span><br><span class="hljs-meta">@add_gift  </span><span class="hljs-comment"># &lt;--- 这就是装饰器语法，相当于给 buy_shoe 穿了层衣服</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_shoe</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一双球鞋&quot;</span>)<br><br><span class="hljs-meta">@add_gift</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_phone</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一台手机&quot;</span>)<br><br><span class="hljs-comment"># --- 运行测试 ---</span><br><br><span class="hljs-comment"># 当你调用 buy_shoe 时，其实你运行的是 wrapper！</span><br>buy_shoe()<br></code></pre></td></tr></table></figure><h2 id="带参数和返回值"><a href="#带参数和返回值" class="headerlink" title="带参数和返回值"></a>带参数和返回值</h2><p>例子虽然简单，但有两个致命的缺陷：</p><ol><li><strong>传参限制</strong>：如果原函数需要参数（比如 <code>buy_shoe(&quot;耐克&quot;)</code>），之前的 <code>wrapper()</code> 没定义参数，一调就报错。</li><li><strong>吞噬返回值</strong>：如果原函数有 <code>return</code>，之前的 <code>wrapper()</code> 没有把结果返回出来，导致外界拿到的是 <code>None</code>。</li></ol><p><strong>装饰器的内部函数格式要和被装饰的原函数 保持一致,即: 原函数是无参无返回的, 则装饰器的内部函数也必须是无参无返回的.原函数有参有返回的, 则装饰器的内部函数也必须是有参有返回的.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-comment"># 1. 【万能参数】：*args, **kwargs</span><br>    <span class="hljs-comment"># 不管原函数传什么参数（一个、两个、关键字参数），我全都能接住</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 正在进行权限核对...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 2. 【调用原函数】并【接收返回值】</span><br>        <span class="hljs-comment"># 把刚才接住的参数，原封不动地传给原函数</span><br>        result = func(*args, **kwargs)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 核对完毕，放行。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 3. 【返回结果】</span><br>        <span class="hljs-comment"># 这一步如果不写，外界拿到的就是 None</span><br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 A：有参数，无返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">food, drink</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在吃<span class="hljs-subst">&#123;food&#125;</span>，喝<span class="hljs-subst">&#123;drink&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 场景 B：有参数，有返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_sum</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在努力计算中...&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 测试 eat (两个参数)</span><br>eat(<span class="hljs-string">&quot;火锅&quot;</span>, <span class="hljs-string">&quot;可乐&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在吃火锅，喝可乐</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 2. 测试 calculate_sum (有返回值)</span><br>res = calculate_sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在努力计算中...</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><span class="hljs-comment"># 计算结果是: 30  &lt;-- 如果 wrapper 没写 return，这里就是 None</span><br></code></pre></td></tr></table></figure><p><strong>args和kwargs<code>就像是一个弹性收纳袋，无论扔进来多少个参数，wrapper 都能收下，然后再原封不动地传递给</code>func</strong></p><p>万能公式 &#x3D; 闭包 + <code>*args/**kwargs</code> + <code>return</code></p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>要在装饰器里传参数，需要在原本的装饰器外面，<strong>再包一层函数</strong>。</p><ul><li><strong>第一层 (最外面)</strong>：负责接收<strong>装饰器的参数</strong>（比如 “ERROR”）。管它叫“装饰器工厂”。</li><li><strong>第二层 (中间层)</strong>：负责接收<strong>被修饰的函数</strong>（<code>func</code>）。这才是真正的装饰器。</li><li><strong>第三层 (最里面)</strong>：负责接收<strong>函数的参数</strong>（<code>*args</code>）。这是具体的干活逻辑（Wrapper）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># --- 第一层：工厂层 (负责接收 level 参数) ---</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">level</span>):<br>    <br>    <span class="hljs-comment"># --- 第二层：装饰器层 (负责接收 func) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <br>        <span class="hljs-comment"># --- 第三层：Wrapper层 (负责接收 func 的参数) ---</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 正在启动功能...&quot;</span>) <span class="hljs-comment"># 这里用到了第一层的变量</span><br>            <br>            <span class="hljs-comment"># 调用原函数</span><br>            result = func(*args, **kwargs)<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 执行结束。&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <br>        <span class="hljs-keyword">return</span> wrapper <span class="hljs-comment"># 返回第三层</span><br>    <br>    <span class="hljs-keyword">return</span> decorator <span class="hljs-comment"># 返回第二层</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 1：普通操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;INFO&quot;</span></span>) </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_page</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打开网页...&quot;</span>)<br><br><span class="hljs-comment"># 场景 2：危险操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;DANGER&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删库跑路...&quot;</span>)<br><br><span class="hljs-comment"># --- 运行 ---</span><br>open_page()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [INFO] 正在启动功能...</span><br><span class="hljs-comment"># 打开网页...</span><br><br>delete_db()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [DANGER] 正在启动功能...</span><br><span class="hljs-comment"># 删库跑路...</span><br></code></pre></td></tr></table></figure><p><strong>FastAPI</strong> 和 <strong>Django</strong> 中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)  </span><span class="hljs-comment"># 传了参数 &quot;/users&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(): ...<br></code></pre></td></tr></table></figure><p>这里 <code>@app.get</code> 就是一个带参数的装饰器，它记录了 URL 路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@permission_required(<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span></span>) </span><span class="hljs-comment"># 传了参数 &quot;admin&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(): ...<br></code></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>用了装饰器后，原函数的名字（<code>__name__</code>）会变成 <code>wrapper</code>，这在调试时很不方便</p><p>先看没有 <code>wraps</code> 时会发生什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 见证“身份被窃” ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 函数的名字是: wrapper   &lt;-- 糟糕！原本叫 login，现在变成 wrapper 了</span><br><span class="hljs-comment"># 函数的说明是: None      &lt;-- 糟糕！原本写的注释说明也没了</span><br></code></pre></td></tr></table></figure><p><strong>为什么会这样？</strong> 因为 <code>login = my_decorator(login)</code>，现在的 <code>login</code> 变量实际上指向的是那个内部函数 <code>wrapper</code>。所以你打印的自然是 <code>wrapper</code> 的名字。</p><p>Python 标准库提供了一个神器 <code>@functools.wraps</code>。它的作用是：<strong>自动把原函数（func）的元数据（名字、注释文档等）拷贝给 wrapper。</strong></p><p>这就是所谓的“伪装”：让 wrapper 看起来跟原函数一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools  <span class="hljs-comment"># 1. 导入模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 【关键】在定义 wrapper 之前，加上这行代码</span><br>    <span class="hljs-comment"># 意思是：把 func 的身份证信息贴到 wrapper 脑门上</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>) </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 再次查验身份 ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 函数的名字是: login</span><br><span class="hljs-comment"># 函数的说明是: 这是登录系统的核心函数</span><br></code></pre></td></tr></table></figure><p>为什么这很关键？</p><p>在简单的脚本里确实没关系，但在<strong>框架开发</strong>中这是致命的：</p><ol><li><strong>FastAPI &#x2F; Django 生成文档</strong>：<ul><li>FastAPI 会自动读取函数名和 docstring 来生成 Swagger 接口文档。</li><li>如果你用了装饰器但没加 <code>wraps</code>，FastAPI 看到的函数全叫 <code>wrapper</code>，文档里的接口说明也会全都变成空白。API 文档瞬间就废了。</li></ul></li><li><strong>自动化测试框架</strong>：<ul><li>在 Pytest 或 Unittest 中，测试报告通常会显示“正在执行 xxxx 用例”。</li><li>如果不加 <code>wraps</code>，测试报告里可能会显示“正在执行 wrapper”，根本不知道崩的是哪个用例。</li></ul></li></ol><hr><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h2><p>赋值操作（<code>=</code>）永远只是复制了对象的引用（内存地址），而没有复制对象本身,即仅仅是多了一个指向同一个内存地址的指针</p><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image2.png" class="" title="普通赋值"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="浅拷贝可变类型"><a href="#浅拷贝可变类型" class="headerlink" title="浅拷贝可变类型"></a>浅拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image3.png" class="" title="浅拷贝可变类型"><p>可以清晰地看出，浅拷贝拷贝可变类型，只拷贝第一层</p><h3 id="浅拷贝不可变类型"><a href="#浅拷贝不可变类型" class="headerlink" title="浅拷贝不可变类型"></a>浅拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image4.png" class="" title="浅拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），浅拷贝（copy）等同于赋值（&#x3D;），根本不会创建新对象！</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="深拷贝可变类型"><a href="#深拷贝可变类型" class="headerlink" title="深拷贝可变类型"></a>深拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image5.png" class="" title="深拷贝可变类型"><p>深拷贝拷贝可变类型，则会拷贝所有可变类型的层。</p><h3 id="深拷贝不可变类型"><a href="#深拷贝不可变类型" class="headerlink" title="深拷贝不可变类型"></a>深拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image6.png" class="" title="深拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），深拷贝（deepcopy）等同于赋值（&#x3D;），根本不会创建新对象！</p><hr><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>简单来说，网络编程就是让<strong>两台计算机（或者同一台电脑上的两个程序）互相说话</strong>。网络编程其实就是：<strong>IP 定位电脑 + Port 定位程序 + TCP&#x2F;UDP 定位规则</strong>。</p><p>为了实现“说话”，必须解决三个核心问题：</p><ol><li><strong>找人</strong>：去哪里找对方？（IP 地址）</li><li><strong>找门</strong>：找到电脑后，跟哪个软件说话？（端口号 Port）</li><li><strong>怎么说</strong>：用什么规则交流？（协议 Protocol）</li></ol><hr><h3 id="1-找人：IP-地址-IP-Address"><a href="#1-找人：IP-地址-IP-Address" class="headerlink" title="1. 找人：IP 地址 (IP Address)"></a>1. 找人：IP 地址 (IP Address)</h3><p>IP 地址就是计算机在网络世界的**“门牌号”**。</p><ul><li><strong>公网 IP</strong>：比如百度的 IP，全世界都能访问。</li><li><strong>局域网 IP</strong>：比如 <code>192.168.1.5</code>，只有你家路由器下面的设备能互访。</li><li><strong>本机 IP</strong>：<code>127.0.0.1</code>（有个别名叫 <code>localhost</code>），特指“我自己”。做测试开发时先在本地部署服务，用的就是这个 IP。</li></ul><hr><h3 id="2-找门：端口号-Port"><a href="#2-找门：端口号-Port" class="headerlink" title="2. 找门：端口号 (Port)"></a>2. 找门：端口号 (Port)</h3><p>找到电脑（IP）后，电脑里运行着几十个程序（微信、QQ、浏览器、你的测试脚本）。消息发给谁呢？</p><p>这就需要端口号。它就像是这栋大楼里的**“房间号”**。</p><ul><li><strong>端口范围</strong>：0 - 65535。</li><li><strong>知名端口</strong>（不要去占用）：<ul><li><code>80</code>: 网页浏览 (HTTP)</li><li><code>443</code>: 加密网页 (HTTPS)</li><li><code>3306</code>: MySQL 数据库</li></ul></li><li><strong>动态端口</strong>：我们写程序时，一般使用 1024 之后的端口（比如 8000, 8080, 9999），避免和系统冲突。</li></ul><hr><h3 id="3-怎么说：通信协议-Protocol"><a href="#3-怎么说：通信协议-Protocol" class="headerlink" title="3. 怎么说：通信协议 (Protocol)"></a>3. 怎么说：通信协议 (Protocol)</h3><p>找到了人，也敲开了门，接下来怎么交流？</p><p>在传输层（Transport Layer），最著名的两位“大佬”是 TCP 和 UDP。它们的性格截然不同：</p><h4 id="A-TCP-协议-Transmission-Control-Protocol-——-“打电话”"><a href="#A-TCP-协议-Transmission-Control-Protocol-——-“打电话”" class="headerlink" title="A. TCP 协议 (Transmission Control Protocol) —— “打电话”"></a>A. TCP 协议 (Transmission Control Protocol) —— “打电话”</h4><ul><li><strong>性格</strong>：严谨、靠谱、慢热。</li><li><strong>特点</strong>：<strong>面向连接</strong>。<ul><li>在发数据前，必须先建立连接（著名的<strong>三次握手</strong>）。</li><li>发出去的数据，对方必须确认收到（ACK）。如果没收到，我会重发。</li><li>保证数据顺序不错乱。</li></ul></li><li><strong>应用</strong>：网页访问 (HTTP)、文件传输、邮件、接口自动化（绝大多数接口测试测的都是基于 TCP 的 HTTP）。</li></ul><h4 id="B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”"><a href="#B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”" class="headerlink" title="B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”"></a>B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”</h4><ul><li><strong>性格</strong>：豪爽、快、不负责任。</li><li><strong>特点</strong>：<strong>无连接</strong>。<ul><li>想发就发，不需要建立连接。</li><li>发出去就不管了，对方收没收到我不知道，也不重发。</li><li>可能会丢包，顺序可能会乱。</li></ul></li><li><strong>应用</strong>：视频会议、在线直播、王者荣耀（卡顿一下没关系，只要实时性高就行）。</li></ul><hr><h3 id="4-Python-的工具：socket"><a href="#4-Python-的工具：socket" class="headerlink" title="4. Python 的工具：socket"></a>4. Python 的工具：socket</h3><p>在 Python 中，实现网络编程主要靠 socket (套接字) 模块。</p><p>把 socket 想象成是一个**“电话机”**。</p><ul><li><strong>服务端 (Server)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>插上电话线，绑定号码 (bind IP &amp; Port)。</li><li>守在电话旁等铃声 (listen)。</li><li>接电话 (accept)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li><li><strong>客户端 (Client)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>拨号 (connect IP &amp; Port)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li></ul><hr><h2 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image7.png" class="" title="网络编程"><p>这张图是 <strong>TCP 网络编程中最经典、最标准的核心流程图</strong>。</p><hr><h3 id="1-右侧：TCP-服务器-Server-——-“客服中心”"><a href="#1-右侧：TCP-服务器-Server-——-“客服中心”" class="headerlink" title="1. 右侧：TCP 服务器 (Server) —— “客服中心”"></a>1. 右侧：TCP 服务器 (Server) —— “客服中心”</h3><p>服务器必须先启动，坐在那儿等着被撩。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>首先需要有一个通信工具。在代码中就是创建一个套接字对象。</li></ul></li><li><strong>插卡&#x2F;定号码 (<code>bind(IP, 端口号)</code>)</strong><ul><li>手机买好了，你得告诉大家你的号码是多少（IP），以及大家打进来找哪个部门（端口号，比如 8080）。</li><li>如果不绑定，别人根本找不到你。</li></ul></li><li><strong>开机&#x2F;设置排队 (<code>listen(最大监听数)</code>)</strong><ul><li><strong>开机</strong>：让端口处于“监听状态”，准备接客。</li><li><strong>最大监听数</strong>：相当于客服系统的“排队上限”。如果同时有 100 个人打进来，但我设了 5，那第 6 个人就会听到“正在通话中”。</li></ul></li><li><strong>等待接听 (<code>accept()</code>) —— 关键步骤！</strong><ul><li>图中有个蓝字解释非常重要：<strong>“等待监听，会返回 1 个元组 (负责和客户端交互的 socket, 客户端信息)”</strong>。</li><li><strong>阻塞 (Blocking)</strong>：代码运行到这儿会<strong>停住</strong>（卡住），直到有电话打进来。</li><li><strong>分身术</strong>：这是新手最容易晕的地方。<code>accept</code> 收到请求后，会<strong>专门分配一个新的分身 socket</strong> 去跟这个客户一对一聊天。原来的主 socket 继续回到 <code>listen</code> 状态等下一个电话。</li></ul></li><li><strong>收发数据 (<code>recv() / send()</code>)</strong><ul><li>图中的箭头展示了数据的流向：服务器先接收请求，处理完后，再发送响应。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>聊完了，释放资源。</li></ul></li></ol><hr><h3 id="2-左侧：TCP-客户端-Client-——-“打电话的人”"><a href="#2-左侧：TCP-客户端-Client-——-“打电话的人”" class="headerlink" title="2. 左侧：TCP 客户端 (Client) —— “打电话的人”"></a>2. 左侧：TCP 客户端 (Client) —— “打电话的人”</h3><p>客户端就比较主动了。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>同样先创建一个 socket 对象。</li></ul></li><li><strong>拨号 (<code>connect(IP, 端口号)</code>)</strong><ul><li><strong>三次握手</strong>：也就是图中间写的“连接建立”。</li><li>这一步如果成功，就说明电话通了；如果失败（比如服务器没开），程序就会直接报错 <code>ConnectionRefusedError</code>。</li></ul></li><li><strong>发收数据 (<code>send() / recv()</code>)</strong><ul><li>注意箭头方向：客户端通常是<strong>先说话</strong>（发送请求 <code>send</code>），然后<strong>等着听</strong>（接收响应 <code>recv</code>）。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>打完收工。</li></ul></li></ol><hr><h3 id="3-图中的三个“隐藏细节”"><a href="#3-图中的三个“隐藏细节”" class="headerlink" title="3. 图中的三个“隐藏细节”"></a>3. 图中的三个“隐藏细节”</h3><p>这张图里有几行不起眼的小字，但这恰恰是写代码时最容易踩坑的地方：</p><ol><li><strong>“二进制传输” (绿色字)</strong><ul><li>网络不认识中文，也不认识字符串。</li><li><strong>潜台词</strong>：你在 Python 里 <code>send(&quot;你好&quot;)</code> 是会报错的！必须 <code>send(&quot;你好&quot;.encode(&quot;utf-8&quot;))</code>，把它变成 <code>bytes</code> 类型才能传。</li></ul></li><li><strong>“一直阻塞到客户连接到达”</strong><ul><li>这就是 <code>accept()</code> 的特性。如果没人连你，你的程序就会像死机一样停在那一行不动。</li></ul></li><li><strong>交互逻辑 (<code>send</code> 对 <code>recv</code>)</strong><ul><li>看图中间的横向箭头：<ul><li>客户端的 <code>send()</code> 数据流向 -&gt; 服务器的 <code>recv()</code>。</li><li>服务器的 <code>send()</code> 数据流向 -&gt; 客户端的 <code>recv()</code>。</li></ul></li><li>如果两边同时写 <code>recv()</code>，就会发生<strong>死锁</strong>（俩人都在等对方先说话，结果谁也不理谁）。</li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这张图就是 TCP 代码的<strong>骨架</strong>。</p><ul><li><strong>Server</strong>: <code>socket</code> -&gt; <code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code> (循环) -&gt; <code>recv/send</code> -&gt; <code>close</code></li><li><strong>Client</strong>: <code>socket</code> -&gt; <code>connect</code> -&gt; <code>send/recv</code> -&gt; <code>close</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机 (创建 socket 对象)</span><br><span class="hljs-comment"># AF_INET: 使用 IPv4</span><br><span class="hljs-comment"># SOCK_STREAM: 使用 TCP 协议</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 插卡 (绑定 IP 和 端口)</span><br><span class="hljs-comment"># &#x27;127.0.0.1&#x27; 代表本机</span><br>server_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 开机 (监听)</span><br>server_socket.listen(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 客服中心已启动，正在等待客户电话...&quot;</span>)<br><br><span class="hljs-comment"># 4. 等待接听 (accept) -- 程序会卡在这里直到有人连接</span><br><span class="hljs-comment"># client_sock: 专门负责跟这个客户聊天的分身 socket</span><br><span class="hljs-comment"># addr: 客户的 IP 地址</span><br>client_sock, addr = server_socket.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 电话通了！客户地址: <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 接收消息 (recv) -- 对应图中的第一对 send/recv</span><br><span class="hljs-comment"># 注意：网络传输必须用 bytes，所以要 decode 解码</span><br>data = client_sock.recv(<span class="hljs-number">1024</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客户消息: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 6. 发送回复 (send) -- 对应图中的第二对 send/recv</span><br>msg = <span class="hljs-string">&quot;你好，我是客服小冰，很高兴为您服务！&quot;</span><br>client_sock.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 必须 encode 转成二进制</span><br><br><span class="hljs-comment"># 7. 挂断</span><br>client_sock.close()<br>server_socket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 拨号 (连接服务器)</span><br><span class="hljs-comment"># 必须和服务器的 IP、端口一致</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 先说话 (send)</span><br>msg = <span class="hljs-string">&quot;你好，我要查余额&quot;</span><br>client_socket.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 4. 等回复 (recv)</span><br>data = client_socket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客服回复: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 挂断</span><br>client_socket.close()<br></code></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="1-核心概念：进程-vs-线程"><a href="#1-核心概念：进程-vs-线程" class="headerlink" title="1. 核心概念：进程 vs 线程"></a>1. 核心概念：进程 vs 线程</h3><ul><li><strong>进程 (Process)</strong>：<ul><li><strong>定义</strong>：资源分配的最小单位。</li><li><strong>比喻</strong>：一个独立运行的 <code>.exe</code> 程序，比如 QQ</li><li><strong>特点</strong>：每个进程都有自己独立的内存空间，互不干扰。QQ 崩了，不会影响微信。</li><li><strong>开销</strong>：创建和销毁都很慢，像盖工厂一样费劲。</li></ul></li><li><strong>线程 (Thread)</strong>：<ul><li><strong>定义</strong>：CPU 调度的最小单位。</li><li><strong>比喻</strong>：<strong>工厂里的工人</strong>。</li><li><strong>特点</strong>：<ul><li>一个进程（工厂）里至少有一个线程（老板自己干活），也可以有多个线程（雇了 10 个工人）。</li><li><strong>共享资源</strong>：所有线程都在同一个工厂里，共用同一个食堂、同一个厕所（共享内存）。这就带来了“争抢资源”的问题</li></ul></li><li><strong>开销</strong>：创建非常快，像招个临时工一样简单。</li></ul></li></ul><hr><h3 id="2-串行、并发、并行"><a href="#2-串行、并发、并行" class="headerlink" title="2. 串行、并发、并行"></a>2. 串行、并发、并行</h3><ul><li><strong>串行 (Serial)</strong>：<ul><li><strong>模式</strong>：一个一个来。</li><li><strong>例子</strong>：你去排队打饭，前一个人没打完，你只能干等。</li></ul></li><li><strong>并发 (Concurrency) —— Python 多线程主要属于这种</strong>：<ul><li><strong>模式</strong>：<strong>假装</strong>同时在做。其实是 CPU 切换得太快了，让你产生了错觉。</li><li><strong>例子</strong>：你一边吃饭一边回微信。其实你不能同时把饭送进嘴里又同时打字。你是“吃一口饭 -&gt; 放下筷子回两句 -&gt; 再吃一口”。因为切换速度极快，看起来像是同时进行的。</li></ul></li><li><strong>并行 (Parallelism)</strong>：<ul><li><strong>模式</strong>：<strong>真正</strong>同时在做。</li><li><strong>例子</strong>：你用左手拿勺子喝汤，你朋友坐在对面用右手拿筷子吃面。你俩互不干扰，真正的同时进行（这通常需要多核 CPU 支持）。</li></ul></li></ul><hr><h3 id="3-Python-多线程的“阿喀琉斯之踵”：GIL-锁"><a href="#3-Python-多线程的“阿喀琉斯之踵”：GIL-锁" class="headerlink" title="3. Python 多线程的“阿喀琉斯之踵”：GIL 锁"></a>3. Python 多线程的“阿喀琉斯之踵”：GIL 锁</h3><p>在 Python 中谈多线程，必须得提 <strong>GIL (Global Interpreter Lock，全局解释器锁)</strong>。</p><ul><li><strong>现象</strong>：因为有 GIL 的存在，Python 的多线程在<strong>同一时刻，只能有一个线程在 CPU 上运行</strong>。</li><li><strong>后果</strong>：<ul><li>Python 的多线程是 <strong>“伪多线程”</strong>（针对 CPU 密集型任务）。哪怕你是 8 核 CPU，Python 多线程也只能用 1 个核。</li></ul></li><li><strong>那多线程还有用吗？</strong><ul><li><strong>非常有用！</strong> 但要分场景：</li><li><strong>计算密集型（CPU Bound）</strong>：比如视频解码、科学计算。<strong>（Python 多线程没用，反而更慢，因为要频繁切换）</strong>。</li><li><strong>IO 密集型（IO Bound）</strong>：比如 <strong>爬虫、接口请求、读写文件</strong>。<strong>（Python 多线程神器！）</strong><ul><li><strong>原因</strong>：当线程 A 去请求网络（IO 操作）时，它处于“等待”状态（不占 CPU），Python 会立刻释放 GIL 锁，让线程 B 赶紧去干活。这样就利用了等待的时间。</li></ul></li></ul></li></ul><hr><h2 id="多线程示例"><a href="#多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image8.png" class="" title="多线程"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟网络延迟，耗时1秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_single</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 依次调用 5 次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        download(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>)<br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[单线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_single()<br>    <br>    <br><span class="hljs-comment"># 开始下载: 图片_1.jpg</span><br><span class="hljs-comment"># ... (等1秒)</span><br><span class="hljs-comment"># 下载完成: 图片_1.jpg</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># [单线程] 总耗时: 5.02 秒</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_multi</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 用来存放所有线程对象的列表</span><br>    threads = []<br>    <br>    <span class="hljs-comment"># 1. 创建并启动线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># target: 指定要干什么活 (函数名)</span><br>        <span class="hljs-comment"># args: 指定参数 (注意必须是元组，如果是1个参数后面要加逗号)</span><br>        t = threading.Thread(target=download, args=(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>,))<br>        <br>        <span class="hljs-comment"># 启动线程！(相当于告诉工人：开始干活！)</span><br>        t.start()<br>        <br>        <span class="hljs-comment"># 把工人的名字记下来</span><br>        threads.append(t)<br>        <br>    <span class="hljs-comment"># 2. 等待所有线程结束 (这一步至关重要！)</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join() <br>        <span class="hljs-comment"># join的意思是：主程序(老板)在这里等着，直到这个线程(工人)干完活才能往下走</span><br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[多线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_multi()<br>    <br><span class="hljs-string">&quot;&quot;&quot;   </span><br><span class="hljs-string">开始下载: 图片_1.jpg</span><br><span class="hljs-string">开始下载: 图片_2.jpg</span><br><span class="hljs-string"><span class="hljs-meta">... </span>(几乎同时打印)</span><br><span class="hljs-string">下载完成: 图片_1.jpg</span><br><span class="hljs-string">...</span><br><span class="hljs-string">[多线程] 总耗时: 1.01 秒</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="A-t-start-vs-t-run"><a href="#A-t-start-vs-t-run" class="headerlink" title="A. t.start() vs t.run()"></a>A. <code>t.start()</code> vs <code>t.run()</code></h4><ul><li><strong><code>start()</code></strong>: <strong>正确写法</strong>。它会向操作系统申请一个新的线程，并在新线程里执行代码（真正的并发）。</li><li><strong><code>run()</code></strong>: <strong>错误写法</strong>。它只是把函数当普通函数调用了一遍，还在主线程里跑，根本没有多线程效果。</li></ul><h4 id="B-t-join-为什么要写？"><a href="#B-t-join-为什么要写？" class="headerlink" title="B. t.join() 为什么要写？"></a>B. <code>t.join()</code> 为什么要写？</h4><p>如果把 <code>join</code> 那段循环删掉，会发现程序会在 <strong>0.00秒</strong> 就打印“总耗时”，然后才慢慢打印“下载完成”。</p><ul><li><strong>原因</strong>：Python 的主线程（老板）启动完子线程（工人）后，默认是<strong>不等的</strong>。工人还在下载，老板已经把最后一句 <code>print(总耗时)</code> 执行完了。</li><li><strong>作用</strong>：<code>join()</code> 就像是设了一个<strong>关卡</strong>：“所有人都得在这儿集合！谁没干完，主程序就不准结束！”</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>使用原始的 <code>threading</code> 模块有两个大麻烦：</p><ol><li><strong>管理麻烦</strong>：如果有 1000 个任务，你不能真的启动 1000 个线程（CPU 切换会累死，内存会爆）。你需要控制<strong>最大并发数</strong>（比如只允许同时有 5 个人干活，后面的人排队）。</li><li><strong>拿结果麻烦</strong>：<code>threading.Thread</code> 很难获取函数的<strong>返回值</strong>。你不知道工人干得怎么样，只能靠改全局变量或用队列，很丑陋。</li></ol><p><strong>线程池完美解决了这两个问题。 核心模块：<code>concurrent.futures</code></strong></p><h4 id="实战代码-1：最常用的-submit-方式（灵活控制）"><a href="#实战代码-1：最常用的-submit-方式（灵活控制）" class="headerlink" title="实战代码 1：最常用的 submit 方式（灵活控制）"></a>实战代码 1：最常用的 <code>submit</code> 方式（灵活控制）</h4><p>这种方式适合：任务参数各不相同，或者你需要实时处理每个完成的任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 模拟一个有返回值的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">name, seconds</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔴 [开始] <span class="hljs-subst">&#123;name&#125;</span> 需要 <span class="hljs-subst">&#123;seconds&#125;</span>秒&quot;</span>)<br>    time.sleep(seconds)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;name&#125;</span> 下载成功！&quot;</span>  <span class="hljs-comment"># 这里有返回值！</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># max_workers=3: 也就是虽然我有 5 个任务，但公司只有 3 个工位</span><br>    <span class="hljs-comment"># 剩下 2 个任务得在外面排队，等有人干完了才能进</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 1. 提交任务 (submit)</span><br>        <span class="hljs-comment"># 这里的 task1, task2 是 &quot;未来对象&quot; (Future)，代表一个将来的结果</span><br>        all_tasks = [<br>            pool.submit(download, <span class="hljs-string">&quot;电影A&quot;</span>, <span class="hljs-number">2</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;图片B&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;小说C&quot;</span>, <span class="hljs-number">3</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;音乐D&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;文件E&quot;</span>, <span class="hljs-number">2</span>)<br>        ]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 任务已全部提交，正在排队执行中...\n&quot;</span>)<br><br>        <span class="hljs-comment"># 2. 获取结果 (as_completed)</span><br>        <span class="hljs-comment"># 谁先干完，谁先返回。不用傻傻地按顺序等。</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(all_tasks):<br>            result = future.result() <span class="hljs-comment"># 【关键】获取函数的返回值</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="实战代码-2：极简的-map-方式（批量处理）"><a href="#实战代码-2：极简的-map-方式（批量处理）" class="headerlink" title="实战代码 2：极简的 map 方式（批量处理）"></a>实战代码 2：极简的 <code>map</code> 方式（批量处理）</h4><p>这种方式适合：任务逻辑完全一样，只是参数不同（比如给 100 个 URL 列表发请求）。它的写法跟 Python 自带的 <code>map</code> 一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_url</span>(<span class="hljs-params">url</span>):<br>    time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 模拟请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;url&#125;</span>] 状态码: 200&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_map</span>():<br>    urls = [<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-string">&quot;www.google.com&quot;</span>, <span class="hljs-string">&quot;www.python.org&quot;</span>]<br>    <br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 一行代码搞定批量提交 + 结果按顺序返回</span><br>        <span class="hljs-comment"># 注意：这里的结果是严格按照 urls 列表的顺序返回的</span><br>        results = pool.<span class="hljs-built_in">map</span>(check_url, urls)<br>        <br>        <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> results:<br>            <span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_map()<br></code></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul><li><strong>可迭代对象 (Iterable)</strong>：<ul><li><strong>含义</strong>：具有“被遍历能力”的数据。</li><li><strong>例子</strong>：<code>list</code>, <code>tuple</code>, <code>str</code>, <code>dict</code>。</li><li><strong>特征</strong>：内部实现了 <code>__iter__</code> 方法。它本身不记录位置，需要转化成迭代器才能用 <code>next()</code>。</li></ul></li><li><strong>迭代器 (Iterator)</strong>：<ul><li><strong>含义</strong>：正在执行遍历动作的那个“指针”。</li><li><strong>例子</strong>：<code>iter(list)</code> 后的结果。</li><li><strong>特征</strong>：同时实现了 <code>__iter__</code> 和 <strong><code>__next__</code></strong> 方法。</li></ul></li></ul><p><code>for x in [1, 2, 3]</code>，其实 Python 偷偷做了三件事：</p><ol><li>调用 <code>iter()</code> 把列表变成迭代器。</li><li>不断调用 <code>next()</code> 获取下一个值。</li><li>遇到 <code>StopIteration</code> 异常时，停止循环。</li></ol><p>手动模拟一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 这是一个可迭代对象 (Iterable)</span><br>my_list = [<span class="hljs-string">&quot;接口A&quot;</span>, <span class="hljs-string">&quot;接口B&quot;</span>, <span class="hljs-string">&quot;接口C&quot;</span>]<br><br><span class="hljs-comment"># ❌ 直接 next(my_list) 会报错，因为它还不是迭代器</span><br><br><span class="hljs-comment"># 2. 变成迭代器 (Iterator)</span><br><span class="hljs-comment"># 这一步相当于给薯片筒装上了弹簧，可以往外弹了</span><br>my_iterator = <span class="hljs-built_in">iter</span>(my_list)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;迭代器长这样: <span class="hljs-subst">&#123;my_iterator&#125;</span>&quot;</span>) <br><span class="hljs-comment"># &lt;list_iterator object at 0x...&gt;</span><br><br><span class="hljs-comment"># 3. 手动调用 next()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口A</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口B</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口C</span><br><br><span class="hljs-comment"># 4. 再拿一次？</span><br><span class="hljs-comment"># print(next(my_iterator)) </span><br><span class="hljs-comment"># 报错！StopIteration (薯片吃完了)</span><br></code></pre></td></tr></table></figure><p>要在 Python 中创建一个自定义的迭代器类，需要实现两个魔术方法：</p><ul><li><code>__iter__(self)</code>: 返回自己。</li><li><code>__next__(self)</code>: 返回下一个数据，或者抛出 <code>StopIteration</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_num</span>):<br>        <span class="hljs-variable language_">self</span>.max_num = max_num<br>        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 1. 必须有这个，表明我是可迭代的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-comment"># 2. 必须有这个，定义“下一次”返回什么</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 只要没超标，就返回新账号</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current &lt;= <span class="hljs-variable language_">self</span>.max_num:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;User_<span class="hljs-subst">&#123;self.current&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 超标了，通知 for 循环停下来</span><br>            <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># --- 使用 ---</span><br><br><span class="hljs-comment"># 创建一个能生成 3 个账号的迭代器</span><br>users = UserGenerator(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 像用列表一样用它</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users:<br>    <span class="hljs-built_in">print</span>(u)<br><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># User_1</span><br><span class="hljs-comment"># User_2</span><br><span class="hljs-comment"># User_3</span><br></code></pre></td></tr></table></figure><p>假设有一个 1GB 的 CSV 文件，里面存了 <strong>100 万条</strong> 真实的交易数据，你要用这些数据来跑测试。</p><ul><li><strong>如果不通过迭代器（用 List）</strong>： <code>data = open(&quot;big_data.csv&quot;).readlines()</code> 这会瞬间把 100 万行数据全部加载到内存里，电脑可能会卡死（MemoryError）。</li><li><strong>如果使用迭代器</strong>： 写一个迭代器，每次只从文件里<strong>读取一行</strong>，测试完这一行，扔掉，再读下一行。 <strong>结果</strong>：不管文件有几百 GB，程序只占几 KB 的内存。这叫 <strong>“惰性求值” (Lazy Evaluation)</strong>。</li></ul><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器 <strong>本质上就是一个迭代器</strong>。 但不需要写复杂的类，只需要写一个<strong>函数</strong>。</p><ul><li><strong>普通函数</strong>：用 <code>return</code> 返回结果。一旦 <code>return</code>，函数就结束了，内存也就释放了。</li><li><strong>生成器函数</strong>：用 <strong><code>yield</code></strong> 返回结果。<ul><li><strong>暂停</strong>：函数执行到 <code>yield</code> 时，会把结果交出去，然后<strong>暂停</strong>在这一行（像按了暂停键）。</li><li><strong>保留现场</strong>：函数内的变量、状态全都保留着，没死。</li><li><strong>恢复</strong>：下次你再调用 <code>next()</code> 时，它从刚才暂停的地方<strong>继续往下执行</strong>。</li></ul></li></ul><p>普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_list</span>():<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        result.append(<span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 必须全部做完才能返回</span><br><br><span class="hljs-comment"># 调用</span><br>plate = make_dumplings_list()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;端上来：<span class="hljs-subst">&#123;plate&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成器函数 (<code>yield</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        <span class="hljs-comment"># 【关键】把饺子交出去，然后在这个位置暂停！</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   (第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子被取走了...继续干活)&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br><span class="hljs-comment"># 注意：这一步并没有执行函数代码！只是创建了一个生成器对象</span><br>gen = make_dumplings_gen()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成器对象: <span class="hljs-subst">&#123;gen&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 开始吃 (手动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 我要吃第一个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师包第1个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 我要吃第二个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师从暂停处恢复 -&gt; 包第2个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-comment"># --- 或者直接用 for 循环 (自动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 剩下的我全包了&quot;</span>)<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(d)<br>    <br><span class="hljs-string">&quot;&quot;&quot;    </span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第一个</span><br><span class="hljs-string">👨‍🍳 正在包第 1 个饺子...</span><br><span class="hljs-string">饺子_1</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第二个</span><br><span class="hljs-string">   (第 1 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 2 个饺子...</span><br><span class="hljs-string">饺子_2</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>剩下的我全包了</span><br><span class="hljs-string">   (第 2 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 3 个饺子...</span><br><span class="hljs-string">饺子_3</span><br><span class="hljs-string">   (第 3 个饺子被取走了...继续干活)</span><br></code></pre></td></tr></table></figure><p>写法2-生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 列表推导式 (耗内存)</span><br>list_data = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(list_data) <br><span class="hljs-comment"># 输出: [0, 1, 4, 9, ..., 81] (内存里真的有10个数)</span><br><br><span class="hljs-comment"># 2. 生成器表达式 (省内存)</span><br>gen_data = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(gen_data)<br><span class="hljs-comment"># 输出: &lt;generator object ...&gt; (内存里只有一个公式，还没算呢)</span><br><br><span class="hljs-comment"># 想用的时候再算</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><hr><h1 id="Property属性"><a href="#Property属性" class="headerlink" title="Property属性"></a>Property属性</h1><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, birth_year</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.birth_year = birth_year<br><br>    <span class="hljs-comment"># 【关键】加上 @property</span><br>    <span class="hljs-comment"># 把这个方法变成一个 &quot;只读属性&quot;</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        current_year = datetime.datetime.now().year<br>        <span class="hljs-keyword">return</span> current_year - <span class="hljs-variable language_">self</span>.birth_year<br><br>s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment"># 1. 像访问变量一样访问 age（注意：后面没有括号！）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;今年年龄: <span class="hljs-subst">&#123;s1.age&#125;</span>&quot;</span>) <br><br><span class="hljs-comment"># 2. 尝试修改它（会报错）</span><br><span class="hljs-comment"># s1.age = 18 </span><br><span class="hljs-comment"># 报错：AttributeError: can&#x27;t set attribute (因为我们只定义了 getter，没定义 setter)</span><br></code></pre></td></tr></table></figure><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这是一个私有变量，不对外公开</span><br>        <span class="hljs-variable language_">self</span>._score = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># --- 1. 定义 Getter (读) ---</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._score<br><br>    <span class="hljs-comment"># --- 2. 定义 Setter (写) ---</span><br>    <span class="hljs-comment"># 语法规则：@函数名.setter</span><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 错误：分数必须是整数！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 错误：分数 <span class="hljs-subst">&#123;value&#125;</span> 超出范围 (0-100)！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>            <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 分数 <span class="hljs-subst">&#123;value&#125;</span> 设置成功&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._score = value<br><br><span class="hljs-comment"># --- 测试 ---</span><br>s = Student()<br><br><span class="hljs-comment"># 正常赋值</span><br>s.score = <span class="hljs-number">90</span>  <span class="hljs-comment"># 自动触发 @score.setter 下的函数</span><br><span class="hljs-built_in">print</span>(s.score) <span class="hljs-comment"># 自动触发 @property 下的函数</span><br><br><span class="hljs-comment"># 异常赋值（会被 setter 里的逻辑拦截）</span><br>s.score = <span class="hljs-number">999</span> <br>s.score = <span class="hljs-string">&quot;不及格&quot;</span><br><br><span class="hljs-comment"># 再次查看，还是原来的 90，没被污染</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前真实分数: <span class="hljs-subst">&#123;s.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="基础语法速查表"><a href="#基础语法速查表" class="headerlink" title="基础语法速查表"></a>基础语法速查表</h3><p>认识几个“特殊符号”（元字符）：</p><h4 id="A-代表“字符”的符号"><a href="#A-代表“字符”的符号" class="headerlink" title="A. 代表“字符”的符号"></a>A. 代表“字符”的符号</h4><ul><li><strong><code>.</code> (点)</strong>：万能符。代表<strong>除了换行符以外的任意一个字符</strong>。</li><li><strong><code>\d</code></strong>：数字 (Digit)。等价于 <code>[0-9]</code>。</li><li><strong><code>\w</code></strong>：单词字符 (Word)。代表 <strong>数字、字母、下划线、中文</strong>（Python 3 中）。</li><li><strong><code>\s</code></strong>：空白符 (Space)。代表空格、Tab、换行。</li></ul><h4 id="B-代表“数量”的符号"><a href="#B-代表“数量”的符号" class="headerlink" title="B. 代表“数量”的符号"></a>B. 代表“数量”的符号</h4><ul><li><strong><code>*</code></strong>：0 次或多次（有没有都行，越多越好）。</li><li><strong><code>+</code></strong>：1 次或多次（至少得有一个）。</li><li><strong><code>?</code></strong>：0 次或 1 次（要么没有，要么有一个）。</li><li><strong><code>&#123;n&#125;</code></strong>：恰好 n 次。</li><li><strong><code>&#123;n, m&#125;</code></strong>：n 到 m 次。</li></ul><h4 id="C-代表“位置”的符号"><a href="#C-代表“位置”的符号" class="headerlink" title="C. 代表“位置”的符号"></a>C. 代表“位置”的符号</h4><ul><li><strong><code>^</code></strong>：必须以…开头。</li><li><strong><code>$</code></strong>：必须以…结尾。</li></ul><p>1：<code>re.findall()</code> —— 找到所有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;张三的电话是 13811112222，李四的电话是 15933334444，还有一个座机 010-123456。&quot;</span><br><br><span class="hljs-comment"># 规则：1开头，后面接10个数字</span><br><span class="hljs-comment"># r&#x27;&#x27; 表示原生字符串，防止转义字符捣乱，写正则建议都要加 r</span><br>pattern = <span class="hljs-string">r&quot;1\d&#123;10&#125;&quot;</span><br><br>phones = re.findall(pattern, text)<br><span class="hljs-built_in">print</span>(phones)<br><span class="hljs-comment"># 输出: [&#x27;13811112222&#x27;, &#x27;15933334444&#x27;]</span><br></code></pre></td></tr></table></figure><p>2：<code>re.search()</code> —— 找到第一个就收工 (最常用):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>html = <span class="hljs-string">&quot;&lt;div&gt;订单号: &lt;span id=&#x27;order&#x27;&gt;20231212001&lt;/span&gt;&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 规则：找数字，但我要更精确</span><br><span class="hljs-comment"># 使用括号 () 进行【分组提取】，这是做接口测试提取数据的核心！</span><br><span class="hljs-comment"># r&quot;(\d&#123;11&#125;)&quot; 意思是：找到11个数字，并把这11个数字单独拿出来</span><br>match_obj = re.search(<span class="hljs-string">r&quot;id=&#x27;order&#x27;&gt;(\d+)&lt;&quot;</span>, html)<br><br><span class="hljs-keyword">if</span> match_obj:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;匹配到的整体: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">0</span>)&#125;</span>&quot;</span>) <span class="hljs-comment"># id=&#x27;order&#x27;&gt;20231212001&lt;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取的目标: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)   <span class="hljs-comment"># 20231212001 (我们通常只要这个)</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没找到&quot;</span>)<br></code></pre></td></tr></table></figure><p>3：<code>re.sub()</code> —— 替换 (清洗数据):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;我给你转了￥100元，又转了$50元&quot;</span><br><br><span class="hljs-comment"># 把所有的货币符号去掉，只留数字</span><br><span class="hljs-comment"># [] 表示“其中任意一个”</span><br>new_text = re.sub(<span class="hljs-string">r&quot;[￥$元]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, text)<br><br><span class="hljs-built_in">print</span>(new_text) <br><span class="hljs-comment"># 输出: 我给你转了100，又转了50</span><br></code></pre></td></tr></table></figure><p>4:re.match()–只从字符串的第一个字符开始匹配:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello Python World&quot;</span><br>pattern = <span class="hljs-string">r&quot;Python&quot;</span><br><br><span class="hljs-comment"># --- 1. 使用 match (碰壁) ---</span><br><span class="hljs-comment"># match 看了看第一个单词 &quot;Hello&quot;，发现不是 &quot;Python&quot;，直接报错(返回None)</span><br>res_match = re.<span class="hljs-keyword">match</span>(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 结果: <span class="hljs-subst">&#123;res_match&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Match 结果: None</span><br><br><br><span class="hljs-comment"># --- 2. 使用 search (成功) ---</span><br><span class="hljs-comment"># search 很有耐心，跳过 Hello，在第 6 个位置找到了 Python</span><br>res_search = re.search(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Search 结果: <span class="hljs-subst">&#123;res_search&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Search 结果: &lt;re.Match object; span=(6, 12), match=&#x27;Python&#x27;&gt;</span><br><br><br><span class="hljs-comment"># --- 3. 只有一种情况 match 能成功 ---</span><br><span class="hljs-comment"># 必须让 Python 出现在开头</span><br>text_2 = <span class="hljs-string">&quot;Python is good&quot;</span><br>res_match_2 = re.<span class="hljs-keyword">match</span>(pattern, text_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 成功: <span class="hljs-subst">&#123;res_match_2&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: Match 成功: &lt;re.Match object...&gt;</span><br></code></pre></td></tr></table></figure><p>5:贪婪与非贪婪:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&quot;&lt;div&gt;第一个&lt;/div&gt;&lt;div&gt;第二个&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 1. 贪婪模式 (.*)</span><br><span class="hljs-comment"># 它会从第一个 &lt;div&gt; 一直吃到最后一个 &lt;/div&gt;，中间不管有多少闭合标签全吞了</span><br>res_greedy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;贪婪: <span class="hljs-subst">&#123;res_greedy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&lt;/div&gt;&lt;div&gt;第二个&#x27;]  &lt;-- 翻车了！</span><br><br><span class="hljs-comment"># 2. 非贪婪模式 (.*?)</span><br><span class="hljs-comment"># 遇到第一个 &lt;/div&gt; 它就觉得“够了”，停止匹配</span><br>res_lazy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*?)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;非贪婪: <span class="hljs-subst">&#123;res_lazy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&#x27;, &#x27;第二个&#x27;] &lt;-- 这才是我们要的</span><br></code></pre></td></tr></table></figure><hr><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Python 的 GC 机制是以【引用计数】为主，以【标记-清除】和【分代回收】为辅。</p><h2 id="引用计数-Reference-Counting"><a href="#引用计数-Reference-Counting" class="headerlink" title="引用计数 (Reference Counting)"></a>引用计数 (Reference Counting)</h2><p>这是 Python 内存管理最核心、最基础的机制。它像是一个**“计分器”**。</p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Python 中的每个对象（比如一个列表、一个数字）内部都有一个字段叫 <code>ob_refcnt</code>，记录着**“现在有多少个变量引用着我”**。</p><ul><li><strong>计数 +1 的情况</strong>：<ul><li>对象被创建：<code>a = [1, 2]</code> （计数&#x3D;1）</li><li>被赋值给别人：<code>b = a</code> （计数&#x3D;2）</li><li>作为参数传给函数：<code>func(a)</code> （计数+1，函数结束-1）</li><li>被放进容器里：<code>list_c = [a]</code> （计数+1）</li></ul></li><li><strong>计数 -1 的情况</strong>：<ul><li>变量被显式销毁：<code>del a</code></li><li>变量被赋予了新值：<code>a = &quot;hello&quot;</code> （原来的 <code>[1,2]</code> 计数-1）</li><li>离开作用域（函数运行结束）：局部变量会被自动销毁。</li></ul></li><li><strong>回收时刻</strong>：<ul><li>一旦某个对象的引用计数变成 <strong>0</strong>，Python 里的“收尸队”会<strong>立刻</strong>把它回收，释放内存。这是一种<strong>实时</strong>的回收机制。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 出生了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💀 <span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了 (内存释放)&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 创建对象（计数=1）</span><br>h1 = Hero(<span class="hljs-string">&quot;亚索&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 注意：sys.getrefcount() 会比实际多 1，因为它自己作为参数也引用了一次</span><br><br><span class="hljs-comment"># 2. 增加引用（计数+1）</span><br>h2 = h1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <span class="hljs-comment"># 现在有两个变量指着它</span><br><br><span class="hljs-comment"># 3. 删除其中一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h1...&quot;</span>)<br><span class="hljs-keyword">del</span> h1<br><span class="hljs-comment"># 此时 h2 还在，引用计数没归零，所以亚索还活着，不会打印 &quot;被销毁&quot;</span><br><br><span class="hljs-comment"># 4. 删除最后一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h2...&quot;</span>)<br><span class="hljs-keyword">del</span> h2<br><span class="hljs-comment"># 此时引用计数为 0，系统立刻触发回收，打印 &quot;被销毁&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 程序结束&quot;</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">✅ 亚索 出生了</span><br><span class="hljs-string">引用计数: 2</span><br><span class="hljs-string">引用计数: 3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h1...</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h2...</span><br><span class="hljs-string">💀 亚索 被销毁了 (内存释放)</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>程序结束</span><br></code></pre></td></tr></table></figure><h4 id="致命缺点：循环引用-Circular-Reference"><a href="#致命缺点：循环引用-Circular-Reference" class="headerlink" title="致命缺点：循环引用 (Circular Reference)"></a>致命缺点：循环引用 (Circular Reference)</h4><p>引用计数非常快，但有一个死穴。请看下面这个经典的“互为舔狗”场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>]<br>b = [<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 互相引用</span><br>a.append(b) <span class="hljs-comment"># a 引用 b</span><br>b.append(a) <span class="hljs-comment"># b 引用 a</span><br><br><span class="hljs-comment"># 删除外部引用</span><br><span class="hljs-keyword">del</span> a<br><span class="hljs-keyword">del</span> b<br></code></pre></td></tr></table></figure><p><strong>结果</strong>：</p><ul><li>执行 <code>del a</code> 后，<code>[1]</code> 的计数从 2 减为 1（因为 <code>b</code> 还在引用它）。</li><li>执行 <code>del b</code> 后，<code>[2]</code> 的计数从 2 减为 1（因为 <code>a</code> 还在引用它）。</li><li><strong>死锁</strong>：外界已经谁也找不到这两个列表了，但它俩在内存里互相抓着对方，计数器永远不为 0。这就造成了<strong>内存泄漏</strong>。</li></ul><p><strong>为了解决这个问题，Python 引入了后面两把辅助斧头。</strong></p><hr><h2 id="标记-清除-Mark-and-Sweep"><a href="#标记-清除-Mark-and-Sweep" class="headerlink" title="标记-清除 (Mark and Sweep)"></a>标记-清除 (Mark and Sweep)</h2><p>这把斧头专门用来解决<strong>循环引用</strong>的问题。</p><p>它不再盯着计数器看，而是从更高的视角看**“连通性”**。</p><h4 id="1-原理（图论思想）"><a href="#1-原理（图论思想）" class="headerlink" title="1. 原理（图论思想）"></a>1. 原理（图论思想）</h4><p>Python 会把所有的对象看作图的节点，引用看作边。</p><ul><li><strong>Root (根节点)</strong>：全局变量、调用栈里的变量、寄存器。这些是绝对不能回收的“大人物”。</li></ul><h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h4><ol><li><strong>标记 (Mark)</strong>：GC 算法从“根节点”出发，沿着引用链往下走。凡是能走到的对象，都打上“<strong>存活</strong>”的标签。</li><li><strong>清除 (Sweep)</strong>：遍历所有对象，凡是<strong>没有</strong>被打上“存活”标签的（也就是那些与外界彻底失联的“孤岛”，比如刚才互为舔狗的那俩），统统干掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 准备好了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;♻️ <span class="hljs-subst">&#123;self.name&#125;</span> 被 GC 回收了&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_cycle</span>():<br>    <span class="hljs-comment"># 1. 创建两个对象</span><br>    n1 = Node(<span class="hljs-string">&quot;节点A&quot;</span>)<br>    n2 = Node(<span class="hljs-string">&quot;节点B&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 制造循环引用 (互为舔狗)</span><br>    n1.partner = n2 <span class="hljs-comment"># Python 允许在对象创建后的任何时间，给它身上贴任何新的属性标签。</span><br>    n2.partner = n1<br><br>    <span class="hljs-comment"># 3. 删除外部引用</span><br>    <span class="hljs-comment"># 按理说，函数结束，n1 和 n2 应该被销毁。</span><br>    <span class="hljs-comment"># 但因为它们互相拉着对方，引用计数不为 0，所以默认无法回收！</span><br>    <span class="hljs-keyword">del</span> n1<br>    <span class="hljs-keyword">del</span> n2<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 函数运行结束，外部引用已断开&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 为了演示效果，我们先关闭自动 GC，模拟引用计数解决不了的场景</span><br>gc.disable()<br><br>create_cycle()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 等待片刻 ---&quot;</span>)<br><span class="hljs-comment"># 此时你会发现，并没有打印 &quot;被 GC 回收了&quot;，说明内存泄漏了！</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 手动触发 GC (标记-清除)...&quot;</span>)<br><span class="hljs-comment"># 手动召唤收尸队</span><br>collected_num = gc.collect()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;本次 GC 清理了 <span class="hljs-subst">&#123;collected_num&#125;</span> 个垃圾对象&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序彻底结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="分代回收-Generational-Collection"><a href="#分代回收-Generational-Collection" class="headerlink" title="分代回收 (Generational Collection)"></a>分代回收 (Generational Collection)</h2><p>标记-清除虽然能解决循环引用，但它要把所有对象扫描一遍，<strong>太慢了</strong>！ 为了不拖慢程序运行速度，Python 引入了**“分代回收”**（基于“空间换时间”的思想）。</p><h4 id="1-核心假设"><a href="#1-核心假设" class="headerlink" title="1. 核心假设"></a>1. 核心假设</h4><p><strong>“对象存活越久，它是垃圾的可能性越小。”</strong></p><ul><li>新创建的对象（比如循环里的临时变量）往往死得快。</li><li>老不死的对象（比如全局配置）往往会一直活下去。</li></ul><h4 id="2-三代人-0代-1代-2代"><a href="#2-三代人-0代-1代-2代" class="headerlink" title="2. 三代人 (0代, 1代, 2代)"></a>2. 三代人 (0代, 1代, 2代)</h4><p>Python 将所有的对象分为三代：</p><ul><li><strong>0代 (Generation 0)</strong>：新生代。所有新创建的对象都放这里。</li><li><strong>1代 (Generation 1)</strong>：中生代。</li><li><strong>2代 (Generation 2)</strong>：老年代。</li></ul><h4 id="3-回收逻辑"><a href="#3-回收逻辑" class="headerlink" title="3. 回收逻辑"></a>3. 回收逻辑</h4><ol><li><strong>扫描频率</strong>：0代扫描最勤快，1代次之，2代最懒。</li><li><strong>晋升机制</strong>：<ul><li>当 GC 扫描 0代列表时，发现有些对象居然还活着（没被回收），那就把它们<strong>移入 1代</strong>。</li><li>同理，如果在扫描 1代时对象还没死，就<strong>移入 2代</strong>。</li></ul></li><li><strong>触发阈值</strong>（了解即可）：<ul><li>当 0代对象数量达到一定阈值（默认 700 个），就会触发一次 0代 GC。</li><li>当 0代 GC 触发 10 次，才会触发一次 1代 GC。</li><li>当 1代 GC 触发 10 次，才会触发一次 2代 GC。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><span class="hljs-comment"># 获取当前的分代回收阈值</span><br>threshold = gc.get_threshold()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;700 表示：0代对象超过 700 个触发一次 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：0代 GC 触发 10 次，触发一次 1代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：1代 GC 触发 10 次，触发一次 2代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前阈值: <span class="hljs-subst">&#123;threshold&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前每一代的垃圾数量</span><br><span class="hljs-comment"># 结果类似 (count0, count1, count2)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前各代垃圾数量: <span class="hljs-subst">&#123;gc.get_count()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="数据结构原理"><a href="#数据结构原理" class="headerlink" title="数据结构原理"></a>数据结构原理</h1><h3 id="1-列表-List-vs-元组-Tuple"><a href="#1-列表-List-vs-元组-Tuple" class="headerlink" title="1. 列表 (List) vs 元组 (Tuple)"></a>1. 列表 (List) vs 元组 (Tuple)</h3><p><strong>面试题</strong>：“List 和 Tuple 有什么区别？为什么 Python 要设计两个看似一样的东西？”</p><h4 id="核心区别："><a href="#核心区别：" class="headerlink" title="核心区别："></a>核心区别：</h4><ol><li><strong>可变性 (Mutability)</strong>：<ul><li><strong>List (<code>[]</code>)</strong>：<strong>可变的（Mutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“背包”**。你可以随时往里塞东西、拿东西出来，甚至把里面的苹果换成香蕉。</li></ul></li><li><strong>Tuple (<code>()</code>)</strong>：<strong>不可变的（Immutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“琥珀”<strong>或者</strong>“封死的快递箱”**。一旦出厂（创建），里面的东西就定死了。你想改？只能打碎了重新做一个。</li></ul></li></ul></li><li><strong>性能 (Performance)</strong>：<ul><li><strong>Tuple 比 List 快</strong>。</li><li><strong>原因</strong>：<ul><li>Python 对 Tuple 做了<strong>内存缓存机制</strong>。当你创建一个 tuple 时，Python 知道它不会变，所以可以放心大胆地分配一段固定的内存，不需要像 List 那样预留额外的空间（为了 append）。</li><li>如果你的数据只读不改（比如配置参数、数据库查出来的结果），请无脑用 Tuple。</li></ul></li></ul></li><li><strong>作为字典的 Key</strong>：<ul><li><strong>Tuple 可以</strong>做字典的 Key（只要里面装的也是不可变元素）。</li><li><strong>List 不行</strong>（因为它是可变的，不可哈希）。</li></ul></li></ol><hr><h3 id="2-字典-Dict-的底层原理-——-哈希表-Hash-Table"><a href="#2-字典-Dict-的底层原理-——-哈希表-Hash-Table" class="headerlink" title="2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)"></a>2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)</h3><p><strong>面试题</strong>：“字典为什么查找速度这么快？底层是怎么实现的？”</p><p>这是 Python 面试中<strong>含金量最高</strong>的问题。</p><h4 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h4><p>字典查找是 <strong>O(1)</strong> 的时间复杂度（也就是<strong>秒查</strong>，不管字典里有 1 万个数据还是 1 亿个，查找速度几乎一样快）。</p><p><strong>比喻：超市储物柜</strong></p><ul><li><strong>Hash 函数</strong>：就是<strong>条形码扫描枪</strong>。</li><li><strong>Key</strong>：你手里的<strong>小票</strong>。</li><li><strong>Value</strong>：柜子里的<strong>包</strong>。</li></ul><p>当你想存东西（<code>dict[&quot;name&quot;] = &quot;亚索&quot;</code>）：</p><ol><li>Python 拿着 “name” 这个 Key，通过 <strong>哈希函数 (hash function)</strong> 算出一个数字（比如 10086）。</li><li>这个数字直接对应内存里的<strong>地址索引</strong>。</li><li>Python 直接把 “亚索” 扔进 10086 号柜子。</li></ol><p>当你想取东西（<code>dict[&quot;name&quot;]</code>）：</p><ol><li>Python 拿着 “name” 再算一次哈希值，算出 10086。</li><li>直接去 10086 号柜子拿数据。</li><li><strong>完全不需要遍历！</strong> 不需要一个个柜子打开看。</li></ol><h4 id="追问：哈希冲突-Hash-Collision"><a href="#追问：哈希冲突-Hash-Collision" class="headerlink" title="追问：哈希冲突 (Hash Collision)"></a>追问：哈希冲突 (Hash Collision)</h4><p><strong>面试题</strong>：“如果两个不同的 Key，算出来的哈希值一样（都要抢 10086 号柜子）怎么办？”</p><ul><li><strong>Java (HashMap)</strong>：采用**“链地址法”**。如果你来了发现 10086 有人了，你在 10086 后面挂个钩子，吊在下面（形成链表）。</li><li><strong>Python (Dict)</strong>：采用**“开放寻址法” (Open Addressing)**。<ul><li><strong>逻辑</strong>：如果你来了发现 10086 被占了，Python 会说：“别急，往后看！”</li><li>它会按照某种规则（比如看 10087、10088…）去找<strong>下一个空的柜子</strong>存进去。</li><li><em>注：Python 3.6+ 之后对字典进行了大量优化（变得有序且更省内存），但核心依然是哈希表。</em></li></ul></li></ul><hr><h3 id="3-列表-List-的底层-——-动态数组"><a href="#3-列表-List-的底层-——-动态数组" class="headerlink" title="3. 列表 (List) 的底层 —— 动态数组"></a>3. 列表 (List) 的底层 —— 动态数组</h3><p><strong>面试题</strong>：“List 是怎么实现动态扩容的？为什么 append 很快，insert 很慢？”</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Python 的 List 不是链表，而是<strong>连续的内存空间（数组）</strong>，里面存的是<strong>指针</strong>（指向具体的对象）。</p><ol><li><strong>为什么 append (尾部插入) 快？</strong><ul><li>List 在初始化时，会<strong>偷偷多申请一点内存</strong>。</li><li>比如你存 3 个数，它实际申请了 4 个坑位。当你 <code>append</code> 第 4 个数时，直接放进去就行，不需要找操作系统要内存。</li></ul></li><li><strong>动态扩容 (Resizing)</strong>：<ul><li>如果你 append 第 5 个数，坑位不够了怎么办？</li><li>Python 会直接申请一个<strong>更大的内存条</strong>（通常是原来的 1.125 倍左右），然后把旧数据<strong>统统复制过去</strong>，再把旧内存扔掉。</li><li>这就是为什么偶尔一次 append 会变慢的原因。</li></ul></li><li><strong>为什么 insert (中间插入) 慢？</strong><ul><li>如果你在 index&#x3D;0 的位置插入一个数据。</li><li>Python 必须把后面所有的数据<strong>全体起立，向后挪一个位置</strong>，给新来的腾地儿。</li><li>数据越多，挪动越慢。所以 List 极其不适合做“队列”使用。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python进阶</tag>
      
      <tag>面向对象</tag>
      
      <tag>装饰器</tag>
      
      <tag>拷贝</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2025/12/09/Python%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-1-字面量"><a href="#1-1-字面量" class="headerlink" title="1.1 字面量"></a>1.1 字面量</h2><p>字面量：在代码中，被写下来的的固定的值，称之为字面量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;人生苦短_&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个变量</span><br>money = <span class="hljs-number">50</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br><br>money -= <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br></code></pre></td></tr></table></figure><hr><h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;小黎&quot;</span>)) <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)) <span class="hljs-comment"># &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">13.14</span>)) <span class="hljs-comment"># &lt;class &#x27;float&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int() 转换为整数类型</span><br>a = <span class="hljs-built_in">int</span>(<span class="hljs-number">99.6</span>) <span class="hljs-comment"># 99.6 转换为 99</span><br><span class="hljs-comment"># float() 转换为浮点类型</span><br>b = <span class="hljs-built_in">float</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 99.0</span><br><span class="hljs-comment"># str() 转换为字符串类型</span><br>c = <span class="hljs-built_in">str</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 &quot;99&quot;</span><br><span class="hljs-comment"># bool() 转换为布尔类型</span><br>d = <span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 转换为 True</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-6-字符串拼接"><a href="#1-6-字符串拼接" class="headerlink" title="1.6 字符串拼接"></a>1.6 字符串拼接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-comment"># 用+拼接只适用于字符串 不适用与整数型或浮点型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-7-字符串格式化"><a href="#1-7-字符串格式化" class="headerlink" title="1.7 字符串格式化"></a>1.7 字符串格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;小黎&quot;</span><br>age = <span class="hljs-number">22</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-comment"># %s 即将内容转换为字符串放入占位位置</span><br>message1 = <span class="hljs-string">&quot;我的名字是%s&quot;</span> %name<br>message2 = <span class="hljs-string">&quot;我的名字是%s,年龄是%d&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message1) <span class="hljs-comment"># 我的名字是小黎</span><br><span class="hljs-built_in">print</span>(message2) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-comment"># 数字精度控制 (会做四舍五入)</span><br>message3 = <span class="hljs-string">&quot;我的名字是%s,年龄是%.2f&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message3) <span class="hljs-comment"># 我的名字是小黎,年龄是22.00</span><br><span class="hljs-comment"># 方式二 比较快捷 不关心精度控制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的名字是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是&quot;</span>,name,<span class="hljs-string">&quot;年龄是&quot;</span>,age) <span class="hljs-comment"># 我的名字是 小黎 年龄是 22</span><br>age = <span class="hljs-number">22.0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age)) <span class="hljs-comment"># 我的年龄是22.00</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-8-表达式格式化"><a href="#1-8-表达式格式化" class="headerlink" title="1.8 表达式格式化"></a>1.8 表达式格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是%s&quot;</span> %(<span class="hljs-number">11</span> + <span class="hljs-number">11</span>)) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的年龄是<span class="hljs-subst">&#123;<span class="hljs-number">11</span> + <span class="hljs-number">11</span>&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字符串在python中的数据类型是%s&quot;</span> %(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;字符串&quot;</span>))) <span class="hljs-comment"># 字符串在python中的数据类型是&lt;class &#x27;str&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="2-1-布尔类型"><a href="#2-1-布尔类型" class="headerlink" title="2.1 布尔类型"></a>2.1 布尔类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-literal">True</span><br>b = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;a的内容是<span class="hljs-subst">&#123;a&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(a)&#125;</span>&quot;</span>) <span class="hljs-comment"># a的内容是True,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;b的内容是<span class="hljs-subst">&#123;b&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(b)&#125;</span>&quot;</span>) <span class="hljs-comment"># b的内容是False,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><br>result = <span class="hljs-number">10</span> &gt; <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10 &gt; 5 的结果是<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 10 &gt; 5 的结果是True</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-2-判断语句"><a href="#2-2-判断语句" class="headerlink" title="2.2 判断语句"></a>2.2 判断语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 产生一个1-10之间的随机数字</span><br>num = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(num)</span><br>guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入您猜测的数:&quot;</span>))<br><span class="hljs-keyword">if</span> guess_num == num:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第一次就猜中了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> guess_num &gt; num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>    guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>    <span class="hljs-keyword">if</span> guess_num == num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第二次猜中了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> guess_num &gt; num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>        guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>        <span class="hljs-keyword">if</span> guess_num == num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第三次猜中了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;很遗憾，三次你都没猜中&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="3-1-while循环"><a href="#3-1-while循环" class="headerlink" title="3.1 while循环"></a>3.1 while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">9</span>:<br>    j = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt;= i:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;j&#125;</span> * <span class="hljs-subst">&#123;i&#125;</span> = <span class="hljs-subst">&#123;j * i&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 不换行且对齐</span><br>        j += <span class="hljs-number">1</span><br>    i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 换行</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-2-for循环"><a href="#3-2-for循环" class="headerlink" title="3.2 for循环"></a>3.2 for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 统计字符串中有多少个a</span><br>name = <span class="hljs-string">&quot;xiaoli is a rapper&quot;</span><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> name:<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;a&quot;</span>:<br>        count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(count)<br></code></pre></td></tr></table></figure><hr><h2 id="3-3-range"><a href="#3-3-range" class="headerlink" title="3.3 range"></a>3.3 range</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># range的作用 获得一个数字序列</span><br>num1 = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num1:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="4-1-传参方式"><a href="#4-1-传参方式" class="headerlink" title="4.1 传参方式"></a>4.1 传参方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示多种传参的形式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 位置传参</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是20,性别是男</span><br><br><span class="hljs-comment"># 关键字传参</span><br>user_info(name=<span class="hljs-string">&#x27;小王&#x27;</span>, age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小王,年龄是19,性别是女</span><br>user_info(age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, name=<span class="hljs-string">&#x27;小黎&#x27;</span>)  <span class="hljs-comment"># 位置可随意</span><br><br><span class="hljs-comment"># 缺省参数(默认参数必须写在最后面)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender=<span class="hljs-string">&#x27;男&#x27;</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是男</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是女</span><br><br><span class="hljs-comment"># 位置不定长 不定长定义的形式参数会作为元组存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;args&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(args)&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;小黎&#x27;</span>, <span class="hljs-string">&#x27;男孩&#x27;</span>) <span class="hljs-comment"># args的内容是(1, 2, 3, &#x27;小黎&#x27;, &#x27;男孩&#x27;)，类型是&lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 关键字不定长 不定长定义的形式参数会作为字典存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;kwargs&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(kwargs)&#125;</span>&quot;</span>)<br><br>user_info(name=<span class="hljs-string">&quot;小黎&quot;</span>, age=<span class="hljs-number">22</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># args的内容是&#123;&#x27;name&#x27;: &#x27;小黎&#x27;, &#x27;age&#x27;: 22, &#x27;gender&#x27;: &#x27;男&#x27;&#125;，类型是&lt;class &#x27;dict&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-2-函数作为参数传递"><a href="#4-2-函数作为参数传递" class="headerlink" title="4.2 函数作为参数传递"></a>4.2 函数作为参数传递</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是<span class="hljs-subst">&#123;result&#125;</span>,参数类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(compute)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br>test_func(compute) <span class="hljs-comment"># 计算结果是3,参数类型是&lt;class &#x27;function&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-3-lambda匿名函数"><a href="#4-3-lambda匿名函数" class="headerlink" title="4.3 lambda匿名函数"></a>4.3 lambda匿名函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果是:<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 将匿名函数作为参数传入</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x + y)<br></code></pre></td></tr></table></figure><hr><h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="5-1-列表"><a href="#5-1-列表" class="headerlink" title="5.1 列表"></a>5.1 列表</h2><h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><p>列表可以修改、支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>,<span class="hljs-number">666</span>,<span class="hljs-string">&quot;python&quot;</span>]<br><span class="hljs-comment"># 查找某元素的下标索引 若不存在会报错</span><br><span class="hljs-built_in">print</span>(mylist.index(<span class="hljs-string">&quot;python&quot;</span>))<br><span class="hljs-comment"># 修改目标索引对应元素的值</span><br>mylist[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;小黎&quot;</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在目标索引处插入元素</span><br>mylist.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加元素</span><br>mylist.append(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br>mylist += [<span class="hljs-string">&quot;人生苦短&quot;</span>]<br>mylist *= <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加一个数据容器中的元素</span><br>mylist2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>mylist.extend(mylist2)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除目标索引处的元素 两种方法 第一种方法可以得到返回值</span><br>element = mylist.pop(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-keyword">del</span> mylist[<span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除某元素在列表中的第一个匹配项</span><br>mylist.remove(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 统计某元素的个数</span><br><span class="hljs-built_in">print</span>(mylist.count(<span class="hljs-string">&quot;xiaoli&quot;</span>))<br><span class="hljs-comment"># 统计所有元素的个数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mylist))<br><span class="hljs-comment"># 清空列表</span><br>mylist.clear()<br><span class="hljs-built_in">print</span>(mylist)<br></code></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_while_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(mylist):<br>        <span class="hljs-built_in">print</span>(mylist[index])<br>        index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 使用for循环遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_for_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> mylist:<br>        <span class="hljs-built_in">print</span>(element)<br><br>list_while_func()<br>list_for_func()<br></code></pre></td></tr></table></figure><hr><h2 id="5-2-元组"><a href="#5-2-元组" class="headerlink" title="5.2 元组"></a>5.2 元组</h2><p>元组不可修改，支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义元组</span><br>t1 = (<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义空元祖</span><br>t2 = ()<br>t3 = <span class="hljs-built_in">tuple</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t1的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t1)&#125;</span>,内容是<span class="hljs-subst">&#123;t1&#125;</span>&quot;</span>) <span class="hljs-comment"># t1的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(2, &#x27;Hello&#x27;, True)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t2的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t2)&#125;</span>,内容是<span class="hljs-subst">&#123;t2&#125;</span>&quot;</span>) <span class="hljs-comment"># t2的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t3的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t3)&#125;</span>,内容是<span class="hljs-subst">&#123;t3&#125;</span>&quot;</span>) <span class="hljs-comment"># t3的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-comment"># 定义单个元素的元组</span><br>t4 = (<span class="hljs-string">&quot;hello&quot;</span>)<br>t5 = (<span class="hljs-string">&quot;hello&quot;</span>,)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t4的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t4)&#125;</span>,内容是<span class="hljs-subst">&#123;t4&#125;</span>&quot;</span>) <span class="hljs-comment"># t4的类型是&lt;class &#x27;str&#x27;&gt;,内容是hello</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t5的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t5)&#125;</span>,内容是<span class="hljs-subst">&#123;t5&#125;</span>&quot;</span>) <span class="hljs-comment"># t5的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(&#x27;hello&#x27;,)</span><br><span class="hljs-comment"># 元组的嵌套</span><br>t6 = ((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t6的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t6)&#125;</span>,内容是<span class="hljs-subst">&#123;t6&#125;</span>&quot;</span>) <span class="hljs-comment"># t6的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是((1, 2, 3), (4, 5, 6))</span><br><span class="hljs-comment"># 取目标索引的值</span><br><span class="hljs-built_in">print</span>(t6[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) <span class="hljs-comment"># 6</span><br><span class="hljs-comment"># index</span><br><span class="hljs-built_in">print</span>(t1.index(<span class="hljs-string">&quot;Hello&quot;</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(t1.count(<span class="hljs-literal">True</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(t1)) <span class="hljs-comment"># 3</span><br><span class="hljs-comment"># while遍历</span><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(t1):<br>    <span class="hljs-built_in">print</span>(t1[index])<br>    index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># for遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> t1:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 不可以直接修改元组中的元素 否则会报错</span><br><span class="hljs-comment"># 但是若元组中包含列表 则可以修改该列表中的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-3-集合"><a href="#5-3-集合" class="headerlink" title="5.3 集合"></a>5.3 集合</h2><p>集合中的元素不重复且内容无序 不支持按照索引访问元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;learn&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>&#125;<br>my_set_empty = <span class="hljs-built_in">set</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set_empty)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 添加新元素</span><br>my_set.add(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 移除元素</span><br>my_set.remove(<span class="hljs-string">&quot;learn&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 随机取出一个元素</span><br>element = my_set.pop()<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 统计集合中元素的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_set))<br><span class="hljs-comment"># 遍历 由于不支持索引查找元素 所以不支持while循环遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> my_set:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 清空集合</span><br>my_set.clear()<br><span class="hljs-built_in">print</span>(my_set)<br><br><span class="hljs-comment"># 集合的数学运算</span><br>set1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>set2 = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment"># 并集 &#123;1,2,3,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.union(set2))<br><span class="hljs-built_in">print</span>(set1 | set2)<br><span class="hljs-comment"># 交集 &#123;3&#125;</span><br><span class="hljs-built_in">print</span>(set1.intersection(set2))<br><span class="hljs-built_in">print</span>(set1 &amp; set2)<br><span class="hljs-comment"># 差集 &#123;1,2&#125;</span><br><span class="hljs-built_in">print</span>(set1.difference(set2))<br><span class="hljs-built_in">print</span>(set1 - set2)<br><span class="hljs-comment"># 对称差集 &#123;1,2,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.symmetric_difference(set2))<br><span class="hljs-built_in">print</span>(set1 ^ set2)<br></code></pre></td></tr></table></figure><hr><h2 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h2><p>典存储的元素是键值对 key不允许重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;黎鸿翔&quot;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&quot;xiaoli&quot;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>: <span class="hljs-number">97</span>&#125;<br>my_dict_empty = &#123;&#125;  <span class="hljs-comment"># 空字典</span><br>my_dict_empty2 = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict的内容是<span class="hljs-subst">&#123;my_dict&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty的内容是<span class="hljs-subst">&#123;my_dict_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty2的内容是<span class="hljs-subst">&#123;my_dict_empty2&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty2)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 通过key获取value</span><br>score = my_dict[<span class="hljs-string">&quot;xiaoli&quot;</span>]<br><span class="hljs-built_in">print</span>(score)<br><span class="hljs-comment"># 修改或新增</span><br>my_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>] = <span class="hljs-number">99.5</span>  <span class="hljs-comment"># key存在则修改value</span><br>my_dict[<span class="hljs-string">&quot;孙悟空&quot;</span>] = <span class="hljs-number">99.9</span>  <span class="hljs-comment"># 若key不存在则为新增</span><br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 删除</span><br>value = my_dict.pop(<span class="hljs-string">&quot;孙悟空&quot;</span>)<br><span class="hljs-built_in">print</span>(value)<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 获取全部的key</span><br>keys = my_dict.keys()<br><span class="hljs-built_in">print</span>(keys)<br><span class="hljs-comment"># 遍历字典</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------&#x27;</span>)<br><span class="hljs-comment">#     方式二:</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 方式三: 通过items()方法获取key-value对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取全部的value</span><br>values = my_dict.values()<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><span class="hljs-comment">#     长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_dict))<br><span class="hljs-comment"># 清空</span><br>my_dict.clear()<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 定义嵌套字典</span><br>stu_score_dict = &#123;<br>    <span class="hljs-string">&quot;黎鸿翔&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">97</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">110</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">107</span><br>    &#125;,<br>    <span class="hljs-string">&quot;xiaoli&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">92</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">140</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">137</span><br>    &#125;,<br>    <span class="hljs-string">&quot;Lil Pear&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">90</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">120</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">100</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(stu_score_dict)<br><span class="hljs-comment"># 取value</span><br><span class="hljs-built_in">print</span>(stu_score_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>][<span class="hljs-string">&quot;数学&quot;</span>])<br></code></pre></td></tr></table></figure><hr><h2 id="5-5-字符串"><a href="#5-5-字符串" class="headerlink" title="5.5 字符串"></a>5.5 字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 小黎专属python固定模板</span><br><span class="hljs-comment"># 开发时间：2024/7/5 21:42</span><br><span class="hljs-comment"># 字符串不可修改，支持重复元素且有序</span><br>my_str = <span class="hljs-string">&quot;xiaoli is the best one&quot;</span><br><span class="hljs-built_in">print</span>(my_str)<br><span class="hljs-comment"># 通过索引取值</span><br><span class="hljs-built_in">print</span>(my_str[<span class="hljs-number">2</span>])<br><span class="hljs-comment"># index方法</span><br><span class="hljs-built_in">print</span>(my_str.index(<span class="hljs-string">&quot;is&quot;</span>))<br><span class="hljs-comment"># replace 替换</span><br>my_str2 = my_str.replace(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>)<br><span class="hljs-built_in">print</span>(my_str2)<br><span class="hljs-built_in">print</span>(my_str) <span class="hljs-comment">#不变</span><br><span class="hljs-comment"># split 字符串分割</span><br>mylist = my_str.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 字符串规整</span><br>my_str3 = <span class="hljs-string">&quot;  xiaoli  &quot;</span><br>my_str4 = <span class="hljs-string">&quot;12xiaoli212&quot;</span><br><span class="hljs-built_in">print</span>(my_str3.strip())<br><span class="hljs-built_in">print</span>(my_str4.strip(<span class="hljs-string">&quot;12&quot;</span>))<br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(my_str.count(<span class="hljs-string">&quot;i&quot;</span>))<br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_str))<br></code></pre></td></tr></table></figure><hr><h2 id="5-6-序列切片"><a href="#5-6-序列切片" class="headerlink" title="5.6 序列切片"></a>5.6 序列切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">序列是指：内容连续、有序，可使用下标索引的一类数据容器</span><br><span class="hljs-string">列表、元组、字符串，均可以视为序列</span><br><span class="hljs-string">切片就是从一个序列中取出一个子序列</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>mytuple = (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>mystr = <span class="hljs-string">&quot;0123456&quot;</span><br><span class="hljs-comment"># 对列表进行切片，从1开始，4结束(不含索引4对应的元素)，步长为1(默认为1可不写)</span><br>mylist2 = mylist[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(mylist2)<br><span class="hljs-comment"># 对元组进行切片，从头开始到尾结束，步长为1</span><br>mytuple2 = mytuple[:]<br><span class="hljs-built_in">print</span>(mytuple2)<br><span class="hljs-comment"># 对字符串进行切片，从头开始到尾结束，步长为2</span><br>mystr2 = mystr[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(mystr):<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr2)<br><br><span class="hljs-comment"># 也可以反向取</span><br><span class="hljs-comment"># 对列表进行切片，从头开始到尾结束，步长为-1</span><br>mylist3 = mylist[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mylist3)<br><span class="hljs-comment"># 对元组进行切片，从3开始到1结束，步长为-1</span><br>mytuple3 = mytuple[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mytuple3)<br><span class="hljs-comment"># 对字符串进行切片 从头开始到尾结束步长为-2</span><br>mystr3 = mystr[::-<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr3)<br></code></pre></td></tr></table></figure><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="6-1-文件读取"><a href="#6-1-文件读取" class="headerlink" title="6.1 文件读取"></a>6.1 文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f))<br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-comment"># print(f.read(9))  # 读取9个字节的内容</span><br><span class="hljs-comment"># print(f.read())</span><br><span class="hljs-comment"># io_list = f.readlines()  # 读取文件的全部行并存到列表中</span><br><span class="hljs-comment"># print(io_list)</span><br><br><span class="hljs-comment"># for line in f.readlines():</span><br><span class="hljs-comment">#     print(line)</span><br><br><span class="hljs-comment"># 读取每行数据</span><br><span class="hljs-comment"># line1 = f.readline()</span><br><span class="hljs-comment"># line2 = f.readline()</span><br><span class="hljs-comment"># line3 = f.readline()</span><br><span class="hljs-comment"># print(line1)</span><br><span class="hljs-comment"># print(line2)</span><br><span class="hljs-comment"># print(line3)</span><br><br><span class="hljs-comment"># for循环读取文件行</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>    <span class="hljs-built_in">print</span>(line.split(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-comment"># print(io_list)</span><br><span class="hljs-comment"># 文件的关闭</span><br>f.close()<br></code></pre></td></tr></table></figure><hr><h2 id="6-2-文件写入"><a href="#6-2-文件写入" class="headerlink" title="6.2 文件写入"></a>6.2 文件写入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件不存在时会创建新文件并写入内容 若文件存在则清空原有的内容并写入新内容 若要追加 则调整为a模式</span><br>f1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f1.write(<span class="hljs-string">&quot;你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f2.write(<span class="hljs-string">&quot;\n你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f1.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f2.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><br><span class="hljs-comment"># 捕获指定的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(name)<br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义的异常&quot;</span>)<br><br><span class="hljs-comment"># 捕获多个类型的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># print(name)</span><br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> (NameError,ZeroDivisionError) <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义或者除以0的异常&quot;</span>)<br><br><span class="hljs-comment"># finally 一定会执行的语句</span><br><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment">#     捕获全部异常的第二种写法</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;好高兴，无异常&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一定会执行finally中的语句&quot;</span>)<br>    f.close()<br></code></pre></td></tr></table></figure><hr><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用（导入模块去使用）</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/image1.png" class="" title="模块"><p>常用的组合形式如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 类、变量、方法等<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 别名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能名 <span class="hljs-keyword">as</span> 别名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种写法</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br><br><span class="hljs-comment"># 第二种写法</span><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br></code></pre></td></tr></table></figure><p>自定义模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a + b)<br><br><span class="hljs-comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> my_module1<br><br>my_module1.test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如，在my_module1.py文件中添加测试代码test(1,1).此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>test</code>函数的调用</p><p>注意事项：当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能</p><p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素</p><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>从物理上看，包就是一个文件夹，在该文件夹下包含了一个 <strong>init</strong>.py 文件，该文件夹可用于包含多个模块文件</p><p>从逻辑上看，包的本质依然是模块</p><p>当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/package.png" class="" title="包"><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-keyword">import</span> 包名.模块名</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">包名.模块名.目标</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础</title>
    <link href="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">目标：学会使用注释</span><br><span class="hljs-comment">     这是程序的讲解注释</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoteDemo</span>&#123;<br>    <span class="hljs-comment">//这是程序的主方法，是程序的入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我开始学习Java程序，好嗨皮~~&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        窗前明月光</span><br><span class="hljs-comment">        疑是地上霜</span><br><span class="hljs-comment">        举头望明月</span><br><span class="hljs-comment">        低头思故乡</span><br><span class="hljs-comment">        */</span><br>        System.out.println(<span class="hljs-string">&quot;播仔&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;deli&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-字面量"><a href="#1-2-字面量" class="headerlink" title="1.2 字面量"></a>1.2 字面量</h2><p>字面量其实就是告诉程序员数据在程序中的书写格式。下面是常用的数据在程序中的书写格式</p><img src="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/image1.png" class="" title="字面量"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">目标：需要同学们掌握常见数据在程序中的书写格式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiteralDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.整数</span><br>        System.out.println(<span class="hljs-number">666</span>);<br>        <br>        <span class="hljs-comment">//2.小数</span><br>        System.out.println(<span class="hljs-number">3.66</span>);<br>        <br>        <span class="hljs-comment">//3.字符: 字符必须用单引号引起来</span><br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;中&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//空格也算字符</span><br>        <span class="hljs-comment">//特殊字符：\t表示制表符 \n表示换行</span><br>        System.out.println(<span class="hljs-string">&#x27;\t&#x27;</span>); <span class="hljs-comment">//这相当于一个tab键，专业叫做制表符</span><br>        System.out.println(<span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">//这是换行的意思</span><br>        <br>        <span class="hljs-comment">//4.字符串：字符串是双引号引起来的</span><br>        System.out.println(<span class="hljs-string">&quot;我爱你中国abc&quot;</span>);<br>        <br>        <span class="hljs-comment">//5.布尔值：只有两个值true和false</span><br>        System.out.println(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>变量是用来记录程序中的数据的。其本质上是内存中的一块区域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p>当执行<code>int age = 18;</code> 这句代码时，JVM会在内存中申请一块区域，在这个区域中存储了一个整数18，给这个区域取的名字叫age； 相当于在盒子中存了一个数据18，这个盒子的名字是age，当我们打印age时，就是从盒子中把盒子中的数据取出来再打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>变量定义在哪个&#123;&#125;范围内，就只在哪个大括号内有效。变量的有效范围称之为变量的作用域<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>System.out.println(a); <span class="hljs-comment">//这是是对的</span><br>&#125;<br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">2.</span>在同一个作用域内，不能有两个同名的变量<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">//这里会出错</span><br>&#125;<br><br><span class="hljs-number">3.</span>变量没有初始化只，不能直接使用<br><span class="hljs-type">int</span> a; <span class="hljs-comment">//仅仅定义了变量，但是没有初始值</span><br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">4.</span>变量可以定义在同一行<br>如：<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>; <span class="hljs-comment">//a和b都是int类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-4-关键字"><a href="#1-4-关键字" class="headerlink" title="1.4 关键字"></a>1.4 关键字</h2><p>关键字是java语言中有特殊含义的单词。比如用int表示整数，用double表示小数，等等</p><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><hr><h2 id="1-5-标识符"><a href="#1-5-标识符" class="headerlink" title="1.5 标识符"></a>1.5 标识符</h2><p>标志符其实就是我们自己取的名字。像前面我们取的类名，变量名其实都是标志符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">强制要求：必须遵守，不遵守就会报错<br><span class="hljs-number">1.</span>最好是字母、数字、下划线、$组成<br><span class="hljs-number">2.</span>不能以数字开头<br><span class="hljs-number">3.</span>不能是Java的关键字<br><br>建议遵守：按照下面的方式取名字会显得更加专业<br><span class="hljs-number">1.</span>所有的名字要见名知意，便于自己和别人阅读<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125; <span class="hljs-comment">//一看这个类就知道表示一个学生</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span><span class="hljs-number">10</span>;    <span class="hljs-comment">//一看这个变量就知道表示年龄</span><br><br><span class="hljs-number">2.</span>类名：首字母大写（大驼峰命名）<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br><br><span class="hljs-number">3.</span>变量名：第二个单词开始首字母大写（小驼峰命名）<br>举例： <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.88</span>;  <br>  <span class="hljs-type">double</span> <span class="hljs-variable">applePrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">7.5</span>; <br></code></pre></td></tr></table></figure><hr><h1 id="类型转换、运算符"><a href="#类型转换、运算符" class="headerlink" title="类型转换、运算符"></a>类型转换、运算符</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java SE</tag>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开题准备-复习ML/DL基础知识</title>
    <link href="/2025/12/09/%E5%BC%80%E9%A2%98%E5%87%86%E5%A4%87-%E5%A4%8D%E4%B9%A0ML-DL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/12/09/%E5%BC%80%E9%A2%98%E5%87%86%E5%A4%87-%E5%A4%8D%E4%B9%A0ML-DL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>机器学习是人工智能的一个重要分支，旨在通过算法和模型使计算机从数据中学习，从而实现预测或决策。其核心目标是通过分析数据中的模式和规律，构建能够适应新数据的模型</p>]]></content>
    
    
    <categories>
      
      <category>科研经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>课程推荐</tag>
      
      <tag>图神经网络</tag>
      
      <tag>对比学习</tag>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试基础</title>
    <link href="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试理论基础"><a href="#软件测试理论基础" class="headerlink" title="软件测试理论基础"></a>软件测试理论基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>标准定义：</strong> 在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</li><li><strong>核心目的 ：</strong><ol><li><strong>发现缺陷：</strong> 尽可能早地找出软件中的Bug。</li><li><strong>评估质量：</strong> 告诉开发和产品经理，现在的软件能不能上线，风险大不大。</li><li><strong>预防风险：</strong> 通过测试反馈，帮助开发改进流程，预防同类Bug再次出现。</li></ol></li></ul><blockquote><p><strong>💡 测开视角：</strong> 作为测开，目标不仅仅是“点点点”找错，而是要**“保障交付质量”**。有时候需要开发工具来提高测试效率，这也是为了这个目标服务。</p></blockquote><h2 id="测试的“七大原则”-ISTQB-标准"><a href="#测试的“七大原则”-ISTQB-标准" class="headerlink" title="测试的“七大原则” (ISTQB 标准)"></a>测试的“七大原则” (ISTQB 标准)</h2><p>国际软件测试认证委员会 (ISTQB) 总结的原则：</p><ol><li><strong>测试显示缺陷的存在 (Testing shows the presence of defects)：</strong> 测试只能证明软件<strong>有</strong>错，不能证明软件<strong>没</strong>错。</li><li><strong>穷尽测试是不可能的 (Exhaustive testing is impossible)：</strong> 输入组合是无穷无尽的，不可能测完所有情况。所以需要<strong>设计</strong>测试用例。</li><li><strong>测试尽早介入 (Early testing)：</strong> Bug 发现得越早，修复成本越低。</li><li><strong>缺陷集群性 (Defect clustering)：</strong> 80% 的错误通常集中在 20% 的核心模块里。（二八原则，找到一个Bug的地方，通常还有更多Bug）。</li><li><strong>杀虫剂悖论 (Pesticide paradox)：</strong> 同样的测试用例如果重复运行很多次，就找不出新Bug了。需要不断更新用例，或者开发自动化脚本来应对。</li></ol><h2 id="软件开发与测试模型-V模型）"><a href="#软件开发与测试模型-V模型）" class="headerlink" title="软件开发与测试模型 (V模型）"></a>软件开发与测试模型 (V模型）</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image1.jpg" class="" title="V模型"><p><strong>V模型</strong>展示了开发阶段和测试阶段的对应关系：</p><ul><li><strong>左边是开发过程：</strong><ol><li><strong>需求分析</strong> (弄清要做什么)</li><li><strong>概要设计</strong> (系统架构设计)</li><li><strong>详细设计</strong> (具体模块&#x2F;函数设计)</li><li><strong>编码</strong> (写代码)</li></ol></li><li><strong>右边是测试过程：</strong><ol><li><strong>单元测试 (Unit Testing)：</strong> 对应<strong>编码</strong>。测最小的函数或类。通常由开发做，或者测开写单测代码。</li><li><strong>集成测试 (Integration Testing)：</strong> 对应<strong>详细设计</strong>。测模块与模块之间的接口（比如 订单模块 调 支付模块 通不通）。</li><li><strong>系统测试 (System Testing)：</strong> 对应<strong>概要设计</strong>。把软件看成一个整体来测（我们常说的功能测试、性能测试都在这）。</li><li><strong>验收测试 (Acceptance Testing)：</strong> 对应<strong>需求分析</strong>。由用户或产品经理来测，确认是否满足了最初的需求。</li></ol></li></ul><h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><h4 id="A-代码可见度划分"><a href="#A-代码可见度划分" class="headerlink" title="A. 代码可见度划分"></a>A. 代码可见度划分</h4><ul><li><strong>黑盒测试 (Black-box)：</strong> 把软件当成一个黑盒子，不看内部代码，只关心输入变成输出对不对。<ul><li><em>应用：</em> 功能测试、用户体验测试。</li></ul></li><li><strong>白盒测试 (White-box)：</strong> 打开盒子，研究里面的代码逻辑、循环、分支是否正确。<ul><li><em>应用：</em> 单元测试、代码审计。</li></ul></li><li><strong>灰盒测试 (Grey-box)：</strong> 介于两者之间，关注接口的输入输出，也关注部分内部逻辑（如数据库状态）。<ul><li><em>应用：</em> <strong>接口测试</strong></li></ul></li></ul><h4 id="B-按是否运行程序分"><a href="#B-按是否运行程序分" class="headerlink" title="B. 按是否运行程序分"></a>B. 按是否运行程序分</h4><ul><li><strong>静态测试：</strong> 不运行程序。比如：检查文档、Review代码（代码走查）。</li><li><strong>动态测试：</strong> 运行程序，看实际结果。平时做的绝大多数测试都是动态的。</li></ul><h4 id="C-按测试属性分-专项测试"><a href="#C-按测试属性分-专项测试" class="headerlink" title="C. 按测试属性分 (专项测试)"></a>C. 按测试属性分 (专项测试)</h4><ul><li><strong>功能测试：</strong> 点点点，验证功能对不对。</li><li><strong>性能测试：</strong> 测快不快（响应时间）、能不能抗住（并发量）。</li><li><strong>安全测试：</strong> 测有没有漏洞（SQL注入、XSS攻击）。</li><li><strong>兼容性测试：</strong> 安卓&#x2F;iOS能不能用，Chrome&#x2F;Edge能不能用。</li></ul><h2 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image2.png" class="" title="质量模型"><h4 id="1-功能性-Functional-Suitability-——-软件是否具备某方面的能力"><a href="#1-功能性-Functional-Suitability-——-软件是否具备某方面的能力" class="headerlink" title="1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力"></a>1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image3.png" class="" title="功能性"><h4 id="2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）"><a href="#2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）" class="headerlink" title="2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）"></a>2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image4.png" class="" title="性能效率"><h4 id="3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用"><a href="#3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用" class="headerlink" title="3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用"></a>3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image5.png" class="" title="兼容性"><h4 id="4-易用性-Usability-——-易学、易用、用户粘性好"><a href="#4-易用性-Usability-——-易学、易用、用户粘性好" class="headerlink" title="4. 易用性 (Usability) —— 易学、易用、用户粘性好"></a>4. 易用性 (Usability) —— 易学、易用、用户粘性好</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image6.png" class="" title="易容性"><h4 id="5-可靠性-Reliability-——-长时间运行稳定，不出现异常"><a href="#5-可靠性-Reliability-——-长时间运行稳定，不出现异常" class="headerlink" title="5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常"></a>5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image7.png" class="" title="可靠性"><h4 id="6-安全性-Security-——-敏感数据存储-传输安全"><a href="#6-安全性-Security-——-敏感数据存储-传输安全" class="headerlink" title="6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全"></a>6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image8.png" class="" title="安全性"><h4 id="7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便"><a href="#7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便" class="headerlink" title="7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便"></a>7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image9.png" class="" title="可维护性"><h4 id="8-可移植性-Portability-——-应用系统升级-数据迁移方便"><a href="#8-可移植性-Portability-——-应用系统升级-数据迁移方便" class="headerlink" title="8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便"></a>8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image10.png" class="" title="可移植性"><p>以微信为例</p><p>1.功能性：与需求数量一致，功能正确 2. 性能：响应快、占用资源少 3. 兼容性：不同设备平台正常使用 4. 易用性：用户体验好 5. 安全性：敏感信息无泄密存储有保障 6. 可靠性：持久运行无异常 7. 可移植性：升级迁移数据不丢失 8. 可维护性：出现异常恢复简单、可扩展功能、升级更新便捷</p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image11.png" class="" title="测试流程"><hr><h1 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h1><h2 id="1-什么是测试用例-Test-Case-？"><a href="#1-什么是测试用例-Test-Case-？" class="headerlink" title="1. 什么是测试用例 (Test Case)？"></a>1. 什么是测试用例 (Test Case)？</h2><p>测试用例就是一个<strong>文档化的“操作剧本”</strong>。它的核心作用是：让任何一个人拿着这份文档，都能按步骤执行，并判断系统是对是错。</p><h4 id="🧪-一个标准测试用例的解剖图"><a href="#🧪-一个标准测试用例的解剖图" class="headerlink" title="🧪 一个标准测试用例的解剖图"></a>🧪 一个标准测试用例的解剖图</h4><p>不同公司的模板（Excel&#x2F;Jira&#x2F;飞书）长相不同，但核心要素万变不离其宗：</p><ol><li><strong>用例编号 (ID):</strong> 唯一标识 (如 <code>LOGIN_001</code>)。</li><li><strong>用例标题 (Title):</strong> 一句话概括测什么 (如：<code>验证输入正确账号密码能成功登录</code>)。</li><li><strong>项目&#x2F;模块</strong></li><li><strong>预置条件 (Precondition):</strong> 执行前需要满足的环境 (如：<code>已注册账号，且网络正常</code>)。</li><li><strong>测试步骤 (Steps):</strong>  第一步做什么，第二步做什么。</li><li><strong>测试数据</strong></li><li><strong>预期结果 (Expected Result):</strong> 也是判断Bug的标准。必须明确！不能写“登录成功”，要写“跳转至首页，右上角显示用户名”。</li><li><strong>实际结果 (Actual Result):</strong> 执行测试时填写的。</li><li><strong>优先级 (Priority):</strong> P0(冒烟&#x2F;核心) &gt; P1 &gt; P2。</li></ol><blockquote><p>👨‍💻 测开视角 Pro Tip：为什么写好用例对“测开”特别重要？</p><p>因为自动化测试脚本其实就是把这些步骤翻译成代码（Python&#x2F;Java）。如果用例逻辑不通，代码根本写不出来。</p></blockquote><hr><h2 id="2-为什么需要设计方法？"><a href="#2-为什么需要设计方法？" class="headerlink" title="2. 为什么需要设计方法？"></a>2. 为什么需要设计方法？</h2><p>穷尽测试是不可能的。比如一个输入框要求输入 <code>1~100</code> 的整数：</p><ul><li>如果测 1, 2, 3…一直测到 100，那是<strong>蛮力</strong>，效率极低。</li><li>如果只测 50，那是<strong>碰运气</strong>。</li></ul><p>所以需要科学的方法，用<strong>最少的用例，覆盖最多的Bug</strong>。即黑盒测试的<strong>五大核心设计方法</strong>。</p><h3 id="（1）等价类划分法"><a href="#（1）等价类划分法" class="headerlink" title="（1）等价类划分法"></a>（1）等价类划分法</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image12.png" class="" title="等价类划分法"><p>它的逻辑基础是：<strong>如果在这个类别中选取的一个数据通过了测试，那么这个类别中的其他数据也一定能通过</strong></p><p>在划分时，必须把数据分为两类：</p><ol><li><strong>有效等价类 (Valid Equivalence Class):</strong><ul><li>完全符合需求规格说明的数据。</li><li><strong>目的：</strong> 验证软件**“做了它该做的事情”**。</li></ul></li><li><strong>无效等价类 (Invalid Equivalence Class):</strong><ul><li>不符合需求的数据（比如格式错、范围错、类型错）。</li><li><strong>目的：</strong> 验证软件**“有错误处理能力”**（比如提示“输入错误”，而不是直接崩溃或乱码）。找Bug通常是在这里找到的！</li></ul></li></ol><p>三步走：</p><p><strong>分析需求：</strong> 找到输入条件（长度、类型、规则）。</p><p><strong>划分集合：</strong> 针对每个条件，列出“有效”和“无效”的情况。</p><p><strong>设计用例：</strong> 从每个集合中挑选 <strong>1个</strong> 代表性数据作为测试数据。设计无效用例时，每次只能破坏一个规则，保证其他规则是正确的</p><hr><p>案例:某电商网站的“修改密码”功能，新密码长度限制为 <strong>8 到 16 位</strong> 的字符,并且必须包含 <strong>大写字母</strong> + <strong>小写字母</strong> + <strong>数字</strong></p><h4 id="1-划分等价类表"><a href="#1-划分等价类表" class="headerlink" title="1. 划分等价类表"></a>1. 划分等价类表</h4><table><thead><tr><th><strong>输入条件</strong></th><th><strong>有效等价类 (合法 - 预期成功)</strong></th><th><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td><strong>长度 (8~16)</strong></td><td>1. 长度在 8~16 之间   <em>(例如选个中间值：10位)</em></td><td>2. 长度 &lt; 8   *(例如：5位)*   3. 长度 &gt; 16   <em>(例如：20位)</em></td></tr><tr><td><strong>规则 (组合)</strong></td><td>4. 同时包含大写+小写+数字</td><td>5. 缺少大写字母   6. 缺少小写字母   7. 缺少数字   8. 为空   9. 包含非法字符(如汉字&#x2F;空格)</td></tr></tbody></table><h4 id="2-挑选测试用例-Sample"><a href="#2-挑选测试用例-Sample" class="headerlink" title="2. 挑选测试用例 (Sample)"></a>2. 挑选测试用例 (Sample)</h4><p>挑选最具代表性的数据：</p><ul><li><strong>【这条必须过】(有效长度+有效规则):</strong><ul><li><code>Netease163</code> (10位，含大写N、小写、数字) -&gt; <strong>预期：通过</strong></li></ul></li><li><strong>【测长度无效】:</strong><ul><li><code>Test1</code> (5位，长度过短) -&gt; <strong>预期：报错“密码长度不足”</strong></li><li><code>Netease123456789000</code> (20位，长度过长) -&gt; <strong>预期：报错“密码过长”</strong></li></ul></li><li><strong>【测规则无效 - 控制变量法】:</strong><ul><li><code>netease163</code> (缺大写) -&gt; <strong>预期：报错“需包含大写字母”</strong></li><li><code>NETEASE163</code> (缺小写) -&gt; <strong>预期：报错“需包含小写字母”</strong></li><li><code>NeteaseTest</code> (缺数字) -&gt; <strong>预期：报错“需包含数字”</strong></li><li>空字符</li><li>非法字符</li></ul></li></ul><hr><h3 id="（2）边界值分析法"><a href="#（2）边界值分析法" class="headerlink" title="（2）边界值分析法"></a>（2）边界值分析法</h3><p>如果代码不小心写成 <code>if (length &gt; 8 &amp;&amp; length &lt; 16)</code>，那么输入 8 和 16 都会报错，这时候只用等价类划分可能无法发现这个错误</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image13.png" class="" title="边界值分析法"><p><strong>边界值分析法</strong>就是专门针对输入范围的<strong>边缘</strong>进行测试的方法</p><h4 id="关键概念：上点、离点、内点"><a href="#关键概念：上点、离点、内点" class="headerlink" title="关键概念：上点、离点、内点"></a>关键概念：上点、离点、内点</h4><p>假设需求是输入范围：<strong>[1, 100]</strong> （包含1和100）。</p><ol><li><strong>上点 (On Point)：</strong> 边界上的点。<ul><li>也就是 <strong>1</strong> 和 <strong>100</strong>。</li><li><em>(在此例中，它们是<strong>有效</strong>的)</em></li></ul></li><li><strong>离点 (Off Point)：</strong> 离边界最近的那个点。<ul><li>也就是 <strong>0</strong> 和 <strong>101</strong>。</li><li><em>(在此例中，它们是<strong>无效</strong>的)</em></li></ul></li><li><strong>内点 (Interior Point)：</strong> 范围内的任意一点。<ul><li>比如 <strong>50</strong>。</li></ul></li></ol><p><strong>等价类</strong>和<strong>边界值</strong>一般都是<strong>同时使用</strong>的</p><hr><p>以上述的案例为例：</p><p>这种方法在方案一的基础上，对“长度”这个条件进行了<strong>极致的精确打击</strong>。因为程序员最容易把 <code>&gt;8</code> 写成 <code>&gt;=8</code>，或者把 <code>16</code> 写成 <code>15</code>。</p><h4 id="1-确定边界点"><a href="#1-确定边界点" class="headerlink" title="1. 确定边界点"></a>1. 确定边界点</h4><ul><li><strong>有效范围：</strong> [8, 16]</li><li><strong>上点 (有效边界)：</strong> 8, 16</li><li><strong>离点 (无效边界)：</strong> 7, 17</li><li><strong>内点 (有效中间)：</strong> 10 (或任意8-16之间的数)</li></ul><h4 id="2-设计测试用例-高能部分"><a href="#2-设计测试用例-高能部分" class="headerlink" title="2. 设计测试用例 (高能部分)"></a>2. 设计测试用例 (高能部分)</h4><p>在设计边界值用例时，<strong>内容规则必须是正确的（大写+小写+数字）</strong>，这样才能确保报错唯一原因是“长度不对”。</p><p><strong>针对“长度”的边界测试：</strong></p><ol><li><strong>【最小无效边界 - 7位】 (关键):</strong><ul><li>输入：<code>Abcdef1</code></li><li>说明：7位，规则满足。</li><li><strong>预期：失败</strong> (刚好不够长)</li></ul></li><li><strong>【最小有效边界 - 8位】 (关键):</strong><ul><li>输入：<code>Abcdefg1</code></li><li>说明：8位，规则满足。</li><li><strong>预期：成功</strong> (刚好够长，测是否写了<code>&gt;8</code>导致8失败)</li></ul></li><li><strong>【中间任意值】:</strong><ul><li>输入：<code>Abcdefg123</code></li><li>说明：10位。</li><li><strong>预期：成功</strong> (日常功能验证)</li></ul></li><li><strong>【最大有效边界 - 16位】 (关键):</strong><ul><li>输入：<code>Abcdefghij123456</code></li><li>说明：16位，规则满足。</li><li><strong>预期：成功</strong></li></ul></li><li><strong>【最大无效边界 - 17位】 (关键):</strong><ul><li>输入：<code>Abcdefghij1234567</code></li><li>说明：17位，规则满足。</li><li><strong>预期：失败</strong> (刚好溢出)</li></ul></li></ol><p><strong>针对“规则”的等价类测试 (同方案一，补充测试):</strong></p><ol><li><strong>【缺大写】:</strong> <code>abcdefg1</code> (8位，满足长度，破坏规则) -&gt; <strong>失败</strong></li><li><strong>【缺小写】:</strong> <code>ABCDEFG1</code> -&gt; <strong>失败</strong></li><li><strong>【缺数字】:</strong> <code>Abcdefgh</code> -&gt; <strong>失败</strong></li><li><strong>【其他非法】:</strong> 空值、空格、中文等。</li></ol><hr><h3 id="（3）判定表法"><a href="#（3）判定表法" class="headerlink" title="（3）判定表法"></a>（3）判定表法</h3><p>判定表法是专门用来处理<strong>多条件组合逻辑</strong>的工具。它能帮你把所有可能的“条件组合”都列出来，确保每一种逻辑分支（True&#x2F;False 组合）都被测到。</p><ul><li><strong>条件桩 (Condition Stub):</strong> 列出问题的所有<strong>输入条件</strong>（例如：是否VIP、金额是否&gt;100）。</li><li><strong>动作桩 (Action Stub):</strong> 列出可能采取的所有<strong>操作&#x2F;结果</strong>（例如：打8折、不打折、包邮）。</li><li><strong>条件项 (Condition Entry):</strong> 填入真假值（True&#x2F;False 或 Yes&#x2F;No），列出所有可能的<strong>组合</strong>。</li><li><strong>动作项 (Action Entry):</strong> 根据每一列的条件组合，勾选出对应的<strong>结果</strong>。</li></ul><p><strong>需求场景：</strong> 某电商网站规定：如果订单金额 <strong>大于 99 元</strong>，<strong>或者</strong> 用户是 <strong>VIP会员</strong>，则享受 <strong>“免运费”</strong> 服务；否则需要 <strong>“支付运费”</strong>。</p><table><thead><tr><th align="center"><strong>组成部分</strong></th><th align="center"><strong>规则 1</strong></th><th align="center"><strong>规则 2</strong></th><th align="center"><strong>规则 3</strong></th><th align="center"><strong>规则 4</strong></th></tr></thead><tbody><tr><td align="center"><strong>【条件桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">C1: 金额 &gt; 99元</td><td align="center"><strong>Y</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center">C2: 是 VIP</td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center"><strong>【动作桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">A1: 免运费</td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"></td></tr><tr><td align="center">A2: 支付运费</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><strong>✔</strong></td></tr></tbody></table><p>根据上面的表格，直接就能写出 4 条测试用例：</p><ol><li><strong>用例1:</strong> 购买 200元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例2:</strong> 购买 200元，非 VIP -&gt; 预期：免运费。</li><li><strong>用例3:</strong> 购买 50元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例4:</strong> 购买 50元，非 VIP -&gt; 预期：支付运费。</li></ol><h3 id="（4）场景图"><a href="#（4）场景图" class="headerlink" title="（4）场景图"></a>（4）场景图</h3><p>把软件运行想象成用户在走一条路。</p><ul><li><strong>基本流 (Basic Flow):</strong> 也叫“快乐路径” (Happy Path)。一切顺利，没有任何报错，用户最想走的那个流程。</li><li><strong>备选流 (Alternative Flow):</strong> 也就是异常流程。走到半路出了岔子（密码错了、没钱了、网断了），程序怎么处理？</li></ul><p>练习流程图工具：visio、processon</p><h4 id="案例-ATM"><a href="#案例-ATM" class="headerlink" title="案例-ATM"></a>案例-ATM</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image14.png" class="" title="ATM流程图"><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image15.png" class="" title="路径"><h5 id="1-基本流-The-Happy-Path"><a href="#1-基本流-The-Happy-Path" class="headerlink" title="1. 基本流 (The Happy Path)"></a>1. 基本流 (The Happy Path)</h5><p>这是最顺畅的一条路，也就是图中中间那一列直直往下走的路。</p><ul><li><strong>路径：</strong> 插入银行卡 -&gt; 验证成功 -&gt; 输入密码 -&gt; 验证正确 -&gt; 选择取款 -&gt; 验证账户余额(足) -&gt; 验证取款金额(对) -&gt; 验证ATM余额(足) -&gt; 出钞 -&gt; <strong>[结束]</strong>。</li><li><strong>对应图中下方的文字：</strong> <code>6、开始-&gt;验证银行卡成功-&gt;...-&gt;取款成功-&gt;结束</code>。</li><li><strong>意义：</strong> 证明ATM机“能用”。</li></ul><h5 id="2-备选流-The-Sad-Paths"><a href="#2-备选流-The-Sad-Paths" class="headerlink" title="2. 备选流 (The Sad Paths)"></a>2. 备选流 (The Sad Paths)</h5><p>这是你在每一个“菱形判断框”遇到红灯（No&#x2F;False）时拐弯走的路。顺着图一个一个找：</p><ul><li><strong>拐弯点 1 (验证银行卡):</strong> 验证不成功 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>1</code>。</li></ul></li><li><strong>拐弯点 2 (验证密码):</strong> 这是一个特殊的<strong>循环结构</strong>。<ul><li>不正确 -&gt; 提示错误 -&gt; 判断到3次了吗？</li><li><strong>没有到3次</strong> -&gt; 箭头指回“输入密码” (让用户重输)。</li><li><strong>到了3次</strong> -&gt; 吞卡 -&gt; <strong>[结束]</strong>。</li><li>这就是路径 <code>2</code>。</li></ul></li><li><strong>拐弯点 3 (验证账户余额):</strong> 不满足 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>3</code>。</li></ul></li><li><strong>拐弯点 4 (验证取款金额):</strong> 不满足 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>4</code>。</li></ul></li><li><strong>拐弯点 5 (验证ATM余额):</strong> 不够用 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>5</code>。</li></ul></li></ul><p><strong>总结：</strong> 通过对着这张图“顺藤摸瓜”，一共摸出了 <strong>6条</strong> 唯一的路径（1条成功 + 5条失败）。</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image16.png" class="" title="ATM测试用例"><hr><h3 id="（5）错误猜测法"><a href="#（5）错误猜测法" class="headerlink" title="（5）错误猜测法"></a>（5）错误猜测法</h3><p>基于你以前见过的 Bug，去“猜”这个程序哪里可能坏掉。通常作为最后一步的<strong>补充测试</strong></p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image17.png" class="" title="错误猜测法"><hr><p>在实际工作中，不要割裂使用，要像打组合拳一样：</p><ol><li>拿到功能，先用 <strong>场景法</strong> 搞清楚业务流程（基本流+备选流）。</li><li>针对流程中的每一个输入框（比如金额、密码），用 <strong>等价类</strong> + <strong>边界值</strong> 设计具体数据。</li><li>如果有复杂的逻辑判断（比如满减、VIP），用 <strong>判定表</strong> 理清逻辑。</li><li>最后，用 <strong>错误猜测法</strong> 搞点破坏，查漏补缺。</li></ol><hr><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>$$<br>Bug &#x3D; 实际结果 (Actual Result) \neq 预期结果 (Expected Result)<br>$$</p><p>软件中存在的各种问题，都为缺陷，简称bug；</p><h2 id="Bug的生命周期"><a href="#Bug的生命周期" class="headerlink" title="Bug的生命周期"></a>Bug的生命周期</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image18.png" class="" title="Bug的生命周期"><p>Bug 的生命周期，就是**“从被发现，到最终被消灭”<strong>的全过程。这中间会经历不同的</strong>状态 (Status)**。</p><h3 id="🔄-标准流程（Happy-Path）"><a href="#🔄-标准流程（Happy-Path）" class="headerlink" title="🔄 标准流程（Happy Path）"></a>🔄 标准流程（Happy Path）</h3><p>这是最顺利的情况，Bug 被发现并成功修复。</p><ol><li><strong>New (新建):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 你发现了Bug，提交到系统里。</li><li><strong>含义：</strong> “嘿，我发现了个问题，待认领。”</li></ul></li><li><strong>Open (打开&#x2F;确认):</strong><ul><li><strong>谁做：</strong> 开发人员（老王）或 测试组长。</li><li><strong>动作：</strong> 开发看到了单子，确认这确实是个Bug，准备开始修。</li><li><strong>含义：</strong> “收到，确实是问题，我开始干活了。”</li></ul></li><li><strong>Fixed &#x2F; Resolved (已修复&#x2F;已解决):</strong><ul><li><strong>谁做：</strong> 开发人员。</li><li><strong>动作：</strong> 代码改好了，开发在系统上点“已修复”。</li><li><strong>含义：</strong> “我改完了，你（测试）去验证一下吧。”</li></ul></li><li><strong>Verified (已验证):</strong><ul><li><strong>谁做：</strong> 测试人员（你）。</li><li><strong>动作：</strong> 你拿到新版本，重新测了一遍，发现真的修好了。</li><li><strong>含义：</strong> “验货通过，没问题了。”</li><li><em>(注：有的公司会跳过这个状态直接Closed，但在严谨流程中，验证是独立动作)</em></li></ul></li><li><strong>Closed (关闭):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 关闭这个Bug单。</li><li><strong>含义：</strong> “此案终结，归档。”</li></ul></li></ol><hr><h4 id="⚠️-异常流程（扯皮与返工）"><a href="#⚠️-异常流程（扯皮与返工）" class="headerlink" title="⚠️ 异常流程（扯皮与返工）"></a>⚠️ 异常流程（扯皮与返工）</h4><ol><li><strong>Reopen (重新打开):</strong><ul><li><strong>场景：</strong> 开发说“修好了” (Fixed)，结果你去验证 (Verify) 发现<strong>还是没好</strong>，或者<strong>引发了新Bug</strong>。</li><li><strong>动作：</strong> 你把状态从 Fixed 改为 Reopen，打回给开发。</li><li><strong>含义：</strong> “老王，你没修好啊，重来！”</li></ul></li><li><strong>Rejected (拒绝):</strong><ul><li><strong>场景：</strong> 开发觉得这不是Bug（比如是你环境配错了，或者需求理解不一致，或者就是“特性不是Bug”）。</li><li><strong>含义：</strong> “这不是我的锅，驳回。”</li><li><em>应对：这时需要找产品经理（PM）来做裁判。</em></li></ul></li><li><strong>Duplicate (重复):</strong><ul><li><strong>场景：</strong> 你提的Bug，别的测试同事昨天已经提过了。</li><li><strong>含义：</strong> “重复单子，关掉其中一个。”</li></ul></li><li><strong>Deferred &#x2F; Postponed (延期):</strong><ul><li><strong>场景：</strong> Bug确实存在，但上线时间紧，这个Bug影响不大（比如一个像素的偏差），决定放到下一个版本再修。</li><li><strong>含义：</strong> “承认问题，但暂不修复，下期再说。”</li></ul></li></ol><hr><h2 id="Bug的管理"><a href="#Bug的管理" class="headerlink" title="Bug的管理"></a>Bug的管理</h2><h3 id="Bug-的核心要素"><a href="#Bug-的核心要素" class="headerlink" title="Bug 的核心要素"></a>Bug 的核心要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image19.png" class="" title="Bug的核心要素"><h3 id="Bug-的提交要素"><a href="#Bug-的提交要素" class="headerlink" title="Bug 的提交要素"></a>Bug 的提交要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image20.png" class="" title="Bug的提交要素"><h3 id="常用管理工具"><a href="#常用管理工具" class="headerlink" title="常用管理工具"></a>常用管理工具</h3><ul><li><strong>Jira:</strong> 全球最通用的项目管理工具，大厂常用。</li><li><strong>禅道 (ZenTao):</strong> 国内中小厂非常流行，集成了用例管理和Bug管理。</li><li><strong>Tapd:</strong> 腾讯出的，很多互联网公司也在用。</li><li><strong>Excel:</strong> 虽然原始，但有些小项目确实还在用 Excel 记 Bug。</li></ul><h3 id="Bug-的等级：严重程度-vs-优先级"><a href="#Bug-的等级：严重程度-vs-优先级" class="headerlink" title="Bug 的等级：严重程度 vs 优先级"></a>Bug 的等级：严重程度 vs 优先级</h3><p><strong>“严重程度高的Bug，优先级一定高吗？”</strong></p><h4 id="A-严重程度-Severity-——-技术视角"><a href="#A-严重程度-Severity-——-技术视角" class="headerlink" title="A. 严重程度 (Severity) —— 技术视角"></a>A. 严重程度 (Severity) —— 技术视角</h4><p>代表这个 Bug 对软件功能的破坏程度。</p><ul><li><strong>S1 (致命):</strong> 系统崩溃、数据丢失、核心功能瘫痪（如无法支付）。</li><li><strong>S2 (严重):</strong> 主要功能出错（如算错钱、逻辑错误），但系统没崩。</li><li><strong>S3 (一般):</strong> 次要功能错误（如提示语模糊、界面布局微调）。</li><li><strong>S4 (轻微):</strong> 建议性问题（如字体不好看、个别错别字）。</li></ul><h4 id="B-优先级-Priority-——-业务视角"><a href="#B-优先级-Priority-——-业务视角" class="headerlink" title="B. 优先级 (Priority) —— 业务视角"></a>B. 优先级 (Priority) —— 业务视角</h4><p>代表开发需要<strong>多快</strong>去修这个 Bug。</p><ul><li><strong>P0 (立即):</strong> 现在、马上、停下手头所有事去修（通常针对阻碍测试进行的Bug）。</li><li><strong>P1 (高):</strong> 下个版本发布前必须修好。</li><li><strong>P2 (中):</strong> 发布前最好修好，修不完可以延期。</li><li><strong>P3 (低):</strong> 有空再修，或者不修。</li></ul><p><strong>问：</strong> “有没有 <strong>严重程度很高</strong>，但 <strong>优先级很低</strong> 的情况？或者反过来？” <strong>答：</strong> 有！</p><ol><li><strong>高严重 + 低优先级：</strong><ul><li><em>例子：</em> 一个会让APP崩溃的Bug，但它只发生在 <strong>iPhone 6 (很久远的机型)</strong> 上，而公司决定下个月就停止支持 iPhone 6 了。虽然崩溃很严重，但修它的优先级很低。</li></ul></li><li><strong>低严重 + 高优先级：</strong><ul><li><em>例子：</em> 公司首页的 Logo 颜色配错了（甚至带了竞争对手的颜色），或者有一句骂人的文案。</li><li><em>分析：</em> 技术上这只是换张图、改个字，完全不影响功能使用（严重度极低）。但这对公司形象影响巨大，必须立刻、马上修好（优先级极高）。</li></ul></li></ol><hr><h1 id="补充-白盒测试方法"><a href="#补充-白盒测试方法" class="headerlink" title="补充-白盒测试方法"></a>补充-白盒测试方法</h1><p>白盒测试的核心思想是：穷尽代码内部的逻辑路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 案例：电商打折逻辑</span><br><span class="hljs-comment"># 如果 消费金额 &gt; 1000 并且 是VIP用户，那么打8折</span><br><span class="hljs-comment"># 如果 消费金额 &gt; 500  或者 是老用户，那么打9折</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_discount</span>(<span class="hljs-params">amount, is_vip, is_old_user</span>):<br>    <span class="hljs-comment"># 判定 A</span><br>    <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">1000</span> <span class="hljs-keyword">and</span> is_vip:<br>        discount = <span class="hljs-number">0.8</span><br>    <span class="hljs-comment"># 判定 B</span><br>    <span class="hljs-keyword">elif</span> amount &gt; <span class="hljs-number">500</span> <span class="hljs-keyword">or</span> is_old_user:<br>        discount = <span class="hljs-number">0.9</span><br>    <span class="hljs-keyword">else</span>:<br>        discount = <span class="hljs-number">1.0</span><br>    <br>    <span class="hljs-keyword">return</span> discount<br></code></pre></td></tr></table></figure><hr><h3 id="1-语句覆盖-Statement-Coverage-——-最弱-🥉"><a href="#1-语句覆盖-Statement-Coverage-——-最弱-🥉" class="headerlink" title="1. 语句覆盖 (Statement Coverage) —— 最弱 🥉"></a>1. 语句覆盖 (Statement Coverage) —— 最弱 🥉</h3><ul><li><strong>定义：</strong> 设计足够多的用例，保证<strong>每一行代码都至少被执行一次</strong>。</li><li><strong>如何做：</strong><ul><li>用例 1：<code>amount=2000, is_vip=True</code> (走到 0.8 折，覆盖了 line 6-7)</li><li>用例 2：<code>amount=600, is_vip=False</code> (走到 0.9 折，覆盖了 line 9-10)</li><li>用例 3：<code>amount=100, is_vip=False, is_old_user=False</code> (走到无折扣，覆盖 line 12)</li></ul></li><li><strong>缺点：</strong> 它的覆盖度最低。比如第一个判断 <code>amount &gt; 1000 and is_vip</code>，如果代码逻辑错写成了 <code>or</code>，语句覆盖也能通过，根本发现不了逻辑错误。</li></ul><h3 id="2-判定覆盖-分支覆盖-Decision-Branch-Coverage-——-标准-🥈"><a href="#2-判定覆盖-分支覆盖-Decision-Branch-Coverage-——-标准-🥈" class="headerlink" title="2. 判定覆盖 &#x2F; 分支覆盖 (Decision&#x2F;Branch Coverage) —— 标准 🥈"></a>2. 判定覆盖 &#x2F; 分支覆盖 (Decision&#x2F;Branch Coverage) —— 标准 🥈</h3><ul><li><strong>定义：</strong> 保证每个 <strong><code>if</code></strong> 语句的 <strong>True</strong> 和 <strong>False</strong> 两个分支都至少被执行一次。</li><li><strong>关注点：</strong> 不关心 <code>if</code> 里面的条件细节，只关心 <code>if</code> 整体的结果是真还是假。</li><li><strong>针对判定 A (<code>amount &gt; 1000 and is_vip</code>)：</strong><ul><li>需要一个 <code>True</code> 的用例（比如：2000, True）。</li><li>需要一个 <code>False</code> 的用例（比如：200, True）。</li></ul></li><li><strong>缺点：</strong> 它把 <code>and</code> 里面的条件当成一个整体。如果 <code>amount &gt; 1000</code> 这个子条件写错了，只要整体结果凑巧对了，测试也就过了。</li></ul><h3 id="3-条件覆盖-Condition-Coverage-——-细节"><a href="#3-条件覆盖-Condition-Coverage-——-细节" class="headerlink" title="3. 条件覆盖 (Condition Coverage) —— 细节"></a>3. 条件覆盖 (Condition Coverage) —— 细节</h3><ul><li><strong>定义：</strong> 不管 <code>if</code> 整体怎么样，我要保证每个<strong>原子条件</strong>（Atomic Condition）的真假都被测到。</li><li><strong>拆解原子条件：</strong><ol><li><code>amount &gt; 1000</code> (取真、取假)</li><li><code>is_vip</code> (取真、取假)</li><li><code>amount &gt; 500</code> (取真、取假)</li><li><code>is_old_user</code> (取真、取假)</li></ol></li><li><strong>如何做：</strong> 设计用例，让上面 4 个小条件分别出现 True 和 False。</li><li><strong>缺点：</strong> 有时候你覆盖了所有小条件的真假，但可能凑不出 <code>if</code> 整体为 True 的情况（虽然概率小，但逻辑上存在）。</li></ul><h3 id="4-路径覆盖-Path-Coverage-——-最强-🥇"><a href="#4-路径覆盖-Path-Coverage-——-最强-🥇" class="headerlink" title="4. 路径覆盖 (Path Coverage) —— 最强 🥇"></a>4. 路径覆盖 (Path Coverage) —— 最强 🥇</h3><ul><li><strong>定义：</strong> 覆盖程序中<strong>所有可能的执行路径</strong>。这是最彻底的测试。</li><li><strong>如何做：</strong> 我们需要画出<strong>控制流图 (Control Flow Graph)</strong>，找出从“开始”到“结束”的所有路线。</li><li><strong>针对案例的路径：</strong><ol><li>路径 1：判定A(真)-&gt;结束</li><li>路径 2：判定A(假)-&gt;判定B(真-&gt;结束</li><li>路径 3：判定A(假) -&gt; 判定B(假) -&gt; 结束</li></ol></li><li><strong>现实中的大坑：</strong> 如果代码里有 <strong>循环 (Loop)</strong>（比如 <code>while</code> 循环 1000 次），路径数量就是天文数字（无穷多），根本测不完。所以通常把循环简化为“执行0次、1次、N次”。</li></ul><hr><h3 id="5-圈复杂度-Cyclomatic-Complexity"><a href="#5-圈复杂度-Cyclomatic-Complexity" class="headerlink" title="5. 圈复杂度 (Cyclomatic Complexity)"></a>5. 圈复杂度 (Cyclomatic Complexity)</h3><p>问：“你怎么判断这段代码难不难测？”</p><p>答：“我会看它的圈复杂度。”</p><ul><li><p><strong>定义：</strong> 衡量代码逻辑复杂程度的一个指标。</p></li><li><p>简单计算公式：</p><p>判定节点数 + 1</p><p>(通俗点说：代码里有多少个 if, while, case, &amp;&amp;, ||，加起来再加 1)</p></li><li><p><strong>意义：</strong></p><ul><li>圈复杂度越高，Bug 可能性越大。</li><li><strong>黄金标准：</strong> 如果一个函数的圈复杂度 <strong>&gt; 10</strong>，说明代码写得太复杂，建议开发重构，或者需要极其严格的测试。</li></ul></li></ul><hr><p>问：“你平时用白盒测试吗？” 答：</p><blockquote><p>“虽然单元测试主要由开发同学完成，但在我的测试工作中，我会大量运用<strong>白盒思维</strong>：</p><ol><li>在设计用例时，对于复杂逻辑，我会<strong>阅读核心代码</strong>（Code Review）来确保没有遗漏特定的逻辑分支（比如特殊的 if&#x2F;else 组合）。</li><li>执行自动化测试后，我会关注<strong>代码覆盖率</strong>，利用白盒工具发现漏测的代码块。</li><li>在定位 Bug 时，我会通过查看<strong>代码和日志</strong>来精准定位问题根源，而不仅仅是停留在 UI 报错层面。”</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>软件测试理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/08/hello-world/"/>
    <url>/2025/12/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于大语言模型的多维意图表示学习的课程推荐模型</title>
    <link href="/2025/12/08/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%84%8F%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/12/08/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%84%8F%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<img src="/2025/12/08/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%84%8F%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B/image1.png" class="" title="模型框架图"><p><strong>1. 利用大模型提取“显式意图”</strong><br>大语言模型（LLM）被用来分析课程的元数据（如标题、描述、先修关系、知识点等）以及用户的历史学习行为。大模型会将这些复杂的信息提炼成易于理解的文字描述，明确指出课程的核心价值和用户的学习目标（例如“为了求职”、“兴趣探索”或“考证准备”）。随后，这些文字通过预训练模型转化为向量，作为语义参考。</p><p><strong>2. 从行为数据中挖掘“隐式意图”</strong><br>模型采用图卷积网络（GCN）来处理用户与课程之间的交互数据。为了捕捉用户那些“无法用言语表达”的潜在动机，模型设计了一个多头自注意力机制。这个机制会将用户的行为模式与一组预设的“意图原型”进行匹配，从而识别出隐藏在行为背后的多维学习意图。</p><p><strong>3. 通过对比学习实现“意图对齐”</strong><br>这是MICR最核心的创新点。模型利用对比学习技术，将上述两种来源不同的意图进行对齐：让从行为中挖掘出的“隐式意图”向大模型生成的“显式语义意图”靠拢。这样做既能利用大模型的深度推理能力来弥补行为数据的稀疏性，又能让模型学习到的特征更具解释性。</p><p><strong>4. 融合信号进行预测</strong><br>最后，模型将协同过滤信号（行为规律）与对齐后的意图信号进行深度融合。为了提高模型的鲁棒性，还引入了类似变分自编码器的随机扰动机制。最终，模型通过计算用户表示和课程表示的相似度，生成个性化的推荐列表。</p><hr>]]></content>
    
    
    <categories>
      
      <category>科研经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>课程推荐</tag>
      
      <tag>图神经网络</tag>
      
      <tag>对比学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
