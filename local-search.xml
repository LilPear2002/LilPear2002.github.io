<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Postman学习</title>
    <link href="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="API接口测试基础"><a href="#API接口测试基础" class="headerlink" title="API接口测试基础"></a>API接口测试基础</h1><p>稳定的练习网站：<strong>JSONPlaceholder</strong>。<a href="https://jsonplaceholder.typicode.com.它模拟了一个博客系统(有帖子/">https://jsonplaceholder.typicode.com。它模拟了一个博客系统（有帖子</a> <code>posts</code>，评论 <code>comments</code>，用户 <code>users</code> 等）。</p><hr><h2 id="GET-请求-获取数据"><a href="#GET-请求-获取数据" class="headerlink" title="GET 请求 - 获取数据"></a>GET 请求 - 获取数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image1.png" class="" title="GET请求"><hr><h2 id="第二步：POST-请求（增）-提交数据"><a href="#第二步：POST-请求（增）-提交数据" class="headerlink" title="第二步：POST 请求（增）- 提交数据"></a>第二步：POST 请求（增）- 提交数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image4.png" class="" title="POST请求1"><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image5.png" class="" title="POST请求2"><hr><h2 id="第三步：PUT-请求（改）-修改数据"><a href="#第三步：PUT-请求（改）-修改数据" class="headerlink" title="第三步：PUT 请求（改）- 修改数据"></a>第三步：PUT 请求（改）- 修改数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image2.png" class="" title="PUT请求1"><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image3.png" class="" title="PUT请求2"><hr><h2 id="第四步：DELETE-请求（删）-删除数据"><a href="#第四步：DELETE-请求（删）-删除数据" class="headerlink" title="第四步：DELETE 请求（删）- 删除数据"></a>第四步：DELETE 请求（删）- 删除数据</h2><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image6.png" class="" title="DELETE请求"><hr><p>注意：在此网址进行测试POST请求和PUT请求时，JSON内容除了输入到raw中，还输入到form-data中也能测试通过</p><p>虽然在这个练习网站（JSONPlaceholder）上两者都能跑通，但在<strong>真实的实习工作中，它们是完全不同的东西</strong>。如果混用，90%的情况下后端会报错。这个问题直击了<strong>后端开发与接口测试的核心：数据传输格式（Content-Type）</strong>。：</p><h3 id="1-本质区别：数据的“包装”方式不同"><a href="#1-本质区别：数据的“包装”方式不同" class="headerlink" title="1. 本质区别：数据的“包装”方式不同"></a>1. 本质区别：数据的“包装”方式不同</h3><ul><li><strong>Raw (JSON)</strong>：就像<strong>寄一封信</strong>。内容必须按照严格的语法（JSON格式）写在纸上。它不仅能写简单的“姓名：小明”，还能写复杂的嵌套结构（比如“爱好”里包含一个列表）。</li><li><strong>Form-data</strong>：就像<strong>填一张表格</strong>，或者<strong>寄一个包裹</strong>。它是一格一格填写的（键值对）。它最大的特点是<strong>可以夹带附件（上传文件）</strong>。</li></ul><h3 id="2-细节：HTTP-Header（请求头）"><a href="#2-细节：HTTP-Header（请求头）" class="headerlink" title="2. 细节：HTTP Header（请求头）"></a>2. 细节：HTTP Header（请求头）</h3><ol><li>选中 <strong>Body</strong> -&gt; <strong>raw (JSON)</strong>，然后点击 Request 区域（中间部分）的 <strong>Headers</strong> 标签。<ul><li>Postman 自动加了一行：<code>Content-Type: application/json</code>。</li><li>这是告诉服务器：“我发给你的是 JSON 字符串。”</li></ul></li><li>选中 <strong>Body</strong> -&gt; <strong>form-data</strong>，再去 <strong>Headers</strong> 标签看。<ul><li>Postman 在发送时会加上：<code>Content-Type: multipart/form-data; boundary=...</code>。</li><li>这是告诉服务器：“我发给你的是表单数据，可能包含文件。”</li></ul></li></ol><p>而 <code>jsonplaceholder</code> 是一个<strong>模拟服务器</strong>，它的设计初衷就是为了方便大家测试，所以它非常“宽容”。它的后端逻辑大概是：“不管你给我 JSON 还是 Form-data，只要能解析出 <code>title</code> 和 <code>body</code>，我就算你成功。”</p><p><strong>但在真实开发中：</strong></p><ul><li>如果后端（例如 Java Spring Boot）代码写的是 <code>@RequestBody User user</code>，它<strong>只接受 JSON</strong>。你如果用 form-data 发送，会直接报 <strong>415 Unsupported Media Type</strong> 或者 <strong>400 Bad Request</strong>。</li><li>如果后端写的是 <code>@RequestParam</code> 或者涉及到文件上传，它才接受 form-data。</li></ul><h3 id="3-总结：什么时候用哪个？"><a href="#3-总结：什么时候用哪个？" class="headerlink" title="3. 总结：什么时候用哪个？"></a>3. 总结：什么时候用哪个？</h3><table><thead><tr><th><strong>模式</strong></th><th><strong>这里的 raw (JSON)</strong></th><th><strong>这里的 form-data</strong></th></tr></thead><tbody><tr><td><strong>全称</strong></td><td><code>application/json</code></td><td><code>multipart/form-data</code></td></tr><tr><td><strong>主要用途</strong></td><td><strong>最常用</strong>。用于发送复杂的结构化数据。</td><td>主要用于<strong>文件上传</strong>（图片、文档）。</td></tr><tr><td><strong>能否嵌套</strong></td><td>能（对象套数组，数组套对象）。</td><td>很难，通常只能是扁平的键值对。</td></tr><tr><td><strong>实习建议</strong></td><td><strong>95%的接口都用这个</strong>。</td><td>只有测“上传头像&#x2F;文件”功能时才用这个。</td></tr></tbody></table><hr><h1 id="断言验证"><a href="#断言验证" class="headerlink" title="断言验证"></a>断言验证</h1><h2 id="检查状态码"><a href="#检查状态码" class="headerlink" title="检查状态码"></a>检查状态码</h2><p>服务器是否正常响应了？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// pm.test 是定义一个测试用例，引号内是测试的名字</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;状态码必须是 200&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// pm.response.to.have.status(200) 是具体的判断逻辑</span><br>    pm.<span class="hljs-property">response</span>.<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image7.png" class="" title="状态码断言"><h2 id="检查返回数据"><a href="#检查返回数据" class="headerlink" title="检查返回数据"></a>检查返回数据</h2><p>光看状态码是不够的。有时候服务器报错也会返回 200（假成功）。需要检查内容是否对得上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 先把返回的 JSON 字符串转换成 JS 对象，方便操作</span><br><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><br><span class="hljs-comment">// 2. 编写断言</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查返回的 ID 是否为 1&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// expect(实际值).to.eql(期望值)</span><br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">id</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><br><span class="hljs-comment">// 3. 再加一个：检查 Title 是否存在（不为空）</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查 Title 字段是否存在&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">title</span>).<span class="hljs-property">to</span>.<span class="hljs-property">exist</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image8.png" class="" title="返回数据断言"><h2 id="检查响应时间"><a href="#检查响应时间" class="headerlink" title="检查响应时间"></a>检查响应时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;响应时间必须小于 500ms&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-title function_">expect</span>(pm.<span class="hljs-property">response</span>.<span class="hljs-property">responseTime</span>).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">below</span>(<span class="hljs-number">500</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image9.png" class="" title="响应时间断言"><hr><p>问：“Postman 的断言是用什么语法写的？”</p><p>回答：是基于 JavaScript 的，使用了 Chai Assertion Library (Chai 断言库) 的语法，比如 pm.expect().to.eql()。</p><p>问“你在 Postman 中怎么验证接口返回数据的正确性？”</p><p>回答：使用 <code>pm.test</code> 编写断言脚本，结合 <code>pm.response.json()</code> 解析响应体，使用 Chai 断言库语法（expect…to.eql）来校验关键字段的值和数据类型，同时也会校验 Status Code 和响应时间。</p><hr><h1 id="参数化测试：使用变量、数据驱动"><a href="#参数化测试：使用变量、数据驱动" class="headerlink" title="参数化测试：使用变量、数据驱动"></a><strong>参数化测试</strong>：使用变量、数据驱动</h1><p>三步走：<strong>环境&#x2F;全局变量</strong> -&gt; <strong>接口关联（动态变量）</strong> -&gt; <strong>数据驱动（CSV&#x2F;JSON）</strong>。</p><hr><h2 id="第一步：使用环境变量-Environment-Variables"><a href="#第一步：使用环境变量-Environment-Variables" class="headerlink" title="第一步：使用环境变量 (Environment Variables)"></a>第一步：使用环境变量 (Environment Variables)</h2><p><strong>场景</strong>：每次都在 URL 里写 <code>https://jsonplaceholder.typicode.com</code>。如果明天公司把测试环境换成了 <code>http://192.168.1.100</code>，不可能去修改几十个接口。</p><ol><li><p><strong>创建环境</strong>：</p><ul><li>Postman 右上角，默认应该是 “No Environment”。</li><li>点击右边的“眼睛图标” (Environment quick look) -&gt; <strong>Add</strong>。</li><li>Name 填：<code>Dev Environment</code>。</li><li><strong>Variable</strong>: <code>host</code></li><li><strong>Current Value</strong>: <code>https://jsonplaceholder.typicode.com</code></li><li>点击 <strong>Save</strong>，然后关闭弹窗。</li></ul><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image10.png" class="" title="环境变量设置"></li><li><p><strong>选择环境</strong>：</p><ul><li>在右上角下拉框选择刚才创建的 <code>Dev Environment</code>。</li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>回到GET 请求。</li><li>把 URL 里的 <code>https://jsonplaceholder.typicode.com</code> 删掉，替换为 <code>&#123;&#123;host&#125;&#125;</code>。</li><li>现在的 URL 应该是：<code>&#123;&#123;host&#125;&#125;/posts/1</code>。</li></ul></li><li><p><strong>发送</strong>：点击 Send。如果依然成功返回 200，说明变量引用成功。</p></li></ol><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image11.png" class="" title="引用变量"><hr><h2 id="第二步：接口关联（动态获取变量）"><a href="#第二步：接口关联（动态获取变量）" class="headerlink" title="第二步：接口关联（动态获取变量）"></a>第二步：接口关联（动态获取变量）</h2><ol><li><strong>接口A（POST）</strong> 创建了一个帖子，服务器生成了 <code>id: 101</code>。</li><li><strong>接口B（GET）</strong> 想要查询刚才生成的那个帖子。</li><li>你需要把 A 的<strong>输出</strong>，变成 B 的<strong>输入</strong>。</li></ol><p><strong>操作步骤</strong>：</p><ol><li><p><strong>在 POST 请求中提取数据</strong>：</p><ul><li>打开之前的 POST 请求 (<code>&#123;&#123;host&#125;&#125;/posts</code>)。</li><li>进入 <strong>Tests</strong> 标签页。</li><li>输入以下代码，把服务器返回的 ID 存入环境变量：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 解析返回的 JSON</span><br><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><br><span class="hljs-comment">// 2. 打印一下看看（养成看 Console 的习惯）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器生成的新ID是: &quot;</span> + jsonData.<span class="hljs-property">id</span>);<br><br><span class="hljs-comment">// 3. 把这个 ID 设置为环境变量 &#x27;new_post_id&#x27;</span><br>pm.<span class="hljs-property">environment</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;new_post_id&quot;</span>, jsonData.<span class="hljs-property">id</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>运行 POST</strong>：点击 Send。</p><ul><li><em>验证</em>：点击右上角的“眼睛图标”，你应该能看到 <code>new_post_id</code> 已经出现在列表里了，值通常是 101。</li></ul></li><li><p><strong>在 GET 请求中使用数据</strong>：</p><ul><li>新建或修改一个 GET 请求。</li><li>URL 写成：<code>&#123;&#123;host&#125;&#125;/posts/&#123;&#123;new_post_id&#125;&#125;</code></li><li>点击 Send。</li></ul></li></ol><p><strong>原理</strong>：Postman 会先解析 <code>&#123;&#123;new_post_id&#125;&#125;</code> 为 101，然后再发送请求。</p><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image12.png" class="" title="接口关联"><hr><h2 id="第三步：数据驱动测试-Data-Driven-Testing"><a href="#第三步：数据驱动测试-Data-Driven-Testing" class="headerlink" title="第三步：数据驱动测试 (Data-Driven Testing)"></a>第三步：数据驱动测试 (Data-Driven Testing)</h2><p><strong>场景</strong>：测试“发布帖子”的功能。需要测试以下 3 种情况：</p><ol><li>标题正常，内容正常。</li><li>标题为空（预期报错或处理）。</li><li>标题超长（预期截断或报错）。</li></ol><p>不需要写 3 个请求，只需要写 <strong>1 个请求 + 1 个数据文件</strong>。</p><ol><li>准备数据文件 (CSV)</li></ol><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title_case,body_case,user_id<br><span class="hljs-keyword">Test </span>Normal,This is normal content,1<br><span class="hljs-keyword">Test </span>Empty,,1<br><span class="hljs-keyword">Test </span>Special,Special #$% Characters,2<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 POST 请求为“参数化”</li></ol><p>回到你的 POST 请求，修改 Body 中的数据，把写死的内容改成变量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;title_case&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;body_case&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span>user_id<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>*(注意：JSON 中的字符串需要引号，数字不需要，但 </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;<span class="hljs-meta">&#123;...&#125;</span>&#125;<br></code></pre></td></tr></table></figure><p> 只是文本替换，所以如果是字符串类型，外面要保留引号)</p><ol start="3"><li>修改断言 (Tests)</li></ol><p>因为数据变了，断言也要动态化。修改 Tests 脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><span class="hljs-comment">// pm.iterationData.get(&quot;csv表头&quot;) 用来获取当前这行 CSV 的数据</span><br><span class="hljs-keyword">var</span> expectedTitle = pm.<span class="hljs-property">iterationData</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;title_case&quot;</span>);<br><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;检查标题是否匹配&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 验证返回的 title 是否等于 CSV 里写的 title</span><br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">title</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(expectedTitle);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>4. 启动 Collection Runner (集合运行器)</strong></p><ol><li>保存好请求，确保它在某个 Collection（集合）里。</li><li>点击左侧集合名称旁边的 <code>...</code> -&gt; <strong>Run collection</strong>。</li><li><strong>关键步骤</strong>：<ul><li>在 <strong>Data</strong> 选项处，点击 <strong>Select File</strong>，上传刚才的 <code>test_data.csv</code>。</li><li>看到 <strong>Iterations</strong> 自动变成了 3 (因为它识别出了有3行数据)。</li><li>点击 <strong>Preview</strong> 确认数据读取无误。</li></ul></li><li>点击 <strong>Run …</strong>。</li></ol><img src="/2025/12/15/Postman%E5%AD%A6%E4%B9%A0/image13.png" class="" title="集合运行"><hr><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>测开工程师需要把这些测试<strong>集成到代码流水线（CI&#x2F;CD）中。服务器上通常没有图形界面（GUI），所以我们需要学会命令行运行 Postman</strong>。要学习的工具叫 <strong>Newman</strong>。</p><h3 id="命令行运行-Newman-——-自动化集成的基础"><a href="#命令行运行-Newman-——-自动化集成的基础" class="headerlink" title="命令行运行 (Newman) —— 自动化集成的基础"></a>命令行运行 (Newman) —— 自动化集成的基础</h3><h4 id="第一步：准备“原料”-导出-JSON"><a href="#第一步：准备“原料”-导出-JSON" class="headerlink" title="第一步：准备“原料” (导出 JSON)"></a>第一步：准备“原料” (导出 JSON)</h4><p>要在命令行跑测试，需要先把 Postman 里的东西“搬”出来。需要导出两个文件：</p><ol><li><strong>导出集合 (Collection)</strong>：<ul><li>点击左侧的 <code>...</code>。</li><li>选择 <strong>Export</strong>。</li><li>选择 <strong>Collection v2.1</strong> (默认推荐)，点击 <strong>Export</strong>。</li><li>保存为 <code>my_collection.json</code>。</li></ul></li><li><strong>导出环境 (Environment)</strong> (如果你用了环境变量的话)：<ul><li>点击左侧边栏的 <strong>Environments</strong>。</li><li>点击你的 <code>Dev Environment</code> 旁边的 <code>...</code> -&gt; <strong>Export</strong>。</li><li>保存为 <code>dev_env.json</code>。</li></ul></li><li><strong>准备数据</strong>：<ul><li>把你刚才的 <code>test.csv</code> 也放在同一个文件夹里。</li></ul></li></ol><p>现在你的文件夹里应该有三个文件：<code>my_collection.json</code>, <code>dev_env.json</code>, <code>test.csv</code>。</p><h4 id="第二步：安装-Newman"><a href="#第二步：安装-Newman" class="headerlink" title="第二步：安装 Newman"></a>第二步：安装 Newman</h4><p>Newman 是 Postman 的命令行引擎，它是基于 Node.js 的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g newman<br></code></pre></td></tr></table></figure><p><em>(如果安装成功，输入 <code>newman -v</code> 应该能看到版本号)</em></p><h4 id="第三步：在命令行运行测试"><a href="#第三步：在命令行运行测试" class="headerlink" title="第三步：在命令行运行测试"></a>第三步：在命令行运行测试</h4><p>这是最帅的一步。假设你现在在那个存放了三个文件的目录下，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">newman run my_collection.json -e dev_env.json -d test.csv<br></code></pre></td></tr></table></figure><p><strong>命令解析</strong>：</p><ul><li><code>run</code>: 运行指令。</li><li><code>my_collection.json</code>: 指定要跑哪个集合。</li><li><code>-e</code>: 指定环境文件 (Environment)。</li><li><code>-d</code>: 指定数据文件 (Data)。</li></ul><p>观察结果：在黑色的终端窗口里看到酷炫的 ASCII 表格，显示每一条请求的执行结果、断言通过情况、以及最终的统计报表。</p><p>问：“你如何将接口测试集成到 Jenkins 或 GitLab CI 中？”</p><p>回答：</p><blockquote><p>“先在 Postman 本地调试好 Collection 和断言，然后导出为 JSON 文件。在 CI&#x2F;CD 流水线中，使用 <strong>Newman</strong> 命令行工具来运行这些脚本，并生成 HTML 或 JUnit 格式的测试报告（使用 <code>-r html</code> 参数），如果测试失败，流水线就会自动报错阻断。”</p></blockquote><hr><h3 id="第五阶段：代码生成-Code-Snippet-——-偷懒神器"><a href="#第五阶段：代码生成-Code-Snippet-——-偷懒神器" class="headerlink" title="第五阶段：代码生成 (Code Snippet) —— 偷懒神器"></a>第五阶段：代码生成 (Code Snippet) —— 偷懒神器</h3><p>作为测开，经常需要写 Python 脚本来做更复杂的逻辑（比如造数据、清洗数据库）。如果已经在 Postman 里调通了一个复杂的接口（Header 巨多、Body 巨复杂），不想手动去写 Python <code>requests</code> 代码，怎么办？</p><ol><li>回到 Postman，点击你配置好的 <strong>POST 请求</strong>。</li><li>在右侧边栏（就是刚才我们找 Tests Snippets 的那个地方），上面有一个图标是 <code>&lt; / &gt;</code> (Code)。点击它。</li><li>你会看到一个下拉菜单，默认可能是 <code>cURL</code>。</li><li>下拉选择 <strong>Python - Requests</strong>。</li></ol><p>Postman 自动帮你生成了完整的 Python 代码！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br>url = <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span><br><br>payload = json.dumps(&#123;<br>  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;title_case&#125;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;body_case&#125;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;userId&quot;</span>: <span class="hljs-number">1</span><br>&#125;)<br>headers = &#123;<br>  <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>, url, headers=headers, data=payload)<br><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>可以直接复制这段代码到 PyCharm&#x2F;VS Code 里去用。支持 Java (OkHttp&#x2F;Unirest)、Go 等各种语言。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口测试</tag>
      
      <tag>自动化测试</tag>
      
      <tag>请求响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django基础学习</title>
    <link href="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Django入门"><a href="#Django入门" class="headerlink" title="Django入门"></a>Django入门</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架，其提供了全栈开发所需的工具，包括数据库 ORM、模板引擎、路由系统、用户认证等，大幅减少重复代码。Django 遵循 MVC（Model-View-Controller）架构，但在 Django 中更常被称为 MTV（Model-Template-View）</p><img src="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image1.png" class="" title="MVT"><h3 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h3><ul><li><strong>Model (模型)</strong>：处理与数据库的交互，定义数据的结构和业务逻辑。</li><li><strong>View (视图)</strong>：负责数据展示，生成用户看到的 HTML 页面。</li><li><strong>Controller (控制器)</strong>：接收用户请求，调用 Model 处理数据，并将结果传递给 View 渲染页面。</li></ul><p><strong>流程：</strong></p><ol><li>用户发送请求到 Controller。</li><li>Controller 处理逻辑，调用 Model 获取数据。</li><li>Controller 将数据传递给 View。</li><li>View 渲染并返回 HTML 页面给用户。</li></ol><h3 id="MVT-Model-Template-View-——-Django-的实现方式"><a href="#MVT-Model-Template-View-——-Django-的实现方式" class="headerlink" title="MVT (Model-Template-View) —— Django 的实现方式"></a>MVT (Model-Template-View) —— Django 的实现方式</h3><p>Django 中采用了 <strong>MVT</strong> 设计模式，类似于 MVC，但有一些区别：</p><ul><li><strong>Model (模型)</strong>：与数据库交互，处理数据的创建、读取、更新、删除。</li><li><strong>Template (模板)</strong>：负责页面渲染，生成最终的 HTML 内容。</li><li><strong>View (视图)</strong>：Django 的 View 更偏向于控制器的角色，接收请求并决定使用哪个模板和数据。</li></ul><p><strong>流程：</strong></p><ol><li>用户访问 URL，请求被 Django 的 <code>urls.py</code> 映射到相应的 View。</li><li>View 处理业务逻辑，调用 Model 获取数据。</li><li>View 将数据传递给 Template。</li><li>Template 渲染 HTML，最终返回给用户。</li></ol><h2 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h2><table><thead><tr><th align="left">功能</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Admin 后台</strong></td><td align="left">自动生成管理界面，无需手动编写 CRUD 逻辑。</td></tr><tr><td align="left"><strong>ORM</strong></td><td align="left">用 Python 类操作数据库，无需写 SQL。</td></tr><tr><td align="left"><strong>表单处理</strong></td><td align="left">内置表单验证，防止 CSRF 攻击。</td></tr><tr><td align="left"><strong>用户认证</strong></td><td align="left">提供登录、注册、权限管理（<code>django.contrib.auth</code>）。</td></tr><tr><td align="left"><strong>路由系统</strong></td><td align="left">URL 映射灵活，支持正则表达式。</td></tr><tr><td align="left"><strong>缓存机制</strong></td><td align="left">支持 Memcached、Redis 等后端。</td></tr></tbody></table><hr><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><ul><li><strong>快速开发</strong>:Django 提供了大量内置功能，如认证、管理后台、表单处理等，让开发者专注于业务逻辑，而非底层实现。</li><li><strong>自动化管理后台</strong>:只需简单的模型定义，即可生成强大的后台管理界面，支持增删改查。</li><li><strong>ORM 数据库映射</strong>:Django 内置 ORM (Object-Relational Mapping)，可以让开发者使用 Python 类与数据库交互，无需编写 SQL。</li><li><strong>强大的 URL 路由</strong>:使用正则表达式灵活定义 URL，轻松实现页面路由。</li><li><strong>模板引擎</strong>:内置强大的模板系统，支持逻辑判断、循环处理，方便渲染 HTML 页面。</li><li><strong>国际化支持</strong>:Django 支持多语言国际化，非常适合全球化应用。</li><li><strong>高安全性</strong>:内置多种安全保护措施，如防止 SQL 注入、XSS 攻击、CSRF 攻击等。</li><li><strong>丰富的社区与扩展</strong>:大量开源的第三方库，如 Django REST framework、Django CMS 等，快速扩展功能。</li><li><strong>FastAPI</strong>: 通常用装饰器 <code>@app.get(&quot;/items&quot;)</code> 直接在函数头上定义路由。</li><li><strong>Django</strong>: 路由（urls.py）和逻辑（views.py）是分离的。这在大型项目中管理几百个接口时会更清晰，但写起来稍微繁琐一点。</li></ul><hr><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="第一阶段：环境搭建"><a href="#第一阶段：环境搭建" class="headerlink" title="第一阶段：环境搭建"></a>第一阶段：环境搭建</h3><p><strong>目标</strong>：跑通第一个 Django 项目，理解目录结构。</p><h4 id="1-安装-Django"><a href="#1-安装-Django" class="headerlink" title="1. 安装 Django"></a>1. 安装 Django</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install django<br></code></pre></td></tr></table></figure><h4 id="2-创建项目-Project"><a href="#2-创建项目-Project" class="headerlink" title="2. 创建项目 (Project)"></a>2. 创建项目 (Project)</h4><p>Django 的层级是：一个项目 (Project) 包含多个应用 (App)。先在终端运行以下命令创建一个名为 TestPlatform 的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">django-admin startproject startdjango<br><span class="hljs-built_in">cd</span> startdjango<br></code></pre></td></tr></table></figure><h4 id="3-认识目录结构"><a href="#3-认识目录结构" class="headerlink" title="3. 认识目录结构"></a>3. 认识目录结构</h4><ul><li><code>manage.py</code>: 项目的管理脚本，以后会经常用它来运行服务、创建数据库表（迁移）等。</li><li><code>startdjango/</code> :<ul><li><code>settings.py</code>: <strong>核心配置文件</strong>。数据库配置、注册 App、中间件都在这。（问：如何配置多环境？）</li><li><code>urls.py</code>: <strong>路由入口</strong>。相当于“总台”，决定哪个 URL 由哪个函数处理。</li><li><code>wsgi.py</code> &#x2F; <code>asgi.py</code>: 部署上线时用的接口文件。</li></ul></li></ul><h4 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4. 启动服务"></a>4. 启动服务</h4><p>在 <code>startdjango</code> 根目录下运行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> runserver<br></code></pre></td></tr></table></figure><p>打开浏览器访问 <code>http://127.0.0.1:8000/</code>。看到一支小火箭🚀就是跑通了！</p><hr><h3 id="第二阶段：创建第一个-App-与-视图"><a href="#第二阶段：创建第一个-App-与-视图" class="headerlink" title="第二阶段：创建第一个 App 与 视图"></a>第二阶段：创建第一个 App 与 视图</h3><p><strong>目标</strong>：理解 Django 的 MVT (Model-View-Template) 模式中的 V (View) 和 URL 映射。Django 提倡将功能模块化。比如创建一个 <code>book</code> 的app。</p><h4 id="1-创建-App"><a href="#1-创建-App" class="headerlink" title="1. 创建 App"></a>1. 创建 App</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py startapp book<br></code></pre></td></tr></table></figure><p>会发现多了一个 book 文件夹。</p><p>重要步骤：去 startdjango&#x2F;settings.py，找到 INSTALLED_APPS 列表，把 ‘book’, 加进去。如果不加，Django 根本不知道这个 App 的存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TestPlatform/settings.py</span><br>INSTALLED_APPS = [<br>    ...<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-comment"># 新增这一行</span><br>]<br></code></pre></td></tr></table></figure><h4 id="2-写一个简单的视图-View"><a href="#2-写一个简单的视图-View" class="headerlink" title="2. 写一个简单的视图 (View)"></a>2. 写一个简单的视图 (View)</h4><p>视图函数负责处理请求并返回响应。打开 book&#x2F;views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-comment"># 查询参数 示例:  /book?id=5</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">book_detail_query_string</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># request.GET 获取查询参数的字典 &#123;&#x27;id&#x27;: &#x27;5&#x27;&#125;</span><br>    book_id = request.GET.get(<span class="hljs-string">&quot;id&quot;</span>)<br>    book_name = request.GET.get(<span class="hljs-string">&quot;name&quot;</span>)<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&quot;你要查找的图书是: <span class="hljs-subst">&#123;book_id&#125;</span>, 图书名称是: <span class="hljs-subst">&#123;book_name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="3-配置-URL-路由"><a href="#3-配置-URL-路由" class="headerlink" title="3. 配置 URL 路由"></a>3. 配置 URL 路由</h4><p>我们需要告诉 Django，访问什么网址时触发上面这个函数。</p><p><strong>第一步</strong>：在 <code>book</code> 目录下新建一个 <code>urls.py</code>（默认没有，需手动建），写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># case_manager/urls.py</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    <span class="hljs-comment"># 访问 /book/ 时，调用 views.index</span><br>    path(<span class="hljs-string">&quot;&quot;</span>, views.book_detail_query_string, name=<span class="hljs-string">&quot;book_detail_query_string&quot;</span>), <br>]<br></code></pre></td></tr></table></figure><p><strong>第二步</strong>：将 App 的路由注册到项目总路由 <code>startdjango/urls.py</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include <span class="hljs-comment"># 记得导入 include</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    <span class="hljs-comment"># 只要是 book/ 开头的路径，都分发给 book 去处理</span><br>    path(<span class="hljs-string">&#x27;book/&#x27;</span>, include(<span class="hljs-string">&#x27;case_manager.urls&#x27;</span>)), <br>]<br></code></pre></td></tr></table></figure><h4 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> runserver<br></code></pre></td></tr></table></figure><p>访问  <a href="http://127.0.0.1:8000/book?id=3&name=123">http://127.0.0.1:8000/book?id=3&amp;name=123</a> 会显示“你要查找的图书是: 3, 图书名称是: 123”</p><hr><h2 id="Path函数"><a href="#Path函数" class="headerlink" title="Path函数"></a>Path函数</h2><p>在 Django 中，<code>path()</code> 函数用于定义 URL 模式。</p><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. <strong>基本语法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;route/&#x27;</span>, views.view_function, name=<span class="hljs-string">&#x27;view-name&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><h2 id="2-参数详解"><a href="#2-参数详解" class="headerlink" title="2. 参数详解"></a>2. <strong>参数详解</strong></h2><h3 id="第一个参数：路由字符串"><a href="#第一个参数：路由字符串" class="headerlink" title="第一个参数：路由字符串"></a><strong>第一个参数：路由字符串</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 指定app命名空间</span><br>app_name = <span class="hljs-string">&quot;book&quot;</span><br><br>urlpatterns = [<br>    <span class="hljs-comment"># /book?id=5</span><br>    path(<span class="hljs-string">&quot;&quot;</span>, views.book_detail_query_string, name=<span class="hljs-string">&quot;book_detail_query_string&quot;</span>),<br>    path(<span class="hljs-string">&quot;&lt;int:book_id&gt;/&quot;</span>, views.book_datail_path, name=<span class="hljs-string">&quot;book_datail_path&quot;</span>),<br>    path(<span class="hljs-string">&quot;str/&lt;str:book_id&gt;/&quot;</span>, views.book_str, name=<span class="hljs-string">&quot;book_str&quot;</span>),<br>    path(<span class="hljs-string">&quot;slug/&lt;slug:book_id&gt;/&quot;</span>, views.book_slug, name=<span class="hljs-string">&quot;book_slug&quot;</span>),<br>    path(<span class="hljs-string">&quot;path/&lt;path:book_id&gt;/&quot;</span>, views.book_path, name=<span class="hljs-string">&quot;book_path&quot;</span>),<br>]<br></code></pre></td></tr></table></figure><h3 id="第二个参数：视图"><a href="#第二个参数：视图" class="headerlink" title="第二个参数：视图"></a><strong>第二个参数：视图</strong></h3><p>可以为一个视图函数或者是类视图.as_view()或者是django.urls.include()函数 的返回值</p><h3 id="第三个参数：kwargs（可选）"><a href="#第三个参数：kwargs（可选）" class="headerlink" title="第三个参数：kwargs（可选）"></a><strong>第三个参数：kwargs（可选）</strong></h3><p>向视图传递额外的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;about/&#x27;</span>, views.about, &#123;<span class="hljs-string">&#x27;template_name&#x27;</span>: <span class="hljs-string">&#x27;custom_about.html&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="第四个参数：name（可选）"><a href="#第四个参数：name（可选）" class="headerlink" title="第四个参数：name（可选）"></a><strong>第四个参数：name（可选）</strong></h3><p>这个参数是给这个url取个名字的，这在项目比较大，url比较多的时候用处很大。对URL 命名，用于反向解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;articles/&lt;int:id&gt;/&#x27;</span>, views.article_detail, name=<span class="hljs-string">&#x27;article-detail&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在模板中使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;article-detail&#x27; id=1 %&#125;&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-路径转换器类型"><a href="#3-路径转换器类型" class="headerlink" title="3. 路径转换器类型"></a>3. <strong>路径转换器类型</strong></h2><p>Django 内置了多种类型转换器：</p><table><thead><tr><th>转换器</th><th>说明</th><th>示例</th><th>匹配示例</th></tr></thead><tbody><tr><td><code>str</code></td><td>匹配非空字符串（不包括 <code>/</code>）</td><td><code>&lt;str:name&gt;</code></td><td><code>john</code>, <code>article-1</code></td></tr><tr><td><code>int</code></td><td>匹配正整数</td><td><code>&lt;int:id&gt;</code></td><td><code>123</code>, <code>0</code></td></tr><tr><td><code>slug</code></td><td>匹配字母、数字、连字符、下划线</td><td><code>&lt;slug:post_slug&gt;</code></td><td><code>my-post-2023</code></td></tr><tr><td><code>uuid</code></td><td>匹配 UUID 格式字符串</td><td><code>&lt;uuid:uuid&gt;</code></td><td><code>123e4567-e89b-12d3...</code></td></tr><tr><td><code>path</code></td><td>匹配包含 <code>/</code> 的字符串</td><td><code>&lt;path:filepath&gt;</code></td><td><code>docs/user/guide.pdf</code></td></tr></tbody></table><hr><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>现在的主流开发方式倾向于“前后端分离”（Django 只写 API，前端用 Vue&#x2F;React），但**Django 模版（Templates）**是其基础</p><p>目前市面上有非常多的模板系统，其中最知名最好用的就是DTL和Jinja2。 DTL 是 Django Template Language 三个单词的缩写，也就是Django自带的模板语言。当然也可以配置Django支持Jinja2等其他模板引擎，但是作为Django内置的模板语言，和Django可以达到无缝衔接而不会产生一些不兼容的情况</p><h2 id="DTL概念"><a href="#DTL概念" class="headerlink" title="DTL概念"></a>DTL概念</h2><p>DTL模板是一种带有特殊语法的HTML文件，这个HTML文件可以被Django编译，可以传递参数进去，实 现数据动态化。在编译完成后，生成一个普通的HTML文件，然后发送给客户端。</p><p>直接将模板渲染成字符串和包装成 HttpResponse 对象一步到位完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;index.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>问：</p><blockquote><p><strong>“Django 的模版渲染是在前端执行还是后端执行的？”</strong></p></blockquote><p>是在<strong>后端</strong>执行的。 Django 在服务器端把 HTML 里的 <code>&#123;&#123; &#125;&#125;</code> 替换成真实数据，生成纯静态的 HTML 字符串，然后发给浏览器。浏览器收到的只是普通的 HTML，看不到任何 <code>&#123;% for %&#125;</code> 代码。这也就是为什么叫“服务端渲染 (SSR)”。</p><h2 id="模版查找路径位置"><a href="#模版查找路径位置" class="headerlink" title="模版查找路径位置"></a>模版查找路径位置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">&quot;BACKEND&quot;</span>: <span class="hljs-string">&quot;django.template.backends.django.DjangoTemplates&quot;</span>,<br>        <span class="hljs-string">&quot;DIRS&quot;</span>: [<br>            <span class="hljs-comment"># 项目级模板目录</span><br>            os.path.join(BASE_DIR, <span class="hljs-string">&#x27;templates&#x27;</span>),<br>        ],<br>        <span class="hljs-string">&quot;APP_DIRS&quot;</span>: <span class="hljs-literal">True</span>, <span class="hljs-comment"># 必须为 True，才能查找应用内的templates目录</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;context_processors&quot;</span>: [<br>                <span class="hljs-string">&quot;django.template.context_processors.request&quot;</span>,<br>                <span class="hljs-string">&quot;django.contrib.auth.context_processors.auth&quot;</span>,<br>                <span class="hljs-string">&quot;django.contrib.messages.context_processors.messages&quot;</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>]<br></code></pre></td></tr></table></figure><p>查找顺序：比如代码 render(‘list.html’) 。先会在 DIRS 这个列表中依次查找路径下有没有这个模版，如果有就返回。如果DIRS 列表中所有的路径都没有找到，那么会先检查当前这个视图所处的app是否已经安装，如果已经安装了，那么就先在当前这个 app 下的 templates 文件夹中查找模板，如果没有找到，那么会在其他已经安装了的 app 中查找。如果所有路径下都没有找到，那么会抛出一个 TemplateDoesNotExist 的异常。</p><h2 id="DTL语法"><a href="#DTL语法" class="headerlink" title="DTL语法"></a>DTL语法</h2>Django 的模版语言（DTL）核心就两点：- **`{{ 变量 }}`**：挖坑，填值。- **`{% 逻辑 %}`**：写代码逻辑，比如循环 `for` 或判断 `if`。<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># 1.普通变量</span><br>    username = <span class="hljs-string">&quot;小黎&quot;</span><br>    <span class="hljs-comment"># 2.字典</span><br>    book = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;施耐庵&quot;</span>&#125;<br>    <span class="hljs-comment"># 3.列表</span><br>    books = [&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;施耐庵&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;罗贯中&quot;</span>&#125;]<br>    <span class="hljs-comment"># 4.对象</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>            <span class="hljs-variable language_">self</span>.name = name<br>            <span class="hljs-variable language_">self</span>.age = age<br>    <span class="hljs-comment"># 传递给模版</span><br>    context = &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: username,<br>        <span class="hljs-string">&#x27;book&#x27;</span>: book,<br>        <span class="hljs-string">&#x27;books&#x27;</span>: books,<br>        <span class="hljs-string">&#x27;person&#x27;</span>: person(<span class="hljs-string">&quot;小黎&quot;</span>, <span class="hljs-number">23</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;info.html&#x27;</span>, context=context)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;book.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;book.author&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;books.0&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;books.1.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;person.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;person.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2025/12/15/django%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image2.png" class="" title="DTL模版变量"><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h4 id="1-if-elif-else"><a href="#1-if-elif-else" class="headerlink" title="1. if &#x2F; elif &#x2F; else"></a>1. <strong><code>if</code> &#x2F; <code>elif</code> &#x2F; <code>else</code></strong></h4><p>if标签相当于 Python 中的标签符号（ if 语句，有 elif 和 else 相对应，但是所有的标签都需要）进行包裹。if标签中可以使用 &#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、in、not in、is、is  not 等判断运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">if_view</span>(<span class="hljs-params">request</span>):<br>    age = <span class="hljs-number">23</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;if.html&#x27;</span>, context=&#123;<span class="hljs-string">&#x27;age&#x27;</span>: age&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> age &gt; 18 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您已满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">elif</span></span> age == 18 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您刚满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">else</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您未满18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a>2. <strong>for 循环</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 基本循环 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; item.name &#125;&#125;</span><span class="language-xml">: </span><span class="hljs-template-variable">&#123;&#123; item.price &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 循环变量 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.counter &#125;&#125;</span><span class="language-xml">        </span><span class="hljs-comment">&#123;# 从1开始计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.counter0 &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 从0开始计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.revcounter &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 倒序计数 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.revcounter0 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 倒序从0开始 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.first &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 是否第一次循环 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.last &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 是否最后一次循环 #&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; forloop.parentloop &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 父级循环对象 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 空循环处理 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> item <span class="hljs-keyword">in</span> items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">empty</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>No items available.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 字典循环 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> key, value <span class="hljs-keyword">in</span> data.items %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; key &#125;&#125;</span><span class="language-xml">: </span><span class="hljs-template-variable">&#123;&#123; value &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-with-创建局部变量"><a href="#3-with-创建局部变量" class="headerlink" title="3. &#96;with 创建局部变量"></a>3. <strong>&#96;with 创建局部变量</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> total=products|<span class="hljs-name">length</span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Total products: </span><span class="hljs-template-variable">&#123;&#123; total &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">with</span></span> alpha=1 beta=2 %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sum: </span><span class="hljs-template-variable">&#123;&#123; alpha|<span class="hljs-name">add</span>:beta &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endwith</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-url-反向解析-URL"><a href="#4-url-反向解析-URL" class="headerlink" title="4.url 反向解析 URL"></a>4.<strong><code>url</code> 反向解析 URL</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 不带参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;home&#x27; %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 带位置参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;article-detail&#x27; 2023 &#x27;django-tutorial&#x27; %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Article<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 带关键字参数 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;profile&#x27; username=user.username %&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Profile<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在变量中使用 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">url</span></span> &#x27;api-endpoint&#x27; <span class="hljs-keyword">as</span> api_url %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; api_url &#125;&#125;</span><span class="language-xml">&quot;;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2>在模版中，有时候需要对一些数据进行处理以后才能使用。在模版中，则是通过过滤器来实现的。过滤器使用的是|来使用。比如使用 add 过滤器<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-variable">&#123;&#123;  value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;2&quot;</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure>过滤器用于在模板中修改变量的显示格式，语法为 `{{ variable|filter:argument }}`<h3 id="1-文本格式化"><a href="#1-文本格式化" class="headerlink" title="1. 文本格式化"></a>1. <strong>文本格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为小写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;HELLO WORLD&quot;|<span class="hljs-name">lower</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# hello world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">upper</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# HELLO WORLD #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 首字母大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">capfirst</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Hello world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 每个单词首字母大写 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# Hello World #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-长度和截断"><a href="#2-长度和截断" class="headerlink" title="2. 长度和截断"></a>2. <strong>长度和截断</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 获取长度 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello&quot;|<span class="hljs-name">length</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 5 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">length</span> &#125;&#125;</span><span class="language-xml">                  </span><span class="hljs-comment">&#123;# 列表长度 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 字符截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long text&quot;|<span class="hljs-name">truncatechars</span>:10 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# This is... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long text&quot;|<span class="hljs-name">truncatechars</span>:15 &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# This is a lon... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 单词截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;This is a long sentence to demonstrate truncation&quot;|<span class="hljs-name">truncatewords</span>:5 &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-comment">&#123;# This is a long sentence... #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 保留HTML标签的截断 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_content|<span class="hljs-name">truncatewords</span>_html:20 &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# 安全截断HTML内容 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-空格和换行处理"><a href="#3-空格和换行处理" class="headerlink" title="3. 空格和换行处理"></a>3. <strong>空格和换行处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除空白字符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;  hello  world  &quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot; &quot;</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# helloworld #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello\tworld\n&quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot;\t&quot;</span> &#125;&#125;</span><span class="language-xml">            </span><span class="hljs-comment">&#123;# helloworld\n #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除指定字符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;Hello-World&quot;|<span class="hljs-name">cut</span>:<span class="hljs-string">&quot;-&quot;</span> &#125;&#125;</span><span class="language-xml">                </span><span class="hljs-comment">&#123;# HelloWorld #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 换行符转换 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;Line1\nLine2\r\nLine3&quot;|<span class="hljs-name">linebreaks</span> &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# &lt;p&gt;Line1&lt;br&gt;Line2&lt;br&gt;Line3&lt;/p&gt; #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; text|<span class="hljs-name">linebreaksbr</span> &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 只转换为&lt;br&gt;标签 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-数字格式化"><a href="#4-数字格式化" class="headerlink" title="4. 数字格式化"></a>4. <strong>数字格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 四舍五入 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span>:2 &#125;&#125;</span><span class="language-xml">        </span><span class="hljs-comment">&#123;# 3.14 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.1|<span class="hljs-name">floatformat</span>:<span class="hljs-string">&quot;-2&quot;</span> &#125;&#125;</span><span class="language-xml">         </span><span class="hljs-comment">&#123;# 3.1 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3.14159|<span class="hljs-name">floatformat</span>:<span class="hljs-string">&quot;0&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 千位分隔符 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1000000|intcomma &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 1,000,000 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1234.56|intcomma &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 1,234.56 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 文件大小格式化（需要humanize） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1024|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 1.0 KB #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1048576|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 1.0 MB #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 123456789|<span class="hljs-name">filesizeformat</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 117.7 MB #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-数学运算"><a href="#5-数学运算" class="headerlink" title="5. 数学运算"></a>5. <strong>数学运算</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 加法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;5&quot;</span> &#125;&#125;</span><span class="language-xml">                </span><span class="hljs-comment">&#123;# value + 5 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;10&quot;|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;5&quot;</span> &#125;&#125;</span><span class="language-xml">                 </span><span class="hljs-comment">&#123;# 15 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list1|<span class="hljs-name">add</span>:list2 &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# 合并两个列表 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 减法（需要自定义或使用计算） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">add</span>:<span class="hljs-string">&quot;-5&quot;</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 间接实现减法 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 乘法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> value 1 100 %&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# value * 100 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> 5 1 100 %&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 500 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 除法 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> 100 5 1 %&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 20 (100 ÷ 5 × 1) #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">widthratio</span></span> value max_value 100 <span class="hljs-keyword">as</span> percentage %&#125;</span><span class="language-xml"></span><br><span class="language-xml">                                   </span><span class="hljs-comment">&#123;# 计算百分比 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 绝对值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; -5|abs &#125;&#125;</span><span class="language-xml">                       </span><span class="hljs-comment">&#123;# 需要自定义过滤器 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-日期格式化"><a href="#6-日期格式化" class="headerlink" title="6. 日期格式化"></a>6. <strong>日期格式化</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 基本格式化 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;Y-m-d&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2023-12-15 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;d/m/Y&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 15/12/2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 常用格式 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;Y年m月d日&quot;</span> &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# 2023年12月15日 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;F j, Y&quot;</span> &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# December 15, 2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">date</span>:<span class="hljs-string">&quot;D d M Y&quot;</span> &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# Fri 15 Dec 2023 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 时间格式化 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;H:i&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 14:30 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;H:i:s&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 14:30:45 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">time</span>:<span class="hljs-string">&quot;g:i A&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2:30 PM #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7-时间相关处理"><a href="#7-时间相关处理" class="headerlink" title="7. 时间相关处理"></a>7. <strong>时间相关处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 相对时间（需要humanize） --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; post.pub_date|naturaltime &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 2 hours ago #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|naturalday &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# today, yesterday #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 时间差 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">timesince</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 2 days, 3 hours #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; datetime_obj|<span class="hljs-name">timesince</span>:other_datetime &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 到某时间的时间差 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; deadline|<span class="hljs-name">timeuntil</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# 3 days, 2 hours #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="8-列表操作"><a href="#8-列表操作" class="headerlink" title="8. 列表操作"></a>8. <strong>列表操作</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 获取第一个/最后一个元素 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">first</span> &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# 第一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">last</span> &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 最后一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 随机排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">random</span> &#125;&#125;</span><span class="language-xml">                  </span><span class="hljs-comment">&#123;# 随机一个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|shuffle &#125;&#125;</span><span class="language-xml">                 </span><span class="hljs-comment">&#123;# 返回None，实际使用需自定义 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 连接列表 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">join</span>:<span class="hljs-string">&quot;, &quot;</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# item1, item2, item3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">join</span>:<span class="hljs-string">&quot; • &quot;</span> &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# item1 • item2 • item3 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 切片 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">slice</span>:<span class="hljs-string">&quot;:5&quot;</span> &#125;&#125;</span><span class="language-xml">              </span><span class="hljs-comment">&#123;# 前5个元素 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; list|<span class="hljs-name">slice</span>:<span class="hljs-string">&quot;1:3&quot;</span> &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 第2到第3个元素 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="9-排序和唯一"><a href="#9-排序和唯一" class="headerlink" title="9. 排序和唯一"></a>9. <strong>排序和唯一</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 字典列表按字段排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsort</span>:<span class="hljs-string">&quot;name&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# 按name排序 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsort</span>:<span class="hljs-string">&quot;age&quot;</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# 按age排序 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 按字段降序排序 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_list|<span class="hljs-name">dictsortreversed</span>:<span class="hljs-string">&quot;age&quot;</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 唯一值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; duplicate_list|unordered_list &#125;&#125;</span><span class="language-xml"> </span><span class="hljs-comment">&#123;# 转为无序列表HTML #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; duplicate_list|unique &#125;&#125;</span><span class="language-xml">         </span><span class="hljs-comment">&#123;# 需要自定义过滤器 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="10-布尔值处理"><a href="#10-布尔值处理" class="headerlink" title="10. 布尔值处理"></a>10. <strong>布尔值处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 默认值 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;N/A&quot;</span> &#125;&#125;</span><span class="language-xml">          </span><span class="hljs-comment">&#123;# 如果value为空或不存在 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&quot;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty string&quot;</span> &#125;&#125;</span><span class="language-xml">    </span><span class="hljs-comment">&#123;# Empty string #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Nothing&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Nothing #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 默认值为空字符串 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">default</span>_if_none:&quot;--&quot; &#125;&#125;</span><span class="language-xml">   </span><span class="hljs-comment">&#123;# 仅当None时替换 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 布尔值显示 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; True|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 是 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; False|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 否 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;是,否,可能&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 可能 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; value|<span class="hljs-name">yesno</span>:<span class="hljs-string">&quot;yup,nope&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# 自定义选项 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="11-空值检查"><a href="#11-空值检查" class="headerlink" title="11. 空值检查"></a>11. <strong>空值检查</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 检查是否为空 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&quot;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty&quot;</span> &#125;&#125;</span><span class="language-xml">           </span><span class="hljs-comment">&#123;# Empty #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; []|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty list&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# Empty list #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &#123;&#125;|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Empty dict&quot;</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# Empty dict #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; None|<span class="hljs-name">default</span>:<span class="hljs-string">&quot;Nothing&quot;</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# Nothing #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="12-HTML处理"><a href="#12-HTML处理" class="headerlink" title="12. HTML处理"></a>12. <strong>HTML处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转义HTML --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;|<span class="hljs-name">escape</span> &#125;&#125;</span><span class="language-xml"> </span><br><span class="language-xml"></span><span class="hljs-comment">&#123;# &amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;/script&amp;gt; #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 简写形式 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; user_input|force_escape &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# 强制转义 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 标记为安全HTML --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_string|<span class="hljs-name">safe</span> &#125;&#125;</span><span class="language-xml">             </span><span class="hljs-comment">&#123;# 谨慎使用！ #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 移除HTML标签 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;&lt;p&gt;Hello&lt;/p&gt;&quot;|<span class="hljs-name">striptags</span> &#125;&#125;</span><span class="language-xml">     </span><span class="hljs-comment">&#123;# Hello #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; html_content|<span class="hljs-name">striptags</span>|<span class="hljs-name">truncatewords</span>:30 &#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="13-URL处理"><a href="#13-URL处理" class="headerlink" title="13. URL处理"></a>13. <strong>URL处理</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- URL编码 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; &quot;hello world&quot;|<span class="hljs-name">urlencode</span> &#125;&#125;</span><span class="language-xml">      </span><span class="hljs-comment">&#123;# hello%20world #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; query_string|<span class="hljs-name">urlencode</span> &#125;&#125;</span><span class="language-xml">       </span><span class="hljs-comment">&#123;# name=John&amp;age=30 #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 转义URL --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; path|<span class="hljs-name">iriencode</span> &#125;&#125;</span><span class="language-xml">               </span><span class="hljs-comment">&#123;# 国际化URL编码 #&#125;</span><br></code></pre></td></tr></table></figure><h3 id="14-JSON格式"><a href="#14-JSON格式" class="headerlink" title="14. JSON格式"></a>14. <strong>JSON格式</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 转换为JSON --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; python_dict|json_script:&quot;data&quot; &#125;&#125;</span><span class="language-xml">  </span><span class="hljs-comment">&#123;# 安全输出JSON #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在JavaScript中使用 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; data|json_script:&quot;data-attr&quot; &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;data-attr&#x27;</span>).<span class="hljs-property">textContent</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="15-复数和序数"><a href="#15-复数和序数" class="headerlink" title="15. 复数和序数"></a>15. <strong>复数和序数</strong></h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">load</span></span> humanize %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 序数 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1|apnumber &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# one #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3|apnumber &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# three #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 数字转为序数词 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 1|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 1st #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 2|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 2nd #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 3|ordinal &#125;&#125;</span><span class="language-xml">                    </span><span class="hljs-comment">&#123;# 3rd #&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; 11|ordinal &#125;&#125;</span><span class="language-xml">                   </span><span class="hljs-comment">&#123;# 11th #&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="模版结构"><a href="#模版结构" class="headerlink" title="模版结构"></a>模版结构</h2><table><thead><tr><th>特性</th><th><code>extend</code></th><th><code>include</code></th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>模板继承，定义骨架</td><td>模块化重用，嵌入片段</td></tr><tr><td><strong>关系</strong></td><td>父子关系</td><td>包含关系</td></tr><tr><td><strong>位置</strong></td><td>必须是模板第一个标签</td><td>可在任意位置</td></tr><tr><td><strong>使用频率</strong></td><td>每个页面通常只继承一次</td><td>一个页面可包含多次</td></tr><tr><td><strong>修改内容</strong></td><td>通过 block 替换</td><td>直接嵌入整个模板</td></tr></tbody></table><h3 id="1、extend-模板继承"><a href="#1、extend-模板继承" class="headerlink" title="1、extend 模板继承"></a>1、<strong>extend 模板继承</strong></h3><h4 id="1-基础结构"><a href="#1-基础结构" class="headerlink" title="1. 基础结构"></a>1. <strong>基础结构</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- base.html (父模板) --&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="language-xml">默认标题</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml">网站头部</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 默认内容 --&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> footer %&#125;</span><span class="language-xml">版权信息</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> scripts %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-子模板使用"><a href="#2-子模板使用" class="headerlink" title="2. 子模板使用"></a>2. <strong>子模板使用</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- home.html (子模板) --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 1. 覆盖title块 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="language-xml">首页 - 我的网站</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2. 添加额外的head内容 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;首页描述&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/home.css&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 3. 覆盖header --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到我的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;nav.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 4. 覆盖content --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hero&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>主要内容区域<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 保留父模板的默认内容 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>额外的首页内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-多级继承"><a href="#3-多级继承" class="headerlink" title="3. 多级继承"></a>3. <strong>多级继承</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- base.html --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- blog_base.html --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> extra_head %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 继承base的extra_head --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/blog.css&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> header %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; block.super &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;blog_nav.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- post_detail.html --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">extends</span></span> &quot;blog_base.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> title %&#125;</span><span class="hljs-template-variable">&#123;&#123; post.title &#125;&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">block</span></span> content %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; post.title &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; post.content|<span class="hljs-name">safe</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endblock</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2、include-模板包含"><a href="#2、include-模板包含" class="headerlink" title="2、include 模板包含"></a>2、<strong>include 模板包含</strong></h3><h4 id="1-基本包含"><a href="#1-基本包含" class="headerlink" title="1. 基本包含"></a>1. <strong>基本包含</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含静态模板 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;header.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含带上下文 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;user_card.html&quot; with user=current_user %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 包含多个变量 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;product.html&quot; with product=item price=item.price only %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- only关键字：限制变量传递 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;component.html&quot; with data=data only %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-动态包含"><a href="#2-动态包含" class="headerlink" title="2. 动态包含"></a>2. <strong>动态包含</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 根据变量包含不同模板 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> user.is_premium %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;premium_features.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">else</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;basic_features.html&quot; %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 使用变量作为模板名 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> template_name %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 循环中包含 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">for</span></span> product <span class="hljs-keyword">in</span> products %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;product_item.html&quot; with product=product %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endfor</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-包含传参示例"><a href="#3-包含传参示例" class="headerlink" title="3. 包含传参示例"></a>3. <strong>包含传参示例</strong></h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- card.html --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card </span></span></span><span class="hljs-template-variable">&#123;&#123; extra_class &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; title &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123; content &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> show_button %&#125;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; button_class &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; button_text &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 使用card --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &quot;card.html&quot; with </span><br><span class="hljs-template-tag">    title=&quot;用户面板&quot; </span><br><span class="hljs-template-tag">    content=user.bio </span><br><span class="hljs-template-tag">    show_button=True </span><br><span class="hljs-template-tag">    button_text=&quot;编辑资料&quot; </span><br><span class="hljs-template-tag">    button_class=&quot;btn-primary&quot; </span><br><span class="hljs-template-tag">    extra_class=&quot;user-card&quot; </span><br><span class="hljs-template-tag">%&#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Django</tag>
      
      <tag>路由</tag>
      
      <tag>模版</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytest基础学习</title>
    <link href="/2025/12/14/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/14/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Pytest基础知识"><a href="#Pytest基础知识" class="headerlink" title="Pytest基础知识"></a>Pytest基础知识</h1><p><code>pytest</code> 是 Python 技术栈的<strong>行业标准</strong>。相比于 Python 自带的 <code>unittest</code>，它更简洁、插件生态更丰富，而且能完美支持后续的 UI 自动化（Selenium&#x2F;Playwright）和接口自动化（Requests）。</p><hr><h3 id="第一阶段：Pytest-基础核心"><a href="#第一阶段：Pytest-基础核心" class="headerlink" title="第一阶段：Pytest 基础核心"></a>第一阶段：Pytest 基础核心</h3><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pytest<br></code></pre></td></tr></table></figure><h4 id="2-核心概念：pytest-如何发现测试用例"><a href="#2-核心概念：pytest-如何发现测试用例" class="headerlink" title="2. 核心概念：pytest 如何发现测试用例"></a>2. 核心概念：pytest 如何发现测试用例</h4><p>Pytest 不像 Java 的 JUnit 需要复杂的配置，它完全依靠<strong>命名规则</strong>来自动寻找测试代码。</p><ol><li><strong>文件名</strong>：必须以 <code>test_</code> 开头（推荐）或者 <code>_test</code> 结尾。例如：<code>test_login.py</code>。</li><li><strong>类名</strong>：必须以 <code>Test</code> 开头，且<strong>不能</strong>包含 <code>__init__</code> 方法。</li><li><strong>函数名</strong>：必须以 <code>test_</code> 开头。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test_demo.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><span class="hljs-comment"># 1. 正确的测试用例：以 test_ 开头</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_01</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行用例 01&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">3</span>  <span class="hljs-comment"># Python 原生 assert</span><br><br><span class="hljs-comment"># 2. 错误的测试用例：没有以 test_ 开头，pytest 会忽略它</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_test_02</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个函数不会被运行&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 3. 故意写一个失败的用例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_failed</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行用例 02&quot;</span>)<br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong>断言（Assertion）：</strong> Pytest 直接使用 Python 原生的 <code>assert</code> 关键字。不需要像 Java JUnit 那样用 <code>Assert.assertEquals()</code>，也不需要 <code>self.assertEqual()</code>。Pytest 会“重写”断言，在失败时提供非常详细的变量值对比，非常方便。</li></ul><h4 id="3-运行测试（命令行参数）"><a href="#3-运行测试（命令行参数）" class="headerlink" title="3. 运行测试（命令行参数）"></a>3. 运行测试（命令行参数）</h4><p>在终端中，进入该文件所在的目录。</p><p><strong>最基础的运行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest<br></code></pre></td></tr></table></figure><p><em>会看到类似 <code>collected 2 items</code> 的提示（因为它只找到了 2 个符合命名规则的函数）。</em></p><p><strong>常用的参数：</strong></p><ol><li><p><strong><code>-v</code> (verbose)</strong>：显示详细信息，包括每个测试用例的文件名和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -v<br></code></pre></td></tr></table></figure></li><li><p><strong><code>-s</code> (show output)</strong>：默认情况下，如果用例通过，Pytest 会吞掉 <code>print()</code> 的输出。加上 <code>-s</code> 可以看到控制台打印的内容（调试时很有用）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -vs  <span class="hljs-comment"># 常用组合</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>-k &quot;keyword&quot;</code></strong>：只运行匹配名称的用例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -k <span class="hljs-string">&quot;01&quot;</span>  <span class="hljs-comment"># 只运行名字里带 01 的用例</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="4-运行结果分析"><a href="#4-运行结果分析" class="headerlink" title="4. 运行结果分析"></a>4. 运行结果分析</h4><p>运行后，你会看到几个特定的字符：</p><ul><li><strong><code>.</code> (点)</strong>：代表 <strong>PASSED</strong>（通过）。</li><li><strong><code>F</code></strong>：代表 <strong>FAILED</strong>（失败）。</li><li><strong><code>E</code></strong>：代表 <strong>ERROR</strong>（代码本身报错，而不是断言失败）。</li><li><strong><code>s</code></strong>：代表 <strong>SKIPPED</strong>（跳过）。</li></ul><hr><h3 id="5-断言的类型"><a href="#5-断言的类型" class="headerlink" title="5.断言的类型"></a>5.断言的类型</h3><p>在 <strong>pytest</strong> 中，设计哲学是 <strong>“Less is More”</strong>。它几乎废弃了所有的 <code>assertXxx</code> 方法，<strong>只用一个 Python 原生的 <code>assert</code> 关键字解决 90% 的问题</strong>，剩下的 10% 用专用辅助函数解决。</p><h3 id="1-基础断言（解决-90-的场景）"><a href="#1-基础断言（解决-90-的场景）" class="headerlink" title="1. 基础断言（解决 90% 的场景）"></a>1. 基础断言（解决 90% 的场景）</h3><p>Pytest 会在底层通过“AST 语法树重写”技术，拦截原本的 Python <code>assert</code> 语句。当断言失败时，它不只是抛出 <code>AssertionError</code>，而是会详细展示<strong>表达式两边的具体值</strong>，甚至列出列表&#x2F;字典的差异。只需要写符合 Python 语法的布尔表达式：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>unittest &#x2F; Java 风格 (旧)</strong></th><th><strong>pytest 风格 (新)</strong></th></tr></thead><tbody><tr><td><strong>值相等</strong></td><td><code>assertEqual(x, y)</code></td><td><code>assert x == y</code></td></tr><tr><td><strong>值不相等</strong></td><td><code>assertNotEqual(x, y)</code></td><td><code>assert x != y</code></td></tr><tr><td><strong>包含</strong></td><td><code>assertIn(x, list)</code></td><td><code>assert x in list</code></td></tr><tr><td><strong>不包含</strong></td><td><code>assertNotIn(x, list)</code></td><td><code>assert x not in list</code></td></tr><tr><td><strong>真&#x2F;假</strong></td><td><code>assertTrue(x)</code></td><td><code>assert x</code></td></tr><tr><td><strong>大小比较</strong></td><td><code>assertGreater(x, y)</code></td><td><code>assert x &gt; y</code></td></tr><tr><td><strong>地址相等</strong></td><td>assertSame(x, y)</td><td>assert x is y</td></tr><tr><td><strong>地址不相等</strong></td><td>assertNotSame(x, y)</td><td>assert x is not y</td></tr></tbody></table><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_basic_assertions</span>():<br>    <span class="hljs-comment"># 1. 字符串比较</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;class&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;classic&quot;</span><br><br>    <span class="hljs-comment"># 2. 列表/字典比较（非常强大，失败时会显示具体哪个元素不同）</span><br>    a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">assert</span> a == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">assert</span> a == b<br>    <span class="hljs-keyword">assert</span> a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b<br><br>    res_dict = &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>&#125;<br>    <span class="hljs-keyword">assert</span> res_dict[<span class="hljs-string">&quot;code&quot;</span>] == <span class="hljs-number">200</span><br><br>    <span class="hljs-comment"># 3. 添加自定义报错信息（可选）</span><br>    <span class="hljs-comment"># 格式：assert 表达式, &quot;报错信息&quot;</span><br>    x = <span class="hljs-number">10</span><br>    <span class="hljs-comment"># assert x &gt; 100, f&quot;x 的值 &#123;x&#125; 竟然没有大于 100！&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-浮点数断言（特殊场景）"><a href="#2-浮点数断言（特殊场景）" class="headerlink" title="2. 浮点数断言（特殊场景）"></a>2. 浮点数断言（特殊场景）</h3><p>计算机中 <code>0.1 + 0.2</code> 并不严格等于 <code>0.3</code>（精度问题）。如果做算法或金融计算，直接用 <code>==</code> 会报错。Pytest 提供了 <code>pytest.approx</code> 来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_float_compare</span>():<br>    <span class="hljs-comment"># 这在 python 中通常是 False，因为结果是 0.30000000000000004</span><br>    <span class="hljs-comment"># assert 0.1 + 0.2 == 0.3  &lt;-- 这样写会失败</span><br>    <br>    <span class="hljs-comment"># 正确写法：使用 pytest.approx</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == pytest.approx(<span class="hljs-number">0.3</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="3-异常断言（预期代码会报错）"><a href="#3-异常断言（预期代码会报错）" class="headerlink" title="3. 异常断言（预期代码会报错）"></a>3. 异常断言（预期代码会报错）</h3><p>做测试时，我们不仅要测“成功”，还要测“失败”。比如：<em>当用户输入非法参数时，程序是否按预期抛出了异常？</em> 如果程序没报错，反而是 Bug。这需要使用 <code>pytest.raises</code> 上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;除数不能为0&quot;</span>)<br>    <span class="hljs-keyword">return</span> x / y<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception</span>():<br>    <span class="hljs-comment"># 场景：我们要断言 divide(1, 0) 一定会抛出 ValueError</span><br>    <span class="hljs-comment"># 如果代码执行完没有抛出异常，这个测试用例就会 FAILED</span><br>    <span class="hljs-keyword">with</span> pytest.raises(ValueError):<br>        divide(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 进阶：断言抛出的异常信息（msg）是否正确</span><br>    <span class="hljs-keyword">with</span> pytest.raises(ValueError) <span class="hljs-keyword">as</span> excinfo:<br>        divide(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># excinfo.value 是捕获到的异常对象</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;除数不能为0&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(excinfo.value)<br></code></pre></td></tr></table></figure><ol><li><strong>绝大多数时候</strong>：直接写 <code>assert 表达式</code>。</li><li><strong>遇到小数</strong>：用 <code>assert x == pytest.approx(y)</code>。</li><li><strong>预测代码崩溃&#x2F;报错</strong>：用 <code>with pytest.raises(ErrorType):</code>。</li></ol><hr><h1 id="Fixtrue基础"><a href="#Fixtrue基础" class="headerlink" title="Fixtrue基础"></a>Fixtrue基础</h1><h3 id="什么是-Fixture？"><a href="#什么是-Fixture？" class="headerlink" title="什么是 Fixture？"></a>什么是 Fixture？</h3><p>在 <code>unittest</code> 中，如果要在测试前做准备（比如连数据库），测试后做清理（比如断开数据库），必须写固定的 <code>setUp()</code> 和 <code>tearDown()</code> 方法。两个问题：</p><ol><li><strong>太死板</strong>：所有用例都会执行它，没法挑着用。</li><li><strong>难复用</strong>：跨文件的复用很麻烦。</li></ol><p>Fixture 的本质是：依赖注入（Dependency Injection）。需要什么配置，就在测试函数的参数里写上那个 Fixture 的名字，Pytest 会自动把在这个东西准备好并“注入”进去。</p><hr><h3 id="核心知识点-1：定义与调用"><a href="#核心知识点-1：定义与调用" class="headerlink" title="核心知识点 1：定义与调用"></a>核心知识点 1：定义与调用</h3><p>使用 <code>@pytest.fixture</code> 装饰器来定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># 1. 定义一个 fixture</span><br><span class="hljs-comment"># 假设这是一个模拟登录的功能</span><br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_data</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n[Setup] 正在准备登录数据...&quot;</span>)<br>    data = &#123;<span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;abc12345&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>&#125;<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># 2. 调用 fixture</span><br><span class="hljs-comment"># 只需要把 fixture 的函数名作为参数传给测试用例即可！</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cart</span>(<span class="hljs-params">login_data</span>):<br>    <span class="hljs-comment"># Pytest 会先运行 login_data函数，把返回值赋给这里的参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在测试购物车...&quot;</span>)<br>    <span class="hljs-comment"># 可以直接使用 fixture 的返回值</span><br>    <span class="hljs-keyword">assert</span> login_data[<span class="hljs-string">&quot;user&quot;</span>] == <span class="hljs-string">&quot;admin&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_search</span>():<br>    <span class="hljs-comment"># 这个用例没有加参数，所以不会执行登录操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在测试搜索（不需要登录）...&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><ul><li><code>test_cart</code> 加上了 <code>login_data</code> 参数，Pytest 就知道：“哦，运行这个用例前，我得先去运行 <code>login_data</code> 这个函数。”</li><li><code>test_search</code> 没加，就不运行。这就是<strong>按需分配</strong>。</li></ul><hr><h3 id="核心知识点-2：-yield（前后置分离）"><a href="#核心知识点-2：-yield（前后置分离）" class="headerlink" title="核心知识点 2： yield（前后置分离）"></a>核心知识点 2： yield（前后置分离）</h3><p>问：<em>“Pytest 怎么做 Teardown（清理操作）？”</em></p><p>答案是：<strong>使用 <code>yield</code> 关键字。</strong></p><p>Fixture 函数中：</p><ul><li><code>yield</code> <strong>之前</strong>的代码：相当于 <code>setUp</code>（前置）。</li><li><code>yield</code> <strong>之后</strong>的代码：相当于 <code>tearDown</code>（后置）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():<br>    service = Service(executable_path=<span class="hljs-string">&quot;D:\\develop\\chromedriver-win64\\chromedriver.exe&quot;</span>)<br>    driver = webdriver.Chrome(service=service)<br>    driver.get(<span class="hljs-string">&quot;https://www.baidu.com/ &quot;</span>)<br>    driver.maximize_window()<br>    <span class="hljs-keyword">yield</span> driver<br>    driver.quit()<br></code></pre></td></tr></table></figure><p>在每个测试函数开始时： 启动 Chrome 浏览器。 打开百度首页并最大化窗口。 将 <code>driver</code>对象提供给测试函数使用。在每个测试函数结束后： 关闭浏览器。</p><hr><h3 id="核心知识点-3：作用域（Scope）——-性能优化的关键"><a href="#核心知识点-3：作用域（Scope）——-性能优化的关键" class="headerlink" title="核心知识点 3：作用域（Scope）—— 性能优化的关键"></a>核心知识点 3：作用域（Scope）—— 性能优化的关键</h3><p>默认情况下，Fixture 是 <code>function</code> 级别的。也就是说，<strong>每个</strong>调用它的测试用例运行前，它都会从头跑一遍。</p><p>有时候很浪费。比如“打开浏览器”或者“登录”，不希望跑 10 个用例就打开 10 次浏览器。我希望打开一次，跑完 10 个用例，再关闭。</p><p>这时就需要配置 <code>scope</code> 参数：</p><table><thead><tr><th><strong>Scope 级别</strong></th><th><strong>含义</strong></th><th><strong>生命周期</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>function</strong> (默认)</td><td>函数级</td><td>每个测试函数执行一次</td><td>需重置的数据，如计算器归零</td></tr><tr><td><strong>class</strong></td><td>类级</td><td>每个测试类执行一次</td><td>测试类中共用的简单配置</td></tr><tr><td><strong>module</strong></td><td>模块级</td><td>每个 .py 文件执行一次</td><td>单个文件内的全局配置</td></tr><tr><td><strong>session</strong></td><td>会话级</td><td><strong>整个自动化脚本只执行一次</strong></td><td><strong>最常用！</strong> 初始化数据库连接、登录获取Token、启动浏览器</td></tr></tbody></table><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一个只执行一次的 fixture</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">global_config</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; [Session Start] 读取全局配置...&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; [Session End] 清理全局资源...&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="核心知识点-4：conftest-py-——-共享之王"><a href="#核心知识点-4：conftest-py-——-共享之王" class="headerlink" title="核心知识点 4：conftest.py —— 共享之王"></a>核心知识点 4：conftest.py —— 共享之王</h3><p>如果有 10 个测试文件（<code>test_a.py</code>, <code>test_b.py</code>…）都需要用到 <code>login</code> 这个 fixture，怎么办？</p><p>不需要在每个文件里都定义一遍，也不需要 import。只需要在项目根目录下创建一个名为 conftest.py 的文件。</p><p><strong>规则：</strong></p><ol><li>文件名是 <code>conftest.py</code>。</li><li>Pytest 会自动读取它里面的 fixture。</li><li>所有测试文件都可以直接使用里面定义的 fixture，就像它们定义在本地一样。</li></ol><p><strong>项目结构示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">project/<br>├── conftest.py      &lt;-- 定义 fixture: login, db_conn<br>├── test_case1.py    &lt;-- 直接在参数里写 login<br>└── test_case2.py    &lt;-- 直接在参数里写 db_conn<br></code></pre></td></tr></table></figure><hr><h1 id="parametrize基础"><a href="#parametrize基础" class="headerlink" title="parametrize基础"></a>parametrize基础</h1><p>数据驱动（Data-Driven Testing） </p><hr><h3 id="1-核心神器：-pytest-mark-parametrize"><a href="#1-核心神器：-pytest-mark-parametrize" class="headerlink" title="1. 核心神器：@pytest.mark.parametrize"></a>1. 核心神器：@pytest.mark.parametrize</h3><p>它的作用是：<strong>参数化</strong>。它可以让同一段测试代码，根据输入数据的不同，自动生成多条测试用例。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;变量名字符串&quot;</span>, [数据列表]</span>)</span><br></code></pre></td></tr></table></figure><h4 id="实战演练：模拟登录测试"><a href="#实战演练：模拟登录测试" class="headerlink" title="实战演练：模拟登录测试"></a>实战演练：模拟登录测试</h4><p>假设有一个登录函数，我们需要测试：</p><ol><li>账号密码正确 -&gt; 成功</li><li>密码错误 -&gt; 失败</li><li>账号为空 -&gt; 失败</li></ol><p>不使用参数化（笨办法）：写 3 个函数，代码重复率极高。</p><p><strong>使用参数化（聪明办法）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># 假设的业务代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-keyword">and</span> password == <span class="hljs-string">&quot;123456&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fail&quot;</span><br><br><span class="hljs-comment"># 数据驱动测试</span><br><span class="hljs-comment"># 1. 第一个参数：变量名，用字符串表示，逗号隔开，必须和下面函数参数名一致</span><br><span class="hljs-comment"># 2. 第二个参数：一个列表，列表里的每个元素是一个元组（代表一组测试数据）</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;user, pwd, expected&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;success&quot;</span></span>),  <span class="hljs-comment"># 用例1</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;wrong&quot;</span>, <span class="hljs-string">&quot;fail&quot;</span></span>),      <span class="hljs-comment"># 用例2</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;fail&quot;</span></span>)           <span class="hljs-comment"># 用例3</span></span></span><br><span class="hljs-params"><span class="hljs-meta">]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_logic</span>(<span class="hljs-params">user, pwd, expected</span>):<br>    <span class="hljs-comment"># Pytest 会自动循环 3 次，每次提取一组数据传进来</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n测试数据: 用户=<span class="hljs-subst">&#123;user&#125;</span>, 密码=<span class="hljs-subst">&#123;pwd&#125;</span>&quot;</span>)<br>    res = login(user, pwd)<br>    <span class="hljs-keyword">assert</span> res == expected<br></code></pre></td></tr></table></figure><p>运行结果：显示 collected 3 items。即它自动把1个函数变成了3个独立的测试用例运行！</p><hr><h3 id="2-进阶技巧：笛卡尔积（组合测试）"><a href="#2-进阶技巧：笛卡尔积（组合测试）" class="headerlink" title="2. 进阶技巧：笛卡尔积（组合测试）"></a>2. 进阶技巧：笛卡尔积（组合测试）</h3><p><em>“如果我要测 3 种手机系统（iOS, Android, Harmony）搭配 2 种网络环境（WiFi, 5G），一共 6 种组合，怎么写最简单？”</em></p><p>不需要手动列出 6 个元组，只需要<strong>堆叠装饰器</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;os&quot;</span>, [<span class="hljs-string">&quot;iOS&quot;</span>, <span class="hljs-string">&quot;Android&quot;</span>, <span class="hljs-string">&quot;Harmony&quot;</span>]</span>)</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;net&quot;</span>, [<span class="hljs-string">&quot;WiFi&quot;</span>, <span class="hljs-string">&quot;5G&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_mobile_env</span>(<span class="hljs-params">os, net</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前环境: <span class="hljs-subst">&#123;os&#125;</span> + <span class="hljs-subst">&#123;net&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>结果</strong>：Pytest 会自动算出所有组合，生成 6 条用例。</p><hr><h3 id="3-全局配置文件：pytest-ini"><a href="#3-全局配置文件：pytest-ini" class="headerlink" title="3. 全局配置文件：pytest.ini"></a>3. 全局配置文件：pytest.ini</h3><p>在实际工作中，不会每次都敲 pytest -vs，也不会希望 Pytest 去扫描所有文件夹。我们需要一个“管家”。</p><p>在项目<strong>根目录</strong>下创建一个名为 <code>pytest.ini</code> 的文件（注意：Windows下文件内尽量不要出现中文注释，容易报编码错误，或者保存为 ANSI 格式）。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-comment">; 1. 默认命令行参数</span><br><span class="hljs-comment">; 以后直接敲 pytest 就行，不需要敲 pytest -vs 了</span><br><span class="hljs-attr">addopts</span> = -vs --html=./report.html<br><br><span class="hljs-comment">; 2. 指定测试用例的搜索目录</span><br><span class="hljs-comment">; 告诉 pytest 只去 testcases 目录下找，别去 venv 目录下瞎找，提升速度</span><br><span class="hljs-attr">testpaths</span> = ./testcases<br><br><span class="hljs-comment">; 3. 修改文件搜索规则（如果你非要以 check_ 开头）</span><br><span class="hljs-attr">python_files</span> = test_*.py check_*.py<br><span class="hljs-attr">python_classes</span> = Test* Check*<br><span class="hljs-attr">python_functions</span> = test_* check_*<br><br><span class="hljs-comment">; 4. 注册自定义标记（为了消除警告）</span><br><span class="hljs-attr">markers</span> =<br>    smoke: 冒烟测试<br>    user_manage: 用户管理模块<br></code></pre></td></tr></table></figure><p>有了这个文件，以后你在终端只需要输入简单的 <code>pytest</code> 四个字母，所有的配置（详细输出、生成报告、路径过滤）都会自动生效。</p><hr><h1 id="Allure基础"><a href="#Allure基础" class="headerlink" title="Allure基础"></a>Allure基础</h1><p><strong>Allure</strong> 是目前测试圈最顶级的测试报告框架。Allure 的报告支持多语言、由 Java 渲染、交互性极强，并且可以直接对接 Jenkins。</p><hr><h3 id="运行并生成报告"><a href="#运行并生成报告" class="headerlink" title="运行并生成报告"></a>运行并生成报告</h3><p>生成报告分两步走：<strong>运行</strong> -&gt; <strong>渲染</strong>。</p><h4 id="1-修改-pytest-ini（推荐）"><a href="#1-修改-pytest-ini（推荐）" class="headerlink" title="1. 修改 pytest.ini（推荐）"></a>1. 修改 pytest.ini（推荐）</h4><p>为了不用每次都敲长命令，修改你的 <code>pytest.ini</code>，加入 <code>addopts</code> 配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -vs --alluredir=./temps --clean-alluredir<br><span class="hljs-attr">testpaths</span> = ./<br><span class="hljs-attr">python_files</span> = test_*.py<br><span class="hljs-attr">python_classes</span> = Test*<br><span class="hljs-attr">python_functions</span> = test_*<br></code></pre></td></tr></table></figure><h4 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2. 运行测试"></a>2. 运行测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest<br></code></pre></td></tr></table></figure><p>运行完后，项目目录下多了一个 <code>temps</code> 文件夹，里面全是乱码一样的 <code>.json</code> 和 <code>.txt</code> 文件。<strong>这是原始数据，不是直接看的。</strong></p><h4 id="3-渲染并查看报告"><a href="#3-渲染并查看报告" class="headerlink" title="3. 渲染并查看报告"></a>3. 渲染并查看报告</h4><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">allure serve ./temps<br></code></pre></td></tr></table></figure><p>*注意：<code>serve</code> 后面跟的是临时数据目录。*执行后，它会自动启动一个临时的 Web 服务（通常是 Java 启动的 Jetty），并自动在默认浏览器打开一个网页。<strong>这就是传说中的 Allure 报告！</strong></p><hr><h3 id="定制化显示"><a href="#定制化显示" class="headerlink" title="定制化显示"></a>定制化显示</h3><p>默认的报告虽然好看，但用例名字都是 <code>test_calc[1-2-3]</code> 这种代码名。需要用装饰器给报告加“元数据”,即加入 Allure 的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> allure  <span class="hljs-comment"># 导入 allure 库</span><br><br><span class="hljs-comment"># 1. Feature: 标注这是哪个大模块</span><br><span class="hljs-meta">@allure.feature(<span class="hljs-params"><span class="hljs-string">&quot;计算器模块&quot;</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCalculator</span>:<br><br>    <span class="hljs-comment"># 2. Story: 标注这是哪个具体功能/用户故事</span><br><span class="hljs-meta">    @allure.story(<span class="hljs-params"><span class="hljs-string">&quot;除法运算功能&quot;</span></span>)</span><br>    <span class="hljs-comment"># 3. Title: 自定义用例标题（支持参数化占位符）</span><br><span class="hljs-meta">    @allure.title(<span class="hljs-params"><span class="hljs-string">&quot;测试用例：&#123;a&#125; 除以 &#123;b&#125;&quot;</span></span>)</span><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;a, b, expected&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0.3333333333</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ZeroDivisionError</span>)</span></span><br><span class="hljs-params"><span class="hljs-meta">    ]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_div</span>(<span class="hljs-params">self, a, b, expected</span>):<br>        <span class="hljs-comment"># 4. Step: 标注测试步骤，报告里会分层级显示</span><br>        <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">f&quot;步骤1：准备数据 a=<span class="hljs-subst">&#123;a&#125;</span>, b=<span class="hljs-subst">&#123;b&#125;</span>&quot;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备数据...&quot;</span>)<br>        <br>        <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">&quot;步骤2：执行计算并断言&quot;</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(expected, <span class="hljs-built_in">type</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(expected, Exception):<br>                <span class="hljs-keyword">with</span> pytest.raises(expected):<br>                    <span class="hljs-keyword">assert</span> a / b<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">assert</span> a / b == pytest.approx(expected)<br></code></pre></td></tr></table></figure><p>报告变得非常清晰：左侧菜单有了“计算器模块”，点进去能看到“除法运算功能”，右侧的步骤里有“步骤1”、“步骤2”，甚至报错时会有红色的堆栈信息。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pytest</tag>
      
      <tag>单元测试</tag>
      
      <tag>fixture</tag>
      
      <tag>allure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP测试</title>
    <link href="/2025/12/13/APP%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/12/13/APP%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="APP与Web区别"><a href="#APP与Web区别" class="headerlink" title="APP与Web区别"></a>APP与Web区别</h1><p>系统架构：APP是C&#x2F;S结构，web是B&#x2F;S结构 </p><p>C&#x2F;S（Client&#x2F;Server ） ：即客户端&#x2F;服务器，需要下载安装客户端。</p><p>B&#x2F;S（Browser&#x2F;Server ）：即浏览器&#x2F;服务器，基于浏览器访问。</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image1.png" class="" title="app测试"><hr><h1 id="APP发布"><a href="#APP发布" class="headerlink" title="APP发布"></a>APP发布</h1><h3 id="1-App-发布的完整环境流转"><a href="#1-App-发布的完整环境流转" class="headerlink" title="1. App 发布的完整环境流转"></a>1. App 发布的完整环境流转</h3><p>在 App 发布给真实用户之前，通常会经历几个不同的环境：</p><ol><li><strong>开发环境 (Dev Environment)</strong><ul><li><strong>谁在用</strong>：开发人员 (Developers)。</li><li><strong>特点</strong>：代码变动最频繁，最不稳定，功能可能只有雏形。</li></ul></li><li><strong>测试环境 (Test &#x2F; SIT - System Integration Testing)</strong><ul><li><strong>谁在用</strong>：<strong>测试&#x2F;测开</strong>。</li><li><strong>特点</strong>：比较稳定。开发提测后，在这里找 Bug。<strong>所有的自动化脚本通常也是针对这个环境编写的。</strong></li></ul></li><li><strong>预发布环境 (Pre-production &#x2F; UAT - User Acceptance Testing)</strong><ul><li><strong>谁在用</strong>：产品经理、测试人员、少部分内部种子用户。</li><li><strong>特点</strong>：<strong>数据源通常连接的是真实的线上数据库</strong>（或者经过脱敏的线上数据），但是代码是新的。这是上线前的最后一道防线，用来检查配置是否正确。</li></ul></li><li><strong>生产环境 (Production)</strong><ul><li><strong>谁在用</strong>：真实用户。</li><li><strong>特点</strong>：绝对严谨，出了问题就是“线上事故”。</li></ul></li></ol><hr><h3 id="2-核心发布策略"><a href="#2-核心发布策略" class="headerlink" title="2. 核心发布策略"></a>2. 核心发布策略</h3><p>问：“你们的 App 是怎么上线的？是一次性全量发布吗？”</p><h4 id="A-全量发布"><a href="#A-全量发布" class="headerlink" title="A. 全量发布"></a>A. 全量发布</h4><ul><li><strong>含义</strong>：设定一个时间点，所有应用商店同步上架，所有用户都能下载到新版本。</li><li><strong>风险</strong>：如果有一个严重的崩溃 Bug（Crash），所有用户都会受影响，损失巨大。</li></ul><h4 id="B-灰度发布-Gray-scale-Release-Canary-Release-——-非常重要"><a href="#B-灰度发布-Gray-scale-Release-Canary-Release-——-非常重要" class="headerlink" title="B. 灰度发布 (Gray-scale Release &#x2F; Canary Release) —— 非常重要"></a>B. 灰度发布 (Gray-scale Release &#x2F; Canary Release) —— <strong>非常重要</strong></h4><ul><li><strong>含义</strong>：先让 <strong>一小部分人</strong> 更新到新版本，如果没有问题，再慢慢扩大范围，直到全量。</li><li><strong>怎么做</strong>：<ul><li><strong>按比例</strong>：先放 5% 的用户，再放 20%，最后 100%。</li><li><strong>按地区</strong>：比如先在某个省份发布。</li><li><strong>按白名单</strong>：先让公司内部员工更新。</li></ul></li><li><strong>测试职责</strong>：在灰度期间，测试人员要通过后台监控系统（如 Bugly, Sentry）紧盯崩溃率。如果报错飙升，必须立即<strong>回滚 (Rollback)</strong>。</li></ul><h4 id="C-A-B-测试"><a href="#C-A-B-测试" class="headerlink" title="C. A&#x2F;B 测试"></a>C. A&#x2F;B 测试</h4><ul><li><strong>含义</strong>：这不是为了修 Bug，而是为了<strong>验证功能</strong>。<ul><li>A 组用户看到红色的购买按钮。</li><li>B 组用户看到蓝色的购买按钮。</li><li>看哪组下单的人多，最后决定上线哪个版本。</li></ul></li></ul><hr><h3 id="3-Android-与-iOS-发布的区别"><a href="#3-Android-与-iOS-发布的区别" class="headerlink" title="3. Android 与 iOS 发布的区别"></a>3. Android 与 iOS 发布的区别</h3><p>这也是 App 测试必须要知道的背景知识，因为审核机制完全不同。</p><table><thead><tr><th><strong>维度</strong></th><th><strong>Android (安卓)</strong></th><th><strong>iOS (苹果)</strong></th></tr></thead><tbody><tr><td><strong>应用商店</strong></td><td><strong>渠道极其分散</strong>。国内主要有：华为、小米、OPPO、VIVO、应用宝、百度手机助手等。</td><td><strong>App Store 唯一渠道</strong> (TestFlight 用于内测)。</td></tr><tr><td><strong>审核时间</strong></td><td>较快（几小时到1天），有时候甚至无需审核（企业包）。</td><td><strong>非常严格</strong>且慢（通常需要 1-3 天），甚至可能因为 UI 不符合苹果规范被拒。</td></tr><tr><td><strong>安装包格式</strong></td><td><code>.apk</code></td><td><code>.ipa</code></td></tr><tr><td><strong>测试痛点</strong></td><td>需要验证<strong>多渠道包</strong>（统计不同商店的下载量），每个商店的包签名可能不同。</td><td>需要验证审核被拒后的紧急修复流程。</td></tr></tbody></table><hr><h3 id="4-强更、弱更与热更新"><a href="#4-强更、弱更与热更新" class="headerlink" title="4. 强更、弱更与热更新"></a>4. 强更、弱更与热更新</h3><p>这是用户感知层面的更新方式，测试时需要专门覆盖这几种场景。</p><ol><li><strong>强制更新 (Force Update)</strong>：<ul><li>App 启动时弹窗，<strong>只有一个“立即更新”按钮</strong>，不更新就退步出，没法用。</li><li><em>测试点</em>：通常用于修复重大 Bug 或 API 协议变更，必须确保旧版本被完全拦截。</li></ul></li><li><strong>非强制更新&#x2F;弱更 (Optional Update)</strong>：<ul><li>弹窗有“以后再说”或“取消”按钮。</li><li><em>测试点</em>：用户点取消后，App 的核心功能（如数据接口）还能不能兼容旧版本？</li></ul></li><li><strong>热更新 (Hotfix) —— 测开必须了解的技术</strong>：<ul><li><strong>原理</strong>：用户<strong>不需要</strong>去应用商店重新下载几十 MB 的安装包。App 启动时默默下载一个小补丁（Patch），直接替换代码。</li><li><strong>优势</strong>：速度快，用户无感知。常用于游戏或修复紧急 Bug。</li><li><em>测试点</em>：补丁下载失败怎么办？补丁是否生效了？</li></ul></li></ol><hr><h3 id="📝-总结：测试人员在发布阶段要做什么？"><a href="#📝-总结：测试人员在发布阶段要做什么？" class="headerlink" title="📝 总结：测试人员在发布阶段要做什么？"></a>📝 总结：测试人员在发布阶段要做什么？</h3><ol><li><strong>回归测试 (Regression Test)</strong>：确保新功能没问题，且<strong>旧功能没有被改坏</strong>。</li><li><strong>验收测试 (UAT)</strong>：产品经理确认功能符合需求。</li><li><strong>兼容性检查</strong>：抽取目前市场上主流的 TOP 10 手机型号（测开通常会维护一个云真机平台）跑一遍安装启动。</li><li><strong>渠道包检查</strong>：如果是安卓，要检查不同应用商店的包（华为包、小米包）是否都能正常唤起支付、登录（因为不同渠道SDK可能不同）。</li></ol><hr><h1 id="APP功能测试"><a href="#APP功能测试" class="headerlink" title="APP功能测试"></a>APP功能测试</h1><p>App 的<strong>功能测试（Functional Testing）</strong>，其核心逻辑和 Web 测试、桌面软件测试是一致的。都是基于<strong>黑盒测试</strong>方法（如等价类划分、边界值分析、错误推测法），验证“<strong>输入</strong>”经过“<strong>处理</strong>”后，得到的“<strong>输出</strong>”是否符合需求文档。</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image2.png" class="" title="功能测试"><h4 id="第一部分：输入框验证（对应图中“1-输入”）"><a href="#第一部分：输入框验证（对应图中“1-输入”）" class="headerlink" title="第一部分：输入框验证（对应图中“1. 输入”）"></a>第一部分：输入框验证（对应图中“1. 输入”）</h4><p>这部分主要考察<strong>等价类划分</strong>（有效数据 vs 无效数据）和<strong>错误推测</strong>。</p><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>基础输入</strong></td><td>输入“牙膏” (汉字)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“yagao” (全拼)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“yag” 或 “gao” (部分拼音)</td><td>搜索出牙膏相关商品</td></tr><tr><td></td><td>输入“toothpaste” (英文)</td><td>搜索出牙膏相关商品</td></tr><tr><td><strong>混合输入</strong></td><td>输入“牙gao” (中英混合)</td><td>搜索出牙膏相关商品</td></tr><tr><td><strong>纠错机制</strong></td><td>输入“呀高”、“牙稿” (同音错别字)</td><td><strong>纠错提示</strong>：“您是否要找‘牙膏’？”，或直接展示牙膏结果，但顶部提示“已为您显示‘牙膏’的搜索结果”</td></tr><tr><td><strong>同音&#x2F;数字</strong></td><td>输入“yinle”</td><td>搜索出“音乐”相关商品</td></tr><tr><td></td><td>输入“12”</td><td>搜索结果包含带“12”的商品，也包含带“十二”的商品</td></tr><tr><td><strong>符号处理</strong></td><td>输入“牙 膏】” (含空格和特殊符号)</td><td>忽略干扰符号，搜索结果等同于“牙膏”</td></tr><tr><td><strong>自动补全</strong></td><td>输入“手机”</td><td>下拉联想框出现“手机壳”、“手机膜”、“手机支架”等高频词</td></tr><tr><td></td><td>删除输入框内容</td><td>联想框消失，恢复初始状态（如显示搜索历史）</td></tr></tbody></table><h4 id="第二部分：匹配逻辑验证（对应图中“2-匹配”）"><a href="#第二部分：匹配逻辑验证（对应图中“2-匹配”）" class="headerlink" title="第二部分：匹配逻辑验证（对应图中“2. 匹配”）"></a>第二部分：匹配逻辑验证（对应图中“2. 匹配”）</h4><p>这部分是搜索的核心算法逻辑，主要验证<strong>后端逻辑</strong>。</p><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>多维度匹配</strong></td><td>输入“华为” (品牌)</td><td>列表展示华为手机、华为电脑、华为数据线等</td></tr><tr><td></td><td>输入某一具体商品标题</td><td>精确匹配到该商品</td></tr><tr><td></td><td>输入商品分类 (如“零食”)</td><td>展示该分类下的所有商品</td></tr><tr><td><strong>分词匹配</strong></td><td>输入“康师傅饮料”</td><td><strong>分词逻辑</strong>：搜索结果应包含“康师傅”品牌且属于“饮料”类的商品 (即 A 且 B)</td></tr><tr><td><strong>为空匹配</strong></td><td>不输入任何内容，直接点击搜索</td><td><strong>需求规定</strong>：展示“推荐内容” (这里要确认是热门推荐还是个性化推荐)</td></tr><tr><td><strong>无结果处理</strong></td><td>输入乱码或数据库不存在的词 (如“@#￥%”)</td><td>展示“未找到相关商品”，并推荐相似商品或热门商品 (依据图中“联想相近词”的需求)</td></tr></tbody></table><h4 id="第三部分：排序与结果展示（对应图中“3-排序”）"><a href="#第三部分：排序与结果展示（对应图中“3-排序”）" class="headerlink" title="第三部分：排序与结果展示（对应图中“3. 排序”）"></a>第三部分：排序与结果展示（对应图中“3. 排序”）</h4><table><thead><tr><th><strong>测试点</strong></th><th><strong>详细测试用例</strong></th><th><strong>预期结果 (基于需求图)</strong></th></tr></thead><tbody><tr><td><strong>默认排序</strong></td><td>搜索任意关键词</td><td>列表第一页商品默认按<strong>销量</strong>降序排列</td></tr><tr><td><strong>手动排序</strong></td><td>点击“价格”</td><td>第一次点击按价格升序，再次点击按价格降序</td></tr><tr><td></td><td>点击“最新”</td><td>按商品上架时间倒序排列</td></tr><tr><td></td><td>点击“人气&#x2F;收藏”</td><td>按收藏量或浏览量排序</td></tr><tr><td><strong>分页加载</strong></td><td>上滑列表到底部</td><td>自动加载下一页数据（通常每页 10-20 条）</td></tr></tbody></table><hr><h3 id="🔥-第四部分：App-特有的功能测试点"><a href="#🔥-第四部分：App-特有的功能测试点" class="headerlink" title="🔥 第四部分：App 特有的功能测试点"></a>🔥 第四部分：App 特有的功能测试点</h3><p><strong>针对 App 搜索，补充以下场景：</strong></p><h4 id="1-软键盘交互-Interaction"><a href="#1-软键盘交互-Interaction" class="headerlink" title="1. 软键盘交互 (Interaction)"></a>1. 软键盘交互 (Interaction)</h4><ul><li><strong>键盘唤起</strong>：点击输入框，手机软键盘是否正常弹出？会不会遮挡输入框？</li><li><strong>搜索键触发</strong>：点击软键盘右下角的“搜索”&#x2F;“Go”&#x2F;“回车”按钮，是否能触发搜索？（<strong>这个非常重要，很多 Bug 出在这里</strong>）</li><li><strong>键盘收起</strong>：开始滚动搜索结果列表时，软键盘是否自动收起？</li></ul><h4 id="2-搜索历史-Search-History"><a href="#2-搜索历史-Search-History" class="headerlink" title="2. 搜索历史 (Search History)"></a>2. 搜索历史 (Search History)</h4><ul><li><strong>历史记录</strong>：搜索成功后，该词条是否存入“历史记录”？</li><li><strong>历史点击</strong>：点击历史记录中的词，是否直接发起搜索？</li><li><strong>历史清除</strong>：是否有“清空历史”的按钮？</li></ul><h4 id="3-语音搜索-Voice-Input"><a href="#3-语音搜索-Voice-Input" class="headerlink" title="3. 语音搜索 (Voice Input)"></a>3. 语音搜索 (Voice Input)</h4><ul><li>如果输入框有麦克风图标，点击能否唤起语音输入？识别的文字是否自动填入输入框？</li></ul><h4 id="4-特殊场景-Interruptions-Network"><a href="#4-特殊场景-Interruptions-Network" class="headerlink" title="4. 特殊场景 (Interruptions &amp; Network)"></a>4. 特殊场景 (Interruptions &amp; Network)</h4><ul><li><strong>网络延迟</strong>：在网络极差（弱网）时，输入“手”，联想词“手机”还没加载出来，用户这时候快速输入了“表”，联想结果会不会乱跳？（比如突然跳出“手”的联想结果覆盖了“手表”的结果）。</li><li><strong>前后台切换</strong>：在搜索结果页切到后台（比如回微信消息），再切回来，页面是否保持原样？还是被刷新了？</li></ul><hr><h1 id="APP专项测试"><a href="#APP专项测试" class="headerlink" title="APP专项测试"></a>APP专项测试</h1><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image8.png" class="" title="专项测试"><h2 id="安装、卸载、升级"><a href="#安装、卸载、升级" class="headerlink" title="安装、卸载、升级"></a>安装、卸载、升级</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image3.png" class="" title="安装测试"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image4.png" class="" title="卸载升级测试"><p>挑几个测试点写测试用例：</p><table><thead><tr><th><strong>模块</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>安装</strong></td><td><strong>P0</strong></td><td><strong>正常安装流程验证</strong></td><td>手机空间充足，网络正常</td><td>1. 获取最新 APK 安装包 2. 点击安装</td><td>1. 安装过程流畅无报错 2. 桌面出现正确图标 3. 点击图标能正常启动</td></tr><tr><td><strong>安装</strong></td><td>P1</td><td><strong>存储空间不足时的安装处理</strong></td><td>手机剩余存储空间 <strong>小于</strong> 安装包大小</td><td>1. 点击 APK 进行安装 2. 观察系统提示</td><td>1. 安装被终止，无 Crash 2. 弹出“存储空间不足”提示</td></tr><tr><td><strong>安装</strong></td><td>P2</td><td><strong>安装过程中断网&#x2F;断电测试</strong></td><td>手机处于安装进度条约 50% 时</td><td>1. 突然断开网络或强制关机 2. 重启手机检查环境</td><td>1. 安装失败 2. 系统无残留不可用的垃圾文件 3. 再次安装能正常进行</td></tr><tr><td><strong>安装</strong></td><td>P2</td><td><strong>低版本覆盖安装高版本（降级）</strong></td><td>手机已安装 V2.0 版本</td><td>1. 尝试覆盖安装 V1.0 版本</td><td>1. 系统提示安装失败（禁止降级） 2. 原有 V2.0 版本不受影响</td></tr><tr><td><strong>卸载</strong></td><td><strong>P0</strong></td><td><strong>正常卸载及数据清理</strong></td><td>App 已登录并产生缓存数据</td><td>1. 长按图标卸载 2. 检查文件管理器</td><td>1. 图标消失 2. 应用私有目录下的缓存文件被彻底删除</td></tr><tr><td><strong>卸载</strong></td><td>P1</td><td><strong>App 运行时强制卸载</strong></td><td>App 正在后台播放音频或下载</td><td>1. 进入系统设置强制卸载该 App</td><td>1. 后台进程立即终止（声音&#x2F;下载停止） 2. 卸载成功，无报错</td></tr><tr><td><strong>卸载</strong></td><td>P2</td><td><strong>取消卸载操作</strong></td><td>无</td><td>1. 点击卸载 2. 在确认弹窗点“取消”</td><td>1. App 未被卸载 2. 点击 App 能正常进入，账号未登出</td></tr><tr><td><strong>升级</strong></td><td><strong>P0</strong></td><td><strong>跨版本升级数据兼容性</strong></td><td>安装 V1.0 并保存了本地数据（如购物车）</td><td>1. 直接覆盖安装 V3.0（跳过 V2.0） 2. 启动 App 检查数据</td><td>1. 启动正常 2. <strong>V1.0 的购物车数据在 V3.0 中完整保留</strong></td></tr><tr><td><strong>升级</strong></td><td>P1</td><td><strong>非 WiFi 环境下应用内升级提醒</strong></td><td>手机使用 4G&#x2F;5G 网络</td><td>1. App 内点击“检查更新” 2. 点击“下载”</td><td>1. 弹出流量消耗提示框 2. 只有用户确认后才开始下载</td></tr><tr><td><strong>升级</strong></td><td>P1</td><td><strong>强制更新策略验证</strong></td><td>服务端配置该版本为“强更”</td><td>1. 启动旧版本 App</td><td>1. 弹出更新弹窗，且<strong>无</strong>关闭&#x2F;取消按钮 2. 不更新无法使用 App 任何功能</td></tr></tbody></table><h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image5.png" class="" title="兼容性测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image6.png" class="" title="兼容性测试2"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>屏幕适配</strong></td><td><strong>P0</strong></td><td><strong>异形屏（刘海&#x2F;挖孔&#x2F;灵动岛）UI 适配验证</strong></td><td>选取一台刘海屏或挖孔屏手机（如 iPhone 14 Pro 或部分安卓机）</td><td>1. 启动 App 进入首页 2. 观察顶部导航栏和状态栏区域 3. 旋转屏幕（横屏模式）</td><td>1. 核心内容未被“刘海”遮挡 2. 按钮可点击，未错位 3. 底部操作栏未被系统手势条覆盖</td></tr><tr><td><strong>系统版本</strong></td><td><strong>P0</strong></td><td><strong>高低版本系统权限兼容性测试</strong></td><td>准备两台手机： A: Android 13&#x2F;14 (高版本) B: Android 6.0&#x2F;8.0 (低版本)</td><td>1. 在两台手机安装 App 2. 首次启动，触发需要权限的功能（如拍照、定位）</td><td>1. <strong>高版本</strong>：必须弹出运行时权限申请框（Runtime Permission），拒绝后 App 不崩溃 2. <strong>低版本</strong>：功能正常运行，无闪退</td></tr><tr><td><strong>应用共存</strong></td><td>P1</td><td><strong>后台音频播放冲突测试</strong></td><td>1. 手机后台正在使用网易云&#x2F;QQ音乐播放歌曲 2. 手机未静音</td><td>1. 打开被测 App 2. 进入播放视频或音频的页面 3. 点击播放</td><td>1. <strong>音频焦点抢占</strong>：后台音乐应自动暂停或音量降低（Duck） 2. App 内视频声音正常播出 3. 退出 App 视频后，后台音乐恢复（可选，视需求而定）</td></tr><tr><td><strong>硬件兼容</strong></td><td>P2</td><td><strong>蓝牙外设连接切换测试</strong></td><td>1. 手机蓝牙开启 2. 准备一副蓝牙耳机</td><td>1. App 正在外放播放视频 2. 连接蓝牙耳机 3. 断开蓝牙耳机</td><td>1. 连接时：声音无缝切换到耳机，且无杂音 2. 断开时：视频自动暂停（防止在公共场合突然外放尴尬）或切换回扬声器</td></tr><tr><td><strong>分辨率</strong></td><td>P1</td><td><strong>低分辨率小屏机型显示测试</strong></td><td>选取老旧机型或设置模拟器为 720*1280 分辨率</td><td>1. 打开 App 包含长文本或列表的页面 2. 调整字体大小（如系统设置了大字体）</td><td>1. 文字未重叠、未溢出边界 2. 底部按钮依然可见，未被挤出屏幕外</td></tr></tbody></table><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image7.png" class="" title="兼容性测试3"><p>问：“市面上手机好几千款，不可能把这些用例在每一台手机上都跑一遍吧？”</p><p>标准的工业级解决方案是：</p><ol><li><strong>Top N 策略</strong>：<ul><li>查看线上的用户数据（比如通过百度统计、Umeng），找出你们 App 用户量最大的 <strong>Top 20 - Top 50</strong> 款机型进行覆盖。</li></ul></li><li><strong>云测平台 (Cloud Testing)</strong>：<ul><li>使用 <strong>Testin (云测)</strong>、<strong>腾讯 WeTest</strong> 等平台。</li><li><strong>怎么做</strong>：只需要把打包好的 APK 上传到网页上，选择“兼容性测试”，勾选 100 台热门手机。</li><li><strong>结果</strong>：云平台会自动安装、启动、运行 Monkey（随机乱点），然后给一份报告，哪款手机安装失败，哪款手机 UI 错位（带截图）。</li></ul></li></ol><h2 id="push消息推送"><a href="#push消息推送" class="headerlink" title="push消息推送"></a>push消息推送</h2><p>Push消息是APP推送的各种通知。 如：点赞、评论、关注</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image9.png" class="" title="push消息推送测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image10.png" class="" title="push消息推送测试2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image11.png" class="" title="push消息推送测试3"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>状态场景</strong></td><td><strong>P0</strong></td><td><strong>App 后台运行时的消息接收与展示</strong></td><td>1. 手机网络正常 2. App 登录并切换至后台（Home 键）</td><td>1. 通过推送平台发送一条标准通知 2. 观察手机通知栏</td><td>1. 手机震动&#x2F;响铃（视系统设置而定） 2. 通知栏弹出消息，标题内容无误 3. 收到消息时 App <strong>不应</strong>被系统唤醒至前台（保持后台状态）</td></tr><tr><td><strong>状态场景</strong></td><td>P1</td><td><strong>App 前台运行时的消息提示</strong></td><td>App 正在当前屏幕运行（用户正在使用）</td><td>1. 发送一条推送消息</td><td>1. <strong>UI 体验检查</strong>：通常不应直接弹出系统通知栏打断用户操作 2. 常见逻辑是：App 顶部出现应用内横幅提醒，或仅在图标上显示小红点（Badging）</td></tr><tr><td><strong>状态场景</strong></td><td>P1</td><td><strong>App 离线&#x2F;进程被杀后的接收能力</strong></td><td>手动划掉 App 进程，确保 App 未运行</td><td>1. 发送推送消息 2. 等待 1-2 分钟</td><td>1. <strong>安卓</strong>：取决于推送通道（厂商通道如华为&#x2F;小米应能收到；第三方 App 通道可能收不到） 2. <strong>iOS</strong>：必须能收到（走 APNs 系统通道）</td></tr><tr><td><strong>交互跳转</strong></td><td><strong>P0</strong></td><td><strong>点击推送消息跳转至指定详情页 (Deep Link)</strong></td><td>手机通知栏已收到一条关于“商品 A 降价”的推送</td><td>1. 点击该条通知消息</td><td>1. 自动启动 App 2. <strong>直接跳转</strong>到“商品 A”的详情页，而不是 App 首页 3. 如果 App 未登录，应先跳登录页，登录后自动跳回商品页</td></tr><tr><td><strong>精准推送</strong></td><td>P1</td><td><strong>特定用户定向推送验证</strong></td><td>准备两台手机： A 手机登录用户 User1 B 手机登录用户 User2</td><td>1. 后台配置仅向 User1 发送优惠券通知 2. 观察两台手机</td><td>1. <strong>A 手机</strong>：收到推送 2. <strong>B 手机</strong>：<strong>未</strong>收到推送（验证身份匹配逻辑）</td></tr><tr><td><strong>用户设置</strong></td><td>P2</td><td><strong>客户端关闭推送权限验证</strong></td><td>在 App 的“设置”或手机系统设置中，<strong>关闭</strong>“接收通知”开关</td><td>1. 后台发送全量推送消息</td><td>1. 手机通知栏<strong>没有任何反应</strong> 2. App 启动后，消息中心（站内信）可能依然有红点（视需求而定，但系统级通知必须屏蔽）</td></tr><tr><td><strong>过期逻辑</strong></td><td>P2</td><td><strong>消息过期&#x2F;TTL 测试</strong></td><td>手机开启飞行模式（断网）</td><td>1. 后台发送一条有效期为 5 分钟的限时抢购消息 2. 等待 10 分钟后 3. 手机关闭飞行模式（恢复网络）</td><td>1. 手机<strong>不应</strong>收到该条消息（因为已过期，服务器应丢弃该消息，避免用户点进去发现活动结束了）</td></tr></tbody></table><p>问：“为什么有时候安卓手机收不到推送，苹果却能收到？” 你可以用图中的知识点回答：</p><ol><li><strong>机制不同</strong>：<ul><li>根据 <code>image_cd349e.png</code>，Push 本质是<strong>长连接</strong>。</li><li><strong>iOS</strong>：统一走苹果官方的 <strong>APNs</strong> (Apple Push Notification service)。只要苹果服务器不崩，手机有网就能收到。</li><li><strong>Android</strong>：虽然谷歌有 GCM&#x2F;FCM，但在国内无法使用。所以各家 App 只能自己搭建或者用第三方（极光、友盟）。</li></ul></li><li><strong>保活问题</strong>：<ul><li>安卓为了省电，系统经常杀后台进程。进程一死，长连接就断了，消息就推不进来了。</li><li><strong>解决方案</strong>：这就是为什么现在的 App 都要接入 <strong>厂商通道</strong>（华为推送、小米推送等）。因为厂商的推送服务是系统级的，杀不掉。</li></ul></li></ol><h2 id="交叉测试"><a href="#交叉测试" class="headerlink" title="交叉测试"></a>交叉测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image12.png" class="" title="交叉测试"><p>一个功能正在执行过程中，另外一个事件或操作对该过程进行干扰</p><table><thead><tr><th><strong>干扰类型</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>电话干扰</strong></td><td><strong>P0</strong></td><td><strong>App 核心操作中接听电话验证</strong></td><td>1. 手机插入 SIM 卡 2. App 正在进行核心操作（如：正在支付输入密码、正在播放视频、正在录入表单）</td><td>1. 使用另一台手机呼叫测试机 2. 测试机<strong>接通</strong>电话，通话 5 秒 3. 挂断电话，自动返回 App</td><td>1. <strong>来电时</strong>：App 自动暂停（视频&#x2F;音乐暂停），不应有异响 2. <strong>挂断后</strong>：App 页面恢复原状，<strong>输入框内的文字不消失</strong>，支付流程可继续，无 Crash</td></tr><tr><td><strong>电话干扰</strong></td><td>P1</td><td><strong>App 运行时拒接&#x2F;挂断电话</strong></td><td>同上</td><td>1. 呼叫测试机 2. 测试机直接点击**“挂断”**</td><td>1. 电话提示框消失 2. App 画面无缝恢复，操作流畅，无卡顿</td></tr><tr><td><strong>网络干扰</strong></td><td><strong>P0</strong></td><td><strong>WiFi 与 4G&#x2F;5G 网络动态切换</strong></td><td>手机连接 WiFi，且已开启 4G 数据流量</td><td>1. App 正在加载列表或下载文件 2. 突然关闭 WiFi 开关（切换到 4G） 3. 等待 10 秒后再打开 WiFi</td><td>1. <strong>切 4G 时</strong>：如下载大文件，应暂停并提示“正在使用流量”；如仅浏览资讯，应自动平滑切换无感知 2. <strong>切回 WiFi 时</strong>：自动恢复下载或数据加载 3. 全程无闪退、无“网络异常”死循环提示</td></tr><tr><td><strong>系统弹窗</strong></td><td>P1</td><td><strong>低电量&#x2F;闹钟弹窗干扰</strong></td><td>1. 设置闹钟为 1 分钟后响铃 2. 或模拟低电量（部分手机可用 ADB 模拟）</td><td>1. 在 App 内滑动浏览 2. 等待闹钟响铃或低电量弹窗弹出</td><td>1. 系统弹窗&#x2F;闹钟画面覆盖在 App 之上 2. <strong>App 进程不被杀掉</strong> 3. 关闭弹窗后，App 页面状态保持不变</td></tr><tr><td><strong>硬件干扰</strong></td><td>P2</td><td><strong>蓝牙设备连接与断开</strong></td><td>App 正在播放音频&#x2F;视频</td><td>1. 打开蓝牙耳机充电仓（自动连接） 2. 听一会儿后，关闭蓝牙（断开）</td><td>1. <strong>连接时</strong>：声音自动切到耳机 2. <strong>断开时</strong>：App 视频应<strong>自动暂停</strong>（防止公共场合外放尴尬），或者切回扬声器但用户需手动继续播放</td></tr><tr><td><strong>屏幕旋转</strong></td><td>P2</td><td><strong>横竖屏切换的数据保持</strong></td><td>手机开启“自动旋转”，App 支持横屏</td><td>1. 在输入框输入一段文字 2. 旋转手机 90 度（竖屏变横屏） 3. 再转回来</td><td>1. UI 布局适配正常（按钮没飞出屏幕） 2. <strong>关键点</strong>：输入框里的<strong>文字没有被清空</strong></td></tr></tbody></table><p>问交叉测试，可以补充以下两个核心观点：</p><ol><li><strong>资源抢占（Resource Preemption）</strong>：<ul><li>电话和闹钟属于<strong>系统级最高优先级</strong>事件。当它们发生时，App 必须乖乖让出音频焦点（Audio Focus）和屏幕焦点。如果 App “死皮赖脸”还要播放声音，就会出现 Bug（比如电话里依然听到游戏背景音）。</li></ul></li><li><strong>生命周期（Lifecycle）管理</strong>：<ul><li>当电话进来时，App 会经历 <code>onPause()</code> -&gt; <code>onStop()</code>。</li><li>电话挂断后，App 会经历 <code>onRestart()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code>。</li><li>交叉测试本质上就是在测<strong>开发人员有没有在 <code>onPause</code> 里保存数据，在 <code>onResume</code> 里恢复数据</strong>。</li></ul></li></ol><h2 id="用户体验测试"><a href="#用户体验测试" class="headerlink" title="用户体验测试"></a>用户体验测试</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image13.png" class="" title="用户体验测试"><table><thead><tr><th><strong>维度</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>易用性</strong></td><td><strong>P0</strong></td><td><strong>空数据状态下的引导页验证</strong></td><td>1. 新注册账号 2. 进入“我的订单”页面</td><td>1. 查看页面显示内容</td><td>1. <strong>不可留白</strong> 2. 显示友好的插图（如箱子图标） 3. 提供“去首页逛逛”的跳转按钮</td></tr><tr><td><strong>易用性</strong></td><td>P1</td><td><strong>按钮点击热区（点击范围）测试</strong></td><td>App 首页右上角有“消息”小图标</td><td>1. 不点击图标中心，点击图标边缘或略微偏离的位置</td><td>1. <strong>能成功触发点击</strong>（实际响应区域应比图标视觉区域大，防止误触或点不中）</td></tr><tr><td><strong>UI</strong></td><td>P1</td><td><strong>加载过程中的反馈提示</strong></td><td>网络设为慢速（弱网）</td><td>1. 点击“提交订单” 2. 等待服务器响应</td><td>1. 必须出现 <code>Loading</code> 转圈动画或进度条 2. 按钮置灰，<strong>禁止用户重复点击</strong>提交</td></tr><tr><td><strong>横竖屏</strong></td><td>P2</td><td><strong>横屏状态下的表格显示</strong></td><td>手机开启自动旋转，进入“股票行情”列表</td><td>1. 旋转手机至横屏</td><td>1. 列表自动适配宽度 2. <strong>显示更多列的信息</strong>（如原本只显示价格，现在显示涨跌幅），而不是单纯拉伸文字</td></tr><tr><td><strong>辅助功能</strong></td><td>P2</td><td><strong>系统超大字体适配测试</strong></td><td>1. 在手机系统设置中，将字体调至<strong>最大</strong> 2. 启动 App</td><td>1. 查看首页新闻标题 2. 查看底部导航栏文字</td><td>1. App 文字随系统变大 2. <strong>文字未重叠、未被遮挡</strong>（这是很多 App 的重灾区）</td></tr><tr><td><strong>易用性</strong></td><td>P2</td><td><strong>操作步骤层级深度检查</strong></td><td>无</td><td>1. 尝试找到“修改密码”功能 2. 计数点击次数</td><td>1. 路径清晰 2. 点击层级不宜过深（建议不超过 4 层菜单）</td></tr></tbody></table><hr><h1 id="APP性能测试"><a href="#APP性能测试" class="headerlink" title="APP性能测试"></a>APP性能测试</h1><p>测试app使用期间占用硬件资源（cpu、内存、流量、电量）使用情况.分类 ① App程序运行时占用手机硬件资源情况 ② App稳定性</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image14.png" class="" title="app性能测试1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image15.png" class="" title="app性能测试2"><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image16.png" class="" title="内存1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image17.png" class="" title="内存2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image18.png" class="" title="内存3"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>MEM_001</strong></td><td><strong>P0</strong></td><td><strong>App 首页静态内存占用基准测试</strong></td><td>1. 手机安装 SoloPi 和被测 App (如 tpshop) 2. 杀掉后台其他无关进程</td><td>1. 打开 SoloPi，勾选 <strong>Memory (PSS)</strong> 监控指标，开启悬浮窗。 2. 启动被测 App，进入首页。 3. <strong>静置 1 分钟</strong>，不要进行任何操作。</td><td>1. PSS 曲线应保持相对平稳，无明显持续上升趋势。 2. 记录一个平均值（例如 200MB）作为<strong>基准线 (Baseline)</strong>。</td></tr><tr><td><strong>MEM_002</strong></td><td><strong>P0</strong></td><td><strong>重复进出页面检测内存泄漏 (核心用例)</strong></td><td>1. SoloPi 悬浮窗已开启 2. 处于 App 首页</td><td>1. 点击进入一个<strong>内容丰富</strong>的二级页面（如“商品详情页”，包含大图&#x2F;视频）。 2. 待加载完成后，点击“返回”回到首页。 3. <strong>重复上述“进入-返回”操作 20 次</strong>。 4. 观察 SoloPi 的曲线变化。</td><td>1. <strong>正常</strong>：内存曲线呈锯齿状（进详情页升高，退回首页降低），最终回到基准线附近。 2. <strong>异常（内存泄漏）</strong>：曲线呈<strong>阶梯状上升</strong>（如 <code>image_c1e1f7.png</code> 所示），每次返回首页后，内存都比上一次高，无法回落到基准线。</td></tr><tr><td><strong>MEM_003</strong></td><td>P1</td><td><strong>长时间滑动列表的内存稳定性测试</strong></td><td>1. SoloPi 悬浮窗已开启 2. 进入“商品列表”或“信息流”页面</td><td>1. 快速向下滑动屏幕，不断加载新图片和数据。 2. 持续滑动 3-5 分钟。 3. 停止滑动，静置 1 分钟。</td><td>1. 滑动过程中内存会上升（正常缓存）。 2. <strong>关键点</strong>：停止滑动后，内存应有明显的<strong>回落</strong>机制（释放离开屏幕的图片资源），不能一直维持在最高点。</td></tr></tbody></table><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image19.png" class="" title="CPU1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image20.png" class="" title="CPU2"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image21.png" class="" title="CPU3"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>CPU_001</strong></td><td><strong>P0</strong></td><td><strong>App 静默&#x2F;待机状态 CPU 占用测试</strong></td><td>1. 启动 SoloPi 监控 CPU 2. 手机无后台下载任务</td><td>1. 启动被测 App，进入首页。 2. <strong>不进行任何操作</strong>，静置 1 分钟。 3. 观察“应用进程 CPU”曲线。</td><td>1. CPU 占用率应极低（通常 &lt; 5%）。 2. 曲线应为一条接近 0 的直线。 3. <strong>如果不为 0</strong>：说明代码里有死循环或无效的轮询（Polling）在空转。</td></tr><tr><td><strong>CPU_002</strong></td><td><strong>P0</strong></td><td><strong>高频滑动&#x2F;复杂动效下的 CPU 峰值测试</strong></td><td>1. 进入 App 内容最密集的页面（如商品瀑布流、朋友圈）</td><td>1. 快速上下滑动屏幕，持续 1 分钟。 2. 或者进入直播间&#x2F;播放高清视频。 3. 观察 CPU 峰值。</td><td>1. 允许有瞬间峰值（如加载时飙到 60%-80%）。 2. <strong>严禁</strong>长时间维持在 90% 以上。 3. 操作停止后，CPU 应迅速回落到低水平。</td></tr><tr><td><strong>CPU_003</strong></td><td>P1</td><td><strong>后台运行时的 CPU 占用（防偷跑）</strong></td><td>1. App 正在运行</td><td>1. 按 Home 键将 App 切到后台。 2. 锁屏，静置 5 分钟。 3. 解锁查看 SoloPi 记录的数据。</td><td>1. <strong>应用进程 CPU 必须接近 0%</strong>。 2. 如果在后台 CPU 依然很高，说明 App 在偷偷挖矿、死循环或者滥用定位，必须报 Bug。</td></tr></tbody></table><p>问：“发现 CPU 占用高，怎么分析？” </p><blockquote><p>“先看 SoloPi 的 <strong>应用进程 CPU</strong> 和 <strong>全局占用 CPU</strong>。 如果是<strong>全局高、应用低</strong>，可能是手机后台有系统更新或别的程序在跑，属于环境干扰。 如果是<strong>应用高</strong>，结合场景：</p><ol><li>如果是<strong>静止</strong>时高，多半是<strong>死循环</strong>或者<strong>定时器</strong>没关。</li><li>如果是<strong>滑动</strong>时高且卡顿，可能是<strong>UI 渲染</strong>太复杂（主线程阻塞），这往往就是导致 <strong>ANR</strong> 的元凶。”</li></ol></blockquote><h2 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image22.png" class="" title="流量1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image23.png" class="" title="流量2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>NET_001</strong></td><td><strong>P0</strong></td><td><strong>App 首次启动与页面加载流量消耗</strong></td><td>1. 手机连接 4G&#x2F;5G 网络（模拟真实环境） 2. 清除 App 缓存（确保是冷启动）</td><td>1. 打开 SoloPi，勾选 <strong>网络 (Network)</strong> 监控。 2. 启动 App，进入首页，等待加载完成。 3. 记录消耗的流量。</td><td>1. 首页加载流量应在合理范围内（如纯文本+缩略图页不应超过 2MB）。 2. 图片资源应经过压缩，不应直接加载原图。</td></tr><tr><td><strong>NET_002</strong></td><td><strong>P0</strong></td><td><strong>二次加载缓存机制验证 (省流测试)</strong></td><td>1. 已完成 NET_001 的操作（首页已加载过） 2. <strong>不清除缓存</strong></td><td>1. 杀掉进程，重新启动 App。 2. 再次进入同一个首页。 3. 对比本次流量与 NET_001 的流量。</td><td>1. <strong>本次流量应显著低于首次加载</strong>。 2. 说明 App 成功利用了本地缓存（Cache），没有重复向服务器请求相同的图片资源。</td></tr><tr><td><strong>NET_003</strong></td><td>P1</td><td><strong>后台静默流量偷跑检测</strong></td><td>1. App 处于运行状态</td><td>1. 按 Home 键切入后台。 2. 观察 SoloPi 的流量数据，持续 5 分钟。</td><td>1. <strong>Process Downlink Traffic (进程下行流量)</strong> 应接近 0KB。 2. 如果后台还在持续跑流量，说明有未关闭的长连接或轮询，属于 Bug。</td></tr><tr><td><strong>NET_004</strong></td><td>P2</td><td><strong>特定业务场景流量评估</strong></td><td>SoloPi 开启</td><td>1. 打开 App 首页。 2. <strong>上下滑动浏览动态 20秒</strong>。 3. 停止滑动。</td><td>1. 记录这 20秒消耗的总流量（例如 5MB）。 2. 与竞品（如淘宝&#x2F;京东）进行对比，如果远高于竞品，说明代码优化不足。</td></tr></tbody></table><p>“如果发现流量消耗过大，建议开发怎么改？” </p><ol><li><strong>图片压缩</strong>：缩略图用小图，点击大图再加载原图。</li><li><strong>数据缓存</strong>：加载过的数据存本地数据库，下次别再请求了。</li><li><strong>增量更新</strong>：刷新列表时，只请求最新的几条数据，而不是把整个列表重新拉一遍。</li><li><strong>数据压缩</strong>：接口传输的 JSON 数据进行 Gzip 压缩。</li></ol><h2 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h2><p>APP应用使用时对电池电量的平均消耗 常见的耗电量大的场景： 定位 网络传输 屏幕亮度 wake_locker（锁屏-解锁）</p><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image24.png" class="" title="电量1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image25.png" class="" title="电量2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>BAT_001</strong></td><td><strong>P0</strong></td><td><strong>高频操作场景下的电量消耗测试</strong></td><td>1. 手机电量充足（&gt;30%） 2. 屏幕亮度固定（如 50%） 3. 关闭蓝牙&#x2F;GPS（减少干扰）</td><td>1. 打开 SoloPi，勾选 <strong>电池 (Battery)</strong> 监控指标。 2. 启动 App 进入首页。 3. <strong>上下滑动浏览动态 2 分钟</strong>（模拟用户逛淘宝）。 4. 停止操作，查看消耗的电量值（mAh）。</td><td>1. 记录 2 分钟内的耗电量（例如 15mAh）。 2. <strong>横向对比</strong>：不能比竞品（如京东）高出太多。 3. 手机背部无异常发烫。</td></tr><tr><td><strong>BAT_002</strong></td><td>P1</td><td><strong>后台静默耗电测试（待机测试）</strong></td><td>1. App 保持后台运行 2. 手机锁屏</td><td>1. SoloPi 开启监控。 2. 将 App 切到后台，锁屏静置 <strong>30 分钟</strong>。 3. 唤醒手机看数据。</td><td>1. 耗电量应极低（接近系统待机水平）。 2. 如果 30 分钟掉了 5% 电，说明 App 唤醒了 GPS 或在该休眠时不休眠（WakeLock 锁死）。</td></tr><tr><td><strong>BAT_003</strong></td><td>P2</td><td><strong>硬件调用场景耗电测试</strong></td><td>1. 开启 GPS 或 摄像头</td><td>1. 使用 App 的地图导航或直播功能 10 分钟。 2. 记录耗电曲线。</td><td>1. 耗电会明显增加（这是正常的）。 2. 但不应导致手机温度触发“过热保护”而降频卡顿。</td></tr></tbody></table><h2 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h2><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image26.png" class="" title="流畅度1"><img src="/2025/12/13/APP%E6%B5%8B%E8%AF%95/image27.png" class="" title="流畅度2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>优先级</strong></th><th><strong>用例标题</strong></th><th><strong>前置条件</strong></th><th><strong>测试步骤 (操作逻辑)</strong></th><th><strong>预期结果 (判断标准)</strong></th></tr></thead><tbody><tr><td><strong>FPS_001</strong></td><td><strong>P0</strong></td><td><strong>长列表快速滑动流畅度测试</strong></td><td>1. 手机开启 60Hz 或更高刷新率 2. SoloPi 勾选 <strong>帧率 (FPS)</strong></td><td>1. 打开 App，进入内容丰富的首页（如商品流）。 2. <strong>快速上下滑动屏幕</strong>，持续 <strong>2分钟</strong>，不要停。 3. 观察 SoloPi 记录的 FPS 均值。</td><td>1. 平均 FPS 应保持在 <strong>50帧以上</strong>（针对 60Hz 屏幕）。 2. 过程中无明显的<strong>冻结帧 (Jank)</strong>（即 FPS 突然掉到 0 这种卡死现象）。</td></tr><tr><td><strong>FPS_002</strong></td><td>P1</td><td><strong>复杂动画转场流畅度测试</strong></td><td>1. SoloPi 监控开启</td><td>1. 点击进入一个带有复杂转场动画的页面（如直播间、送礼物特效）。 2. 反复进出该页面 10 次。</td><td>1. 动画播放过程中 FPS 不应低于 24帧。 2. 画面无撕裂、无掉帧。</td></tr><tr><td><strong>FPS_003</strong></td><td>P2</td><td><strong>静态页面 FPS 校验 (反向测试)</strong></td><td>1. SoloPi 监控开启</td><td>1. 进入一个纯文字详情页。 2. <strong>手指离开屏幕，完全静止不动</strong> 30秒。</td><td>1. <strong>FPS 极低（甚至为 0）是正常的</strong>。 2. 这不是 Bug，而是系统为了省电停止了 GPU 绘制（SurfaceFlinger 休眠）。</td></tr></tbody></table><hr><h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-什么是-ADB？-What-is-ADB"><a href="#1-什么是-ADB？-What-is-ADB" class="headerlink" title="1. 什么是 ADB？(What is ADB?)"></a>1. 什么是 ADB？(What is ADB?)</h3><p>全称 <strong>Android Debug Bridge</strong>（安卓调试桥）。</p><ul><li><strong>通俗理解</strong>：它是一座 <strong>“桥”</strong>，或者说是一个 <strong>“翻译官”</strong>。</li><li><strong>作用</strong>：它连接了 <strong>电脑 (PC&#x2F;Mac)</strong> 和 <strong>手机 (Android Device)</strong>。<ul><li>电脑不懂手机的内部指令，手机也不听电脑的鼠标点击。</li><li>ADB 的作用就是：在电脑的黑窗口（CMD）里输入一行命令，ADB 把它翻译给手机，手机执行后，再把结果（比如日志、截图）传回给电脑。</li></ul></li></ul><hr><h3 id="2-ADB-的工作原理（架构）"><a href="#2-ADB-的工作原理（架构）" class="headerlink" title="2. ADB 的工作原理（架构）"></a>2. ADB 的工作原理（架构）</h3><p>ADB 采用的是 <strong>C&#x2F;S 架构 (Client-Server)</strong>，由三部分组成：</p><ol><li><strong>Client (客户端)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>电脑</strong> 上。</li><li><strong>是谁</strong>：就是你敲命令的那个黑窗口（CMD &#x2F; Terminal）。当你输入 <code>adb devices</code> 时，就是 Client 在发号施令。</li></ul></li><li><strong>Server (服务端)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>电脑</strong> 后台运行。</li><li><strong>作用</strong>：它是一个管家。它负责管理 Client 和手机之间的通信。如果 ADB 挂了，通常重启这个 Server 就能好 (<code>adb kill-server</code> &#x2F; <code>adb start-server</code>)。</li></ul></li><li><strong>Daemon (守护进程 adbd)</strong>：<ul><li><strong>在哪</strong>：在你的 <strong>手机</strong> 上。</li><li><strong>作用</strong>：它是手机里的执行者。你发出的命令，最终都是由它在手机后台默默执行的。</li></ul></li></ol><hr><h3 id="3-为什么学-ADB？"><a href="#3-为什么学-ADB？" class="headerlink" title="3. 为什么学 ADB？"></a>3. 为什么学 ADB？</h3><ul><li><strong>自动化测试的灵魂</strong>：<ul><li>Appium等自动化工具，底层全是调用的 ADB 命令。<strong>没有 ADB，就没有自动化。</strong></li></ul></li><li><strong>抓取崩溃日志 (Logcat)</strong>：<ul><li>App 闪退了，界面上什么都不显示。开发会问：“日志呢？” 这时候你需要用 <code>adb logcat</code> 把手机肚子里的报错信息抓出来。</li></ul></li><li><strong>模拟特殊场景</strong>：<ul><li>怎么模拟“低电量”？怎么模拟“弱网”？怎么在不碰手机的情况下“模拟点击屏幕”？全靠 ADB。</li></ul></li></ul><hr><h3 id="4-ADB常用功能预览"><a href="#4-ADB常用功能预览" class="headerlink" title="4. ADB常用功能预览"></a>4. ADB常用功能预览</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>能帮你做什么？</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td><strong>设备连接</strong></td><td>查看手机连没连上</td><td><code>adb devices</code></td></tr><tr><td><strong>应用管理</strong></td><td>电脑上一键安装&#x2F;卸载 App</td><td><code>adb install xxx.apk</code></td></tr><tr><td><strong>文件传输</strong></td><td>把电脑的电影传到手机，或把手机截图传到电脑</td><td><code>adb push</code> &#x2F; <code>adb pull</code></td></tr><tr><td><strong>日志获取</strong></td><td>抓取 Crash 报错信息</td><td><code>adb logcat</code></td></tr><tr><td><strong>模拟操作</strong></td><td>模拟点击、滑动、按键（Home&#x2F;返回）</td><td><code>adb shell input tap ...</code></td></tr><tr><td><strong>性能监控</strong></td><td>查看 CPU、内存、启动时间</td><td><code>adb shell dumpsys ...</code></td></tr></tbody></table><hr><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h4 id="1-检查设备连接"><a href="#1-检查设备连接" class="headerlink" title="1. 检查设备连接"></a>1. 检查设备连接</h4><p>这是每天工作的第一件事。不连上设备，后面什么都做不了。</p><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb devices<br></code></pre></td></tr></table></figure></li><li><p><strong>可能看到的结果</strong>：</p><ul><li><p><strong>成功</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">List of devices attached<br>HT75W020xxxx    device  &lt;-- 看到这个 <span class="hljs-string">&quot;device&quot;</span> 才算真正成功<br></code></pre></td></tr></table></figure></li><li><p><strong>失败 1 (Unauthorized)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HT75W020xxxx    unauthorized<br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：手机上没点“允许”。<strong>解决</strong>：看手机屏幕，会有一个弹窗“允许 USB 调试吗？”，勾选“始终允许”并点击确认。</li></ul></li><li><p><strong>失败 2 (Offline)</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HT75W020xxxx    offline<br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：连接线接触不良或 ADB 服务卡死。<strong>解决</strong>：拔掉线重插，或者输入 <code>adb kill-server</code> 然后再 <code>adb start-server</code>。</li></ul></li></ul></li></ul><h4 id="2-安装与卸载-App"><a href="#2-安装与卸载-App" class="headerlink" title="2. 安装与卸载 App"></a>2. 安装与卸载 App</h4><ul><li><p><strong>安装 App</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb install 路径\安装包.apk<br><span class="hljs-comment"># 技巧：输入 &quot;adb install &quot; (有个空格)，然后直接把 apk 文件拖进黑窗口，路径会自动生成！</span><br></code></pre></td></tr></table></figure><ul><li><em>覆盖安装（保留数据）</em>：<code>adb install -r 路径\安装包.apk</code></li></ul></li><li><p>卸载 App：注意：卸载不能用“应用名”（比如微信），必须用 “包名” (Package Name)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb uninstall 包名<br><span class="hljs-comment"># 例如：adb uninstall com.tencent.mm</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-查找包名"><a href="#3-查找包名" class="headerlink" title="3. 查找包名"></a>3. 查找包名</h4><p><strong>查看手机里所有的 App</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell pm list packages<br></code></pre></td></tr></table></figure><ul><li><strong>查看当前正在运行的 App 包名</strong><ol><li>在手机上打开你想测的 App（比如淘宝）。</li><li>在电脑输入：<ul><li><strong>Windows</strong>: <code>adb shell dumpsys window | findstr mCurrentFocus</code></li><li><strong>Mac</strong>: <code>adb shell dumpsys window | grep mCurrentFocus</code></li></ul></li><li>输出结果中，<code>&#123;&#125;</code> 里的内容，斜杠 <code>/</code> 前面的就是包名。<ul><li>例如：<code>u0a205 com.taobao.taobao/com.taobao.tao.TBMainActivity...</code></li><li>包名就是：<code>com.taobao.taobao</code></li></ul></li></ol></li></ul><hr><h3 id="靶场App"><a href="#靶场App" class="headerlink" title="靶场App"></a>靶场App</h3><h4 id="1-Sauce-Labs-Demo-App-Swag-Labs-——-强烈推荐"><a href="#1-Sauce-Labs-Demo-App-Swag-Labs-——-强烈推荐" class="headerlink" title="1. Sauce Labs Demo App (Swag Labs) —— 强烈推荐"></a>1. Sauce Labs Demo App (Swag Labs) —— <strong>强烈推荐</strong></h4><ul><li><strong>特点</strong>：包含标准的登录页、商品列表、拖拽操作、WebView 混合页面、绘图板等，专门为了刁难自动化工具而设计的。</li><li><strong>下载地址 (GitHub)</strong>：<a href="https://github.com/saucelabs/my-demo-app-android/releases">Sauce Labs My Demo App Android Releases</a></li></ul><h4 id="2-ApiDemos-官方-API-演示"><a href="#2-ApiDemos-官方-API-演示" class="headerlink" title="2. ApiDemos (官方 API 演示)"></a>2. ApiDemos (官方 API 演示)</h4><p>这是 Google 官方提供的“安卓字典”。</p><ul><li><strong>特点</strong>：它没有任何商业逻辑，但包含了安卓系统里<strong>所有的</strong>控件（按钮、下拉框、弹窗、通知栏等）。</li><li><strong>下载地址 (GitHub)</strong>：<a href="https://github.com/appium/android-apidemos/releases">ApiDemos-debug.apk</a></li></ul><hr><h2 id="文件管理与日志操作"><a href="#文件管理与日志操作" class="headerlink" title="文件管理与日志操作"></a>文件管理与日志操作</h2><p>三条命令：<code>push</code>、<code>pull</code> 和 <code>logcat</code>。</p><h3 id="📂-Part-1：文件搬运工-Push-Pull"><a href="#📂-Part-1：文件搬运工-Push-Pull" class="headerlink" title="📂 Part 1：文件搬运工 (Push &amp; Pull)"></a>📂 Part 1：文件搬运工 (Push &amp; Pull)</h3><p>安卓手机的文件系统和 Windows 不太一样，记住一个“万能路径”：<strong><code>/sdcard/</code></strong>。这通常是手机的内部存储根目录</p><h4 id="1-adb-push：电脑-➔-手机"><a href="#1-adb-push：电脑-➔-手机" class="headerlink" title="1. adb push：电脑 ➔ 手机"></a>1. <code>adb push</code>：电脑 ➔ 手机</h4><ul><li><p><strong>场景</strong>：测“上传头像”功能，需要往手机里放一张图片；或者要测“导入文档”功能。</p></li><li><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb push &lt;电脑上的文件路径&gt; &lt;手机上的目标路径&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>👉 实操任务 A：把一个文件推送到手机</strong></p><ol><li><p><strong>准备</strong>：在你的电脑桌面上新建一个文本文档，命名为 <code>test.txt</code>，里面随便写点字（比如 “Hello ADB”）。</p></li><li><p><strong>执行</strong>：在 CMD 里输入以下命令（配合拖拽大法）：</p><ul><li><p>输入 <code>adb push </code> (注意空格)</p></li><li><p>把桌面的 <code>test.txt</code> <strong>拖进</strong> CMD 窗口。</p></li><li><p>接着输入手机路径 <code> /sdcard/</code> (注意前面有个空格)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb push C:\Users\LilPear2002\Desktop\test.txt /sdcard/<br>C:\Users\LilPear2002\Desktop\test.txt: 1 file pushed. 0.0 MB/s (9 bytes <span class="hljs-keyword">in</span> 0.028s)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>看到 <code>1 file pushed</code>，成功！</p></li></ol><h4 id="2-adb-pull：手机-➔-电脑"><a href="#2-adb-pull：手机-➔-电脑" class="headerlink" title="2. adb pull：手机 ➔ 电脑"></a>2. <code>adb pull</code>：手机 ➔ 电脑</h4><ul><li><p><strong>场景</strong>：手机截图了 Bug，或者录屏了，需要把文件拉到电脑上发给开发；或者把手机里的数据库拉出来分析。</p></li><li><p><strong>命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb pull &lt;手机上的文件路径&gt; &lt;电脑上的目标路径&gt;<br></code></pre></td></tr></table></figure></li></ul><p>👉 实操任务 B：把刚才的文件拉回来</p><p>我们把刚才推过去的 test.txt 拉回到电脑的 C盘根目录（或者其他盘），并改个名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb pull /sdcard/test.txt C:\Users\LilPear2002\Desktop\test_back.txt<br>/sdcard/test.txt: 1 file pulled. 0.0 MB/s (9 bytes <span class="hljs-keyword">in</span> 0.008s)<br></code></pre></td></tr></table></figure><hr><h3 id="📝-Part-2：日志侦探-Logcat-——-重点中的重点"><a href="#📝-Part-2：日志侦探-Logcat-——-重点中的重点" class="headerlink" title="📝 Part 2：日志侦探 (Logcat) —— 重点中的重点"></a>📝 Part 2：日志侦探 (Logcat) —— 重点中的重点</h3><p>当 App 闪退（Crash）或者报错时，界面上往往什么都不说。开发问：“Log 呢？” 这时候就要用 adb logcat 把手机报错信息全倒出来。</p><h4 id="1-体验“刷屏”"><a href="#1-体验“刷屏”" class="headerlink" title="1. 体验“刷屏”"></a>1. 体验“刷屏”</h4><p>在 CMD 里直接输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb logcat<br></code></pre></td></tr></table></figure><ul><li><strong>现象</strong>：会看到屏幕疯狂滚动，像黑客帝国一样。这是手机系统和所有 App 正在产生的实时日志。</li><li><strong>停止</strong>：按键盘上的 <strong><code>Ctrl + C</code></strong> 终止。</li></ul><h4 id="2-“抓”日志到文件-最常用"><a href="#2-“抓”日志到文件-最常用" class="headerlink" title="2. “抓”日志到文件 (最常用)"></a>2. “抓”日志到文件 (最常用)</h4><p>直接看屏幕是看不清的，需要把日志<strong>保存</strong>到电脑的一个 <code>.txt</code> 或 <code>.log</code> 文件里。</p><p><strong>👉 实操任务 C：抓取一段日志</strong></p><ol><li><p><strong>清理缓存</strong>（好习惯）：先清空旧的日志，只抓新的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb logcat -c<br></code></pre></td></tr></table></figure></li><li><p><strong>开始抓取</strong>：输入命令，<strong>把日志“重定向”到桌面</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\LilPear2002&gt;adb logcat &gt; C:\Users\LilPear2002\Desktop\test.log<br></code></pre></td></tr></table></figure></li><li><p><strong>制造场景</strong>：</p><ul><li>现在 CMD 看起来像“卡死”了一样（其实它在后台默默记录）。</li><li>拿起手机，打开刚才安装的 <strong>Sauce Labs</strong> 或 <strong>ApiDemos</strong>，随便点两下。</li></ul></li><li><p><strong>结束抓取</strong>：</p><ul><li>回到 CMD，按 <strong><code>Ctrl + C</code></strong> 结束。</li></ul></li><li><p><strong>查看战果</strong>：</p><ul><li>桌面看看crash.log,里面就是刚才操作手机时产生的所有系统日志！</li></ul></li></ol><hr><h2 id="模拟用户操作"><a href="#模拟用户操作" class="headerlink" title="模拟用户操作"></a>模拟用户操作</h2><p>自动化测试工具（Appium）的底层原理，其实就是把这些命令封装起来了。</p><p>主要使用 <code>adb shell input</code> 这个命令集。</p><hr><h3 id="🎮-Part-1：物理按键-Key-Events"><a href="#🎮-Part-1：物理按键-Key-Events" class="headerlink" title="🎮 Part 1：物理按键 (Key Events)"></a>🎮 Part 1：物理按键 (Key Events)</h3><p>这是最简单也是最稳定的命令。就算不知道屏幕坐标，也能控制手机。</p><p>比如：手机的 Home 键、返回键、电源键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input keyevent &lt;按键代码&gt;<br></code></pre></td></tr></table></figure><h4 id="常用代码速查表"><a href="#常用代码速查表" class="headerlink" title="常用代码速查表"></a>常用代码速查表</h4><table><thead><tr><th><strong>按键</strong></th><th><strong>代码 (Code)</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Home</strong></td><td><code>3</code></td><td>回到桌面</td></tr><tr><td><strong>Back</strong></td><td><code>4</code></td><td>返回上一页</td></tr><tr><td><strong>Enter</strong></td><td><code>66</code></td><td>回车&#x2F;确认</td></tr></tbody></table><p><strong>👉 实操任务 A：</strong></p><ol><li>打开刚才安装的 <strong>Sauce Labs</strong> 或 <strong>ApiDemos</strong> 应用。</li><li>在 CMD 输入：<code>adb shell input keyevent 3</code></li><li><strong>结果</strong>：手机瞬间回到桌面了</li><li>再输入：<code>adb shell input keyevent 4</code></li></ol><hr><h3 id="👆-Part-2：触摸操作-Tap-Swipe"><a href="#👆-Part-2：触摸操作-Tap-Swipe" class="headerlink" title="👆 Part 2：触摸操作 (Tap &amp; Swipe)"></a>👆 Part 2：触摸操作 (Tap &amp; Swipe)</h3><p>想要像手指一样点击屏幕，你必须告诉 ADB <strong>“点哪里”</strong>。这就涉及到 <strong>X, Y 坐标</strong>。</p><h4 id="🔧-开启“上帝之眼”：指针位置"><a href="#🔧-开启“上帝之眼”：指针位置" class="headerlink" title="🔧 开启“上帝之眼”：指针位置"></a>🔧 开启“上帝之眼”：指针位置</h4><p>为了知道坐标，我们需要去手机开启一个开发者设置：</p><ol><li>打开手机 <strong>“设置” -&gt; “开发者选项”</strong>。</li><li>找到并开启 <strong>“指针位置” (Pointer Location)</strong>。</li><li><strong>效果</strong>：现在你触摸屏幕，屏幕顶部会显示当前手指的 <strong>X:xxx Y:xxx</strong> 坐标。</li></ol><h4 id="1-点击-Tap"><a href="#1-点击-Tap" class="headerlink" title="1. 点击 (Tap)"></a>1. 点击 (Tap)</h4><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input tap &lt;X&gt; &lt;Y&gt;<br></code></pre></td></tr></table></figure></li><li><p>例子：假设你现在的 App 图标在屏幕中间，坐标大概是 500 1000。</p></li></ul><h4 id="2-滑动-Swipe"><a href="#2-滑动-Swipe" class="headerlink" title="2. 滑动 (Swipe)"></a>2. 滑动 (Swipe)</h4><ul><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input swipe &lt;起点X&gt; &lt;起点Y&gt; &lt;终点X&gt; &lt;终点Y&gt; [耗时毫秒]<br></code></pre></td></tr></table></figure></li><li><p><strong>场景</strong>：刷抖音（上滑）、解锁屏幕。</p></li></ul><p>自动刷抖音脚本：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">chcp</span> <span class="hljs-number">65001</span> &gt;<span class="hljs-built_in">nul</span><br><span class="hljs-built_in">title</span> 抖音自动刷 - 按Ctrl+C停止<br><span class="hljs-built_in">echo</span> 抖音自动刷脚本启动...<br><span class="hljs-built_in">echo</span> 按 Ctrl+C 停止程序<br><span class="hljs-built_in">echo</span>.<br><br>:loop<br><span class="hljs-comment">REM 上滑操作（从屏幕下方滑到上方）</span><br>adb shell input swipe <span class="hljs-number">500</span> <span class="hljs-number">1600</span> <span class="hljs-number">500</span> <span class="hljs-number">600</span> <span class="hljs-number">350</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">%time%</span> 上滑一次<br><span class="hljs-comment"></span><br><span class="hljs-comment">REM 随机等待时间（3-6秒，更像真人）</span><br><span class="hljs-built_in">set</span> /a waitTime=<span class="hljs-variable">%random%</span> %% <span class="hljs-number">4</span> + <span class="hljs-number">3</span><br>timeout /t <span class="hljs-variable">%waitTime%</span> /nobreak &gt;<span class="hljs-built_in">nul</span><br><span class="hljs-keyword">goto</span> loop<br></code></pre></td></tr></table></figure><hr><h3 id="⌨️-Part-3：输入文本-Text"><a href="#⌨️-Part-3：输入文本-Text" class="headerlink" title="⌨️ Part 3：输入文本 (Text)"></a>⌨️ Part 3：输入文本 (Text)</h3><p>可以帮你自动输入账号密码。</p><ul><li><p><strong>注意</strong>：<code>adb shell input text</code> <strong>只能输入英文和数字</strong>，不支持中文（除非安装特殊的 ADB 键盘）。</p></li><li><p><strong>注意</strong>：输入前，必须先保证<strong>光标已经在输入框里了</strong>（也就是你需要先点一下输入框）。</p></li><li><p><strong>命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input text &lt;内容&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🔥-终极实战任务：自动化登录"><a href="#🔥-终极实战任务：自动化登录" class="headerlink" title="🔥 终极实战任务：自动化登录"></a>🔥 终极实战任务：自动化登录</h3><p>结合刚才学的，我们要用纯命令完成 <strong>Sauce Labs</strong> App 的登录操作。</p><p><strong>请一步步跟着做：</strong></p><ol><li><p><strong>启动 App</strong>：手动点击打开 <strong>Sauce Labs</strong> App（那个红色的 Swag Labs）。</p></li><li><p><strong>获取坐标</strong>：</p><ul><li>看一眼屏幕上 <strong>“Username”</strong> 输入框的位置，记下它的 X, Y（例如 X&#x3D;500, Y&#x3D;400）。</li><li>看一眼 <strong>“LOGIN”</strong> 按钮的位置，记下它的 X, Y（例如 X&#x3D;500, Y&#x3D;1000）。</li></ul></li><li><p><strong>执行自动化脚本</strong>（在 CMD 依次输入）：</p><ul><li><p>步骤 1 (聚焦)：点击输入框</p><p>adb shell input tap 500 400 (把这里的坐标换成你刚才记下的)</p></li><li><p>步骤 2 (输入)：输入用户名</p><p>adb shell input text standard_user</p></li><li><p>步骤 3 (收起键盘)：有时候键盘挡住按钮了，按一下返回键收起键盘</p><p>adb shell input keyevent 4</p></li><li><p>步骤 4 (登录)：点击登录按钮</p><p>adb shell input tap 500 1000 (换成你记下的按钮坐标)</p></li></ul></li></ol><hr><p>如果这个时候要测 100 台 不同型号的手机，每台手机分辨率不一样，按钮坐标肯定也不一样。</p><p>这时候用 ADB 写死坐标 tap 500 400 还有用吗？</p><p><em>(这就是为什么需要 Appium —— 它能通过“控件名”而不是“死坐标”来点击。)</em></p><hr><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><h2 id="1-Appium-是什么？"><a href="#1-Appium-是什么？" class="headerlink" title="1. Appium 是什么？"></a>1. Appium 是什么？</h2><p>用一句话定义：<strong>Appium 是移动端自动化测试的“世界通用语”。</strong></p><ul><li><strong>跨平台 (Cross-Platform)</strong>：<ul><li>学会了一套代码，既能测 <strong>Android</strong>（安卓），也能测 <strong>iOS</strong>（苹果）。</li><li><em>注：ADB 只能测安卓。</em></li></ul></li><li><strong>多语言支持</strong>：<ul><li><strong>Python</strong> 写</li><li><strong>Java</strong></li><li>JavaScript、Ruby… 都支持。</li></ul></li><li><strong>黑盒测试</strong>：<ul><li>不需要 App 的源代码，只要有个安装包就能测。</li></ul></li></ul><h3 id="Appium-的核心原理（C-S-架构）"><a href="#Appium-的核心原理（C-S-架构）" class="headerlink" title="Appium 的核心原理（C&#x2F;S 架构）"></a>Appium 的核心原理（C&#x2F;S 架构）</h3><p>这是面试必考题，也是理解后续安装步骤的关键。请看下面这个流程：</p><blockquote><p><strong>你的代码 (Client) ↔ Appium Server ↔ 手机 (Driver)</strong></p></blockquote><ol><li><strong>Client (客户端)</strong>：<ul><li>这就是你写的 Python 代码。写了一句 <code>driver.click()</code>。</li></ul></li><li><strong>Appium Server (服务端)</strong>：<ul><li>这是一个运行在电脑上的程序（基于 Node.js）。</li><li>它像个**“翻译官”**。它收到 Python 代码，把它翻译成手机能听懂的 JSON 指令。</li></ul></li><li><strong>Driver (驱动)</strong>：<ul><li>在安卓上，Appium 会在手机里装一个叫 <code>UiAutomator2</code> 的东西。</li><li>这个驱动接收“翻译官”的指令，然后指挥手机去点击按钮。</li></ul></li></ol><hr><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li><strong>Node.js</strong>：因为 Appium Server 是用 JS 写的，必须装它才能运行 Server。</li><li><strong>Appium Server</strong>：核心服务程序。</li><li><strong>Appium Inspector</strong>：一个<strong>可视化工具</strong>。<ul><li><em>它的作用</em>：你可以像在网页上“审查元素”一样，用鼠标点一下手机屏幕上的按钮，它就会告诉你这个按钮的 ID 是什么，XPath 是什么。<strong>这是写脚本的神器。</strong></li></ul></li><li><strong>Appium-Python-Client</strong>：Python 的第三方库（<code>pip install</code> 即可）。</li></ol><hr><h2 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h2><p>主要使用 <strong><code>AppiumBy</code></strong> 这个类（需要导入：<code>from appium.webdriver.common.appiumby import AppiumBy</code>）。</p><hr><h3 id="🏆-第一梯队：最推荐"><a href="#🏆-第一梯队：最推荐" class="headerlink" title="🏆 第一梯队：最推荐"></a>🏆 第一梯队：最推荐</h3><h4 id="1-ID-定位-AppiumBy-ID"><a href="#1-ID-定位-AppiumBy-ID" class="headerlink" title="1. ID 定位 (AppiumBy.ID)"></a>1. ID 定位 (<code>AppiumBy.ID</code>)</h4><ul><li><p><strong>对应属性</strong>：<strong><code>resource-id</code></strong></p></li><li><p><strong>Selenium 对比</strong>：等同于 Web 的 <code>id</code>。</p></li><li><p><strong>特点</strong>：通常是唯一的，也是最快的。</p></li><li><p>B站例子：</p><p>B站首页搜索框的 resource-id 通常长这样：tv.danmaku.bili:id&#x2F;expand_search。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/expand_search&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Accessibility-ID-定位-AppiumBy-ACCESSIBILITY-ID-——-移动端特有"><a href="#2-Accessibility-ID-定位-AppiumBy-ACCESSIBILITY-ID-——-移动端特有" class="headerlink" title="2. Accessibility ID 定位 (AppiumBy.ACCESSIBILITY_ID) —— 移动端特有"></a>2. Accessibility ID 定位 (<code>AppiumBy.ACCESSIBILITY_ID</code>) —— <strong>移动端特有</strong></h4><ul><li><p><strong>对应属性</strong>：<strong><code>content-desc</code></strong> (Android) &#x2F; <strong><code>accessibility-id</code></strong> (iOS)</p></li><li><p><strong>特点</strong>：这是 Appium 的<strong>王牌</strong>。</p><ul><li>它原本是给盲人读屏软件用的（比如“这是一个搜索按钮”）。</li><li><strong>跨平台神器</strong>：如果你将来测 iOS，这招也通用。</li><li><strong>B站例子</strong>：很多图片按钮没有文字，但开发会加 <code>content-desc</code>。比如“更多”按钮。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;更多&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🥈-第二梯队：万能但慢（兜底方案）"><a href="#🥈-第二梯队：万能但慢（兜底方案）" class="headerlink" title="🥈 第二梯队：万能但慢（兜底方案）"></a>🥈 第二梯队：万能但慢（兜底方案）</h3><h4 id="3-XPath-定位-AppiumBy-XPATH"><a href="#3-XPath-定位-AppiumBy-XPATH" class="headerlink" title="3. XPath 定位 (AppiumBy.XPATH)"></a>3. XPath 定位 (<code>AppiumBy.XPATH</code>)</h4><ul><li><p><strong>对应属性</strong>：可以使用任何属性组合（text, class, index…）。</p></li><li><p><strong>Selenium 对比</strong>：语法基本一样，但<strong>标签名变了</strong>。</p><ul><li>Web 标签是 <code>div</code>, <code>input</code>, <code>a</code>。</li><li>Android 标签是 <strong>完整的类名</strong>，比如 <code>android.widget.TextView</code>, <code>android.widget.EditText</code>。</li></ul></li><li><p>B站例子：</p><p>定位那个写着“Python”的搜索建议：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语法：//类名[@属性=&#x27;值&#x27;]</span><br>driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.TextView[@text=&#x27;Python自动化&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>包含匹配 (contains)</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.TextView[contains(@text, &#x27;Python&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🥉-第三梯队：安卓原生黑科技（进阶）"><a href="#🥉-第三梯队：安卓原生黑科技（进阶）" class="headerlink" title="🥉 第三梯队：安卓原生黑科技（进阶）"></a>🥉 第三梯队：安卓原生黑科技（进阶）</h3><h4 id="4-Android-UIAutomator-AppiumBy-ANDROID-UIAUTOMATOR"><a href="#4-Android-UIAutomator-AppiumBy-ANDROID-UIAUTOMATOR" class="headerlink" title="4. Android UIAutomator (AppiumBy.ANDROID_UIAUTOMATOR)"></a>4. Android UIAutomator (<code>AppiumBy.ANDROID_UIAUTOMATOR</code>)</h4><ul><li><p><strong>原理</strong>：这是绕过 Appium，直接用安卓底层的 Java 代码去查元素。<strong>速度极快</strong>，特别适合滚动查找。</p></li><li><p><strong>语法</strong>：里面写的是 <strong>Java 字符串</strong>。</p></li><li><p><strong>B站例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相当于：new UiSelector().text(&quot;推荐&quot;)</span><br>driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, <span class="hljs-string">&#x27;new UiSelector().text(&quot;推荐&quot;)&#x27;</span>)<br><br><span class="hljs-comment"># 组合定位：找一个 resource-id 是 xxx 且 text 是 &quot;搜索&quot; 的元素</span><br>driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, <span class="hljs-string">&#x27;new UiSelector().resourceId(&quot;xxx&quot;).text(&quot;搜索&quot;)&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🚫-避坑指南：不再推荐的方式"><a href="#🚫-避坑指南：不再推荐的方式" class="headerlink" title="🚫 避坑指南：不再推荐的方式"></a>🚫 避坑指南：不再推荐的方式</h3><ol><li><strong><code>By.NAME</code></strong>：在 Appium 1.x 早期版本可以用，但在 Appium 2.x 和高版本安卓中基本<strong>废弃</strong>了，不要用。</li><li><strong><code>By.TAG_NAME</code></strong>（Class Name）：<ul><li>在 Web 里，<code>TAG_NAME</code> 是 <code>input</code>，这很明确。</li><li>在 App 里，页面上可能有 100 个 <code>android.widget.TextView</code>。你用这个定位，肯定不准。</li></ul></li></ol><hr><h3 id="🛠️-实战演练：如何在-Inspector-里挑"><a href="#🛠️-实战演练：如何在-Inspector-里挑" class="headerlink" title="🛠️ 实战演练：如何在 Inspector 里挑"></a>🛠️ 实战演练：如何在 Inspector 里挑</h3><p>当你用 Appium Inspector 点击 B站的一个图标时，右侧会显示一大堆属性。<strong>选谁？请按这个顺序：</strong></p><ol><li>先看 <strong><code>accessibility-id</code> (content-desc)</strong>：如果有值，<strong>首选它</strong>！</li><li>再看 <strong><code>resource-id</code></strong>：如果有值，用 <code>AppiumBy.ID</code>。</li><li>如果前两个都没有，或者都不唯一：<ul><li>看 <strong><code>text</code></strong>：如果有文字，用 XPath <code>//...[@text=&#39;文字&#39;]</code>。</li><li>如果连文字都没有（只是个纯图标）：只能靠 XPath 的层级关系（找它爸爸）或者坐标了。</li></ul></li></ol><hr><h3 id="📝-总结表"><a href="#📝-总结表" class="headerlink" title="📝 总结表"></a>📝 总结表</h3><table><thead><tr><th><strong>定位方式</strong></th><th><strong>代码写法 (AppiumBy.xxx)</strong></th><th><strong>依赖属性 (Inspector里看)</strong></th><th><strong>推荐指数</strong></th><th><strong>评价</strong></th></tr></thead><tbody><tr><td><strong>ID</strong></td><td><code>ID</code></td><td><code>resource-id</code></td><td>⭐⭐⭐⭐⭐</td><td><strong>首选</strong>，最快最稳。</td></tr><tr><td><strong>Accessibility ID</strong></td><td><code>ACCESSIBILITY_ID</code></td><td><code>content-desc</code></td><td>⭐⭐⭐⭐⭐</td><td><strong>首选</strong>，跨平台，语义清晰。</td></tr><tr><td><strong>XPath</strong></td><td><code>XPATH</code></td><td>任意 (text, class…)</td><td>⭐⭐⭐</td><td><strong>万能</strong>，但性能较差，语法繁琐。</td></tr><tr><td><strong>UIAutomator</strong></td><td><code>ANDROID_UIAUTOMATOR</code></td><td>任意 (Java语法)</td><td>⭐⭐⭐⭐</td><td><strong>安卓特供</strong>，速度快，适合复杂场景（如滚动）。</td></tr><tr><td><strong>Class Name</strong></td><td><code>CLASS_NAME</code></td><td><code>class</code></td><td>⭐</td><td><strong>不推荐</strong>，重复率太高。</td></tr></tbody></table><hr><p>案例：打开B站搜索Python自动化测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.appiumby <span class="hljs-keyword">import</span> AppiumBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># --- 配置参数 ---</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&#x27;platformName&#x27;</span>: <span class="hljs-string">&#x27;Android&#x27;</span>,<br>    <span class="hljs-string">&#x27;platformVersion&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>,<br>    <span class="hljs-string">&#x27;deviceName&#x27;</span>: <span class="hljs-string">&#x27;V4YHB6XS6DSSQ89L&#x27;</span>,<br>    <span class="hljs-string">&#x27;appPackage&#x27;</span>: <span class="hljs-string">&#x27;tv.danmaku.bili&#x27;</span>,<br>    <span class="hljs-string">&#x27;appActivity&#x27;</span>: <span class="hljs-string">&#x27;.MainActivityV2&#x27;</span>,<br>    <span class="hljs-string">&#x27;automationName&#x27;</span>: <span class="hljs-string">&#x27;UiAutomator2&#x27;</span>,<br>    <span class="hljs-comment"># 关键参数：不重置应用（保留你的登录状态，避免每次都弹隐私协议）</span><br>    <span class="hljs-string">&#x27;noReset&#x27;</span>: <span class="hljs-literal">True</span><br>&#125;<br><br>driver = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在连接 Appium...&quot;</span>)<br>    driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723&#x27;</span>, desired_caps)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;强制唤醒 B站...&quot;</span>)<br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    <span class="hljs-comment"># 设置全局隐式等待 10秒（给B站启动一点缓冲时间）</span><br>    driver.implicitly_wait(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B站启动成功！&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># --- 1. 处理“青少年模式”弹窗 (B站特有) ---</span><br>    <span class="hljs-comment"># 这是一个“可能出现，也可能不出现”的弹窗，所以我们要用 try-except</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检查是否有青少年模式弹窗...&quot;</span>)<br>        <span class="hljs-comment"># 这里需要你填入你在 Inspector 里抓到的“我知道了”按钮的 ID</span><br>        <span class="hljs-comment"># B站通常的 ID 可能是 text_view 或者 close_button，下面是示例 ID，你需要替换！</span><br>        teenager_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/text_ok&quot;</span>)<br>        teenager_btn.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭青少年模式弹窗&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未检测到弹窗，继续执行...&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 点击首页顶部的“搜索框” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在寻找搜索框...&quot;</span>)<br>    <span class="hljs-comment"># 这里的 ID 是 B站首页顶部搜索框的典型 ID (expand_search)</span><br>    <span class="hljs-comment"># 如果报错，请用 Inspector 确认一下是不是这个</span><br>    search_box = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_text&quot;</span>)<br><br>    search_box.click()<br><br>    <span class="hljs-comment"># --- 3. 输入关键字 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入搜索页，输入关键字...&quot;</span>)<br>    <span class="hljs-comment"># 点击搜索框后，会跳转到一个新页面，这里有一个真正的输入框</span><br>    <span class="hljs-comment"># 这里的 ID 通常是 search_src_text</span><br>    <span class="hljs-comment"># input_field = driver.find_element(AppiumBy.ID, &quot;tv.danmaku.bili:id/search_src_text&quot;)</span><br>    input_field = driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;搜索查询&quot;</span>)<br>    input_field.send_keys(<span class="hljs-string">&quot;Python自动化测试&quot;</span>)<br><br>    <span class="hljs-comment"># --- 4. 点击“搜索”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击搜索按钮...&quot;</span>)<br>    <span class="hljs-comment"># 这是一个 text 属性为“搜索”的 TextView</span><br>    search_btn = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&#x27;//android.widget.TextView[@resource-id=&quot;tv.danmaku.bili:id/action_search&quot;]&#x27;</span>)<br>    search_btn.click()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 搜索动作完成！请看手机屏幕效果&quot;</span>)<br><br>    <span class="hljs-comment"># 停留一会让你看结果</span><br>    time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> driver:<br>        driver.quit()<br></code></pre></td></tr></table></figure><hr><h2 id="3-操作"><a href="#3-操作" class="headerlink" title="3.操作"></a>3.操作</h2><p>因为手机和浏览器不一样（手机有实体按键、手指触摸），所以常用方法分为两类：</p><ol><li><strong>“老朋友”</strong>：和 Selenium 一模一样的（点击、输入）。</li><li><strong>“新面孔”</strong>：移动端特有的（按键、触摸、属性获取）。</li></ol><hr><h3 id="🕹️-Part-1-元素操作-和-Selenium-对标"><a href="#🕹️-Part-1-元素操作-和-Selenium-对标" class="headerlink" title="🕹️ Part 1: 元素操作 (和 Selenium 对标)"></a>🕹️ Part 1: 元素操作 (和 Selenium 对标)</h3><h4 id="1-点击与输入-完全一致"><a href="#1-点击与输入-完全一致" class="headerlink" title="1. 点击与输入 (完全一致)"></a>1. 点击与输入 (完全一致)</h4><ul><li><code>element.click()</code>：点击。</li><li><code>element.send_keys(&quot;...&quot;)</code>：输入。</li><li><code>element.clear()</code>：清空输入框。</li></ul><h4 id="2-获取属性-Get-Attribute-——-有差异！"><a href="#2-获取属性-Get-Attribute-——-有差异！" class="headerlink" title="2. 获取属性 (Get Attribute) —— 有差异！"></a>2. 获取属性 (Get Attribute) —— <strong>有差异！</strong></h4><p>在 Appium 里，属性名变了：</p><table><thead><tr><th><strong>想要获取什么？</strong></th><th><strong>Selenium (Web)</strong></th><th><strong>Appium (Android)</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>显示的文字</strong></td><td><code>element.text</code></td><td><code>element.text</code></td><td><strong>通用</strong>。优先用这个。</td></tr><tr><td><strong>是否被选中</strong></td><td><code>get_attribute(&quot;checked&quot;)</code></td><td><code>get_attribute(&quot;checked&quot;)</code></td><td>复选框&#x2F;单选框常用（返回 “true”&#x2F;“false” 字符串）。</td></tr><tr><td><strong>是否可用</strong></td><td><code>is_enabled()</code></td><td><code>get_attribute(&quot;enabled&quot;)</code></td><td>按钮是否变灰。</td></tr><tr><td><strong>无障碍描述</strong></td><td>(无)</td><td><strong><code>get_attribute(&quot;content-desc&quot;)</code></strong></td><td><strong>重点！</strong> 很多图片按钮没文字，只能靠这个断言。</td></tr><tr><td><strong>包名</strong></td><td>(无)</td><td><code>get_attribute(&quot;package&quot;)</code></td><td>验证是否跳到了别的 App。</td></tr></tbody></table><p>👉 实战场景：</p><p>你搜索完“Python”后，想验证搜索框里的字是不是“Python”？或者想获取某个视频的标题。</p><hr><h3 id="📱-Part-2-手机硬按键-Hardware-Keys-——-Appium-特有"><a href="#📱-Part-2-手机硬按键-Hardware-Keys-——-Appium-特有" class="headerlink" title="📱 Part 2: 手机硬按键 (Hardware Keys) —— Appium 特有"></a>📱 Part 2: 手机硬按键 (Hardware Keys) —— <strong>Appium 特有</strong></h3><p>做 App 测试经常需要：返回上一页、回到桌面、调节音量。使用 driver.press_keycode(代码) 方法。</p><h4 id="常用按键代码-KeyCodes"><a href="#常用按键代码-KeyCodes" class="headerlink" title="常用按键代码 (KeyCodes)"></a>常用按键代码 (KeyCodes)</h4><ul><li><strong>返回键 (Back)</strong>: <code>4</code> (最常用！)</li><li><strong>Home 键</strong>: <code>3</code></li><li><strong>音量加</strong>: <code>24</code></li><li><strong>音量减</strong>: <code>25</code></li><li><strong>回车 (Enter)</strong>: <code>66</code> (搜索时除了点搜索按钮，也可以按这个)</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模拟手指按手机侧面的“返回”键</span><br>driver.press_keycode(<span class="hljs-number">4</span>) <br></code></pre></td></tr></table></figure><hr><h3 id="👆-Part-3-滑动操作-Swipe-——-重头戏"><a href="#👆-Part-3-滑动操作-Swipe-——-重头戏" class="headerlink" title="👆 Part 3: 滑动操作 (Swipe) —— 重头戏"></a>👆 Part 3: 滑动操作 (Swipe) —— <strong>重头戏</strong></h3><p>这是 Web 和 App 最大的区别。</p><p>Web 页面长了有滚动条，Selenium 可以用 JS window.scrollTo。App 没有滚动条，全靠手指滑。Appium 提供了简单的滑动 API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.swipe(start_x, start_y, end_x, end_y, duration)<br></code></pre></td></tr></table></figure><ul><li><code>start_x</code>, <code>start_y</code>: 起点坐标。</li><li><code>end_x</code>, <code>end_y</code>: 终点坐标。</li><li><code>duration</code>: 滑动耗时（毫秒）。<strong>越短滑得越快（惯性大），越长越精准。</strong></li></ul><p>📐 坐标怎么算？</p><p>不要写死 500, 1000！因为不同手机屏幕大小不一样。</p><p>通用公式：先获取屏幕尺寸，然后按百分比滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取屏幕宽高</span><br>size = driver.get_window_size()<br>width = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>height = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br><br><span class="hljs-comment"># 向上滑动 (手指从下往上，浏览下面的内容)</span><br><span class="hljs-comment"># x 轴不变（屏幕中间），y 轴从 90% 处滑到 10% 处</span><br>driver.swipe(width * <span class="hljs-number">0.5</span>, height * <span class="hljs-number">0.9</span>, width * <span class="hljs-number">0.5</span>, height * <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚔️-实战任务：B-站搜索-滑动-返回"><a href="#⚔️-实战任务：B-站搜索-滑动-返回" class="headerlink" title="⚔️ 实战任务：B 站搜索 + 滑动 + 返回"></a>⚔️ 实战任务：B 站搜索 + 滑动 + 返回</h3><p>任务目标：</p><ol><li>启动 B 站，搜“Python自动化”。</li><li><strong>断言</strong>：验证搜索结果页的输入框里确实填着“Python自动化”（练习 <code>text</code> 属性）。</li><li><strong>滑动</strong>：向下滑动两下，浏览下面的视频（练习 <code>swipe</code>）。</li><li><strong>返回</strong>：按两次物理返回键，回到 B 站首页（练习 <code>keycode</code>）。</li></ol><p>请更新你的脚本（保留前面的 setup 部分）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前面的配置和启动代码保持不变) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 1. --- 之前的搜索流程 (略，保留你写的) ---</span><br>    <span class="hljs-comment"># ... (点击搜索框 -&gt; 输入&quot;Python自动化&quot; -&gt; 点击搜索按钮) ...</span><br>    <span class="hljs-comment"># 假设你已经点完搜索按钮了，现在在结果页</span><br><br>    time.sleep(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等结果加载</span><br><br>    <span class="hljs-comment"># 2. --- 练习：获取属性与断言 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在验证搜索结果...&quot;</span>)<br>    <span class="hljs-comment"># 重新定位结果页顶部的搜索框 (ID 通常和首页不一样，或者是同一个，视 B 站版本而定)</span><br>    <span class="hljs-comment"># B 站结果页输入框 ID 通常还是: tv.danmaku.bili:id/search_src_text</span><br>    result_input = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_src_text&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取它显示的文字</span><br>    actual_text = result_input.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;搜索框里的文字是: <span class="hljs-subst">&#123;actual_text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 断言</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Python&quot;</span> <span class="hljs-keyword">in</span> actual_text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 断言成功：搜索词正确&quot;</span>)<br><br>    <span class="hljs-comment"># 3. --- 练习：屏幕滑动 (Swipe) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备向下滑动浏览视频...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取屏幕尺寸</span><br>    size = driver.get_window_size()<br>    w = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>    h = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 滑动两次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span> 次滑动...&quot;</span>)<br>        <span class="hljs-comment"># 从下(70%) 往上(30%) 滑，模拟手指上滑</span><br>        driver.swipe(w * <span class="hljs-number">0.5</span>, h * <span class="hljs-number">0.7</span>, w * <span class="hljs-number">0.5</span>, h * <span class="hljs-number">0.3</span>, <span class="hljs-number">1000</span>)<br>        time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 滑完停顿一下，像真人在看</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 滑动完成&quot;</span>)<br><br>    <span class="hljs-comment"># 4. --- 练习：物理按键 (Back) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备按物理返回键回到首页...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 按一次返回 (可能只是收起键盘，或者退回上一步)</span><br>    driver.press_keycode(<span class="hljs-number">4</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 再按一次返回 (彻底退回首页)</span><br>    driver.press_keycode(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已执行返回操作&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    time.sleep(<span class="hljs-number">3</span>)<br>    driver.quit()<br></code></pre></td></tr></table></figure><hr><h2 id="4-窗口和标签页操作"><a href="#4-窗口和标签页操作" class="headerlink" title="4.窗口和标签页操作"></a>4.窗口和标签页操作</h2><p>这里有一个 <strong>巨大的思维转换</strong> 需要注意：</p><h3 id="🤯-核心概念：Appium-vs-Selenium-的“窗口”区别"><a href="#🤯-核心概念：Appium-vs-Selenium-的“窗口”区别" class="headerlink" title="🤯 核心概念：Appium vs Selenium 的“窗口”区别"></a>🤯 核心概念：Appium vs Selenium 的“窗口”区别</h3><p>在 Selenium（Web）中，点击一个链接，可能会弹出一个新的浏览器标签页（Tab）或窗口（Window），此时必须用 <code>driver.switch_to.window(handle)</code> 才能控制新页面。</p><p><strong>但在 Appium（原生 App）中，逻辑完全不同：</strong></p><ol><li><strong>没有“多窗口”概念</strong>：<ul><li>手机屏幕一次只能显示一个 App 的页面。</li><li>当点击一个按钮跳到新页面时（比如从“搜索列表”跳到“视频详情页”），<strong>Appium 会自动跟随过去</strong>。</li><li><strong>结论</strong>：<strong>不需要</strong>写 <code>switch_to.window</code>！焦点永远在当前显示的屏幕上。</li></ul></li><li><strong>“Activity” 代替了 “Window”</strong>：<ul><li>Web 里的“页面 URL”，在安卓里叫 <strong><code>Activity</code></strong>（活动）。</li><li>可以通过检查 <code>driver.current_activity</code> 来判断当前是在“首页”还是“详情页”。</li></ul></li><li><strong>唯一的“特殊情况” —— WebView (H5)</strong>：<ul><li>如果在 B站里点了一个广告，打开了一个<strong>网页</strong>，这时候才涉及到类似 Selenium 的“切换框架”操作（这叫 <strong>Context 切换</strong>，它是高级内容）。</li></ul></li></ol><hr><h3 id="🎬-实战案例：B站“视频详情页”进出测试"><a href="#🎬-实战案例：B站“视频详情页”进出测试" class="headerlink" title="🎬 实战案例：B站“视频详情页”进出测试"></a>🎬 实战案例：B站“视频详情页”进出测试</h3><p>既然不用切换窗口，那我们怎么测“页面跳转”呢？</p><p>逻辑是： 记录当前 Activity -&gt; 点击跳转 -&gt; 等待新页面 -&gt; 验证新 Activity -&gt; 按返回键“关闭”页面。</p><p><strong>任务目标</strong>：</p><ol><li>在搜索结果页，点击<strong>第一个视频</strong>。</li><li><strong>验证</strong>：是否成功进入了“视频播放页”（检测 Activity 变了没）。</li><li><strong>操作</strong>：在播放页停留 5 秒（模拟看视频）。</li><li><strong>返回</strong>：按返回键，回到搜索结果页。</li></ol><h4 id="💻-代码实战"><a href="#💻-代码实战" class="headerlink" title="💻 代码实战"></a>💻 代码实战</h4><p>请在之前的搜索脚本后面，续写以下内容（注意看注释里的 Activity 变化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前面是搜索代码：输入关键字 -&gt; 点击搜索按钮 -&gt; 验证结果页文字) ...</span><br><span class="hljs-comment"># 假设现在代码运行到了搜索结果页</span><br><br>    <span class="hljs-comment"># --- 5. 进阶：页面跳转与 Activity 验证 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 开始测试页面跳转 ---&quot;</span>)<br>    <br>    <span class="hljs-comment"># A. 打印当前的 Activity (应该是搜索结果页)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;跳转前 Activity: <span class="hljs-subst">&#123;driver.current_activity&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># B. 点击第一个视频</span><br>    <span class="hljs-comment"># B站搜索结果通常是一个列表，我们用 XPath 找第一个包含“Python”的标题</span><br>    <span class="hljs-comment"># 注意：这里可能会点到广告，为了简单，我们尝试点列表里的第一个项</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击第一个视频...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 这个 XPath 意思是：找当前页面所有包含文本的 TextView，选第2个或第3个(因为第1个可能是搜索框里的字)</span><br>    <span class="hljs-comment"># 更好的方式是用 Inspector 抓取视频封面的 ID，这里演示通用逻辑</span><br>    video_item = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;(//android.widget.TextView[contains(@text, &#x27;Python&#x27;)])[3]&quot;</span>)<br>    video_item.click()<br>    <br>    <span class="hljs-comment"># C. 等待跳转 (页面切换需要时间)</span><br>    time.sleep(<span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment"># D. 验证是否进入了新页面 (Activity 应该变了)</span><br>    current_act = driver.current_activity<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;跳转后 Activity: <span class="hljs-subst">&#123;current_act&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># B站的视频播放页 Activity 通常包含 &quot;VideoDetails&quot; 或 &quot;Bangumi&quot;</span><br>    <span class="hljs-comment"># 如果 Activity 名字变了，就说明跳转成功</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Details&quot;</span> <span class="hljs-keyword">in</span> current_act <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;Video&quot;</span> <span class="hljs-keyword">in</span> current_act:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 成功进入视频详情页！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;⚠️ Activity 名字好像没变，当前是: <span class="hljs-subst">&#123;current_act&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># E. 模拟看视频 5秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在假装看视频...&quot;</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <br>    <span class="hljs-comment"># F. 退出页面 (相当于 Selenium 的 close window)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看完啦，按返回键退出...&quot;</span>)<br>    driver.press_keycode(<span class="hljs-number">4</span>) <span class="hljs-comment"># Back 键</span><br>    <br>    <span class="hljs-comment"># 验证是否回到了搜索页</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;返回后 Activity: <span class="hljs-subst">&#123;driver.current_activity&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># ... (后面的 quit 代码) ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="🕵️‍♂️-真正的“Tab”操作：底部导航栏"><a href="#🕵️‍♂️-真正的“Tab”操作：底部导航栏" class="headerlink" title="🕵️‍♂️ 真正的“Tab”操作：底部导航栏"></a>🕵️‍♂️ 真正的“Tab”操作：底部导航栏</h3><p>标签页（Tab）在 App 里通常指的是<strong>底部的导航栏</strong>（首页 | 动态 | 会员购 | 我的）。</p><p>测这个非常简单，就是点点点。</p><p><strong>实战任务 B：底部 Tab 切换测试</strong></p><ol><li>启动 B 站。</li><li>点击底部的 <strong>“我的”</strong>。</li><li>检查是否到了个人中心。</li><li>点击底部的 <strong>“首页”</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这段代码可以单独运行，或者放在搜索之前</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># ... (连接 Appium 代码) ...</span><br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 开始测试底部 Tab 切换 ---&quot;</span>)<br>    <br>    <span class="hljs-comment"># 1. 寻找底部的“我的”按钮</span><br>    <span class="hljs-comment"># 这种固定按钮，通常 text 是固定的，用 XPath 或者 Accessibility ID 找</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击 &#x27;我的&#x27;...&quot;</span>)<br>    <span class="hljs-comment"># 尝试用 XPath 文本定位</span><br>    me_tab = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;我的&#x27;]&quot;</span>)<br>    me_tab.click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 2. 验证 (比如找一下页面上有没有“历史记录”这个按钮)</span><br>    <span class="hljs-comment"># 注意：如果你没登录，可能看到的是“点击登录”</span><br>    <span class="hljs-keyword">try</span>:<br>        driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;历史记录&#x27; or @text=&#x27;点击登录&#x27;]&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已切换到个人中心&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 切换失败&quot;</span>)<br>        <br>    <span class="hljs-comment"># 3. 切回首页</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击 &#x27;首页&#x27;...&quot;</span>)<br>    home_tab = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;//*[@text=&#x27;首页&#x27;]&quot;</span>)<br>    home_tab.click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已回到首页&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚠️-高级预警：WebView-H5-——-真正的“切窗口”"><a href="#⚠️-高级预警：WebView-H5-——-真正的“切窗口”" class="headerlink" title="⚠️ 高级预警：WebView (H5) —— 真正的“切窗口”"></a>⚠️ 高级预警：WebView (H5) —— 真正的“切窗口”</h3><p>在 App 里，如果嵌入了一个网页（比如 B站的“会员购”页面，或者活动页面），那个东西叫 WebView。</p><ul><li><strong>Native (原生)</strong>：按钮、图片都是安卓控件。</li><li><strong>WebView (H5)</strong>：里面是 HTML 代码。</li></ul><p><strong>如果你想在 Appium 里控制 WebView 里的元素（比如点击 H5 里的链接）：</strong></p><ol><li><p>你必须像 Selenium 切换 iframe 一样，切换 <strong>Context</strong>。</p></li><li><p>代码长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 获取所有上下文</span><br>contexts = driver.contexts  <span class="hljs-comment"># 返回 [&#x27;NATIVE_APP&#x27;, &#x27;WEBVIEW_com.bilibili&#x27;]</span><br><br><span class="hljs-comment"># 2. 切换到 WebView (相当于 switch_to.window/frame)</span><br>driver.switch_to.context(contexts[-<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 3. 现在可以用 Selenium 的方式找 div/a 标签了</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;div.banner&quot;</span>).click()<br><br><span class="hljs-comment"># 4. 切回原生</span><br>driver.switch_to.context(<span class="hljs-string">&quot;NATIVE_APP&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>🛑 劝退警告：绝大多数市面上的 App（包括 B站 release 版），都关闭了 WebView 的调试权限。这意味着 driver.contexts 只能读到 NATIVE_APP，读不到 WEBVIEW。除非你有 B站的内部开发包，或者手机 Root 了。现阶段，把 App 当作纯 Native 应用来测（Activity 跳转 + 底部 Tab 切换），这涵盖了 95% 的工作场景。</p><hr><h2 id="三大等待"><a href="#三大等待" class="headerlink" title="三大等待"></a>三大等待</h2><p>这部分和selenium基本一样：</p><ol><li><strong>强制等待</strong>：<code>time.sleep(3)</code><ul><li><em>场景</em>：调试时用，或者有些顽固的动画（比如 B 站开屏广告）实在没法定位时，硬等。</li></ul></li><li><strong>隐式等待</strong>：<code>driver.implicitly_wait(10)</code><ul><li><em>场景</em>：全局兜底。脚本一上来就设好，管 ID&#x2F;XPath 找不找得到。</li></ul></li><li><strong>显式等待</strong> (WebDriverWait)：<strong>王牌</strong>。<ul><li><em>场景</em>：等元素<strong>可点击</strong>、等<strong>文字出现</strong>、等<strong>Toast 消失</strong>。</li></ul></li></ol><hr><h3 id="🔥-Appium-独有的难点：Toast-消息捕获"><a href="#🔥-Appium-独有的难点：Toast-消息捕获" class="headerlink" title="🔥 Appium 独有的难点：Toast 消息捕获"></a>🔥 Appium 独有的难点：Toast 消息捕获</h3><ul><li><p>什么是 Toast？</p><p>就是点赞后，屏幕下方弹出的那个黑底白字小气泡：“已点赞” 或 “登录失败”。</p></li><li><p><strong>难点在哪？</strong></p><ol><li><strong>它消失得很快</strong>（通常 2-3 秒），手慢无。</li><li><strong>它不属于 App 的页面结构</strong>，而是属于 <strong>安卓系统</strong> 的。用普通的 Inspector 截图很难截到它（因为它一闪而过）。</li></ol></li></ul><h4 id="🛠️-怎么抓-Toast？"><a href="#🛠️-怎么抓-Toast？" class="headerlink" title="🛠️ 怎么抓 Toast？"></a>🛠️ 怎么抓 Toast？</h4><p>虽然很难截到，但它的 <strong>XPath</strong> 是固定的！(标准安卓 Toast)</p><ul><li><p><strong>万能 XPath</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 记住这个类名，这是安卓系统级的 Toast 控件</span><br>toast_xpath = <span class="hljs-string">&quot;//android.widget.Toast&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>必须使用显式等待：</p><p>因为 Toast 可能是第 0.5 秒出现，第 2 秒消失。如果不用显式等待去“守株待兔”，很难抓到。</p></li></ul><hr><h3 id="💻-实战任务：B站“点赞-取消点赞”的-Toast-捕获"><a href="#💻-实战任务：B站“点赞-取消点赞”的-Toast-捕获" class="headerlink" title="💻 实战任务：B站“点赞&#x2F;取消点赞”的 Toast 捕获"></a>💻 实战任务：B站“点赞&#x2F;取消点赞”的 Toast 捕获</h3><p>我们要验证：点击视频的点赞按钮后，是否弹出了“点赞成功”或“取消点赞”的提示。</p><p><strong>脚本逻辑：</strong></p><ol><li>搜 BV 号进视频（用之前的代码）。</li><li>点击视频画面（唤起控制条）。</li><li>点击“点赞”图标。</li><li><strong>【关键】使用显式等待捕获包含“点赞”字样的 Toast</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.appiumby <span class="hljs-keyword">import</span> AppiumBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># --- 配置参数 ---</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&#x27;platformName&#x27;</span>: <span class="hljs-string">&#x27;Android&#x27;</span>,<br>    <span class="hljs-string">&#x27;platformVersion&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>,<br>    <span class="hljs-string">&#x27;deviceName&#x27;</span>: <span class="hljs-string">&#x27;V4YHB6XS6DSSQ89L&#x27;</span>,<br>    <span class="hljs-string">&#x27;appPackage&#x27;</span>: <span class="hljs-string">&#x27;tv.danmaku.bili&#x27;</span>,<br>    <span class="hljs-string">&#x27;appActivity&#x27;</span>: <span class="hljs-string">&#x27;.MainActivityV2&#x27;</span>,<br>    <span class="hljs-string">&#x27;automationName&#x27;</span>: <span class="hljs-string">&#x27;UiAutomator2&#x27;</span>,<br>    <span class="hljs-comment"># 关键参数：不重置应用（保留你的登录状态，避免每次都弹隐私协议）</span><br>    <span class="hljs-string">&#x27;noReset&#x27;</span>: <span class="hljs-literal">True</span><br>&#125;<br><br>driver = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在连接 Appium...&quot;</span>)<br>    driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723&#x27;</span>, desired_caps)<br><br>    bv_id = <span class="hljs-string">&quot;BV1Qm2DBLEYk&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;强制唤醒 B站...&quot;</span>)<br>    driver.activate_app(<span class="hljs-string">&quot;tv.danmaku.bili&quot;</span>)<br>    <span class="hljs-comment"># 设置全局隐式等待 10秒（给B站启动一点缓冲时间）</span><br>    driver.implicitly_wait(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B站启动成功！&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># --- 1. 处理“青少年模式”弹窗 (B站特有) ---</span><br>    <span class="hljs-comment"># 这是一个“可能出现，也可能不出现”的弹窗，所以我们要用 try-except</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;检查是否有青少年模式弹窗...&quot;</span>)<br>        <span class="hljs-comment"># 这里需要你填入你在 Inspector 里抓到的“我知道了”按钮的 ID</span><br>        <span class="hljs-comment"># B站通常的 ID 可能是 text_view 或者 close_button，下面是示例 ID，你需要替换！</span><br>        teenager_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/text_ok&quot;</span>)<br>        teenager_btn.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭青少年模式弹窗&quot;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未检测到弹窗，继续执行...&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 点击首页顶部的“搜索框” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在寻找搜索框...&quot;</span>)<br>    <span class="hljs-comment"># 这里的 ID 是 B站首页顶部搜索框的典型 ID (expand_search)</span><br>    <span class="hljs-comment"># 如果报错，请用 Inspector 确认一下是不是这个</span><br>    search_box = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/search_text&quot;</span>)<br><br>    search_box.click()<br><br>    <span class="hljs-comment"># --- 3. 输入关键字 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入搜索页，输入关键字...&quot;</span>)<br>    <span class="hljs-comment"># 点击搜索框后，会跳转到一个新页面，这里有一个真正的输入框</span><br>    <span class="hljs-comment"># 这里的 ID 通常是 search_src_text</span><br>    <span class="hljs-comment"># input_field = driver.find_element(AppiumBy.ID, &quot;tv.danmaku.bili:id/search_src_text&quot;)</span><br>    input_field = driver.find_element(AppiumBy.ACCESSIBILITY_ID, <span class="hljs-string">&quot;搜索查询&quot;</span>)<br>    input_field.send_keys(bv_id)<br><br>    <span class="hljs-comment"># --- 4. 点击“搜索”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点击搜索按钮...&quot;</span>)<br>    <span class="hljs-comment"># 这是一个 text 属性为“搜索”的 TextView</span><br>    search_btn = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&#x27;//android.widget.TextView[@resource-id=&quot;tv.danmaku.bili:id/action_search&quot;]&#x27;</span>)<br>    search_btn.click()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 搜索动作完成！请看手机屏幕效果&quot;</span>)<br><br>    <span class="hljs-comment"># 停留一会让你看结果</span><br>    time.sleep(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 2. 点击点赞 (难点：B站的点赞按钮 ID)</span><br>    <span class="hljs-comment"># B站播放页结构很复杂，点赞通常叫 &quot;love&quot; 或 &quot;like&quot;</span><br>    <span class="hljs-comment"># 我们先暂停一下视频，防止干扰</span><br>    time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 等广告过</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;尝试点击点赞...&quot;</span>)<br>    <span class="hljs-comment"># 注意：B站的点赞按钮 id 经常是 tv.danmaku.bili:id/recommend_icon 或者是类似的</span><br>    <span class="hljs-comment"># 如果你找不到 ID，可以用 xpath 找那个“大拇指”图标</span><br>    <span class="hljs-comment"># 点赞按钮 ID 通常是 tv.danmaku.bili:id/follow</span><br>    follow_btn = driver.find_element(AppiumBy.ID, <span class="hljs-string">&quot;tv.danmaku.bili:id/frame_like&quot;</span>)<br>    follow_btn.click()<br><br>    <span class="hljs-comment"># --- 🔥 核心：捕获 Toast (显式等待) ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待 Toast 出现...&quot;</span>)<br><br>    <span class="hljs-comment"># 写法：等待 text 包含 &quot;关注&quot; 的 Toast 元素出现</span><br>    <span class="hljs-comment"># 注意：presence_of_element_located 是判断元素在不在 DOM 里，这对 Toast 最有效</span><br>    toast_element = WebDriverWait(driver, <span class="hljs-number">5</span>, poll_frequency=<span class="hljs-number">0.1</span>).until(<br>        EC.presence_of_element_located((AppiumBy.XPATH, <span class="hljs-string">&quot;//android.widget.Toast[contains(@text, &#x27;点赞&#x27;)]&quot;</span>))<br>    )<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功捕获 Toast 内容: <span class="hljs-subst">&#123;toast_element.text&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 出错了: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> driver:<br>        driver.quit()<br></code></pre></td></tr></table></figure><hr><p>特别注意：现在的 App越来越花哨，很多提示不再使用安卓原生的 Toast (android.widget.Toast)，而是开发自己画的一个 TextView 飘在上面。</p><ul><li><strong>怎么分辨？</strong><ul><li><strong>原生 Toast</strong>：不能被点击，Inspector 很难选中。</li><li><strong>伪造 Toast (自定义 View)</strong>：Inspector 能选中，它就是一个普通的 TextView。</li></ul></li></ul><p>如果上面的代码抓不到，说明用的是自定义 View。需要把 XPath 改成普通的文本查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 针对自定义 UI 的 Toast</span><br>xpath = <span class="hljs-string">&quot;//*[contains(@text, &#x27;关注成功&#x27;)]&quot;</span> <br>WebDriverWait(driver, <span class="hljs-number">5</span>).until(EC.visibility_of_element_located((AppiumBy.XPATH, xpath)))<br></code></pre></td></tr></table></figure><hr><h2 id="5-手势操作"><a href="#5-手势操作" class="headerlink" title="5.手势操作"></a>5.手势操作</h2><p>在 Appium 里，我们依然使用 ActionChains，但底层的逻辑从“鼠标”变成了 “手指 (Touch)”。Appium 现在全面拥抱 <strong>W3C Actions</strong> 标准。这意味着可以像剪辑视频一样，一帧一帧地“编排”手指动作。</p><p>看两个 B 站的高频场景：</p><ol><li><strong>长按 (Long Press)</strong>：长按视频封面，弹出“不感兴趣&#x2F;稍后再看”菜单。</li><li><strong>精准拖拽 (Drag &amp; Drop)</strong>：在这个视频上发弹幕，或者拖动进度条。</li></ol><hr><h3 id="👆-核心武器：ActionChains"><a href="#👆-核心武器：ActionChains" class="headerlink" title="👆 核心武器：ActionChains"></a>👆 核心武器：ActionChains</h3><p>需要引入这个老朋友：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions.action_builder <span class="hljs-keyword">import</span> ActionBuilder<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions.pointer_input <span class="hljs-keyword">import</span> PointerInput<br><span class="hljs-keyword">from</span> selenium.webdriver.common.actions <span class="hljs-keyword">import</span> interaction<br></code></pre></td></tr></table></figure><p><em>(其实通常只引入 <code>ActionChains</code> 就够用了，Appium 封装好了)</em></p><hr><h3 id="场景一：长按-Long-Press-——-呼出菜单"><a href="#场景一：长按-Long-Press-——-呼出菜单" class="headerlink" title="场景一：长按 (Long Press) —— 呼出菜单"></a>场景一：长按 (Long Press) —— 呼出菜单</h3><p>在 B 站首页或搜索列表，<strong>长按</strong>一个视频封面，通常会弹出一个预览窗口或者快捷菜单。</p><p><strong>动作分解</strong>：</p><ol><li>移动到元素中心。</li><li>按下 (click_and_hold)。</li><li><strong>停顿 (pause)</strong> —— 关键！不停顿就是普通点击。</li><li>松开 (release)。</li><li>执行 (perform)。</li></ol><h4 id="💻-代码实战-1"><a href="#💻-代码实战-1" class="headerlink" title="💻 代码实战"></a>💻 代码实战</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (前置代码：启动 B 站，进入搜索结果页) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备测试长按手势...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 1. 定位目标元素 (找列表里的第一个视频封面或标题)</span><br>    <span class="hljs-comment"># B站的视频容器 ID 通常包含 &#x27;card&#x27; 或 &#x27;cover&#x27;</span><br>    target_element = driver.find_element(AppiumBy.XPATH, <span class="hljs-string">&quot;(//android.widget.TextView[contains(@text, &#x27;Python&#x27;)])[2]&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 构建动作链</span><br>    actions = ActionChains(driver)<br>    <br>    <span class="hljs-comment"># 链式写法：</span><br>    <span class="hljs-comment"># click_and_hold(元素) -&gt; pause(秒) -&gt; release()</span><br>    actions.click_and_hold(target_element)\<br>           .pause(<span class="hljs-number">2</span>)\<br>           .release()<br>           <br>    <span class="hljs-comment"># 3. 执行动作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行长按...&quot;</span>)<br>    actions.perform()<br>    <br>    <span class="hljs-comment"># 4. 验证效果 (长按后通常会震动，或者弹窗)</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;长按结束，请看手机屏幕是否有变化&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 长按失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="场景二：精准拖拽-Drag-Scroll-——-下拉刷新"><a href="#场景二：精准拖拽-Drag-Scroll-——-下拉刷新" class="headerlink" title="场景二：精准拖拽 (Drag &#x2F; Scroll) —— 下拉刷新"></a>场景二：精准拖拽 (Drag &#x2F; Scroll) —— 下拉刷新</h3><p>虽然我们之前学过 <code>driver.swipe</code>，但 <code>ActionChains</code> 能做更细腻的**“慢速滑动”**（比如下拉刷新，滑太快可能触发不了）。</p><p><strong>动作分解</strong>：</p><ol><li>手指按下 (比如屏幕中间 <code>x=500, y=500</code>)。</li><li>移动手指 (移动到 <code>x=500, y=1500</code>)。</li><li>松开。</li></ol><h4 id="💻-代码实战：首页下拉刷新"><a href="#💻-代码实战：首页下拉刷新" class="headerlink" title="💻 代码实战：首页下拉刷新"></a>💻 代码实战：首页下拉刷新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... (在 B 站首页) ...</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备测试下拉刷新...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取屏幕尺寸，为了通用性</span><br>    size = driver.get_window_size()<br>    w = size[<span class="hljs-string">&#x27;width&#x27;</span>]<br>    h = size[<span class="hljs-string">&#x27;height&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 起点：屏幕上方 20% 处</span><br>    start_x = w * <span class="hljs-number">0.5</span><br>    start_y = h * <span class="hljs-number">0.2</span><br>    <br>    <span class="hljs-comment"># 终点：屏幕下方 80% 处</span><br>    end_x = w * <span class="hljs-number">0.5</span><br>    end_y = h * <span class="hljs-number">0.8</span><br>    <br>    <span class="hljs-comment"># 构建动作</span><br>    actions = ActionChains(driver)<br>    <br>    <span class="hljs-comment"># pointer_action 是更底层的写法，click_and_hold 默认是点元素</span><br>    <span class="hljs-comment"># 如果要按“坐标”点，建议用 w3c_actions 的写法，或者如下技巧：</span><br>    <br>    <span class="hljs-comment"># --- 技巧：使用 move_to_location 移动到坐标 ---</span><br>    actions.w3c_actions.pointer_action.move_to_location(start_x, start_y)<br>    actions.w3c_actions.pointer_action.pointer_down() <span class="hljs-comment"># 按下</span><br>    actions.w3c_actions.pointer_action.pause(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 稍微停顿</span><br>    actions.w3c_actions.pointer_action.move_to_location(end_x, end_y) <span class="hljs-comment"># 拖到下面</span><br>    actions.w3c_actions.pointer_action.pause(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 停顿看效果</span><br>    actions.w3c_actions.pointer_action.pointer_up() <span class="hljs-comment"># 松开</span><br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行下拉...&quot;</span>)<br>    actions.perform()<br>    <br>    <span class="hljs-comment"># 验证：下拉后通常会出现“正在刷新”的 loading 图标</span><br>    time.sleep(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 下拉失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APP测试理论基础</tag>
      
      <tag>python</tag>
      
      <tag>Appium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试基础功能测试小案例</title>
    <link href="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
    <url>/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>前台地址： <a href="https://hmshop-test.itheima.net/">https://hmshop-test.itheima.net/</a></p><p>后台地址： <a href="https://hmshop-test.itheima.net/admin">https://hmshop-test.itheima.net/admin</a></p><p>本次目标： 1. 核心业务：下单业务 2. 核心模块：选择商品、购物车、注册登录、下单、支付</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image1.png" class="" title="测试流程"><h1 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h1><p>首先熟悉需求-流程：选择商品-&gt;立即购买-&gt;登录成功-&gt;提交订单成功-&gt;支付成功</p><p>并对下单业务绘制流程图</p><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image2.png" class="" title="流程图"><p><strong>分析出测试点：</strong></p><ul><li><strong>下单成功</strong></li><li><strong>下单失败（购物车添加失败）</strong></li><li><strong>下单失败（登录失败）</strong></li><li><strong>下单失败（提交订单失败）</strong></li><li><strong>下单失败（支付失败）</strong></li></ul><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">order_001</td><td align="center">下单成功（购物车）</td><td align="center">下单业务</td><td align="center">P0</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息</td><td align="center">1、选择商品           2、添加购物车       3、登录成功           4、提交订单成功     5、支付</td><td align="center">商品：001        商品购买数量：1            支付方式：货到付款</td><td align="center">下单成功，订单状态为待发货。     商品001库存数量减少1</td><td align="center">不通过，原因：下单成功后库存数量未减少</td></tr><tr><td align="center">order_002</td><td align="center">下单失败（添加购物车失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品002已上架且库存0</td><td align="center">1、选择商品     2、添加购物车</td><td align="center">商品：002</td><td align="center">下单失败，添加购物车按钮置灰不可点。</td><td align="center">通过</td></tr><tr><td align="center">order_003</td><td align="center">下单失败（登录失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品003已上架且库存200</td><td align="center">1、选择商品     2、添加购物车     3、登录操作</td><td align="center">商品：003     商品购买数量：1     登录操作：不登录</td><td align="center">下单失败，跳转到登录页面。</td><td align="center">通过</td></tr><tr><td align="center">order_004</td><td align="center">下单失败（提交订单失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、未添加收货人信息</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单操作</td><td align="center">商品：001     商品购买数量：1     提交订单：未选择收货人信息</td><td align="center">下单失败，提示：请填写收货人信息</td><td align="center">不通过，原因：未选择收货人信息，下单成功。</td></tr><tr><td align="center">order_005</td><td align="center">下单失败（支付失败）</td><td align="center">下单业务</td><td align="center">P1</td><td align="center">1、商品001已上架且库存200     2、已注册账号     3、已添加收货人信息     4、微信余额为0     5、商品001售价大于0</td><td align="center">1、选择商品     2、添加购物车     3、登录成功     4、提交订单成功     5、支付</td><td align="center">商品：001     商品购买数量：1     支付方式：微信</td><td align="center">下单失败，提示：余额不足，请更换其他支付方式。</td><td align="center">不通过，原因：返回错误信息不友好（{“return_code”:”FAIL”,”return_msg”:”mch_id参数格式错误”}）</td></tr></tbody></table><p>为这三个bug写报告：</p><hr><h3 id="🐛-Bug-报告-1：严重的数据逻辑错误"><a href="#🐛-Bug-报告-1：严重的数据逻辑错误" class="headerlink" title="🐛 Bug 报告 1：严重的数据逻辑错误"></a>🐛 Bug 报告 1：严重的数据逻辑错误</h3><p>问题来源： 用例 order_001</p><p>缺陷类型： 数据一致性 (严重程度高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 用户下单支付成功后，后台商品库存数量未自动扣减</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (严重)</strong> - <em>涉及核心库存数据，会导致超卖，属于重大事故。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 库存管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001已上架，后台库存显示为 200。 2. 用户账号已注册并登录，且已添加收货地址。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入商品详情页，选择商品001，数量为 1。 2. 点击“加入购物车”并进入结算页。 3. 点击“提交订单”并完成支付（货到付款）。 4. 登录后台管理系统，查看商品001的剩余库存。</td></tr><tr><td><strong>预期结果</strong></td><td>前台提示下单成功；<strong>后台商品001的库存数量应减少1（变为199）。</strong></td></tr><tr><td><strong>实际结果</strong></td><td>前台提示下单成功；<strong>但后台商品001的库存数量仍显示为 200（未扣减）。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：校验逻辑缺失"><a href="#🐛-Bug-报告-2：校验逻辑缺失" class="headerlink" title="🐛 Bug 报告 2：校验逻辑缺失"></a>🐛 Bug 报告 2：校验逻辑缺失</h3><p>问题来源： 用例 order_004</p><p>缺陷类型： 功能逻辑错误 (严重程度中等偏高)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[下单业务] 结算页未选择&#x2F;未填写收货人信息，仍能成功提交订单</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (重要)</strong> - <em>导致产生无效订单，后续无法发货。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 订单提交</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 商品001库存充足。 2. 用户已注册账号，<strong>但账号下未添加任何收货人信息</strong>。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 登录该无收货信息的账号。 2. 将商品001加入购物车。 3. 进入结算页面（此时收货人信息栏为空）。 4. 直接点击“提交订单”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td>订单提交失败，页面应弹出提示框：<strong>“请填写收货人信息”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行拦截，直接提示“下单成功”，生成了无地址的异常订单。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露"><a href="#🐛-Bug-报告-3：报错信息不友好-乱码-代码泄露" class="headerlink" title="🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)"></a>🐛 Bug 报告 3：报错信息不友好 (乱码&#x2F;代码泄露)</h3><p>问题来源： 用例 order_005</p><p>缺陷类型： 用户体验 (UI&#x2F;UX)</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 余额不足导致支付失败时，页面直接展示原始代码报错信息</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S3 (一般)</strong> - <em>功能逻辑是正确的（拦截了），但体验很差。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P2 (中)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>下单业务 &#x2F; 支付接口</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已下单待支付。 2. 选择“微信支付”，且模拟微信余额为 0。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 在支付页面选择“微信支付”。 2. 点击“确认支付”。 3. 观察页面返回的错误提示。</td></tr><tr><td><strong>预期结果</strong></td><td>页面应弹出友好提示：<strong>“余额不足，请更换其他支付方式”</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td>页面弹窗显示后端原始 JSON 代码：<code>&#123;“return_code”:“FAIL”, “return_msg”:“mch_id参数格式错误”&#125;</code>，用户无法理解。</td></tr></tbody></table><hr><h1 id="单模块测试"><a href="#单模块测试" class="headerlink" title="单模块测试"></a>单模块测试</h1><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image3.png" class="" title="登录功能"><table><thead><tr><th align="center"><strong>输入项</strong></th><th align="center"><strong>有效等价类 (合法 - 预期成功)</strong></th><th align="center"><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td align="center">1.用户名</td><td align="center">手机号已注册</td><td align="center">用户名为空</td></tr><tr><td align="center"></td><td align="center">邮箱已注册</td><td align="center">格式错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">未注册</td></tr><tr><td align="center">2.密码</td><td align="center">密码正确</td><td align="center">密码为空</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">密码错误</td></tr><tr><td align="center">3.验证码</td><td align="center">完全匹配</td><td align="center">为空</td></tr><tr><td align="center"></td><td align="center">不限制大小写</td><td align="center">验证码错误</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">已失效或过期的验证码</td></tr></tbody></table><p>设计测试用例：</p><table><thead><tr><th align="center">用例编号</th><th align="center">用例标题</th><th align="center">项目&#x2F;模块</th><th align="center">优先级</th><th align="center">前置条件</th><th align="center">测试步骤</th><th align="center">测试数据</th><th align="center">预期结果</th><th align="center">实际结果</th></tr></thead><tbody><tr><td align="center">shop_login_001</td><td align="center">手机号登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册手机号 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.手机号：已注册的手机号 2.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_002</td><td align="center">邮箱登录成功</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册邮箱 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.验证码打乱大小写 4.点击登录</td><td align="center">1.邮箱：已注册的邮箱 2.验证码：大小写打乱 3.其他：正确输入</td><td align="center">登陆成功，无提示，跳转到我的商城界面</td><td align="center">pass</td></tr><tr><td align="center">shop_login_003</td><td align="center">用户名为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名为空 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名为空 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_004</td><td align="center">用户名格式错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已打开登录页面</td><td align="center">1.用户名格式错误 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名格式错误 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号格式不匹配！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_005</td><td align="center">用户名未注册登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.未注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：未注册的用户名 2.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“账号不存在！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_006</td><td align="center">密码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：错误密码 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_007</td><td align="center">密码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入验证码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：空 3.其他：正确输入</td><td align="center">登陆失败，弹窗提示：“密码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_008</td><td align="center">验证码为空登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：空</td><td align="center">登陆失败，弹窗提示：“验证码不能为空！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_009</td><td align="center">验证码错误登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：错误的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr><tr><td align="center">shop_login_0010</td><td align="center">验证码过期登录失败校验</td><td align="center">登录功能</td><td align="center">P2</td><td align="center">1.已注册用户名 2.已打开登录页面</td><td align="center">1.输入用户名 2.输入密码 3.输入验证码 4.点击登录</td><td align="center">1.用户名：已注册的用户名 2.密码：正确密码 3.验证码：过期的验证码</td><td align="center">登陆失败，弹窗提示：“验证码错误！”</td><td align="center">pass</td></tr></tbody></table><hr><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image4.png" class="" title="购物车1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image5.png" class="" title="购物车2"><p>重点分析 <strong>“购物车添加商品数量”</strong> 和 <strong>“商品种类限制”</strong> 这两个核心规则。</p><h3 id="1-核心分析对象：商品数量-添加-修改"><a href="#1-核心分析对象：商品数量-添加-修改" class="headerlink" title="1. 核心分析对象：商品数量 (添加&#x2F;修改)"></a>1. 核心分析对象：商品数量 (添加&#x2F;修改)</h3><p>需求明确指出：</p><ul><li><strong>库存充足 (&gt;&#x3D;200) 时：</strong> 数量取值为 <code>[1, 200]</code>。</li><li><strong>库存不足 (&lt;200) 时：</strong> 数量取值为 <code>[1, 库存量]</code>。</li></ul><p>这意味着需要设计 <strong>两套</strong> 边界值方案。</p><h4 id="📊-分析表：商品数量输入框"><a href="#📊-分析表：商品数量输入框" class="headerlink" title="📊 分析表：商品数量输入框"></a>📊 分析表：商品数量输入框</h4><p>假设现在有一款商品 A。</p><table><thead><tr><th><strong>测试场景</strong></th><th><strong>前置条件 (环境)</strong></th><th><strong>有效等价类 (合法)</strong></th><th><strong>边界值 (BVA) - 重点！</strong></th><th><strong>无效等价类 (非法)</strong></th></tr></thead><tbody><tr><td><strong>场景 A：库存充足</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>500</strong></td><td>1 ~ 200 之间的整数</td><td><strong>上点 (有效):</strong> 1, 200 <strong>离点 (无效):</strong> 0, 201</td><td>1. 大于 200 的数 (如 201) 2. 小于 1 的数 (如 0, -1) 3. 非整数 (如 1.5) 4. 非数字 (如 abc)</td></tr><tr><td><strong>场景 B：库存紧张</strong></td><td>后台设置商品 A 库存 &#x3D; <strong>5</strong></td><td>1 ~ 5 之间的整数</td><td><strong>上点 (有效):</strong> 1, 5 <strong>离点 (无效):</strong> 0, 6</td><td>1. 大于 5 的数 (如 6) 2. 小于 1 的数 (如 0) … (同上)</td></tr></tbody></table><h3 id="2-核心分析对象：商品种类限制"><a href="#2-核心分析对象：商品种类限制" class="headerlink" title="2. 核心分析对象：商品种类限制"></a>2. 核心分析对象：商品种类限制</h3><p>需求指出：“商品种类不能大于 20 种”。</p><p>(注意：是“种类”，不是“总数量”。买了 100 个苹果 + 1 个梨，这是 2 种)。</p><h4 id="📊-分析表：购物车种类上限"><a href="#📊-分析表：购物车种类上限" class="headerlink" title="📊 分析表：购物车种类上限"></a>📊 分析表：购物车种类上限</h4><table><thead><tr><th><strong>规则</strong></th><th><strong>有效等价类</strong></th><th><strong>边界值 (BVA)</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td><strong>种类 &lt;&#x3D; 20</strong></td><td>购物车内已有 1~19 种商品</td><td><strong>上点 (能加):</strong> 已有 19 种，再加第 20 种 -&gt; <strong>成功</strong> <strong>离点 (报错):</strong> 已有 20 种，再加第 21 种 -&gt; <strong>失败&#x2F;提示</strong></td><td>已有 20 种以上 (如数据库脏数据导致有25种)，再操作添加</td></tr></tbody></table><hr><h3 id="3-核心分析对象：修改方式-号与输入框"><a href="#3-核心分析对象：修改方式-号与输入框" class="headerlink" title="3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)"></a>3. 核心分析对象：修改方式 (+&#x2F;- 号与输入框)</h3><p>需求提到可以使用 <strong>【+】</strong> 和 <strong>【-】</strong> 调节，也可以 <strong>直接修改数字</strong>。</p><p>这里主要用 <strong>等价类划分</strong> 来覆盖交互逻辑：</p><table><thead><tr><th><strong>输入方式</strong></th><th><strong>正常类 (Happy Path)</strong></th><th><strong>异常类 (Exception)</strong></th></tr></thead><tbody><tr><td><strong>点击【+】号</strong></td><td>当前数量 &lt; 最大限制 (如库存或200)，点击后数量+1</td><td>当前数量 &#x3D; 最大限制，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (UI测试点)</td></tr><tr><td><strong>点击【-】号</strong></td><td>当前数量 &gt; 1，点击后数量-1</td><td>当前数量 &#x3D; 1，<strong>点击后数量不变</strong> 或 <strong>按钮置灰</strong> (有些设计是弹出删除提示，需确认需求)</td></tr><tr><td><strong>直接输入框</strong></td><td>输入正常整数</td><td>输入 <strong>空格</strong>、<strong>中文</strong>、<strong>特殊符号</strong>、<strong>超长数字</strong>、<strong>负数</strong></td></tr></tbody></table><hr><h3 id="🛒-购物车功能测试用例"><a href="#🛒-购物车功能测试用例" class="headerlink" title="🛒 购物车功能测试用例"></a>🛒 购物车功能测试用例</h3><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>CART_001</strong></td><td><strong>添加商品-库存充足边界值 (Max)</strong></td><td><strong>P0</strong></td><td>1. 商品A库存为 <strong>500</strong> 2. 购物车无该商品</td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>200</strong></td><td>添加成功，购物车中显示商品A数量为 200</td></tr><tr><td><strong>CART_002</strong></td><td><strong>添加商品-超过最大购买限制</strong></td><td>P1</td><td>1. 商品A库存为 <strong>500</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>201</strong></td><td>添加失败，提示“最多只能购买200件”或自动变为200</td></tr><tr><td><strong>CART_003</strong></td><td><strong>添加商品-动态库存边界 (全部库存)</strong></td><td><strong>P0</strong></td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>5</strong></td><td>添加成功，购物车中显示商品B数量为 5</td></tr><tr><td><strong>CART_004</strong></td><td><strong>添加商品-超过动态库存</strong></td><td>P1</td><td>1. 商品B库存仅为 <strong>5</strong></td><td>1. 在商品页输入数量 2. 点击加入购物车</td><td>数量: <strong>6</strong></td><td>添加失败，提示“库存不足”或自动修正为5</td></tr><tr><td><strong>CART_005</strong></td><td><strong>修改数量-最小边界值 (Min)</strong></td><td>P1</td><td>1. 购物车中有 2 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td>数量变为 <strong>1</strong>，且【-】号按钮变灰或不可点击</td></tr><tr><td><strong>CART_006</strong></td><td><strong>修改数量-下限溢出保护</strong></td><td>P2</td><td>1. 购物车中有 1 件商品A</td><td>1. 点击 <strong>【-】</strong> 号</td><td>&#x2F;</td><td><strong>数量保持为 1</strong> (或弹出删除确认框，视具体交互而定)，不能变为 0 或负数</td></tr><tr><td><strong>CART_007</strong></td><td><strong>直接输入非法字符</strong></td><td>P2</td><td>1. 购物车中有商品A</td><td>1. 点击数量输入框 2. 输入非法字符</td><td>数量: <code>abc</code> 或 <code>1.5</code></td><td>输入框不接受非法字符，或自动恢复为修改前的数字</td></tr><tr><td><strong>CART_008</strong></td><td><strong>商品种类上限-有效边界</strong></td><td>P1</td><td>1. 购物车已添加 <strong>19</strong> 种不同商品</td><td>1. 去添加第 <strong>20</strong> 种新商品</td><td>商品T (新种类)</td><td>添加成功，购物车内显示 20 种商品</td></tr><tr><td><strong>CART_009</strong></td><td><strong>商品种类上限-无效边界</strong></td><td>P2</td><td>1. 购物车已添加 <strong>20</strong> 种不同商品</td><td>1. 去添加第 <strong>21</strong> 种新商品</td><td>商品U (新种类)</td><td>添加失败，提示“购物车商品种类已达上限(20种)”</td></tr><tr><td><strong>CART_010</strong></td><td><strong>删除功能-批量删除</strong></td><td>P1</td><td>1. 购物车有商品A, B, C</td><td>1. 勾选商品A和B 2. 点击【删除选中商品】</td><td>&#x2F;</td><td>商品A和B消失，商品C保留，总价自动重新计算</td></tr><tr><td><strong>CART_011</strong></td><td><strong>空状态显示 (已登录)</strong></td><td>P2</td><td>1. 用户已登录 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车空空的哦<del>，去看看心仪的商品吧</del>”</td></tr><tr><td><strong>CART_012</strong></td><td><strong>空状态显示 (未登录)</strong></td><td>P2</td><td>1. 用户<strong>未登录</strong> 2. 购物车为空</td><td>1. 进入购物车页面</td><td>&#x2F;</td><td>页面展示：“购物车内暂时没有商品，登录后将显示您之前加入的商品”</td></tr></tbody></table><hr><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image6.png" class="" title="支付1"><img src="/2025/12/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%A1%88%E4%BE%8B/image7.png" class="" title="支付2"><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题 (测试点)</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>PAY_001</strong></td><td><strong>最小金额支付 (边界值)</strong></td><td><strong>P0</strong></td><td>订单金额为 <strong>0.01</strong> 元</td><td>选择支付方式，点击确认支付</td><td>金额: 0.01</td><td>成功发起支付，跳转第三方或显示支付成功</td></tr><tr><td><strong>PAY_002</strong></td><td><strong>零金额支付限制 (边界值)</strong></td><td>P1</td><td>订单金额为 <strong>0.00</strong> 元 (需后台造数据)</td><td>尝试点击确认支付</td><td>金额: 0.00</td><td><strong>支付按钮置灰</strong> 或 提示“支付金额不能为0”</td></tr><tr><td><strong>PAY_003</strong></td><td><strong>支付倒计时有效性</strong></td><td>P1</td><td>订单已生成 <strong>29分50秒</strong></td><td>等待至 30分01秒，刷新页面或点击支付</td><td>&#x2F;</td><td>提示“订单已超时&#x2F;已关闭”，无法继续支付</td></tr><tr><td><strong>PAY_004</strong></td><td><strong>支付方式互斥性 (UI)</strong></td><td>P2</td><td>&#x2F;</td><td>1. 默认“货到付款”被选中 2. 点击“支付宝”</td><td>&#x2F;</td><td>“货到付款”自动取消选中，“支付宝”变为选中状态</td></tr><tr><td><strong>PAY_005</strong></td><td><strong>余额不足支付失败</strong></td><td>P1</td><td>选择微信支付</td><td>1. 扫码 2. 使用余额为0的微信账号支付</td><td>&#x2F;</td><td>微信端提示余额不足，商城页面保持在“待支付”状态</td></tr><tr><td><strong>PAY_006</strong></td><td><strong>重复支付拦截 (幂等性)</strong></td><td><strong>P0</strong></td><td>订单已在另一个窗口支付成功</td><td>1. 在当前窗口（旧状态）再次点击“支付”</td><td>&#x2F;</td><td>系统拦截，提示“该订单已支付”，并自动刷新状态为已支付</td></tr><tr><td><strong>PAY_007</strong></td><td><strong>支付时价格变动 (高风险)</strong></td><td><strong>P1</strong></td><td>1. 下单时商品 100元 2. <strong>后台将商品改价为 200元</strong></td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td><strong>页面刷新显示最新价格 200元</strong>，并提示“商品价格已变动，请重新确认”</td></tr><tr><td><strong>PAY_008</strong></td><td><strong>密码错误重试</strong></td><td>P2</td><td>选择银行卡支付</td><td>1. 输错密码 2. 再次输入正确密码</td><td>&#x2F;</td><td>第一次提示错误，第二次支付成功</td></tr><tr><td><strong>PAY_009</strong></td><td><strong>合并支付</strong></td><td>P2</td><td>购物车有商品A和商品B</td><td>1. 勾选A和B 2. 提交订单并支付</td><td>&#x2F;</td><td>支付金额为 A+B 的总和，支付一次即可</td></tr></tbody></table><p>太棒了！我们就挑选支付模块中**“含金量”最高**（也是面试官最爱听）的两个场景来写 Bug 报告。</p><p>这两个 Bug 分别对应了 <strong>严重的功能逻辑漏洞（让公司亏钱）</strong> 和 <strong>边界值校验缺失</strong>。</p><p>请按照下面的格式，直接把这两个单子录入到你的缺陷管理系统里。</p><hr><h3 id="🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）"><a href="#🐛-Bug-报告-1：支付金额未同步（逻辑漏洞）" class="headerlink" title="🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）"></a>🐛 Bug 报告 1：支付金额未同步（逻辑漏洞）</h3><p>这个 Bug 非常经典，直接违反了需求文档中“支付时刻会获取当前订单的最新价格进行显示支付” 这一条风控规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单生成后后台修改商品价格，前台支付时未同步最新价格，导致用户可低价购买</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S1 (致命)</strong> - <em>直接导致资金损失，属于核心业务逻辑错误。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P0 (立即修复)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心 &#x2F; 订单管理</td></tr><tr><td><strong>环境</strong></td><td>测试环境 (Chrome 浏览器)</td></tr><tr><td><strong>预置条件</strong></td><td>1. 用户已登录，且购物车中有商品A（单价 100元）。 2. 拥有后台管理系统权限的账号已登录。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户在前台提交包含商品A的订单，订单金额显示 100元，状态为“待支付”。 2. <strong>(关键步骤)</strong> 管理员在后台将商品A的单价修改为 <strong>200元</strong>。 3. 用户在支付页面（不刷新）或订单列表点击“去支付”。 4. 观察支付网关显示的应付金额。</td></tr><tr><td><strong>预期结果</strong></td><td>系统应拦截旧价格支付，提示**“商品价格已变动，请重新确认”**，并刷新支付金额为 <strong>200元</strong>。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>系统未进行价格二次校验，支付网关仍显示应付金额 100元，用户成功以旧价格完成支付。</strong></td></tr></tbody></table><hr><h3 id="🐛-Bug-报告-2：零金额支付漏洞（边界值校验）"><a href="#🐛-Bug-报告-2：零金额支付漏洞（边界值校验）" class="headerlink" title="🐛 Bug 报告 2：零金额支付漏洞（边界值校验）"></a>🐛 Bug 报告 2：零金额支付漏洞（边界值校验）</h3><p>这个 Bug 对应需求文档中“待支付的订单金额为0.00时，无法进行确认支付” 这一条规则。</p><table><thead><tr><th><strong>字段</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>缺陷标题</strong></td><td><strong>[支付业务] 订单金额为 0.00 元时，未限制“确认支付”操作，可直接发起支付</strong></td></tr><tr><td><strong>严重程度</strong></td><td><strong>S2 (严重)</strong> - <em>虽然不涉及亏钱，但违反了明确的业务规则，可能导致下游财务系统账单异常。</em></td></tr><tr><td><strong>优先级</strong></td><td><strong>P1 (高)</strong></td></tr><tr><td><strong>所属模块</strong></td><td>支付中心</td></tr><tr><td><strong>环境</strong></td><td>测试环境</td></tr><tr><td><strong>预置条件</strong></td><td>1. 后台创建一个价格为 0.00 元的测试商品（或使用优惠券抵扣至0元）。 2. 用户下单该商品，生成金额为 0.00 的待支付订单。</td></tr><tr><td><strong>复现步骤</strong></td><td>1. 用户进入该订单的支付页面。 2. 保持默认支付方式（如货到付款或在线支付）。 3. 点击“确认支付”按钮。</td></tr><tr><td><strong>预期结果</strong></td><td><strong>“确认支付”按钮应置灰不可点击</strong>，或点击后弹出提示“订单金额为0，无法进行支付”。</td></tr><tr><td><strong>实际结果</strong></td><td><strong>按钮可点击，系统提示“支付成功”或跳转到了第三方支付页面（报错参数错误），未能正确拦截。</strong></td></tr></tbody></table><hr><h3 id="💡-为什么选这两个写报告？"><a href="#💡-为什么选这两个写报告？" class="headerlink" title="💡 为什么选这两个写报告？"></a>💡 为什么选这两个写报告？</h3><p>问：“在项目中发现过什么印象深刻的 Bug？”</p><blockquote><p>“我在测试支付模块时，发现了一个 <strong>数据一致性</strong> 的严重 Bug。需求要求支付时必须获取最新价格，但我模拟了‘下单后后台改价’的场景，发现前端传给支付接口的还是旧价格。这会导致用户能‘薅羊毛’，造成公司资损。后来我提了 P0 级的 Bug，开发加了支付前的二次校验逻辑才修复。”</p></blockquote><hr><h1 id="非功能性测试"><a href="#非功能性测试" class="headerlink" title="非功能性测试"></a>非功能性测试</h1><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目&#x2F;模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>tpshop_not_function_001</td><td>项目所有功能显示和操作正常（谷歌）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新谷歌浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_002</td><td>项目所有功能显示和操作正常（火狐）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新火狐浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_003</td><td>项目所有功能显示和操作正常（Edge）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新Edge浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_004</td><td>项目所有功能显示和操作正常（苹果）</td><td>兼容性</td><td>P2</td><td>1、项目功能测试完毕     2、已安装最新苹果浏览器</td><td>1、运行所有业务     2、运行所有单功能&#x2F;页面</td><td>&#x2F;</td><td>所有业务和单功能显示及操作正常</td></tr><tr><td>tpshop_not_function_005</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr><tr><td>tpshop_not_function_006</td><td>项目所有页面布局与原型图一致</td><td>易用性</td><td>P2</td><td>1、已准备所有页面原型图和需求文档     2、项目功能已测试完毕</td><td>1、运行页面和交互窗口</td><td>&#x2F;</td><td>所有页面布局颜色与原型图一致</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_PERF_001</strong></td><td><strong>提交订单接口响应时间测试</strong></td><td><strong>P1</strong></td><td>1. 模拟 50 个用户并发在线 2. 数据库中有充足库存</td><td>1. 使用 JMeter 或 LoadRunner 模拟并发点击“提交订单”</td><td>并发数: 50</td><td>1. 平均响应时间 &lt; <strong>3秒</strong> 2. 成功率 100% 3. 服务器 CPU&#x2F;内存占用率 &lt; 80%</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_SEC_001</strong></td><td><strong>商品搜索框 SQL 注入漏洞测试</strong></td><td><strong>P0</strong></td><td>打开商城首页</td><td>1. 在搜索框输入 SQL 注入脚本 2. 点击搜索</td><td><code>&#39; OR 1=1 --</code></td><td>系统拦截特殊字符或提示“未找到商品”，<strong>严禁</strong> 显示数据库报错信息或列出所有商品数据</td></tr><tr><td><strong>NON_FUNC_SEC_002</strong></td><td><strong>XSS 跨站脚本攻击 (评论区)</strong></td><td>P1</td><td>用户已登录</td><td>1. 在商品评价输入框填入 JS 脚本 2. 提交评价 3. 换个账号查看该评价</td><td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td><td>脚本被转义显示为普通文本，<strong>不会</strong> 弹出浏览器弹窗 (Alert)</td></tr></tbody></table><table><thead><tr><th><strong>用例编号</strong></th><th><strong>用例标题</strong></th><th><strong>优先级</strong></th><th><strong>预置条件</strong></th><th><strong>测试步骤</strong></th><th><strong>测试数据</strong></th><th><strong>预期结果</strong></th></tr></thead><tbody><tr><td><strong>NON_FUNC_NET_001</strong></td><td><strong>弱网环境支付测试 (丢包&#x2F;延迟)</strong></td><td>P2</td><td>1. 使用 Fiddler&#x2F;Charles 开启弱网模拟 (上行 2kb&#x2F;s) 2. 处于支付确认页</td><td>1. 点击“确认支付”</td><td>&#x2F;</td><td>1. 页面出现 Loading 动画，而不是假死 2. 若超时，提示“网络不给力，请重试” 3. <strong>不会</strong> 出现崩溃或白屏</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试基础</tag>
      
      <tag>功能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Playwright学习</title>
    <link href="/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/12/Playwright%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><p>在 Playwright 中，定位元素主要分为<strong>两派</strong>：</p><ol><li><strong>传统派（兼容 Selenium 思维）</strong>：使用 CSS 和 XPath。</li><li><strong>新潮派（官方推荐）</strong>：使用“用户看到什么就找什么”的方式。</li></ol><hr><h3 id="第一步：传统派-——-page-locator"><a href="#第一步：传统派-——-page-locator" class="headerlink" title="第一步：传统派 —— page.locator()"></a>第一步：传统派 —— <code>page.locator()</code></h3><p>在 Playwright 里，不需要像 Selenium 那样记 By.ID, By.XPATH, By.CSS_SELECTOR 这么多分类。</p><p>你只需要记住一个万能方法：page.locator(“写在这里”)。</p><p>它会自动识别你写的是 CSS 还是 XPath。</p><h4 id="1-ID-定位"><a href="#1-ID-定位" class="headerlink" title="1. ID 定位"></a>1. ID 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.ID, &quot;kw&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>#</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Class-定位"><a href="#2-Class-定位" class="headerlink" title="2. Class 定位"></a>2. Class 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CLASS_NAME, &quot;s_ipt&quot;)</code></p></li><li><p><strong>Playwright</strong>: 使用 CSS 的 <code>.</code> 语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;.s_ipt&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-XPath-定位"><a href="#3-XPath-定位" class="headerlink" title="3. XPath 定位"></a>3. XPath 定位</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.XPATH, &quot;//input[@id=&#39;kw&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>: 直接写 XPath 字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-CSS-选择器-最常用"><a href="#4-CSS-选择器-最常用" class="headerlink" title="4. CSS 选择器 (最常用)"></a>4. CSS 选择器 (最常用)</h4><ul><li><p><strong>Selenium</strong>: <code>driver.find_element(By.CSS_SELECTOR, &quot;input[name=&#39;wd&#39;]&quot;)</code></p></li><li><p><strong>Playwright</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">page.locator(<span class="hljs-string">&quot;input[name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>🟢 总结：</strong> 只要会写 CSS 或 XPath，直接往 <code>page.locator()</code> 里塞就行了，不需要指定类型。</p></blockquote><hr><h3 id="第二步：新潮派-——-官方推荐的“语义化定位”"><a href="#第二步：新潮派-——-官方推荐的“语义化定位”" class="headerlink" title="第二步：新潮派 —— 官方推荐的“语义化定位”"></a>第二步：新潮派 —— 官方推荐的“语义化定位”</h3><p>Playwright 认为：CSS 和 XPath 是给程序员看的，不是给用户看的。</p><p>如果程序员改了代码（比如把 id&#x3D;”submit-btn” 改成了 id&#x3D;”login-btn”），CSS 定位就挂了。但**按钮上的文字“登录”**通常不会变。</p><p>所以，Playwright 推出了一套<strong>根据页面内容</strong>定位的方法。</p><h4 id="1-找文字-——-get-by-text"><a href="#1-找文字-——-get-by-text" class="headerlink" title="1. 找文字 —— get_by_text()"></a>1. 找文字 —— <code>get_by_text()</code></h4><p>对应 Selenium 的 <code>By.LINK_TEXT</code> 或 XPath 的 <code>text()=</code>。</p><ul><li><p><strong>场景</strong>：页面上有个 <code>&lt;span&gt;欢迎回来&lt;/span&gt;</code> 或 <code>&lt;a&gt;新闻&lt;/a&gt;</code>。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模糊匹配（包含即可）</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎&quot;</span>) <br><br><span class="hljs-comment"># 精确匹配</span><br>page.get_by_text(<span class="hljs-string">&quot;欢迎回来&quot;</span>, exact=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-找表单输入框-——-get-by-placeholder"><a href="#2-找表单输入框-——-get-by-placeholder" class="headerlink" title="2. 找表单输入框 —— get_by_placeholder()"></a>2. 找表单输入框 —— <code>get_by_placeholder()</code></h4><ul><li><p><strong>场景</strong>：输入框里灰色的提示字（Placeholder）。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要输入框里写着 &quot;请输入密码&quot;，就能找到</span><br>page.get_by_placeholder(<span class="hljs-string">&quot;请输入密码&quot;</span>).fill(<span class="hljs-string">&quot;123456&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-找角色（按钮-链接-标题）——-get-by-role-最核心"><a href="#3-找角色（按钮-链接-标题）——-get-by-role-最核心" class="headerlink" title="3. 找角色（按钮&#x2F;链接&#x2F;标题）—— get_by_role() (最核心)"></a>3. 找角色（按钮&#x2F;链接&#x2F;标题）—— <code>get_by_role()</code> <strong>(最核心)</strong></h4><p>这是 Playwright 最强大的地方，它通过 HTML 的<strong>语义</strong>来找。</p><ul><li><p><strong>找按钮</strong> (<code>&lt;button&gt;</code> 或 <code>input type=&quot;submit&quot;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;登录&quot; 的按钮</span><br>page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;登录&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找链接</strong> (<code>&lt;a&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找名字叫 &quot;首页&quot; 的链接</span><br>page.get_by_role(<span class="hljs-string">&quot;link&quot;</span>, name=<span class="hljs-string">&quot;首页&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>找标题</strong> (<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找内容是 &quot;用户注册&quot; 的一级标题</span><br>page.get_by_role(<span class="hljs-string">&quot;heading&quot;</span>, name=<span class="hljs-string">&quot;用户注册&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="第三步：实战练习（通过高亮来验证）"><a href="#第三步：实战练习（通过高亮来验证）" class="headerlink" title="第三步：实战练习（通过高亮来验证）"></a>第三步：实战练习（通过高亮来验证）</h3><p>为了让你直观地看到定位对不对，我们不执行点击，而是用 <strong><code>.highlight()</code></strong> 方法。这会在浏览器里给元素画个红框，非常适合学习！</p><p>我们以 <strong>百度 (baidu.com)</strong> 为例。</p><p>请新建一个 <code>demo_locator.py</code>，把下面的代码复制进去运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># --- 练习 1: 使用 CSS ID 定位搜索框 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在高亮搜索框 (CSS ID)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.ID &quot;kw&quot;</span><br>    page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿 2 秒让你看清楚红框</span><br><br>    <span class="hljs-comment"># --- 练习 2: 使用 XPath 定位“百度一下”按钮 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2. 正在高亮按钮 (XPath)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.XPATH</span><br>    page.locator(<span class="hljs-string">&quot;//input[@id=&#x27;su&#x27;]&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 3: 使用新潮的 get_by_text 定位右上角的“新闻” ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3. 正在高亮链接 (Text)...&quot;</span>)<br>    <span class="hljs-comment"># 对应 Selenium: By.LINK_TEXT &quot;新闻&quot;</span><br>    page.get_by_text(<span class="hljs-string">&quot;新闻&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># --- 练习 4: 使用新潮的 get_by_role 定位“百度一下”按钮 ---</span><br>    <span class="hljs-comment"># 注意：百度的按钮有时候识别有点怪，这里作为进阶尝试</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;4. 尝试用 Role 定位按钮...&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;百度一下&quot;</span>).highlight()<br>    time.sleep(<span class="hljs-number">2</span>)<br><br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h1><p>Playwright 的操作逻辑更简洁，而且解决了一个 Selenium 的大痛点：<strong>它会自动等待元素准备好</strong>。</p><hr><h3 id="1-导航操作-Browser-Actions"><a href="#1-导航操作-Browser-Actions" class="headerlink" title="1. 导航操作 (Browser Actions)"></a>1. 导航操作 (Browser Actions)</h3><p>Playwright 的导航方法和 Selenium 非常像，只是名字稍微变了一点点。</p><table><thead><tr><th><strong>操作</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>打开网页</td><td><code>driver.get(url)</code></td><td><code>page.goto(url)</code></td><td>Playwright 默认会等待页面加载完成(load状态)</td></tr><tr><td>后退</td><td><code>driver.back()</code></td><td><code>page.go_back()</code></td><td>-</td></tr><tr><td>前进</td><td><code>driver.forward()</code></td><td><code>page.go_forward()</code></td><td>-</td></tr><tr><td>刷新</td><td><code>driver.refresh()</code></td><td><code>page.reload()</code></td><td>-</td></tr><tr><td>获取标题</td><td><code>driver.title</code> (属性)</td><td><code>page.title()</code> (方法)</td><td>注意 Playwright 是方法，要加括号 <code>()</code></td></tr><tr><td>获取URL</td><td><code>driver.current_url</code></td><td><code>page.url</code> (属性)</td><td>这个是属性，<strong>不加</strong>括号</td></tr></tbody></table><hr><h3 id="2-元素核心操作-Interaction"><a href="#2-元素核心操作-Interaction" class="headerlink" title="2. 元素核心操作 (Interaction)"></a>2. 元素核心操作 (Interaction)</h3><p>这是自动化测试最高频的操作：输入和点击。</p><h4 id="A-输入框：fill-vs-send-keys"><a href="#A-输入框：fill-vs-send-keys" class="headerlink" title="A. 输入框：fill vs send_keys"></a>A. 输入框：<code>fill</code> vs <code>send_keys</code></h4><ul><li><p>Selenium:</p><p>你需要先 clear() 清空，再 send_keys()。</p></li><li><p>Playwright:</p><p>只有一个神器 fill(“内容”)。它会自动先清空输入框，再输入内容。一步到位。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Selenium</span><br>ele.clear()<br>ele.send_keys(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (推荐)</span><br>page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># Playwright (如果你想模拟逐个按键，比如测试搜索联想)</span><br>page.locator(<span class="hljs-string">&quot;#search&quot;</span>).press_sequentially(<span class="hljs-string">&quot;test&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h4 id="B-点击：click"><a href="#B-点击：click" class="headerlink" title="B. 点击：click"></a>B. 点击：<code>click</code></h4><ul><li><p>Playwright: page.locator(“…”).click()。</p><p>最大优势：它自带智能等待。它会检查元素是否可见、是否停止移动、是否被遮挡。如果被遮挡，它会等待遮挡物消失再点。</p></li></ul><hr><h3 id="3-获取元素信息-Get-Info"><a href="#3-获取元素信息-Get-Info" class="headerlink" title="3. 获取元素信息 (Get Info)"></a>3. 获取元素信息 (Get Info)</h3><p>用于做断言（Assert），验证测试结果。</p><table><thead><tr><th><strong>获取内容</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>获取文本</strong></td><td><code>ele.text</code></td><td><code>locator.inner_text()</code> (可见文本) <code>locator.text_content()</code> (包含隐藏文本)</td></tr><tr><td><strong>获取属性</strong></td><td><code>ele.get_attribute(&quot;type&quot;)</code></td><td><code>locator.get_attribute(&quot;type&quot;)</code></td></tr><tr><td><strong>是否可见</strong></td><td><code>ele.is_displayed()</code></td><td><code>locator.is_visible()</code></td></tr><tr><td><strong>是否可用</strong></td><td><code>ele.is_enabled()</code></td><td><code>locator.is_enabled()</code></td></tr></tbody></table><hr><h3 id="💻-实战演练"><a href="#💻-实战演练" class="headerlink" title="💻 实战演练"></a>💻 实战演练</h3><p>场景：网站 the-internet.herokuapp.com。</p><ol><li>打开登录页。</li><li>输入用户名和密码（使用 <code>fill</code>）。</li><li>点击登录。</li><li>获取提示文字（使用 <code>inner_text</code>）。</li><li>刷新页面。</li></ol><p>新建文件 <code>demo_action.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">1000</span>) <span class="hljs-comment"># slow_mo 让你看清操作</span><br>    page = browser.new_page()<br><br>    <span class="hljs-comment"># 2. 导航</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在打开网页...&quot;</span>)<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span>)<br>    <br>    <span class="hljs-comment"># 打印当前标题</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 3. 元素操作：输入 (使用 fill，自动清空 + 输入)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在输入账号密码...&quot;</span>)<br>    <span class="hljs-comment"># 这里演示用 CSS 选择器定位</span><br>    page.locator(<span class="hljs-string">&quot;#username&quot;</span>).fill(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br>    page.locator(<span class="hljs-string">&quot;#password&quot;</span>).fill(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br>    <span class="hljs-comment"># 4. 元素操作：点击</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 点击登录按钮...&quot;</span>)<br>    <span class="hljs-comment"># 使用语义化定位：找一个 type=&quot;submit&quot; 的按钮 (或者用 class=&quot;radius&quot;)</span><br>    page.locator(<span class="hljs-string">&quot;button[type=&#x27;submit&#x27;]&quot;</span>).click()<br><br>    <span class="hljs-comment"># 5. 获取信息：断言</span><br>    <span class="hljs-comment"># 登录成功后会出现一个 id=&quot;flash&quot; 的提示条</span><br>    flash_message = page.locator(<span class="hljs-string">&quot;#flash&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 获取到的提示信息: \n<span class="hljs-subst">&#123;flash_message&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 简单断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> flash_message:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 测试通过：登录成功！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 测试失败&quot;</span>)<br><br>    <span class="hljs-comment"># 6. 额外操作：刷新</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 刷新页面...&quot;</span>)<br>    page.reload()<br><br>    <span class="hljs-comment"># 截图留念 (Selenium 是 get_screenshot_as_file)</span><br>    page.screenshot(path=<span class="hljs-string">&quot;login_result.png&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已截图保存为 login_result.png&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h1 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h1><p>这部分是 Playwright 对比 Selenium <strong>最爽</strong>的改进之一！🤯</p><p>在你的 Selenium 笔记中，处理新窗口（Tab）非常痛苦：</p><ol><li>先获取 <code>window_handles</code>（一堆看不懂的字符串 ID）。</li><li>必须写个循环判断哪个是新窗口。</li><li><strong>核心痛点</strong>：Driver 是“单线程”的，必须 <code>switch_to</code> 过去才能操作新窗口，操作完还得 <code>switch_to</code> 回来。一旦忘了切回来，代码立马报错。</li></ol><h3 id="Playwright-的逻辑：多线操作"><a href="#Playwright-的逻辑：多线操作" class="headerlink" title="Playwright 的逻辑：多线操作"></a>Playwright 的逻辑：多线操作</h3><p>Playwright 不需要切换句柄（Switch）。</p><p>它把每一个标签页都看作一个独立的对象 (Page Object)。</p><ul><li>主窗口是 <code>page1</code>。</li><li>新窗口是 <code>page2</code>。</li><li>手里拿着两个遥控器，<strong>同时</strong>控制两个窗口，完全不需要切来切去！</li></ul><hr><h3 id="1-捕获新窗口"><a href="#1-捕获新窗口" class="headerlink" title="1. 捕获新窗口"></a>1. 捕获新窗口</h3><p>在 Selenium 里是“点击 -&gt; 然后找窗口”。</p><p>在 Playwright 里是“设置陷阱 (监听器) -&gt; 点击 -&gt; 捕获窗口”。</p><p>我们使用 Python 的 <code>with</code> 语法来捕获弹出的新页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置监听器：当有新页面弹出(popup)时，把信息存到 popup_info 里</span><br><span class="hljs-keyword">with</span> page.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>    page.get_by_text(<span class="hljs-string">&quot;打开新窗口&quot;</span>).click()<br><br><span class="hljs-comment"># 拿到新窗口对象，命名为 page2</span><br>page2 = popup_info.value<br></code></pre></td></tr></table></figure><p>现在，<code>page</code> 变量控制老窗口，<code>page2</code> 变量控制新窗口。就这么简单。</p><hr><h3 id="💻-实战演示"><a href="#💻-实战演示" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h3><p>我们继续使用你笔记里的 <strong>The Internet</strong> 靶场 进行演示。</p><p>新建文件 <code>demo_window.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    <span class="hljs-comment"># 1. 启动</span><br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    context = browser.new_context()<br>    <br>    <span class="hljs-comment"># page1 代表主窗口 (老家)</span><br>    page1 = context.new_page()<br>    page1.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;page1.title()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：点击链接并捕获新窗口 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 准备点击链接...&quot;</span>)<br>    <br>    <span class="hljs-comment"># 语法含义：在这个代码块执行期间，如果弹出了新窗口，就抓给我！</span><br>    <span class="hljs-keyword">with</span> page1.expect_popup() <span class="hljs-keyword">as</span> popup_info:<br>        page1.get_by_text(<span class="hljs-string">&quot;Click Here&quot;</span>).click()<br>    <br>    <span class="hljs-comment"># 获取新窗口对象，这才是我们要操作的新页面</span><br>    page2 = popup_info.value<br>    <br>    <span class="hljs-comment"># 等待新页面加载完成 (Playwright 自动处理，但显式等一下更稳)</span><br>    page2.wait_for_load_state()<br><br>    <span class="hljs-comment"># --- 3. 同时操作两个窗口 (无需 Switch!) ---</span><br>    <br>    <span class="hljs-comment"># 操作新窗口</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口标题: <span class="hljs-subst">&#123;page2.title()&#125;</span>&quot;</span>)<br>    heading_text = page2.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口内容: <span class="hljs-subst">&#123;heading_text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 操作老窗口 (直接用 page1 即可，完全不用切回去)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回去操作老窗口 (没切句柄哦)...&quot;</span>)<br>    original_heading = page1.locator(<span class="hljs-string">&quot;h3&quot;</span>).inner_text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;老窗口内容: <span class="hljs-subst">&#123;original_heading&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 4. 关闭 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭新窗口&quot;</span>)<br>    page2.close()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 关闭主窗口&quot;</span>)<br>    page1.close()<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="2-Iframe"><a href="#2-Iframe" class="headerlink" title="2. Iframe"></a>2. Iframe</h3><p>你笔记里也提到了 <strong>Iframe</strong> 的痛点：需要 <code>switch_to.frame()</code> 进去，操作完必须 <code>switch_to.default_content()</code> 出来。</p><p>Playwright 同样不需要切进切出！它引入了一个 frame_locator 的概念。</p><p>你就把它当成是“路径”的一部分，一层层点下去就行。</p><p><strong>语法对比：</strong></p><ul><li><p><strong>Selenium (切进切出):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;frame_id&quot;</span>)<br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br>driver.switch_to.default_content() <span class="hljs-comment"># 必须记得出来！</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Playwright (直接钻取):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 意思是：找到 id 为 frame_id 的框，再在里面找 id 为 btn 的按钮，点击。</span><br>page.frame_locator(<span class="hljs-string">&quot;#frame_id&quot;</span>).locator(<span class="hljs-string">&quot;#btn&quot;</span>).click()<br></code></pre></td></tr></table></figure><p><em>它只是定位链条变长了，不需要改变上下文状态。</em></p></li></ul><hr><h1 id="等待机制"><a href="#等待机制" class="headerlink" title="等待机制"></a>等待机制</h1><p>这是 Playwright 对比 Selenium <strong>降维打击</strong>最狠的地方。</p><hr><h3 id="1-强制等待-Forced-Wait"><a href="#1-强制等待-Forced-Wait" class="headerlink" title="1. 强制等待 (Forced Wait)"></a>1. 强制等待 (Forced Wait)</h3><ul><li><strong>Selenium</strong>: <code>time.sleep(3)</code> (单位：秒)</li><li><strong>Playwright</strong>: <code>page.wait_for_timeout(3000)</code> (单位：<strong>毫秒</strong>)<ul><li><strong>注意</strong>: 和 Selenium 一样，官方<strong>强烈不推荐</strong>在生产代码里用。它只适合在调试时想让浏览器停下看一眼。</li></ul></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait"><a href="#2-隐式等待-Implicit-Wait" class="headerlink" title="2. 隐式等待 (Implicit Wait)"></a>2. 隐式等待 (Implicit Wait)</h3><ul><li><strong>Selenium</strong>: <code>driver.implicitly_wait(10)</code><ul><li>设置一个全局查找超时时间。</li></ul></li><li><strong>Playwright</strong>: <strong>全局超时 (Global Timeout)</strong><ul><li>Playwright 默认就有 <strong>30秒</strong> 的超时时间。</li><li>不需要像 Selenium 那样手动写一行代码去开启它。</li><li>如果想改，可以用 <code>page.set_default_timeout(5000)</code>。</li></ul></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-核心区别！"><a href="#3-显式等待-Explicit-Wait-——-核心区别！" class="headerlink" title="3. 显式等待 (Explicit Wait) —— 核心区别！"></a>3. 显式等待 (Explicit Wait) —— 核心区别！</h3><p>这是重点。在 Selenium 里，必须手动写 <code>WebDriverWait</code> + <code>EC.element_to_be_clickable</code>。</p><p><strong>在 Playwright 中，显式等待融入到了每一个操作里。</strong></p><h4 id="A-动作自动等待-Auto-Wait-for-Actions"><a href="#A-动作自动等待-Auto-Wait-for-Actions" class="headerlink" title="A. 动作自动等待 (Auto-Wait for Actions)"></a>A. 动作自动等待 (Auto-Wait for Actions)</h4><p>当你执行 <code>.click()</code>, <code>.fill()</code>, <code>.check()</code> 等操作时，Playwright 会<strong>自动</strong>执行一系列检查（相当于内置了最严格的显式等待）：</p><ol><li><strong>Attached</strong>: 元素是否已经连接到 DOM？</li><li><strong>Visible</strong>: 元素是否可见（没有 <code>display: none</code>）？</li><li><strong>Stable</strong>: 元素是否停止了动画（位置不再飘移）？</li><li><strong>Receives Events</strong>: 元素是否被其他层（比如遮罩）挡住了？</li><li><strong>Enabled</strong>: 元素是否可用（没有 <code>disabled</code> 属性）？</li></ol><p><strong>结论：</strong> 再也不用写 <code>wait_until_clickable</code> 了。直接 <code>click()</code>，如果不满足条件，它自己会等。</p><h4 id="B-断言自动等待-Web-First-Assertions"><a href="#B-断言自动等待-Web-First-Assertions" class="headerlink" title="B. 断言自动等待 (Web-First Assertions)"></a>B. 断言自动等待 (Web-First Assertions)</h4><p>对应 Selenium 的 WebDriverWait(driver).until(EC.visibility_of(…))。</p><p>Playwright 使用 expect 断言库来实现智能等待。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这一行代码会自动重试（默认 5 秒），直到文字变成 &quot;Success&quot;</span><br><span class="hljs-comment"># 如果 5 秒后还不是这个字，才会报错</span><br>expect(page.locator(<span class="hljs-string">&quot;#status&quot;</span>)).to_have_text(<span class="hljs-string">&quot;Success&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="⚔️-实战：动态加载页面-VS-Selenium"><a href="#⚔️-实战：动态加载页面-VS-Selenium" class="headerlink" title="⚔️ 实战：动态加载页面 (VS Selenium)"></a>⚔️ 实战：动态加载页面 (VS Selenium)</h3><p>The Internet - Dynamic Loading。</p><p>场景：点击 “Start” 按钮，等 5 秒 loading 条消失，出现 “Hello World!”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    <br>    <span class="hljs-comment"># 1. 打开动态加载页面</span><br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 点击 Start</span><br>    <span class="hljs-comment"># Playwright 会自动等待按钮准备好再点</span><br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Start&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 已点击 Start，正在等待 Hello World 出现...&quot;</span>)<br>    <br>    <span class="hljs-comment"># --- 核心对比 ---</span><br>    <br>    <span class="hljs-comment"># Selenium 需要写: </span><br>    <span class="hljs-comment"># WebDriverWait(driver, 10).until(EC.visibility_of_element_located(...))</span><br>    <br>    <span class="hljs-comment"># Playwright 只需要写断言:</span><br>    <span class="hljs-comment"># expect 会自动等待(默认5秒)直到元素可见。</span><br>    <span class="hljs-comment"># 注意：这个网页加载特别慢(超5秒)，我们可以单独给这一步加长超时时间</span><br>    target_text = page.get_by_text(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    expect(target_text).to_be_visible(timeout=<span class="hljs-number">10000</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 成功！文字出现了。&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_text.inner_text()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><h3 id="🧠-如果非要等呢？"><a href="#🧠-如果非要等呢？" class="headerlink" title="🧠 如果非要等呢？"></a>🧠 如果非要等呢？</h3><p>虽然 <code>expect</code> 和 <code>auto-wait</code> 覆盖了 99% 的场景，但有时候你就是想单纯地“等某个元素出现，但不操作它，也不断言它”。</p><p>Playwright 提供了类似 Selenium <code>EC</code> 的手动等待方法：</p><table><thead><tr><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><code>wait.until(EC.visibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;visible&quot;)</code></td></tr><tr><td><code>wait.until(EC.invisibility_of(...))</code></td><td><code>locator.wait_for(state=&quot;hidden&quot;)</code></td></tr><tr><td><code>wait.until(EC.presence_of(...))</code></td><td><code>locator.wait_for(state=&quot;attached&quot;)</code></td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 等待 loading 条消失 (detached / hidden)</span><br>page.locator(<span class="hljs-string">&quot;#loading&quot;</span>).wait_for(state=<span class="hljs-string">&quot;hidden&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><p>下拉框被分为了“标准”和“非标准”两类。Playwright 对这两类的处理方式和 Selenium 逻辑一致，但在 API 上做到了<strong>极简</strong>。</p><hr><h3 id="第一类：标准下拉框-标签"><a href="#第一类：标准下拉框-标签" class="headerlink" title="第一类：标准下拉框 (&lt;select&gt; 标签)"></a>第一类：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>在 Selenium 中，必须引入 <code>Select</code> 类，实例化它，然后调用 <code>select_by_visible_text</code> 等方法。</p><p>Playwright 不需要引入额外的类。它直接在 locator 上提供了一个 select_option() 方法，把 Selenium 的三种选择方式合三为一了。</p><h4 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 通过 value 属性选 (对应 select_by_value)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(value=<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-comment"># 2. 通过可见文本选 (对应 select_by_visible_text) —— 最常用</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br><br><span class="hljs-comment"># 3. 通过索引选 (对应 select_by_index)</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(index=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="💻-实战演示-1"><a href="#💻-实战演示-1" class="headerlink" title="💻 实战演示"></a>💻 实战演示</h4><p><code>the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># 定位到 select 元素</span><br>    dropdown = page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方式 1: 通过 Label (文本) 选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 1 (by Label)...&quot;</span>)<br>    <span class="hljs-comment"># 这相当于 Selenium 的 select_by_visible_text(&quot;Option 1&quot;)</span><br>    dropdown.select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># --- 方式 2: 通过 Value 属性选择 ---</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在选择 Option 2 (by Value)...&quot;</span>)<br>    <span class="hljs-comment"># HTML: &lt;option value=&quot;2&quot;&gt;Option 2&lt;/option&gt;</span><br>    dropdown.select_option(value=<span class="hljs-string">&quot;2&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># --- 验证结果 ---</span><br>    <span class="hljs-comment"># 怎么获取当前选中的值？</span><br>    <span class="hljs-comment"># 在 Playwright 中，直接看 value 属性即可</span><br>    current_value = dropdown.input_value()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中的 value 是: <span class="hljs-subst">&#123;current_value&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="第二类：非标准下拉框-Div-Ul-模拟"><a href="#第二类：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二类：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二类：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>这是现在前端框架（React, Vue）最喜欢的写法。它们看起来像下拉框，但 HTML 里根本没有 <code>&lt;select&gt;</code> 标签，全是一堆 <code>&lt;div&gt;</code> 和 <code>&lt;li&gt;</code>。</p><p>Playwright 的处理逻辑：把它当成普通的点击操作。</p><p>假设有一个用 Div 做的下拉框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 点击下拉框，让它展开</span><br>page.locator(<span class="hljs-string">&quot;#custom-dropdown-trigger&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 点击里面的选项</span><br><span class="hljs-comment"># Playwright 会自动等待 &quot;高级教程&quot; 这个选项出现在屏幕上再点击</span><br>page.get_by_text(<span class="hljs-string">&quot;高级教程&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="💡-模糊匹配选项"><a href="#💡-模糊匹配选项" class="headerlink" title="💡 模糊匹配选项"></a>💡 模糊匹配选项</h3><p>有时候下拉框里的字很长，或者有空格，比如 “ Option 1 “。</p><p>在 Selenium 里如果你用 select_by_visible_text，差一个空格都会报错。</p><p>在 Playwright 中，可以结合 <code>match</code> 参数（支持正则）或 <code>contains</code> 逻辑来选：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要包含 &quot;Option 1&quot; 就能选中，不用管有没有空格</span><br>page.locator(<span class="hljs-string">&quot;#dropdown&quot;</span>).select_option(label=<span class="hljs-string">&quot;Option 1&quot;</span>) <br></code></pre></td></tr></table></figure><hr><h1 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h1><h3 id="核心区别：监听器-Event-Listener"><a href="#核心区别：监听器-Event-Listener" class="headerlink" title="核心区别：监听器 (Event Listener)"></a>核心区别：监听器 (Event Listener)</h3><ul><li><strong>Selenium</strong>: “出了事再处理”。（必须等弹窗出来，脚本才能去切换、操作）。</li><li><strong>Playwright</strong>: “先立好规矩”。（在点击按钮<strong>之前</strong>，先告诉浏览器：“待会儿如果有弹窗出来，你就帮我点确定”）。</li></ul><blockquote><p><strong>⚠️ 默认行为：</strong> 如果你不写任何监听代码，Playwright 会<strong>自动关闭 (Dismiss)</strong> 所有弹出的 Dialog，防止脚本卡死。这虽然安全，但如果你想测试“点击确定后的效果”，就必须手动设置监听器。</p></blockquote><hr><h3 id="1-怎么写监听器？"><a href="#1-怎么写监听器？" class="headerlink" title="1. 怎么写监听器？"></a>1. 怎么写监听器？</h3><p>需要使用 <strong><code>page.on(&quot;dialog&quot;, 处理函数)</code></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个处理函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_dialog</span>(<span class="hljs-params">dialog</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;弹窗内容: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>    dialog.accept() <span class="hljs-comment"># 点击确定</span><br><br><span class="hljs-comment"># 1. 先注册监听器 (埋伏好)</span><br>page.on(<span class="hljs-string">&quot;dialog&quot;</span>, handle_dialog)<br><br><span class="hljs-comment"># 2. 再触发弹窗 (踩雷)</span><br>page.get_by_text(<span class="hljs-string">&quot;点击弹出Alert&quot;</span>).click()<br></code></pre></td></tr></table></figure><hr><h3 id="2-实战演练：Alert-Confirm-Prompt"><a href="#2-实战演练：Alert-Confirm-Prompt" class="headerlink" title="2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt"></a>2. 实战演练：Alert &#x2F; Confirm &#x2F; Prompt</h3><p>the-internet.herokuapp.com&#x2F;javascript_alerts。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>        browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>        page = browser.new_page()<br>        page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 1: Alert (只有确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 1. 测试 JS Alert&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这里的 lambda d: d.accept() 意思是：只要有弹窗，就点确定</span><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, <span class="hljs-keyword">lambda</span> d: d.accept()) <br>        <br>        <span class="hljs-comment"># 步骤 B: 点击按钮触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Alert&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证结果</span><br>        result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 应该是 You successfully clicked an alert</span><br><br>        <span class="hljs-comment"># --- 场景 2: Confirm (确定/取消) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 2. 测试 JS Confirm (点击取消)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 这次我们定义稍微复杂点的逻辑：打印内容并点击取消</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_confirm</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到弹窗: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.dismiss() <span class="hljs-comment"># 点击取消 (Selenium 的 dismiss)</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_confirm)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Confirm&quot;</span>).click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;page.locator(<span class="hljs-string">&#x27;#result&#x27;</span>).inner_text()&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># --- 场景 3: Prompt (输入 + 确定) ---</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 3. 测试 JS Prompt (输入内容)&quot;</span>)<br>        <br>        <span class="hljs-comment"># 步骤 A: 设置监听器</span><br>        <span class="hljs-comment"># 在 Playwright 中，accept() 可以直接传参数用来输入！</span><br>        <span class="hljs-comment"># Selenium 需要先 send_keys 再 accept，Playwright 合二为一了</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_prompt</span>(<span class="hljs-params">dialog</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;捕获到 Prompt: <span class="hljs-subst">&#123;dialog.message&#125;</span>&quot;</span>)<br>            dialog.accept(<span class="hljs-string">&quot;Playwright 练习生&quot;</span>) <span class="hljs-comment"># 输入并确定</span><br><br>        page.once(<span class="hljs-string">&quot;dialog&quot;</span>, handle_prompt)<br>        <br>        <span class="hljs-comment"># 步骤 B: 触发</span><br>        page.get_by_text(<span class="hljs-string">&quot;Click for JS Prompt&quot;</span>).click()<br>        <br>        <span class="hljs-comment"># 验证</span><br>        final_result = page.locator(<span class="hljs-string">&quot;#result&quot;</span>).inner_text()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终结果: <span class="hljs-subst">&#123;final_result&#125;</span>&quot;</span>)<br>        <br>        time.sleep(<span class="hljs-number">2</span>)<br>        browser.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run()<br></code></pre></td></tr></table></figure><h3 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3. 代码解析"></a>3. 代码解析</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>切换</strong></td><td><code>driver.switch_to.alert</code></td><td><code>page.on(&quot;dialog&quot;, handler)</code></td></tr><tr><td><strong>点确定</strong></td><td><code>alert.accept()</code></td><td><code>dialog.accept()</code></td></tr><tr><td><strong>点取消</strong></td><td><code>alert.dismiss()</code></td><td><code>dialog.dismiss()</code></td></tr><tr><td><strong>输入</strong></td><td><code>alert.send_keys(&quot;abc&quot;)</code></td><td><code>dialog.accept(&quot;abc&quot;)</code> <strong>(注意区别)</strong></td></tr><tr><td><strong>获取文字</strong></td><td><code>alert.text</code></td><td><code>dialog.message</code></td></tr></tbody></table><blockquote><ul><li><code>page.on</code>: <strong>永久</strong>监听。只要有弹窗，一直用这个逻辑处理。</li><li><code>page.once</code>: <strong>一次性</strong>监听。处理完这一个弹窗后，监听器就失效了。</li><li>在测试中，通常用 <code>once</code>，因为每个测试用例对弹窗的处理要求可能不一样（有的要点确定，有的要点取消）。</li></ul></blockquote><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><h3 id="1-鼠标操作-Mouse"><a href="#1-鼠标操作-Mouse" class="headerlink" title="1. 鼠标操作 (Mouse)"></a>1. 鼠标操作 (Mouse)</h3><p>不需要初始化 <code>ActionChains</code>，直接调用方法即可。</p><table><thead><tr><th><strong>操作</strong></th><th><strong>Selenium (ActionChains)</strong></th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>悬停 (Hover)</strong></td><td><code>.move_to_element(ele).perform()</code></td><td><strong><code>locator.hover()</code></strong></td></tr><tr><td><strong>双击</strong></td><td><code>.double_click(ele).perform()</code></td><td><strong><code>locator.dblclick()</code></strong></td></tr><tr><td><strong>右键</strong></td><td><code>.context_click(ele).perform()</code></td><td><strong><code>locator.click(button=&quot;right&quot;)</code></strong></td></tr><tr><td><strong>拖拽</strong></td><td><code>.drag_and_drop(src, dst).perform()</code></td><td><strong><code>page.drag_and_drop(src, dst)</code></strong></td></tr></tbody></table><h4 id="💻-实战-A：鼠标悬停-Baidu-Settings"><a href="#💻-实战-A：鼠标悬停-Baidu-Settings" class="headerlink" title="💻 实战 A：鼠标悬停 (Baidu Settings)"></a>💻 实战 A：鼠标悬停 (Baidu Settings)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 定位“设置”</span><br>    settings_btn = page.locator(<span class="hljs-string">&quot;#s-usersetting-top&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 鼠标悬停 (Selenium 需要 ActionChains，这里直接 hover)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 正在悬停鼠标...&quot;</span>)<br>    settings_btn.hover()<br>    <br>    <span class="hljs-comment"># 3. 悬停后，菜单浮现，点击“高级搜索”</span><br>    <span class="hljs-comment"># 注意：Playwright 会自动等待菜单变成可见状态再点击</span><br>    page.get_by_text(<span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 已点击高级搜索&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    browser.close()<br></code></pre></td></tr></table></figure><h4 id="💻-实战-B：拖拽-Drag-and-Drop"><a href="#💻-实战-B：拖拽-Drag-and-Drop" class="headerlink" title="💻 实战 B：拖拽 (Drag and Drop)"></a>💻 实战 B：拖拽 (Drag and Drop)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># page.drag_and_drop(源元素选择器, 目标元素选择器)</span><br>page.drag_and_drop(<span class="hljs-string">&quot;#column-a&quot;</span>, <span class="hljs-string">&quot;#column-b&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-键盘操作-Keyboard"><a href="#2-键盘操作-Keyboard" class="headerlink" title="2. 键盘操作 (Keyboard)"></a>2. 键盘操作 (Keyboard)</h3><p>在 Selenium 中，你需要 Keys 类 (Keys.ENTER, Keys.CONTROL)。Playwright 用字符串来表示按键，更加直观。</p><h4 id="核心方法：press-按键名"><a href="#核心方法：press-按键名" class="headerlink" title="核心方法：press(&quot;按键名&quot;)"></a>核心方法：<code>press(&quot;按键名&quot;)</code></h4><ul><li><strong>单键</strong>：<code>press(&quot;Enter&quot;)</code>, <code>press(&quot;ArrowDown&quot;)</code>, <code>press(&quot;Backspace&quot;)</code></li><li><strong>组合键</strong>：用 <code>+</code> 连接。<ul><li><code>press(&quot;Control+A&quot;)</code> (全选)</li><li><code>press(&quot;Control+C&quot;)</code> (复制)</li><li><code>press(&quot;Shift+ArrowLeft&quot;)</code> (选中左边文字)</li></ul></li></ul><h4 id="💻-实战-C：键盘组合键-Baidu-Search"><a href="#💻-实战-C：键盘组合键-Baidu-Search" class="headerlink" title="💻 实战 C：键盘组合键 (Baidu Search)"></a>💻 实战 C：键盘组合键 (Baidu Search)</h4><p><strong>百度搜索组合键</strong> 案例：输入 -&gt; 全选 -&gt; 剪切 -&gt; 粘贴 -&gt; 回车。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>, slow_mo=<span class="hljs-number">500</span>) <span class="hljs-comment"># 慢放动作</span><br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br>    search_input = page.locator(<span class="hljs-string">&quot;#kw&quot;</span>)<br><br>    <span class="hljs-comment"># 1. 输入内容</span><br>    search_input.fill(<span class="hljs-string">&quot;Playwright&quot;</span>)<br>    <br>    <span class="hljs-comment"># 2. 模拟全选 (Ctrl+A / Mac上是 Meta+A)</span><br>    <span class="hljs-comment"># Playwright 智能之处：它知道你是什么系统，可以用 &quot;Control+A&quot; 通杀</span><br>    <span class="hljs-comment"># 或者显式写 &quot;Meta+A&quot; (Mac Command键)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 全选...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+A&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 模拟剪切 (Ctrl+X)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 剪切...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+X&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 模拟粘贴 (Ctrl+V)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 粘贴...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Control+V&quot;</span>)<br>    <br>    <span class="hljs-comment"># 5. 模拟回车 (Enter) 提交搜索</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 回车搜索...&quot;</span>)<br>    search_input.press(<span class="hljs-string">&quot;Enter&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证是否跳转</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;page.title()&#125;</span>&quot;</span>)<br>    <br>    browser.close()<br></code></pre></td></tr></table></figure><hr><h3 id="3-特殊：逐字输入-模拟人工打字"><a href="#3-特殊：逐字输入-模拟人工打字" class="headerlink" title="3. 特殊：逐字输入 (模拟人工打字)"></a>3. 特殊：逐字输入 (模拟人工打字)</h3><p>自动化测试有时候输入太快，触发不了页面上的联想搜索（Suggest）。</p><p>Playwright 提供了一个神器：press_sequentially (旧版本叫 type)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每个字符间隔 100 毫秒，模拟真人打字</span><br>page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).press_sequentially(<span class="hljs-string">&quot;Selenium&quot;</span>, delay=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这对应 Selenium 里 <strong>联想输入框</strong> 的难点。</p><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="1-标准上传"><a href="#1-标准上传" class="headerlink" title="1. 标准上传"></a>1. 标准上传</h3><p>如果页面上有一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签（哪怕它是隐藏的），可以直接把文件路径“填”进去。</p><ul><li><strong>Selenium</strong>: <code>ele.send_keys(&quot;路径&quot;)</code></li><li><strong>Playwright</strong>: <strong><code>locator.set_input_files(&quot;路径&quot;)</code></strong></li></ul><h4 id="💻-实战代码"><a href="#💻-实战代码" class="headerlink" title="💻 实战代码"></a>💻 实战代码</h4><p><code>the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright, expect<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 准备一个测试文件 (在当前目录下创建 test.txt)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;Hello Playwright Upload!&quot;</span>)<br><br><span class="hljs-comment"># 获取绝对路径 (和 Selenium 笔记里一样，推荐用绝对路径)</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 准备上传文件: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># --- 方法 1: 直接设置文件 (最稳) ---</span><br>    <span class="hljs-comment"># 找到 input 标签，直接塞入文件</span><br>    <span class="hljs-comment"># 注意：不要点击那个 &quot;Choose File&quot; 按钮，直接操作 input</span><br>    page.locator(<span class="hljs-string">&quot;#file-upload&quot;</span>).set_input_files(file_path)<br><br>    <span class="hljs-comment"># 点击上传按钮</span><br>    page.locator(<span class="hljs-string">&quot;#file-submit&quot;</span>).click()<br><br>    <span class="hljs-comment"># 断言结果</span><br>    expect(page.locator(<span class="hljs-string">&quot;#uploaded-files&quot;</span>)).to_have_text(<span class="hljs-string">&quot;test.txt&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 标准上传成功！&quot;</span>)<br><br>    page.wait_for_timeout(<span class="hljs-number">2000</span>)<br>    browser.close()<br><br><span class="hljs-comment"># 清理测试文件</span><br>os.remove(<span class="hljs-string">&quot;test.txt&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-高级上传-拦截文件选择器"><a href="#2-高级上传-拦截文件选择器" class="headerlink" title="2. 高级上传 (拦截文件选择器)"></a>2. 高级上传 (拦截文件选择器)</h3><p>这是 Playwright 的<strong>杀手锏</strong>。在 Selenium 中，如果必须点击按钮才能上传（比如 input 标签被复杂的 JS 逻辑移除了），你会遇到系统弹窗，Selenium 就束手无策了。Playwright 的逻辑：它不管系统弹窗（它是“无头”的思维），它拦截的是**“浏览器请求选择文件”**这个事件。</p><p><strong>步骤：</strong></p><ol><li>设置监听器：<code>expect_file_chooser()</code> (这就好比刚才学的监听弹窗 <code>expect_popup</code>)。</li><li>点击按钮：触发事件。</li><li>在拦截到的“选择器对象”中设置文件。</li></ol><h4 id="💻-实战演示-即使是标准按钮也能用这招"><a href="#💻-实战演示-即使是标准按钮也能用这招" class="headerlink" title="💻 实战演示 (即使是标准按钮也能用这招)"></a>💻 实战演示 (即使是标准按钮也能用这招)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面代码一样 ...</span><br><br><span class="hljs-comment"># --- 方法 2: 点击按钮触发上传 (Selenium 做不到，Playwright 能做) ---</span><br><br><span class="hljs-comment"># 1. 设置监听器 (当文件选择器弹出时...)</span><br><span class="hljs-keyword">with</span> page.expect_file_chooser() <span class="hljs-keyword">as</span> fc_info:<br>    <span class="hljs-comment"># 2. 点击那个会触发弹窗的按钮 (甚至是普通的 div 或 span)</span><br>    page.locator(<span class="hljs-string">&quot;#drag-drop-upload&quot;</span>).click() <span class="hljs-comment"># 这里假设有个点击上传区域</span><br><br><span class="hljs-comment"># 3. 拿到拦截到的选择器</span><br>file_chooser = fc_info.value<br><br><span class="hljs-comment"># 4. 设置文件</span><br>file_chooser.set_files(file_path)<br><br><span class="hljs-comment"># ... 后面一样 ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th><strong>场景</strong></th><th>**Selenium **</th><th><strong>Playwright</strong></th></tr></thead><tbody><tr><td><strong>标准 Input</strong></td><td><code>send_keys(&quot;path&quot;)</code></td><td><code>locator.set_input_files(&quot;path&quot;)</code></td></tr><tr><td><strong>清除文件</strong></td><td><code>clear</code></td><td><code>locator.set_input_files([])</code> (传空列表)</td></tr><tr><td><strong>多文件上传</strong></td><td><code>send_keys(&quot;a.txt \n b.txt&quot;)</code> (看浏览器)</td><td><code>set_input_files([&quot;a.txt&quot;, &quot;b.txt&quot;])</code> (原生支持列表)</td></tr><tr><td><strong>非标准&#x2F;必须点击</strong></td><td><strong>PyAutoGUI &#x2F; AutoIt</strong></td><td><strong><code>expect_file_chooser()</code></strong> (原生支持，无需外挂)</td></tr></tbody></table><hr><h1 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h1><p><strong>页面（Page）与测试（Test）分离</strong>。</p><hr><h3 id="1-核心区别：BasePage-还需要吗？"><a href="#1-核心区别：BasePage-还需要吗？" class="headerlink" title="1. 核心区别：BasePage 还需要吗？"></a>1. 核心区别：BasePage 还需要吗？</h3><p>在Selenium 笔记中，<code>BasePage</code> 非常重要，因为你需要封装 <code>find_element</code> 来实现显式等待，防止报错。</p><p>但在 Playwright 中：由于它自带自动等待（Auto-wait），不需要再封装一个复杂的 find() 方法去写 WebDriverWait。</p><ul><li><strong>Selenium BasePage</strong>: 必须有。用来“保命”（防报错）。</li><li><strong>Playwright BasePage</strong>: 可选。主要用来存放公共业务逻辑（比如“回到首页”、“截图”、“处理通用弹窗”），而不是为了封装底层 API。</li></ul><hr><h3 id="2-项目结构搭建"><a href="#2-项目结构搭建" class="headerlink" title="2. 项目结构搭建"></a>2. 项目结构搭建</h3><p>按照标准的 Python 工程结构来建立文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Playwright_PO/<br>├── pages/              # 【菜单】存放页面对象<br>│   ├── base_page.py    # 父类 (通用方法)<br>│   └── login_page.py   # 登录页<br>├── tests/              # 【顾客】存放测试用例<br>│   └── test_login.py   <br>├── conftest.py         # 【厨房管家】Pytest 的配置文件 (核心！)<br>└── main.py             # 运行入口<br></code></pre></td></tr></table></figure><hr><h3 id="3-第一步：编写-BasePage-父类"><a href="#3-第一步：编写-BasePage-父类" class="headerlink" title="3. 第一步：编写 BasePage (父类)"></a>3. 第一步：编写 BasePage (父类)</h3><p>虽然 Playwright 不需要封装等待，但为了代码规范，还是写一个轻量级的父类。</p><p>新建 <code>pages/base_page.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page: Page</span>):<br>        <span class="hljs-variable language_">self</span>.page = page<br><br>    <span class="hljs-comment"># 封装一个通用的打开网址方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-variable language_">self</span>.page.goto(url)<br><br>    <span class="hljs-comment"># 封装通用的获取标题</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_title</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.page.title()<br>        <br>    <span class="hljs-comment"># 如果有通用的弹窗处理、Cookie保存，都可以写在这里</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-第二步：编写-LoginPage-页面层"><a href="#4-第二步：编写-LoginPage-页面层" class="headerlink" title="4. 第二步：编写 LoginPage (页面层)"></a>4. 第二步：编写 LoginPage (页面层)</h3><p>注意变化： 在 <strong>init</strong> 里直接定义好 Locator，动作方法里直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pages.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 定义 Locator (写在构造函数里，清晰明了) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br>        <span class="hljs-variable language_">self</span>.url = <span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span><br>        <span class="hljs-comment"># 这里的 locator 只是定义，不会立即查找，所以不用担心页面没加载</span><br>        <span class="hljs-variable language_">self</span>.username_input = page.locator(<span class="hljs-string">&quot;#user-name&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.password_input = page.locator(<span class="hljs-string">&quot;#password&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.login_btn = page.locator(<span class="hljs-string">&quot;#login-button&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.error_msg = page.locator(<span class="hljs-string">&quot;[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 定义动作 (Action) ---</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">navigate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username, password</span>):<br>        <span class="hljs-comment"># Playwright 的 fill 和 click 自带等待，直接写逻辑，极其干净</span><br>        <span class="hljs-variable language_">self</span>.username_input.fill(username)<br>        <span class="hljs-variable language_">self</span>.password_input.fill(password)<br>        <span class="hljs-variable language_">self</span>.login_btn.click()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_text</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.error_msg.inner_text()<br></code></pre></td></tr></table></figure><hr><h3 id="5-第三步：编写测试用例-结合-Pytest"><a href="#5-第三步：编写测试用例-结合-Pytest" class="headerlink" title="5. 第三步：编写测试用例 (结合 Pytest)"></a>5. 第三步：编写测试用例 (结合 Pytest)</h3><p>这里是 Playwright 最舒服的地方。使用 pytest-playwright 插件。不需要手动创建 browser 和 page，Pytest 会自动生成一个 page 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Page, expect<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># Pytest 会自动把 page 夹具注入进来，不需要我们自己 launch browser</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">page: Page</span>):<br>    <span class="hljs-comment"># 1. 实例化页面对象</span><br>    login_page = LoginPage(page)<br>    <br>    <span class="hljs-comment"># 2. 调用页面方法 (业务逻辑)</span><br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3. 断言 (Test层负责断言，Page层不要有 expect)</span><br>    expect(page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_failed</span>(<span class="hljs-params">page: Page</span>):<br>    login_page = LoginPage(page)<br>    <br>    login_page.navigate()<br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_pwd&quot;</span>)<br>    <br>    <span class="hljs-comment"># 验证错误提示</span><br>    error_text = login_page.get_error_text()<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text<br></code></pre></td></tr></table></figure><hr><h3 id="6-进阶优化：使用-conftest-py-管理对象"><a href="#6-进阶优化：使用-conftest-py-管理对象" class="headerlink" title="6. 进阶优化：使用 conftest.py 管理对象"></a>6. 进阶优化：使用 <code>conftest.py</code> 管理对象</h3><p>上面的测试代码里，每个用例都要写一句 login_page &#x3D; LoginPage(page)，有点啰嗦。可以用 Pytest 的 fixture 把页面对象的初始化也提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 定义一个 fixture，名字就叫 login</span><br><span class="hljs-comment"># 只要测试用例参数里写了 login，就会自动执行这个函数</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">page</span>):<br>    <span class="hljs-keyword">return</span> LoginPage(page)<br></code></pre></td></tr></table></figure><p><strong>优化后的测试用例 (<code>tests/test_login.py</code>)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> expect<br><br><span class="hljs-comment"># 注意参数变成了 login (对应上面的 fixture)，page 都不用传了</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_success</span>(<span class="hljs-params">login</span>): <br>    <span class="hljs-comment"># login 已经是实例化好的 LoginPage 对象了</span><br>    login.navigate()<br>    login.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 这里的 login.page 是我们在 BasePage 里存的 self.page</span><br>    expect(login.page).to_have_url(<span class="hljs-string">&quot;https://www.saucedemo.com/inventory.html&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="7-怎么运行？"><a href="#7-怎么运行？" class="headerlink" title="7. 怎么运行？"></a>7. 怎么运行？</h3><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行所有测试</span><br>pytest<br><br><span class="hljs-comment"># 运行特定文件并显示浏览器 (headed) 和慢放 (slowmo)</span><br>pytest tests/test_login.py --headed --slowmo 1000<br></code></pre></td></tr></table></figure><hr><h3 id="总结：Selenium-PO-vs-Playwright-PO"><a href="#总结：Selenium-PO-vs-Playwright-PO" class="headerlink" title="总结：Selenium PO vs Playwright PO"></a>总结：Selenium PO vs Playwright PO</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Selenium PO</strong></th><th><strong>Playwright PO</strong></th></tr></thead><tbody><tr><td><strong>BasePage</strong></td><td><strong>必须且厚重</strong> (封装 WebDriverWait)</td><td><strong>可选且轻量</strong> (仅存公共逻辑)</td></tr><tr><td><strong>Locator 定义</strong></td><td><code>(By.ID, &quot;val&quot;)</code> 元组</td><td><code>page.locator(&quot;#val&quot;)</code> 对象</td></tr><tr><td><strong>操作方法</strong></td><td><code>find(*loc).click()</code></td><td><code>self.btn.click()</code></td></tr><tr><td><strong>Driver 传递</strong></td><td>手动初始化 Driver 并传递</td><td>Pytest <code>page</code> fixture 自动注入</td></tr><tr><td><strong>代码量</strong></td><td>多，容易出错</td><td>少，逻辑清晰</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Web自动化测试</tag>
      
      <tag>playwright</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium学习</title>
    <link href="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Selenium特点"><a href="#Selenium特点" class="headerlink" title="Selenium特点"></a>Selenium特点</h1><ul><li><strong>跨浏览器支持</strong>：Selenium 支持多种主流浏览器，如 Chrome、Firefox、Safari、Internet Explorer 等，可以在不同浏览器中执行相同的测试脚本。</li><li><strong>多语言支持</strong>：Selenium 支持多种编程语言，开发者可以用自己熟悉的语言来编写测试脚本。</li><li><strong>灵活性</strong>：Selenium 可以与各种测试框架结合使用，如 TestNG、JUnit、PyTest 等，提供了丰富的测试功能。</li><li><strong>与 CI&#x2F;CD 集成</strong>：Selenium 可以与 Jenkins 等持续集成工具集成，帮助实现自动化测试和持续交付。</li><li><strong>自动化Web交互</strong>：Selenium 可以模拟真实用户的操作，如点击、滚动、键盘输入等</li></ul><hr><h1 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h1><p>Selenium WebDriver 是 Selenium 的核心组件，它提供了与浏览器交互的 API，允许开发者通过编程语言控制浏览器并执行各种操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所需模块</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br><span class="hljs-comment"># 使用 get() 方法打开指定的 URL</span><br>driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>)<br><br><span class="hljs-comment"># 最大化窗口</span><br>driver.maximize_window()<br><br><span class="hljs-comment"># 获取页面标题和 URL</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;页面标题:&quot;</span>, driver.title)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前 URL:&quot;</span>, driver.current_url)<br><br><span class="hljs-comment"># 导航到另一个页面</span><br>driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>)<br><br><span class="hljs-comment"># 返回上一个页面</span><br>driver.back()<br><br><span class="hljs-comment"># 刷新页面</span><br>driver.refresh()<br><br><span class="hljs-comment"># 关闭浏览器</span><br>driver.quit()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openqa.selenium.WebDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeleniumExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置 ChromeDriver 路径（方式1：通过系统属性）</span><br>        System.setProperty(<span class="hljs-string">&quot;webdriver.chrome.driver&quot;</span>, <span class="hljs-string">&quot;./chromedriver-mac-arm64/chromedriver&quot;</span>);<br>        <br>        <span class="hljs-comment">// 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>        <span class="hljs-type">ChromeOptions</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeOptions</span>();<br>        <br>        <span class="hljs-comment">// 创建 ChromeDriver 对象，启动 Chrome 浏览器</span><br>        <span class="hljs-type">WebDriver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeDriver</span>(options);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用 get() 方法打开指定的 URL</span><br>            driver.get(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 最大化窗口</span><br>            driver.manage().window().maximize();<br>            <br>            <span class="hljs-comment">// 获取页面标题和 URL</span><br>            System.out.println(<span class="hljs-string">&quot;页面标题: &quot;</span> + driver.getTitle());<br>            System.out.println(<span class="hljs-string">&quot;当前 URL: &quot;</span> + driver.getCurrentUrl());<br>            <br>            <span class="hljs-comment">// 导航到另一个页面</span><br>            driver.get(<span class="hljs-string">&quot;https://www.jyshare.com&quot;</span>);<br>            <br>            <span class="hljs-comment">// 返回上一个页面</span><br>            driver.navigate().back();<br>            <br>            <span class="hljs-comment">// 刷新页面</span><br>            driver.navigate().refresh();<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭浏览器</span><br>            driver.quit();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><h2 id="1-ID定位"><a href="#1-ID定位" class="headerlink" title="1.ID定位"></a>1.ID定位</h2><p>id是标签的唯一属性,可以通过id属性来唯一定位一个元素(唯一且最快，如果有ID先用ID)</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image1.png" class="" title="ID定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.ID,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.id(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="2-name定位"><a href="#2-name定位" class="headerlink" title="2.name定位"></a>2.name定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image2.png" class="" title="name定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.Name,<span class="hljs-string">&quot; &quot;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.name(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="3-ClassName定位"><a href="#3-ClassName定位" class="headerlink" title="3.ClassName定位"></a>3.ClassName定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image3.png" class="" title="ClassName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.CLASS_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.className(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><p>坑：如果 HTML 是 <code>button class=&quot;btn btn-primary&quot;</code>，你不能直接写 “btn btn-primary”。因为中间有空格，Selenium 会认为这是两个类名，会报错。所以只取其中一个唯一的类名，或者改用 CSS Selector。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ❌ 错误写法</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn btn-primary&quot;</span>)<br><br><span class="hljs-comment"># ✅ 正确写法 (只取其中一段)</span><br>driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;btn-primary&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-tagName定位"><a href="#4-tagName定位" class="headerlink" title="4.tagName定位"></a>4.<strong>tagName</strong>定位</h2><p>备胎。容易重复，不推荐作为首选</p><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image4.png" class="" title="tagName定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.TAG_NAME,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.tagName(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="5-cssSelector定位"><a href="#5-cssSelector定位" class="headerlink" title="5.cssSelector定位"></a>5.<strong>cssSelector</strong>定位</h2><p>语法简洁，渲染速度比 XPath 快，适合没有 ID 但有特定属性的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.CSS_SELECTOR,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.cssSelector(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）id选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#kw&quot;</span>)<br><br><span class="hljs-comment"># 2）类选择器定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;.s_ipt&quot;</span>)<br><br><span class="hljs-comment"># 3）标签选择器</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;input&quot;</span>)  <span class="hljs-comment"># 查找第一个`input`标签</span><br></code></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1）单个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 2）多个属性定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;[rows=&#x27;1&#x27;][autocomplete=&#x27;off&#x27;][id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 3）标签名+属性选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea[id=&#x27;chat-textarea&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 4）通过标签名+ID选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea#chat-textarea&quot;</span>)<br><br><span class="hljs-comment"># 5）通过标签名+类选择器组合定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;textarea.chat-input-textarea&quot;</span>)<br><br><span class="hljs-comment"># 6）通过标签层级定位</span><br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;form&gt;span&gt;input&quot;</span>)<br>driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;div&gt;div:nth-child(2)&gt;div:nth-child(2)&gt;a:nth-child(3)&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-link-text定位"><a href="#6-link-text定位" class="headerlink" title="6.link_text定位"></a>6.<strong>link_text</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image5.png" class="" title="link_text定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.linkText(<span class="hljs-string">&quot;地图&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="7-partialLinkText定位"><a href="#7-partialLinkText定位" class="headerlink" title="7.partialLinkText定位"></a>7.<strong>partialLinkText</strong>定位</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image6.png" class="" title="partialLinkText定位"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element( By.PARTIAL_LINK_TEXT,<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">driver.findElement(By.partialLinkText(<span class="hljs-string">&quot;更&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="8-Xpath定位"><a href="#8-Xpath定位" class="headerlink" title="8.Xpath定位"></a>8.Xpath定位</h2><p><strong>功能最强（能通过文本定位、能找父节点），但速度稍慢，语法啰嗦</strong>。但Xpath是万能的</p><h3 id="绝对路径定位"><a href="#绝对路径定位" class="headerlink" title="绝对路径定位"></a>绝对路径定位</h3><p><strong>特点：</strong> 从 HTML 根节点一层层往下找，极其脆弱。前端稍微加个 <code>div</code> 你的代码就挂了。 <strong>语法：</strong> 单斜杠 <code>/</code> 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非常不建议用</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;/html/body/div[1]/div[2]/div/div[1]/input&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="相对路径定位"><a href="#相对路径定位" class="headerlink" title="相对路径定位"></a>相对路径定位</h3><p><strong>特点：</strong> 忽略层级，在整个页面中查找。 <strong>语法：</strong> 双斜杠 <code>//</code> 开头 + 标签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在整个页面找 input 标签（如果有很多 input，默认返回第一个）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input&quot;</span>) <br><br><span class="hljs-comment"># 找页面所有的 div 下面的 form 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div//form&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="元素属性定位"><a href="#元素属性定位" class="headerlink" title="元素属性定位"></a>元素属性定位</h3><p><strong>特点：</strong> 结合 <code>@属性名</code> 精准定位。 <strong>语法：</strong> <code>//标签名[@属性=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过 id 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 name 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 通过 class 属性定位</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 结合标签层级：找到 form 标签下的 input 标签，且该 input 有 id=&#x27;kw&#x27;</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//form//input[@id=&#x27;kw&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="逻辑运算符定位"><a href="#逻辑运算符定位" class="headerlink" title="逻辑运算符定位"></a>逻辑运算符定位</h3><p><strong>特点：</strong> 当一个属性无法唯一定位时，用 <code>and</code> 或 <code>or</code> 组合多个属性。 <strong>语法：</strong> <code>[@属性1=&#39;值&#39; and @属性2=&#39;值&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同时满足 name=&#x27;wd&#x27; 且 class=&#x27;s_ipt&#x27; 的 input 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;wd&#x27; and @class=&#x27;s_ipt&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 只要满足 id=&#x27;kw&#x27; 或者 name=&#x27;wd&#x27; 任意一个即可</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@id=&#x27;kw&#x27; or @name=&#x27;wd&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="文本内容定位"><a href="#文本内容定位" class="headerlink" title="文本内容定位"></a>文本内容定位</h3><p><strong>特点：</strong> 很多链接或按钮没有 ID，只有文字。 <strong>语法：</strong> <code>text()=&#39;完整文字&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定位文本完全等于 &quot;新闻&quot; 的 a 标签</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[text()=&#x27;新闻&#x27;]&quot;</span>) <br><br><span class="hljs-comment"># 定位文本完全等于 &quot;登录&quot; 的 button 按钮</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;登录&#x27;]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="部分文本-属性定位-模糊匹配"><a href="#部分文本-属性定位-模糊匹配" class="headerlink" title="部分文本&#x2F;属性定位-模糊匹配"></a>部分文本&#x2F;属性定位-模糊匹配</h3><p><strong>特点：</strong> 处理动态变化的元素（例如：<code>id=&quot;user_123&quot;</code>, <code>id=&quot;user_456&quot;</code>）或长文本。 <strong>语法：</strong> <code>contains(@属性或text(), &#39;部分值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文本包含 &quot;百度&quot; 的所有链接（能匹配 &quot;百度一下&quot;、&quot;关于百度&quot; 等）</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//a[contains(text(), &#x27;百度&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># id 属性中包含 &quot;user_name&quot; 的 input (能匹配 id=&quot;my_user_name_input&quot;)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[contains(@id, &#x27;user_name&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用函数定位"><a href="#使用函数定位" class="headerlink" title="使用函数定位"></a>使用函数定位</h3><p><strong>特点：</strong> 匹配以特定字符开头的内容。 <strong>语法：</strong> <code>starts-with(@属性, &#39;开头值&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配 id 以 &quot;ctrl_7&quot; 开头的 input 元素 (常用于 ExtJS 等自动生成 ID 的框架)</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[starts-with(@id, &#x27;ctrl_7&#x27;)]&quot;</span>) <br><br><span class="hljs-comment"># 匹配文本以 &quot;欢迎&quot; 开头的 div</span><br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[starts-with(text(), &#x27;欢迎&#x27;)]&quot;</span>)<br></code></pre></td></tr></table></figure><p>问：遇到一个非常难定位的元素，你会怎么写 XPath？</p><p>如果是静态属性，我优先用 <strong>属性定位</strong> (&#x2F;&#x2F;tag[@id&#x3D;’…’])；如果是链接或按钮，我会用 <strong>文本定位</strong> (&#x2F;&#x2F;a[text()&#x3D;’…’])；如果是动态 ID 或复杂场景，我会用 <strong>contains 模糊匹配</strong> (&#x2F;&#x2F;div[contains(@class, ‘…’)])，或者结合 <strong>父子层级关系</strong> 来写</p><h2 id="基础定位练习-SauceDemo"><a href="#基础定位练习-SauceDemo" class="headerlink" title="基础定位练习-SauceDemo"></a>基础定位练习-<strong>SauceDemo</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service <span class="hljs-keyword">as</span> ChromeService<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><br><span class="hljs-comment"># 创建 ChromeService 对象，指定 ChromeDriver 的路径。</span><br>service = ChromeService(executable_path=<span class="hljs-string">&quot;D:\\develop\\chromedriver-win64\\chromedriver.exe&quot;</span>)<br><span class="hljs-comment"># 创建 ChromeOptions 对象，用于配置浏览器的启动选项</span><br>options = webdriver.ChromeOptions()<br><span class="hljs-comment"># 使用 webdriver.Chrome() 启动 Chrome 浏览器，并传入 service 和 options 参数</span><br>driver = webdriver.Chrome(service=service, options=options)<br><br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>driver.maximize_window()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>user_input = driver.find_element(By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>user_input.send_keys(<span class="hljs-string">&quot;standard_user&quot;</span>)<br>password_input = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;password&#x27;]&quot;</span>)<br>password_input.send_keys(<span class="hljs-string">&quot;secret_sauce&quot;</span>)<br><br><span class="hljs-comment"># login_btn = driver.find_element(By.CSS_SELECTOR, &quot;input.btn_action&quot;)</span><br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;#login-button&quot;</span>)<br>login_btn.click()<br><br><span class="hljs-comment"># 断言是否登录成功</span><br><span class="hljs-comment"># time.sleep(2)</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url<br><span class="hljs-comment"># 判断Swag Labs是否预期</span><br>page_title = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//div[@class=&#x27;app_logo&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> page_title == <span class="hljs-string">&quot;Swag Labs&quot;</span><br><br><span class="hljs-comment"># time.sleep(1)</span><br><br><span class="hljs-comment"># add_to_cart_btn = driver.find_element(By.XPATH, &quot;//button[text()=&#x27;Add to cart&#x27;]&quot;)</span><br>add_to_cart_btn = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[contains(text(),&#x27;Add to cart&#x27;)]&quot;</span>)<br>add_to_cart_btn.click()<br><br><span class="hljs-comment"># time.sleep(1)</span><br><span class="hljs-comment"># 验证购物车图标上的数量是否为1</span><br>cart_badge = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//span[@class=&#x27;shopping_cart_badge&#x27;]&quot;</span>).text<br><span class="hljs-keyword">assert</span> cart_badge == <span class="hljs-string">&quot;1&quot;</span><br><br><span class="hljs-comment"># driver.close()</span><br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素定位不到"><a href="#元素定位不到" class="headerlink" title="元素定位不到"></a>元素定位不到</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image7.png" class="" title="元素定位不到"><hr><h1 id="WebDriver常用方法"><a href="#WebDriver常用方法" class="headerlink" title="WebDriver常用方法"></a>WebDriver常用方法</h1><h2 id="导航方法"><a href="#导航方法" class="headerlink" title="导航方法"></a>导航方法</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image8.png" class="" title="导航方法"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 加上隐式等待</span><br><br><span class="hljs-comment"># --- 动作 1: 打开第一个网页 (百度) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 正在打开百度...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 强制等待是为了看清效果 实际最好别用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前URL: <span class="hljs-subst">&#123;driver.current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 2: 打开第二个网页 (B站) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 正在跳转到 Bilibili...&quot;</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 3: 后退 (Back) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 执行后退操作 (回到百度)...&quot;</span>)<br>driver.back()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 验证一下是不是回到了百度</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 后退成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 4: 前进 (Forward) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n4. 执行前进操作 (回到 Bilibili)...&quot;</span>)<br>driver.forward()<br>time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;哔哩哔哩&quot;</span> <span class="hljs-keyword">in</span> driver.title:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 前进成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 动作 5: 刷新 (Refresh) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n5. 执行刷新当前页面...&quot;</span>)<br>driver.refresh()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 页面刷新完毕&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image9.png" class="" title="元素操作"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br><span class="hljs-comment"># 1. 启动浏览器</span><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>) <span class="hljs-comment"># 全局隐式等待</span><br><br><span class="hljs-comment"># 2. 打开练习靶场</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/login&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在打开: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>driver.get(url)<br><br><span class="hljs-comment"># --- 定位元素 ---</span><br>username_input = driver.find_element(By.ID, <span class="hljs-string">&quot;username&quot;</span>)<br>password_input = driver.find_element(By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>login_btn = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&quot;button.radius&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 1: 状态判断 (is_displayed) ---</span><br><span class="hljs-keyword">if</span> username_input.is_displayed():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用户名输入框可见，准备操作...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找不到输入框！&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 2: 输入与清空 (send_keys + clear) ---</span><br><span class="hljs-comment"># 模拟手误：输入了错误的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;wrong_user_123&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到输入了错误的内容</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入错误用户名&quot;</span>)<br><br><span class="hljs-comment"># 发现错了，清空！</span><br>username_input.clear()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停一下让你看到清空的效果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已清空输入框&quot;</span>)<br><br><span class="hljs-comment"># 输入正确的用户名</span><br>username_input.send_keys(<span class="hljs-string">&quot;tomsmith&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入正确用户名: tomsmith&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 3: 获取属性 (get_attribute) —— 安全测试常用 ---</span><br><br><span class="hljs-comment"># 面试题：你怎么验证密码框里的密码是掩码显示的（即显示为圆点或星号）？</span><br><span class="hljs-comment"># 答案：获取它的 type 属性，看是不是等于 &quot;password&quot;</span><br><span class="hljs-comment"># type_attr = password_input.get_attribute(&quot;type&quot;)</span><br>type_attr = password_input.get_dom_attribute(<span class="hljs-string">&quot;type&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;密码框的 type 属性是: <span class="hljs-subst">&#123;type_attr&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> type_attr == <span class="hljs-string">&quot;password&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 安全检查通过：密码框是加密显示的&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 安全漏洞：密码框是明文显示的！&quot;</span>)<br><br><span class="hljs-comment"># 输入密码</span><br>password_input.send_keys(<span class="hljs-string">&quot;SuperSecretPassword!&quot;</span>)<br><br><span class="hljs-comment"># --- 演示 4: 点击登录 (click) ---</span><br>login_btn.click()<br><br><span class="hljs-comment"># --- 验证结果 ---</span><br><span class="hljs-comment"># 登录成功后，页面会出现一个绿色的提示条</span><br>success_msg = driver.find_element(By.ID, <span class="hljs-string">&quot;flash&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面提示信息: <span class="hljs-subst">&#123;success_msg&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 断言：验证提示信息里包含 &#x27;You logged into a secure area&#x27;</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;You logged into a secure area&quot;</span> <span class="hljs-keyword">in</span> success_msg<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🎉 测试通过！成功登录。&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的URL</span><br>current_url = driver.current_url<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面URL: <span class="hljs-subst">&#123;current_url&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的标题</span><br>current_title = driver.title<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面标题: <span class="hljs-subst">&#123;current_title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前页面的HTML源代码</span><br>page_source = driver.page_source<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前页面HTML源代码长度: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(page_source)&#125;</span> 字符&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><ul><li><strong>get_dom_attribute(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>HTML 源代码里写死的属性</strong>。</li><li><strong>场景</strong>：获取 id、name、type、href、class。</li><li><strong>例子</strong>：<code>input value=&quot;123&quot;</code> -&gt; 永远返回 “123”。</li></ul></li><li><strong>get_property(name)</strong>：<ul><li><strong>用途</strong>：获取 <strong>浏览器运行时产生的属性</strong>（即用户操作后的状态）。</li><li><strong>场景</strong>：获取用户<strong>输入框里敲进去的字</strong> (value)、复选框是否被勾选 (checked)。</li><li><strong>例子</strong>：<code>input value=&quot;123&quot;</code>，用户删掉 123 输入了 abc -&gt; get_property(‘value’) 返回 “abc”。</li></ul></li></ul><h2 id="窗口和标签页操作"><a href="#窗口和标签页操作" class="headerlink" title="窗口和标签页操作"></a>窗口和标签页操作</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image10.png" class="" title="窗口和标签页操作"><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>把句柄想象成<strong>窗口的身份证号</strong>。</p><ul><li>每个标签页（Tab）或窗口都有一个唯一的字符串 ID。</li><li>Selenium 通过这个 ID 来决定控制哪个窗口。</li></ul><p><strong>核心方法 ：</strong></p><ol><li>driver.current_window_handle: 获取<strong>当前</strong>窗口的句柄。</li><li>driver.window_handles: 获取浏览器里<strong>所有</strong>窗口的句柄（返回一个列表 List）。</li><li>driver.switch_to.window(handle): 切换到指定句柄的窗口。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开主页面</span><br>url = <span class="hljs-string">&quot;https://the-internet.herokuapp.com/windows&quot;</span><br>driver.get(url)<br><br><span class="hljs-comment"># 获取当前主窗口的句柄 (相当于记下：这是&quot;老家&quot;)</span><br>original_window = driver.current_window_handle<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口句柄: <span class="hljs-subst">&#123;original_window&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主窗口标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 点击链接，打开新窗口</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;Click Here&quot;</span>).click()<br><br><span class="hljs-comment"># --- 关键时刻：切换窗口 ---</span><br><br><span class="hljs-comment"># 此时虽然新窗口弹出来了，但 driver 还在老窗口</span><br><span class="hljs-comment"># 我们获取所有窗口的句柄列表</span><br>all_handles = driver.window_handles<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前所有句柄: <span class="hljs-subst">&#123;all_handles&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 遍历列表，找到那个“不是老家”的句柄，就是新窗口</span><br><span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> all_handles:<br>    <span class="hljs-keyword">if</span> handle != original_window:<br>        <span class="hljs-comment"># 找到了新窗口，切换过去！</span><br>        driver.switch_to.window(handle)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🔀 已切换到新窗口！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># --- 3. 在新窗口操作 ---</span><br><span class="hljs-comment"># 只有切换成功了，这行代码才能找到元素，否则会报错</span><br>new_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;新窗口里的文字是: <span class="hljs-subst">&#123;new_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> new_text == <span class="hljs-string">&quot;New Window&quot;</span><br><br><span class="hljs-comment"># --- 4. 关闭新窗口，切回主窗口 ---</span><br><span class="hljs-comment"># close() 只关闭当前标签页</span><br>driver.close() <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已关闭新窗口&quot;</span>)<br><br><span class="hljs-comment"># ⚠️ 注意：关掉新窗口后，driver 此时处于“失重”状态，谁也没控制</span><br><span class="hljs-comment"># 必须立刻切回主窗口，否则后续操作会报错</span><br>driver.switch_to.window(original_window)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔀 已切回主窗口: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 验证一下是不是真的回来了</span><br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;The Internet&quot;</span> <span class="hljs-keyword">in</span> driver.title<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><h4 id="1-什么是-Iframe？"><a href="#1-什么是-Iframe？" class="headerlink" title="1. 什么是 Iframe？"></a>1. 什么是 Iframe？</h4><p>简单来说，就是<strong>网页里套网页</strong>。<br>想象一下，走进一个大房子（主页面），墙上挂着一台电视机（Iframe）。电视机里在播放另一个画面。</p><ul><li>Selenium 默认只能操作“大房子”里的东西。</li><li>如果你想操作“电视机”里的菜单，你必须先<strong>把遥控器对准电视机</strong>（切换进去）。</li><li>操作完后，必须<strong>把视线移回大房子</strong>（切换出来），否则找不到房子里的其他家具。</li></ul><p><strong>症状</strong>：<br>在开发者工具（F12）里明明能看到这个元素，XPath 写得也对，但代码运行就是报 NoSuchElementException。这时候，<strong>99% 是因为元素在 Iframe 里</strong>。</p><hr><h4 id="2-怎么识别-Iframe？"><a href="#2-怎么识别-Iframe？" class="headerlink" title="2. 怎么识别 Iframe？"></a>2. 怎么识别 Iframe？</h4><p>在 F12 开发者工具里，如果你看到元素的父级标签有 <code>iframe</code> 或 <code>frame</code>，那就是它了。</p><hr><h4 id="3-核心操作方法"><a href="#3-核心操作方法" class="headerlink" title="3. 核心操作方法"></a>3. 核心操作方法</h4><h5 id="A-切换进去-switch-to-frame"><a href="#A-切换进去-switch-to-frame" class="headerlink" title="A. 切换进去 (switch_to.frame)"></a>A. 切换进去 (switch_to.frame)</h5><p>有 3 种方式可以切换进去：</p><ol><li><p><strong>通过 ID 或 Name (最简单)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.switch_to.frame(<span class="hljs-string">&quot;iframe_id&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;iframe_name&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过 WebElement 对象 (最稳，推荐)</strong>：<br>如果 Iframe 没有 ID，或者 ID 是动态的。你可以先用 find_element 找到这个 iframe 标签，再切进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">iframe_element = driver.find_element(By.XPATH, <span class="hljs-string">&quot;//iframe[@class=&#x27;...&#x27;]&quot;</span>)<br>driver.switch_to.frame(iframe_element)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过索引 (Index)</strong>：<br>driver.switch_to.frame(0) (切到第1个 iframe)。<em>不推荐，因为页面变动容易挂。</em></p></li></ol><h4 id="B-切换出来-switch-to-default-content"><a href="#B-切换出来-switch-to-default-content" class="headerlink" title="B. 切换出来 (switch_to.default_content)"></a>B. 切换出来 (switch_to.default_content)</h4><p>操作完 Iframe 里的东西，<strong>一定要切回来！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回到最外层的主页面</span><br>driver.switch_to.default_content()<br><span class="hljs-comment"># (选学) 如果是嵌套 Iframe (A套B，B套C)，想从 C 回到 B：</span><br>driver.switch_to.parent_frame()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 1. 打开页面</span><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/iframe&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换进 Iframe ---</span><br><span class="hljs-comment"># 这里的 iframe 有个 id 叫 &#x27;mce_0_ifr&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在切换进 Iframe...&quot;</span>)<br>driver.switch_to.frame(<span class="hljs-string">&quot;mce_0_ifr&quot;</span>)<br><br><span class="hljs-comment"># --- 2. 在 Iframe 内部操作 ---</span><br><span class="hljs-comment"># 注意：切进来后，我们找的是 iframe 里面的 body 标签</span><br>editor_body = driver.find_element(By.ID, <span class="hljs-string">&quot;tinymce&quot;</span>)<br><br><span class="hljs-comment"># 清空原有内容</span><br>editor_body.clear()<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 输入新内容</span><br>editor_body.send_keys(<span class="hljs-string">&quot;你好，我是 Selenium 练习生！&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已在编辑器中输入内容&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：切换回主页面 ---</span><br><span class="hljs-comment"># 如果不写这句，下面找标题会报错，因为标题在 iframe 外面</span><br>driver.switch_to.default_content()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已切回主页面&quot;</span>)<br><br><span class="hljs-comment"># --- 3. 在主页面操作 ---</span><br><span class="hljs-comment"># 获取页面上方的大标题</span><br>h3_text = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;h3&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主页面标题: <span class="hljs-subst">&#123;h3_text&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">assert</span> h3_text == <span class="hljs-string">&quot;An iFrame containing the TinyMCE WYSIWYG Editor&quot;</span><br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><h2 id="浏览器管理与执行JS"><a href="#浏览器管理与执行JS" class="headerlink" title="浏览器管理与执行JS"></a>浏览器管理与执行JS</h2><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image11.png" class="" title="浏览器管理"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image12.png" class="" title="执行JS"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 打开京东</span><br>driver.get(<span class="hljs-string">&quot;https://www.jd.com&quot;</span>)<br><br><span class="hljs-comment"># --- 浏览器管理演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在最大化窗口...&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># --- JS 执行演示：滚动条 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备滚动到底部...&quot;</span>)<br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 停顿一下让你看清</span><br><br><span class="hljs-comment"># 执行 JS 滚动到底部</span><br><span class="hljs-comment"># document.body.scrollHeight 是获取页面总高度</span><br>driver.execute_script(<span class="hljs-string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已滚动到底部，等待图片懒加载...&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等待页面加载更多内容</span><br><br><span class="hljs-comment"># --- 截图演示 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在截图...&quot;</span>)<br><span class="hljs-comment"># 截图会保存在当前代码的目录下</span><br>driver.get_screenshot_as_file(<span class="hljs-string">&quot;jd_bottom.png&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 截图已保存为 jd_bottom.png&quot;</span>)<br><br><span class="hljs-comment"># --- Cookie 演示 ---</span><br>cookies = driver.get_cookies()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前获取到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(cookies)&#125;</span> 个 Cookie&quot;</span>)<br><span class="hljs-comment"># 随便打印第一个看看长什么样</span><br><span class="hljs-keyword">if</span> cookies:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一个 Cookie: <span class="hljs-subst">&#123;cookies[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- JS 进阶：修改页面标题 (好玩的操作) ---</span><br><span class="hljs-comment"># 你甚至可以用 JS 修改网页显示的内容</span><br>driver.execute_script(<span class="hljs-string">&quot;document.title = &#x27;这是我用 Selenium 改的标题！&#x27;;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;修改后的标题: <span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><p><strong>Q1: 自动化测试中，如何处理页面滚动？</strong></p><blockquote><p><strong>答</strong>：Selenium 原生没有滚动方法，我通常使用 execute_script 执行 JavaScript。<br>比如 window.scrollTo(0, document.body.scrollHeight) 滚动到底部，或者使用 arguments[0].scrollIntoView() 滚动到特定元素。</p></blockquote><p><strong>Q2: 遇到一个日期控件，无法直接输入，怎么处理？</strong></p><blockquote><p><strong>答</strong>：通常是因为 input 标签有 readonly 属性。我会先用 JS 移除这个属性 (removeAttribute(‘readonly’))，然后就可以直接用 send_keys 输入日期了，这样比通过 UI 选日历更稳定。</p></blockquote><p><strong>Q3: 自动化测试执行失败了，怎么排查？</strong></p><blockquote><p><strong>答</strong>：我会配置测试框架，在用例失败（Fail）或报错（Error）时，自动调用 driver.get_screenshot_as_file 进行截图，并把截图嵌入到测试报告（如 Allure）中，方便后续分析。</p></blockquote><hr><h1 id="三大等待"><a href="#三大等待" class="headerlink" title="三大等待"></a>三大等待</h1><hr><h3 id="1-强制等待-Forced-Wait-——-time-sleep"><a href="#1-强制等待-Forced-Wait-——-time-sleep" class="headerlink" title="1. 强制等待 (Forced Wait) —— time.sleep()"></a>1. 强制等待 (Forced Wait) —— <code>time.sleep()</code></h3><p>这是 Python 自带的库，不是 Selenium 的功能。</p><ul><li><p><strong>原理</strong>：不管网页加载完没，不管元素出来没，我就死等指定的秒数。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.sleep(<span class="hljs-number">5</span>) <span class="hljs-comment"># 睡 5 秒</span><br></code></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：简单，粗暴，调试（Debug）时最好用。</p></li><li><p><strong>缺点</strong>：</p><ul><li><strong>浪费时间</strong>：网页 1秒加载完，你睡 5秒，浪费 4秒。</li><li><strong>不稳定</strong>：网页 6秒加载完，你睡 5秒，脚本报错。</li></ul></li><li><p><strong>结论</strong>：<strong>写作业、调试可以用，但上线运行的代码里尽量别用。</strong></p></li></ul><hr><h3 id="2-隐式等待-Implicit-Wait-——-driver-implicitly-wait"><a href="#2-隐式等待-Implicit-Wait-——-driver-implicitly-wait" class="headerlink" title="2. 隐式等待 (Implicit Wait) —— driver.implicitly_wait()"></a>2. 隐式等待 (Implicit Wait) —— <code>driver.implicitly_wait()</code></h3><p>这是 Selenium 的全局设置。</p><ul><li><p><strong>原理</strong>：设置一个<strong>最长等待时间</strong>。在找元素（<code>find_element</code>）时，如果元素没立刻出现，Selenium 会不断轮询（每隔 0.5秒看一眼），直到元素出现<strong>或者</strong>超时报错。</p></li><li><p><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只需要在启动浏览器后写一次，全局生效</span><br>driver.implicitly_wait(<span class="hljs-number">10</span>) <br></code></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：写一行代码，管所有元素，省事。</p></li><li><p><strong>缺点 (面试考点)</strong>：</p><ul><li>它只能判断元素<strong>是否在 HTML (DOM) 里</strong>。</li><li><strong>致命伤</strong>：如果元素在 HTML 里了，但是是<strong>不可见</strong>的（比如 loading 遮罩层还没消失），或者<strong>不可点击</strong>的，隐式等待会认为“找到了”，立刻去点，结果报错 <code>ElementNotInteractableException</code>。</li></ul></li><li><p><strong>结论</strong>：<strong>作为保底手段，每个脚本都加上，但不能完全依赖它。</strong></p></li></ul><hr><h3 id="3-显式等待-Explicit-Wait-——-WebDriverWait"><a href="#3-显式等待-Explicit-Wait-——-WebDriverWait" class="headerlink" title="3. 显式等待 (Explicit Wait) —— WebDriverWait"></a>3. 显式等待 (Explicit Wait) —— <code>WebDriverWait</code></h3><p>这是<strong>最智能、最推荐</strong>的等待方式。</p><ul><li><p><strong>原理</strong>：专门等待<strong>某个条件</strong>成立（比如：等这个按钮变成“可点击”状态，或者等这段文字“可见”）。</p></li><li><p><strong>代码结构</strong>：<br>需要引入三个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br></code></pre></td></tr></table></figure></li><li><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># WebDriverWait(driver, 超时时间, 轮询频率).until(等待条件)</span><br>element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.element_to_be_clickable((By.ID, <span class="hljs-string">&quot;login_btn&quot;</span>))<br>)<br>element.click()<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="⚔️-核心实战：常用-EC-Expected-Conditions-条件"><a href="#⚔️-核心实战：常用-EC-Expected-Conditions-条件" class="headerlink" title="⚔️ 核心实战：常用 EC (Expected Conditions) 条件"></a>⚔️ 核心实战：常用 EC (Expected Conditions) 条件</h3><p><code>expected_conditions</code> (简称 EC) 提供了很多判断标准，面试和工作中<strong>最常用</strong>的是这三个：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>presence_of_element_located</code></strong></td><td align="left">元素存在于 HTML 中</td><td align="left">等同于隐式等待，只要代码里有这个标签就行，不管你看没看见。</td></tr><tr><td align="left"><strong><code>visibility_of_element_located</code></strong></td><td align="left"><strong>元素可见</strong></td><td align="left"><strong>最常用！</strong> 元素不仅在 HTML 里，而且长宽大于 0，肉眼能看见。</td></tr><tr><td align="left"><strong><code>element_to_be_clickable</code></strong></td><td align="left"><strong>元素可点击</strong></td><td align="left"><strong>最稳！</strong> 元素可见且可用（没有 disable）。点按钮前必用这个。</td></tr></tbody></table><hr><h3 id="💻-代码实战：显式等待演示"><a href="#💻-代码实战：显式等待演示" class="headerlink" title="💻 代码实战：显式等待演示"></a>💻 代码实战：显式等待演示</h3><p>去<strong>The Internet</strong> 的动态加载页面。<br><strong>场景</strong>：点击 “Start” 按钮，页面会出现一个 loading 条，过 5 秒后才会出现 “Hello World!” 文字。</p><ul><li>如果用隐式等待，可能会因为 loading 条还在就去抓文字，导致失败。</li><li>我们要用显式等待，直到文字<strong>可见</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br><span class="hljs-comment"># 虽然有显式等待，加个隐式等待做保底也是好习惯</span><br>driver.implicitly_wait(<span class="hljs-number">5</span>) <br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dynamic_loading/1&quot;</span>)<br><br><span class="hljs-comment"># 1. 点击 Start 按钮</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;button&quot;</span>).click()<br><br><span class="hljs-comment"># 2. 等待结果</span><br><span class="hljs-comment"># 此时页面上有一个 loading 进度条，&quot;Hello World&quot; 其实已经在 HTML 里了(hidden)，但不可见。</span><br><span class="hljs-comment"># 如果直接 find_element，隐式等待会立刻找到它（因为在 HTML 里），然后去获取 text，</span><br><span class="hljs-comment"># 结果获取到的是空字符串（因为没显示出来），导致断言失败。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待 Hello World 出现...&quot;</span>)<br><br><span class="hljs-comment"># --- 使用显式等待 ---</span><br><span class="hljs-comment"># 意思：最多等 10 秒，直到 ID 为 &#x27;finish&#x27; 的元素变成【可见】状态</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(<br>    EC.visibility_of_element_located((By.ID, <span class="hljs-string">&quot;finish&quot;</span>))<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取到的文字: <span class="hljs-subst">&#123;target_element.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> target_element.text == <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试通过！&quot;</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问</strong>：我既设置了 <code>implicitly_wait(10)</code>，又在代码里写了 <code>WebDriverWait(driver, 10)</code>，会有什么问题？</p><p><strong>答</strong>：</p><blockquote><p><strong>尽量不要混用，或者要非常小心。</strong><br>因为 Selenium 的机制原因，当两者混用时，超时时间可能会出现<strong>不可预测的叠加</strong>。<br>比如你本意是等 10 秒，结果它俩互相影响，可能导致脚本卡死 20 秒甚至更久才报错。<br><strong>最佳实践</strong>：设置一个较短的全局隐式等待（如 5秒），关键步骤（如点击、断言）使用显式等待。</p></blockquote><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a>🚀 总结</h3><ol><li><strong><code>time.sleep</code></strong>：调试用，死等。</li><li><strong><code>implicitly_wait</code></strong>：全局设置，只管元素在不在 HTML 里，不管能不能点。</li><li><strong><code>WebDriverWait</code></strong>：<strong>王牌</strong>。精准等待元素可见、可点击。</li></ol><hr><h1 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image13.png" class="" title="下拉框"><ol><li><strong>标准下拉框</strong>：HTML 标签是 <code>&lt;select&gt;</code> + <code>&lt;option&gt;</code>。Selenium 提供了专门的 <code>Select</code> 类来处理，非常简单。</li><li><strong>非标准下拉框</strong>：HTML 标签是 <code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code> 模拟的（现在的前端框架如 Vue&#x2F;React 常用这种）。这种<strong>不能</strong>用 <code>Select</code> 类，必须把它当成普通的元素，用“点击 -&gt; 等待 -&gt; 点击”的方式处理。</li></ol><hr><h3 id="第一种：标准下拉框-标签"><a href="#第一种：标准下拉框-标签" class="headerlink" title="第一种：标准下拉框 (&lt;select&gt; 标签)"></a>第一种：标准下拉框 (<code>&lt;select&gt;</code> 标签)</h3><p>Selenium 专门提供了一个 <code>Select</code> 类，专门治这种元素。</p><p><strong>核心步骤</strong>：</p><ol><li>引入：<code>from selenium.webdriver.support.ui import Select</code></li><li>定位：先找到那个 <code>&lt;select&gt;</code> 元素。</li><li>初始化：<code>select = Select(元素对象)</code></li><li>选择：使用三大方法选你想要的。</li></ol><p>**三大选择方法 ：</p><ul><li><code>select_by_visible_text(&quot;文字&quot;)</code>：<strong>最常用</strong>。根据用户看到的文字选，比如 “Option 1”。</li><li><code>select_by_value(&quot;值&quot;)</code>：根据 HTML 里的 <code>value</code> 属性选，比如 <code>value=&quot;1&quot;</code>。</li><li><code>select_by_index(索引)</code>：根据顺序选，从 0 开始。<strong>不推荐</strong>，因为选项顺序容易变。</li></ul><h4 id="💻-代码实战：标准下拉框"><a href="#💻-代码实战：标准下拉框" class="headerlink" title="💻 代码实战：标准下拉框"></a>💻 代码实战：标准下拉框</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/dropdown</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-comment"># 1. 引入 Select 类</span><br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> Select<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br><br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/dropdown&quot;</span>)<br><br><span class="hljs-comment"># 2. 先定位到 select 标签本身</span><br>dropdown_element = driver.find_element(By.ID, <span class="hljs-string">&quot;dropdown&quot;</span>)<br><br><span class="hljs-comment"># 3. 初始化 Select 对象</span><br>select = Select(dropdown_element)<br><br><span class="hljs-comment"># --- 方法 A: 通过可见文本选择 (最推荐) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 1...&quot;</span>)<br>select.select_by_visible_text(<span class="hljs-string">&quot;Option 1&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 验证一下选上了没 (获取当前选中的选项)</span><br><span class="hljs-comment"># first_selected_option 是获取当前显示的那个元素</span><br>current_val = select.first_selected_option.text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前选中: <span class="hljs-subst">&#123;current_val&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> current_val == <span class="hljs-string">&quot;Option 1&quot;</span><br><br><span class="hljs-comment"># --- 方法 B: 通过 value 属性选择 ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择 Option 2 (通过 value)...&quot;</span>)<br>select.select_by_value(<span class="hljs-string">&quot;2&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># --- 方法 C: 通过索引选择 (不推荐) ---</span><br><span class="hljs-comment"># 索引 1 对应 Option 1 (因为索引 0 是那个 &quot;Please select an option&quot; 的提示语)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在选择索引 1...&quot;</span>)<br>select.select_by_index(<span class="hljs-number">1</span>) <br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二种：非标准下拉框-Div-Ul-模拟"><a href="#第二种：非标准下拉框-Div-Ul-模拟" class="headerlink" title="第二种：非标准下拉框 (Div&#x2F;Ul 模拟)"></a>第二种：非标准下拉框 (Div&#x2F;Ul 模拟)</h3><p>如果对着一个 <code>&lt;div&gt;</code> 标签用 <code>Select()</code> 类，Selenium 会直接报错：<br><code>UnexpectedTagNameException: Select only works on &lt;select&gt; elements</code>。</p><p><strong>处理逻辑</strong>：<br>把它当成普通的点击操作</p><hr><p><strong>问：</strong> “你在自动化测试中遇到过下拉框吗？怎么处理的？”</p><blockquote><p>“遇到过，我通常会先看它的 HTML 标签。</p><ol><li>如果是标准的 <strong><code>&lt;select&gt;</code></strong> 标签，我会直接用 Selenium 的 <strong><code>Select</code> 类</strong>，通过 <code>select_by_visible_text</code> 来选择，这样代码最简洁。</li><li>如果是前端框架（如 Vue&#x2F;React）生成的 <strong><code>&lt;div&gt;</code> 或 <code>&lt;ul&gt;</code></strong> 模拟的下拉框，<code>Select</code> 类是用不了的。我会把它当成普通元素，<strong>分两步处理</strong>：先点击下拉框弹出列表，再定位并点击具体的选项。为了稳定性，我通常会在第二步加上<strong>显式等待</strong>，确保选项可见后再点击。”</li></ol></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Select 类</strong>：只给 <code>&lt;select&gt;</code> 标签用。</li><li><strong>非 Select</strong>：点击框 -&gt; 等待 -&gt; 点击选项。</li></ul><hr><h1 id="Alert、Prompt、Confirm弹出框"><a href="#Alert、Prompt、Confirm弹出框" class="headerlink" title="Alert、Prompt、Confirm弹出框"></a>Alert、Prompt、Confirm弹出框</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image14.png" class="" title="弹框"><h3 id="1-什么是-Alert-Confirm-Prompt？"><a href="#1-什么是-Alert-Confirm-Prompt？" class="headerlink" title="1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？"></a>1. 什么是 Alert&#x2F;Confirm&#x2F;Prompt？</h3><p>这些是浏览器<strong>原生</strong>的弹窗（JavaScript 触发的）。</p><ul><li><strong>特点</strong>：它们<strong>不是</strong> HTML 元素！你<strong>无法</strong>用 F12 审查元素，也<strong>无法</strong>用 <code>find_element</code> 定位。</li><li><strong>表现</strong>：弹出来的时候，浏览器会被“冻结”，你必须处理掉它（点确定或取消），才能继续操作页面。</li></ul><h3 id="2-核心操作方法"><a href="#2-核心操作方法" class="headerlink" title="2. 核心操作方法"></a>2. 核心操作方法</h3><p>Selenium 提供了一个 <code>Alert</code> 类来专门处理它们。</p><p><strong>第一步：切换控制权</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">alert = driver.switch_to.alert<br></code></pre></td></tr></table></figure><p><strong>第二步：操作弹窗 (4 个方法背下来)</strong></p><ol><li><strong><code>alert.accept()</code></strong>：点击“确定” (OK)。</li><li><strong><code>alert.dismiss()</code></strong>：点击“取消” (Cancel)。</li><li><strong><code>alert.text</code></strong>：获取弹窗里的文字 (用来做断言)。</li><li><strong><code>alert.send_keys(&quot;内容&quot;)</code></strong>：在弹窗里输入文字 (仅针对 Prompt)。</li></ol><hr><h3 id="3-三种弹窗的区别"><a href="#3-三种弹窗的区别" class="headerlink" title="3. 三种弹窗的区别"></a>3. 三种弹窗的区别</h3><ol><li><strong>Alert (警告框)</strong>：只有一个“确定”按钮。</li><li><strong>Confirm (确认框)</strong>：有“确定”和“取消”两个按钮。</li><li><strong>Prompt (提示框)</strong>：有个输入框，加上“确定”和“取消”。</li></ol><hr><h3 id="代码实战：全套演练"><a href="#代码实战：全套演练" class="headerlink" title="代码实战：全套演练"></a>代码实战：全套演练</h3><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/javascript_alerts</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/javascript_alerts&quot;</span>)<br><br><span class="hljs-comment"># --- 场景 1: 处理 Alert (只有确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1. 点击 Alert 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Alert&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿让你看清楚弹窗出来了</span><br><br><span class="hljs-comment"># 切换到弹窗</span><br>alert = driver.switch_to.alert<br><br><span class="hljs-comment"># 获取文字并断言</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Alert 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> alert.text == <span class="hljs-string">&quot;I am a JS Alert&quot;</span><br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Alert 已处理&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 2: 处理 Confirm (确定/取消) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n2. 点击 Confirm 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Confirm&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Confirm 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 这次我们点“取消”试试</span><br>alert.dismiss()<br><br><span class="hljs-comment"># 验证页面结果 (页面会显示 You clicked: Cancel)</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Cancel&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Confirm 已取消&quot;</span>)<br><br><br><span class="hljs-comment"># --- 场景 3: 处理 Prompt (输入 + 确定) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n3. 点击 Prompt 按钮...&quot;</span>)<br>driver.find_element(By.XPATH, <span class="hljs-string">&quot;//button[text()=&#x27;Click for JS Prompt&#x27;]&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>)<br><br>alert = driver.switch_to.alert<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Prompt 弹窗文字: <span class="hljs-subst">&#123;alert.text&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 输入内容</span><br><span class="hljs-comment"># 注意：在 Chrome 中，你可能看不到字打进去的动画，但实际上已经输入了</span><br>alert.send_keys(<span class="hljs-string">&quot;Selenium 练习生&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br><br><span class="hljs-comment"># 验证结果</span><br>result = driver.find_element(By.ID, <span class="hljs-string">&quot;result&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;Selenium 练习生&quot;</span> <span class="hljs-keyword">in</span> result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ Prompt 输入并确认成功&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><p><strong>问：</strong> “页面上弹出了一个框，你用 <code>switch_to.alert</code> 报错说 <code>NoAlertPresentException</code>，为什么？”</p><p><strong>答：</strong></p><blockquote><p>“这说明那个弹窗<strong>不是</strong>浏览器原生的 Alert，而是前端用 HTML&#x2F;CSS（比如 Bootstrap 的 Modal）画出来的<strong>伪弹窗</strong>。</p><p><strong>怎么区分？</strong></p><ul><li><strong>原生 Alert</strong>：右键点击弹窗，<strong>没有</strong>‘检查&#x2F;Inspect’选项，且弹窗出现时浏览器无法操作其他地方。</li><li><strong>HTML 模态框</strong>：右键可以‘检查’，本质上就是个 <code>div</code>。</li></ul><p><strong>处理方法</strong>：</p><ul><li>如果是原生的：用 <code>driver.switch_to.alert</code>。</li><li>如果是 HTML 的：直接用 <code>driver.find_element</code> 定位上面的按钮，然后 <code>click()</code> 即可。”</li></ul></blockquote><hr><h3 id="进阶技巧：显式等待处理-Alert"><a href="#进阶技巧：显式等待处理-Alert" class="headerlink" title="进阶技巧：显式等待处理 Alert"></a>进阶技巧：显式等待处理 Alert</h3><p>有时候点击按钮后，Alert 弹窗不是立刻出来的（比如要请求服务器）。这时候直接 <code>switch_to.alert</code> 会报错。</p><p><strong>解决方案</strong>：使用 <code>EC.alert_is_present()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-comment"># 点击按钮</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;btn&quot;</span>).click()<br><br><span class="hljs-comment"># 显式等待：直到弹窗出现，并自动切换过去返回 alert 对象</span><br>alert = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.alert_is_present())<br><br><span class="hljs-comment"># 直接操作</span><br>alert.accept()<br></code></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Alert 处理非常简单，记住：</p><ol><li><code>switch_to.alert</code></li><li><code>accept()</code> &#x2F; <code>dismiss()</code></li><li><code>send_keys()</code></li></ol><hr><h1 id="鼠标键盘操作"><a href="#鼠标键盘操作" class="headerlink" title="鼠标键盘操作"></a>鼠标键盘操作</h1><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image15.png" class="" title="鼠标操作"><img src="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/image16.png" class="" title="键盘操作"><p>普通的 <code>click()</code> 和 <code>send_keys()</code> 只能处理简单的交互。遇到以下场景，就必须请出 <strong><code>ActionChains</code></strong> 类：</p><ol><li><strong>鼠标悬停 (Hover)</strong>：鼠标移上去才显示下拉菜单（如京东&#x2F;淘宝的商品分类）。</li><li><strong>拖拽 (Drag &amp; Drop)</strong>：滑块验证码、拖动文件上传。</li><li><strong>右键&#x2F;双击</strong>：网页游戏或复杂的后台管理系统。</li><li><strong>键盘组合键</strong>：Ctrl+C, Ctrl+V, 按 Enter 提交。</li></ol><hr><h3 id="核心概念：动作链-Chain"><a href="#核心概念：动作链-Chain" class="headerlink" title="核心概念：动作链 (Chain)"></a>核心概念：动作链 (Chain)</h3><p><code>ActionChains</code> 的工作原理像<strong>录像机</strong>：</p><ol><li>先把一连串的动作（移动、点击、按键）<strong>排队</strong>放进队列里。</li><li>最后必须调用 <strong><code>.perform()</code></strong> 方法，Selenium 才会真正去执行这些动作。</li></ol><hr><h3 id="第一部分：鼠标操作-Mouse-Actions"><a href="#第一部分：鼠标操作-Mouse-Actions" class="headerlink" title="第一部分：鼠标操作 (Mouse Actions)"></a>第一部分：鼠标操作 (Mouse Actions)</h3><h4 id="实战-1：鼠标悬停-Hover-——-百度设置"><a href="#实战-1：鼠标悬停-Hover-——-百度设置" class="headerlink" title="实战 1：鼠标悬停 (Hover) —— 百度设置"></a>实战 1：鼠标悬停 (Hover) —— 百度设置</h4><p><strong>场景</strong>：<br>在百度首页，鼠标如果不移到右上角的“设置”上，下拉菜单是不会出来的，你也点不到里面的“高级搜索”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains <span class="hljs-comment"># 1. 引入 ActionChains</span><br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">5</span>)<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>driver.maximize_window()<br><br><span class="hljs-comment"># 定位“设置”元素</span><br>settings_btn = driver.find_element(By.ID, <span class="hljs-string">&quot;s-usersetting-top&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤 ---</span><br><span class="hljs-comment"># 链式写法：初始化 -&gt; 移动鼠标 -&gt; 执行</span><br><span class="hljs-comment"># 翻译：把鼠标移到 settings_btn 上，然后执行！</span><br>ActionChains(driver).move_to_element(settings_btn).perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;鼠标已悬停，菜单应该出来了&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 停顿一下让你看清楚</span><br><br><span class="hljs-comment"># 现在菜单出来了，可以点击里面的“高级搜索”了</span><br>driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;高级搜索&quot;</span>).click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已点击高级搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h4 id="实战-2：拖拽-Drag-and-Drop"><a href="#实战-2：拖拽-Drag-and-Drop" class="headerlink" title="实战 2：拖拽 (Drag and Drop)"></a>实战 2：拖拽 (Drag and Drop)</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/drag_and_drop</code><br><strong>任务</strong>：把方块 A 拖到 方块 B 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/drag_and_drop&quot;</span>)<br><br><span class="hljs-comment"># 1. 定位源元素 (A) 和 目标元素 (B)</span><br>source_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-a&quot;</span>)<br>target_ele = driver.find_element(By.ID, <span class="hljs-string">&quot;column-b&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备拖拽 A 到 B...&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 执行拖拽</span><br>actions = ActionChains(driver)<br>actions.drag_and_drop(source_ele, target_ele).perform()<br><br><span class="hljs-comment"># 验证：检查 A 的文字是不是变了（这个网页拖拽成功后 header 会互换）</span><br><span class="hljs-comment"># 注意：DOM 里的 ID 不会变，但里面的 text 会变</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;拖拽完成！&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="第二部分：键盘操作-Keyboard-Actions"><a href="#第二部分：键盘操作-Keyboard-Actions" class="headerlink" title="第二部分：键盘操作 (Keyboard Actions)"></a>第二部分：键盘操作 (Keyboard Actions)</h3><h4 id="实战-3：组合键操作-Ctrl-A-Ctrl-C"><a href="#实战-3：组合键操作-Ctrl-A-Ctrl-C" class="headerlink" title="实战 3：组合键操作 (Ctrl+A, Ctrl+C)"></a>实战 3：组合键操作 (Ctrl+A, Ctrl+C)</h4><p><strong>场景</strong>：</p><ol><li>在百度搜索框输入 “Python”。</li><li><strong>Ctrl + A</strong> 全选。</li><li><strong>Ctrl + X</strong> 剪切。</li><li><strong>Ctrl + V</strong> 粘贴。</li><li><strong>Enter</strong> 回车搜索（不点按钮）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys <span class="hljs-comment"># 引入 Keys</span><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><br><span class="hljs-comment"># 定位搜索框</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br><br><span class="hljs-comment"># 1. 正常输入</span><br>search_input.send_keys(<span class="hljs-string">&quot;Python&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 2. 模拟组合键：Ctrl + A (全选)</span><br><span class="hljs-comment"># key_down(按下) -&gt; send_keys(A) -&gt; key_up(松开)</span><br>ActionChains(driver)\<br>    .key_down(Keys.CONTROL)\<br>    .send_keys(<span class="hljs-string">&quot;a&quot;</span>)\<br>    .key_up(Keys.CONTROL)\<br>    .perform()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已全选&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 模拟组合键：Ctrl + X (剪切)</span><br><span class="hljs-comment"># 其实 send_keys 也可以直接传组合键，不用 ActionChains 也可以，这是简便写法：</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已剪切&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 4. 模拟组合键：Ctrl + V (粘贴)</span><br>search_input.send_keys(Keys.CONTROL, <span class="hljs-string">&#x27;v&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已粘贴&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 5. 模拟回车键 (提交搜索)</span><br><span class="hljs-comment"># 很多时候不用去找“百度一下”按钮，直接回车更稳</span><br>search_input.send_keys(Keys.ENTER)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已回车搜索&quot;</span>)<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传分为两种情况，处理方式天差地别：</p><ol><li><strong>标准控件 (<code>&lt;input type=&quot;file&quot;&gt;</code>)</strong>：Selenium 可以轻松搞定。</li><li><strong>非标准控件 (Flash&#x2F;JS&#x2F;Div)</strong>：Selenium <strong>无能为力</strong>，必须借助外挂。</li></ol><hr><h3 id="情况一：标准-Input-标签-90-的情况"><a href="#情况一：标准-Input-标签-90-的情况" class="headerlink" title="情况一：标准 Input 标签 (90% 的情况)"></a>情况一：标准 Input 标签 (90% 的情况)</h3><p>如果网页上的上传按钮对应的 HTML 标签是 <code>&lt;input type=&quot;file&quot; ...&gt;</code>，这是最简单的情况。</p><p><strong>核心秘诀：千万不要点击上传按钮！</strong></p><ul><li><strong>错误做法</strong>：你点击按钮 -&gt; 操作系统弹出一个“文件选择框” -&gt; Selenium 傻眼了（因为它控制不了操作系统窗口）。</li><li><strong>正确做法</strong>：直接把<strong>文件路径</strong> <code>send_keys</code> 给那个 input 元素。</li></ul><h4 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h4><p><strong>网址</strong>：<code>https://the-internet.herokuapp.com/upload</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.implicitly_wait(<span class="hljs-number">10</span>)<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>)<br><br><span class="hljs-comment"># 1. 准备文件路径</span><br><span class="hljs-comment"># 建议使用绝对路径，防止因为运行目录不同找不到文件</span><br><span class="hljs-comment"># 假设当前目录下有一个 test.txt</span><br>file_path = os.path.abspath(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;准备上传的文件路径: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 定位上传控件</span><br><span class="hljs-comment"># 注意：我们要找的是那个 input 标签，而不是那个漂亮的“Choose File”按钮</span><br><span class="hljs-comment"># 哪怕 input 是隐藏的，只要能定位到就行</span><br>upload_input = driver.find_element(By.ID, <span class="hljs-string">&quot;file-upload&quot;</span>)<br><br><span class="hljs-comment"># 3. 核心步骤：直接发送路径</span><br><span class="hljs-comment"># 这一步相当于：Selenium 帮你把路径填进去，并自动触发了文件选择</span><br>upload_input.send_keys(file_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已发送文件路径&quot;</span>)<br><br><span class="hljs-comment"># 4. 点击“Upload”按钮 (提交表单)</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;file-submit&quot;</span>).click()<br><br><span class="hljs-comment"># 5. 验证结果</span><br>uploaded_text = driver.find_element(By.ID, <span class="hljs-string">&quot;uploaded-files&quot;</span>).text<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面显示已上传: <span class="hljs-subst">&#123;uploaded_text&#125;</span>&quot;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;test.txt&quot;</span> <span class="hljs-keyword">in</span> uploaded_text<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="情况二：非标准控件-面试难点"><a href="#情况二：非标准控件-面试难点" class="headerlink" title="情况二：非标准控件 (面试难点)"></a>情况二：非标准控件 (面试难点)</h3><p>有些网站（比如花哨的图片上传插件），找不到 <code>&lt;input&gt;</code> 标签，或者那个标签被复杂的 JS 逻辑包裹，<code>send_keys</code> 不生效。必须点击按钮，弹出 Windows&#x2F;Mac 的文件选择框才能上传。</p><p><strong>Selenium 的局限性</strong>：Selenium 只能控制浏览器，<strong>控制不了操作系统的弹窗</strong>。</p><p><strong>解决方案</strong>：<br>需要引入“外援”来控制鼠标和键盘。</p><h4 id="1-PyAutoGUI-Python-库，推荐"><a href="#1-PyAutoGUI-Python-库，推荐" class="headerlink" title="1. PyAutoGUI (Python 库，推荐)"></a>1. PyAutoGUI (Python 库，推荐)</h4><p>这是一个能控制鼠标键盘的 Python 库。</p><ul><li><strong>思路</strong>：Selenium 点击按钮 -&gt; 弹窗出现 -&gt; PyAutoGUI 输入路径 -&gt; PyAutoGUI 按回车。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要先安装: pip install pyautogui</span><br><span class="hljs-keyword">import</span> pyautogui<br><br><span class="hljs-comment"># ... Selenium 点击按钮的代码 ...</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;upload_btn&quot;</span>).click()<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等弹窗出来</span><br><br><span class="hljs-comment"># 使用 PyAutoGUI 操作 Windows 弹窗</span><br>pyautogui.write(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>) <span class="hljs-comment"># 输入路径</span><br>pyautogui.press(<span class="hljs-string">&quot;enter&quot;</span>)        <span class="hljs-comment"># 按回车</span><br></code></pre></td></tr></table></figure><ul><li><strong>缺点</strong>：脚本运行时，<strong>鼠标焦点必须在浏览器上</strong>，你不能去干别的事，否则会输错地方。而且在“无头模式”（Headless，后台运行）下无法使用。</li></ul><h4 id="2-AutoIt-Windows-老牌工具"><a href="#2-AutoIt-Windows-老牌工具" class="headerlink" title="2. AutoIt (Windows 老牌工具)"></a>2. AutoIt (Windows 老牌工具)</h4><p>写一个 <code>.exe</code> 脚本来处理弹窗，Python 调用这个 exe。</p><ul><li><strong>缺点</strong>：学习成本高，只能在 Windows 上用，现在用的人越来越少了。</li></ul><hr><p><strong>问：</strong> “如果上传按钮不是 input 标签，或者 input 标签是 hidden（隐藏）的，怎么处理？”</p><p><strong>答：</strong></p><blockquote><p>“如果是 <code>input</code> 标签被 <code>hidden</code> 隐藏了：</p><ol><li>我会先尝试用 JS (<code>execute_script</code>) 把它的 <code>style.display</code> 改为 <code>block</code> 让它显示出来。</li><li>然后直接用 <code>send_keys</code> 上传，这是最稳的。</li></ol><p>如果根本没有 <code>input</code> 标签，必须操作 OS 弹窗：</p><ul><li>我会使用 <strong>PyAutoGUI</strong> 这样的第三方库来模拟键盘输入路径并回车。</li><li>但在 CI&#x2F;CD 流水线（无界面环境）中这会失效，所以我会尽量和开发沟通，让他们提供一个可供自动化调用的上传接口。”</li></ul></blockquote><hr><h1 id="日期选择"><a href="#日期选择" class="headerlink" title="日期选择"></a>日期选择</h1><ol><li><strong>结构复杂</strong>：通常是嵌套了无数层 <code>div</code>、<code>table</code> 的控件。</li><li><strong>只读限制</strong>：很多输入框有 <code>readonly=&quot;readonly&quot;</code> 属性，禁止你直接输入，强制你点日历。</li><li><strong>翻页麻烦</strong>：如果要选“去年”或者“下个月”，你得写循环去点“上一页&#x2F;下一页”，非常容易出错。</li></ol><hr><h3 id="中策：直接输入-send-keys"><a href="#中策：直接输入-send-keys" class="headerlink" title="中策：直接输入 (send_keys)"></a>中策：直接输入 (send_keys)</h3><p>如果开发比较“仁慈”，没有给输入框加 <code>readonly</code> 属性，或者允许键盘输入。</p><ul><li><p><strong>做法</strong>：</p><ol><li><code>clear()</code> 清空（或者 Ctrl+A -&gt; Delete）。</li><li><code>send_keys(&quot;2023-12-12&quot;)</code>。</li><li>按 <code>Keys.TAB</code> 或点击空白处让日历收起来。</li></ol></li><li><p><strong>注意</strong>：要注意日期的格式（是 <code>yyyy-mm-dd</code> 还是 <code>yyyy/mm/dd</code>），输错了网页会报错。</p></li></ul><hr><h3 id="上策：JS-强行祛除“只读”属性-The-Killer-Move"><a href="#上策：JS-强行祛除“只读”属性-The-Killer-Move" class="headerlink" title="上策：JS 强行祛除“只读”属性 (The Killer Move)"></a>上策：JS 强行祛除“只读”属性 (The Killer Move)</h3><p><strong>原理</strong>：<br>既然 Selenium 控制不了日历控件，那我就用 JS 把输入框的 <code>readonly</code> 属性撕掉！把它变成一个普通的输入框，然后直接填值。</p><h4 id="JS-暴力填单"><a href="#JS-暴力填单" class="headerlink" title="JS 暴力填单"></a>JS 暴力填单</h4><p>假设 HTML 长这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有 readonly，不让你直接输 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;train_date&quot;</span> <span class="hljs-attr">readonly</span>=<span class="hljs-string">&quot;readonly&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.12306.cn/index/&quot;</span>) <span class="hljs-comment"># 以 12306 为例</span><br><br><span class="hljs-comment"># 1. 定位日期输入框</span><br><span class="hljs-comment"># 12306 的出发日期 id 是 &#x27;train_date&#x27;</span><br>date_input = driver.find_element(By.ID, <span class="hljs-string">&quot;train_date&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：JS 祛除 readonly ---</span><br><br><span class="hljs-comment"># 这段 JS 的意思是：找到这个元素(arguments[0])，移除它的 readonly 属性</span><br>js_remove_readonly = <span class="hljs-string">&quot;arguments[0].removeAttribute(&#x27;readonly&#x27;);&quot;</span><br>driver.execute_script(js_remove_readonly, date_input)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已移除只读属性&quot;</span>)<br><br><span class="hljs-comment"># --- 关键步骤：清空并输入 ---</span><br><br><span class="hljs-comment"># 2. 清空原有的日期</span><br>date_input.clear()<br><br><span class="hljs-comment"># 3. 输入你想去的日期</span><br><span class="hljs-comment"># 注意：12306 这种网站对格式要求很严，必须是 yyyy-mm-dd</span><br>date_input.send_keys(<span class="hljs-string">&quot;2025-01-01&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已输入日期: 2025-01-01&quot;</span>)<br><br><span class="hljs-comment"># 4. (可选) 有时候输入完日历还在遮挡视线，可以点一下别的地方</span><br>driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>).click()<br><br>time.sleep(<span class="hljs-number">3</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="进阶坑点：Vue-React-框架的日期控件"><a href="#进阶坑点：Vue-React-框架的日期控件" class="headerlink" title="进阶坑点：Vue&#x2F;React 框架的日期控件"></a>进阶坑点：Vue&#x2F;React 框架的日期控件</h3><p>现在的网站很多是用 Vue 或 React 写的。<br>可能会发现：<strong>用上面的方法 <code>send_keys</code> 填进去了，但一点“查询”，日期又变回去了！</strong></p><p><strong>原因</strong>：<br>这些前端框架是“双向绑定”的。光改了 HTML 里的 value，但没有触发网页的 <code>input</code> 或 <code>change</code> 事件，框架不知道改了值。</p><p><strong>解决方案 (JS 直接赋值)</strong>：<br>不要用 <code>send_keys</code>，直接用 JS 修改 value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 针对 Vue/React 等难搞的控件</span><br><span class="hljs-comment"># 直接把 value 改掉，一步到位</span><br>js_value = <span class="hljs-string">&quot;arguments[0].value = &#x27;2025-01-01&#x27;;&quot;</span><br>driver.execute_script(js_value, date_input)<br></code></pre></td></tr></table></figure><hr><h1 id="联想输入框"><a href="#联想输入框" class="headerlink" title="联想输入框"></a>联想输入框</h1><p>它的难点在于：<strong>选项是动态加载的</strong>。</p><ol><li>输入“电脑”。</li><li>浏览器发送请求给服务器。</li><li>服务器返回数据，前端再渲染出一个下拉列表（通常是 <code>&lt;ul&gt;&lt;li&gt;</code> 或 <code>&lt;div&gt;</code> 结构）。</li><li>这个过程有<strong>延迟</strong>，必须处理好等待。</li></ol><hr><h3 id="方法一：XPath-文本定位"><a href="#方法一：XPath-文本定位" class="headerlink" title="方法一：XPath 文本定位"></a>方法一：XPath 文本定位</h3><p>如果明确知道想选哪一个（比如输入 “selenium”，你想选 “selenium教程”），直接用 XPath 的文本匹配去点。</p><p><strong>核心逻辑</strong>：<br>输入 -&gt; <strong>显式等待</strong>列表出现 -&gt; <strong>XPath 定位包含特定文字的元素</strong> -&gt; 点击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://www.zhihu.com/&quot;</span>)<br>driver.maximize_window()<br><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 1. 输入关键词</span><br>driver.find_element(By.ID, <span class="hljs-string">&quot;Popover1-toggle&quot;</span>).send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br><br><span class="hljs-comment"># 2. 【关键】显式等待联想框出现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在等待联想选项出现...&quot;</span>)<br><br>target_text = <span class="hljs-string">&quot;selenium被淘汰了吗&quot;</span><br><br><span class="hljs-comment"># XPath 解析：在所有 span 标签中，找到文本包含 &#x27;selenium被淘汰了吗&#x27; 的那个</span><br><span class="hljs-comment"># 注意：联想词通常在 li 标签或者 div 标签或者 span里</span><br>target_element = WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.XPATH, <span class="hljs-string">f&quot;//span[contains(., &#x27;<span class="hljs-subst">&#123;target_text&#125;</span>&#x27;)]&quot;</span>))<br>)<br><br><span class="hljs-comment"># 3. 点击它</span><br>target_element.click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已点击选项: <span class="hljs-subst">&#123;target_text&#125;</span>&quot;</span>)<br><br>time.sleep(<span class="hljs-number">2</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><hr><h3 id="方法二：循环遍历法"><a href="#方法二：循环遍历法" class="headerlink" title="方法二：循环遍历法"></a>方法二：循环遍历法</h3><p>有时候 XPath 文本匹配可能会因为空格、换行符导致定位失败。或者想打印出所有联想词看看。这时候可以用<strong>遍历法</strong>。</p><p><strong>核心逻辑</strong>：</p><ol><li>找到所有的选项元素（返回一个 List）。</li><li>用 <code>for</code> 循环一个一个看。</li><li>如果文字对上了，就点击，然后 <code>break</code> 跳出循环。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ... 前面输入代码一样 ...</span><br><br><span class="hljs-comment"># 1. 等待任意一个选项出现，确保列表加载了</span><br>WebDriverWait(driver, <span class="hljs-number">5</span>).until(<br>    EC.visibility_of_element_located((By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>))<br>)<br><br><span class="hljs-comment"># 2. 获取所有选项列表</span><br><span class="hljs-comment"># 百度联想项的 CSS 通常是 .bdsug li (具体要按 F12 确认)</span><br>options = driver.find_elements(By.CSS_SELECTOR, <span class="hljs-string">&quot;.bdsug li&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;一共找到了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(options)&#125;</span> 个联想词&quot;</span>)<br><br><span class="hljs-comment"># 3. 循环遍历</span><br>want_to_click = <span class="hljs-string">&quot;selenium安装教程&quot;</span><br><br><span class="hljs-keyword">for</span> option <span class="hljs-keyword">in</span> options:<br>    <span class="hljs-comment"># 获取当前选项的文本</span><br>    text = option.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发现选项: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 模糊匹配：如果我想点的词在选项里</span><br>    <span class="hljs-keyword">if</span> want_to_click <span class="hljs-keyword">in</span> text:<br>        option.click()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功点击: <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 找了一圈没找到你要的词&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="方法三：键盘操作法"><a href="#方法三：键盘操作法" class="headerlink" title="方法三：键盘操作法"></a>方法三：键盘操作法</h3><p>如果你不在乎具体选哪个，或者列表结构太复杂（比如嵌套了无数层 div），你可以模拟键盘的 <strong>“向下箭头” + “回车”</strong>。</p><p><strong>场景</strong>：输入后，默认选第一个联想词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<br><br><span class="hljs-comment"># 1. 输入文本</span><br>search_input = driver.find_element(By.ID, <span class="hljs-string">&quot;kw&quot;</span>)<br>search_input.send_keys(<span class="hljs-string">&quot;selenium&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 等一下列表出来</span><br><br><span class="hljs-comment"># 2. 模拟按键：向下箭头 -&gt; 向下箭头 -&gt; 回车</span><br><span class="hljs-comment"># 选第二个联想词</span><br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ARROW_DOWN)<br>time.sleep(<span class="hljs-number">0.5</span>)<br>search_input.send_keys(Keys.ENTER)<br></code></pre></td></tr></table></figure><hr><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><h2 id="1-基本交互方法"><a href="#1-基本交互方法" class="headerlink" title="1. 基本交互方法"></a>1. <strong>基本交互方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><br>driver = webdriver.Chrome()<br>driver.get(<span class="hljs-string">&quot;https://the-internet.herokuapp.com/challenging_dom&quot;</span>) <span class="hljs-comment"># 这里只是举例，找个有 canvas 的网页很难，假设页面有个 id=&#x27;myCanvas&#x27;</span><br><br><span class="hljs-comment"># 1. 定位 Canvas 元素本身</span><br><span class="hljs-comment"># canvas = driver.find_element(By.ID, &quot;myCanvas&quot;) </span><br><span class="hljs-comment"># 为了演示代码不报错，我用 body 代替 canvas 演示动作</span><br>canvas = driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;body&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义裁剪的动作</span><br><span class="hljs-comment"># 假设：裁剪框的起始点在画布 (100, 100) 的位置</span><br><span class="hljs-comment"># 假设：我们要向右下角拖拽，宽 200，高 150</span><br><br>action = ActionChains(driver)<br><br><span class="hljs-comment"># 步骤分解：</span><br><span class="hljs-comment"># A. 移动鼠标到画布的 (100, 100) 位置</span><br><span class="hljs-comment"># 注意：move_to_element_with_offset 是相对于元素的左上角</span><br>action.move_to_element_with_offset(canvas, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># B. 按下鼠标左键 (不松开)</span><br>action.click_and_hold()<br><br><span class="hljs-comment"># C. 拖拽鼠标 (相对移动)</span><br><span class="hljs-comment"># 向右移动 200px，向下移动 150px</span><br>action.move_by_offset(<span class="hljs-number">200</span>, <span class="hljs-number">150</span>)<br><br><span class="hljs-comment"># D. 松开鼠标</span><br>action.release()<br><br><span class="hljs-comment"># E. 执行！</span><br>action.perform()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已完成 Canvas 上的拖拽操作&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-JavaScript-执行方法"><a href="#2-JavaScript-执行方法" class="headerlink" title="2. JavaScript 执行方法"></a>2. <strong>JavaScript 执行方法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取像素数据</span><br>script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);</span><br><span class="hljs-string">return Array.from(imageData.data);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>pixel_data = driver.execute_script(script, canvas)<br><br><span class="hljs-comment"># 在 Canvas 上绘制</span><br>draw_script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">var canvas = arguments[0];</span><br><span class="hljs-string">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="hljs-string">ctx.fillStyle = &#x27;red&#x27;;</span><br><span class="hljs-string">ctx.fillRect(10, 10, 50, 50);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>driver.execute_script(draw_script, canvas)<br></code></pre></td></tr></table></figure><hr><h1 id="PO模式"><a href="#PO模式" class="headerlink" title="PO模式"></a>PO模式</h1><h3 id="1-什么是-PO-模式？"><a href="#1-什么是-PO-模式？" class="headerlink" title="1. 什么是 PO 模式？"></a>1. 什么是 PO 模式？</h3><p><strong>核心思想</strong>：<strong>页面（Page）与测试逻辑（Test）分离</strong>。</p><ul><li><strong>没有 PO 模式</strong>：想吃宫保鸡丁，直接冲进厨房，自己切鸡肉、自己炒菜、自己吃。（测试脚本里混杂了定位元素、点击操作、断言逻辑）。</li><li><strong>用了 PO 模式</strong>：<ul><li><strong>Page (菜单)</strong>：厨房封装好了“宫保鸡丁”这道菜（封装了定位和操作）。</li><li><strong>Test (顾客)</strong>：只需要对着菜单喊一声“我要一份宫保鸡丁”（调用方法），不需要知道厨房里是怎么切菜的。</li></ul></li></ul><hr><h3 id="2-为什么要用它"><a href="#2-为什么要用它" class="headerlink" title="2. 为什么要用它"></a>2. 为什么要用它</h3><p>假设有 50 条测试用例都涉及“登录”。<br>有一天，前端开发把登录按钮的 <code>id=&quot;login-btn&quot;</code> 改成了 <code>id=&quot;submit-btn&quot;</code>。</p><ul><li><strong>惨状（无 PO）</strong>：需要打开 50 个测试文件，一个一个查找替换。</li><li><strong>优雅（有 PO）</strong>：只需要打开 <code>LoginPage.py</code> 这<strong>一个</strong>文件，修改一行代码。50 条用例自动修复。</li></ul><hr><h3 id="3-PO-模式的三层架构"><a href="#3-PO-模式的三层架构" class="headerlink" title="3. PO 模式的三层架构"></a>3. PO 模式的三层架构</h3><p>把代码拆分成三个文件夹（层级）：</p><ol><li><strong><code>base/</code> (基类层)</strong>：<strong>地基</strong>。封装 Selenium 最底层的 <code>find_element</code>、<code>click</code> 等方法，加上显式等待。</li><li><strong><code>pages/</code> (页面层)</strong>：<strong>菜单</strong>。每个页面写一个类（如 <code>LoginPage</code>），只存放<strong>元素定位</strong>和<strong>页面操作</strong>。</li><li><strong><code>test_cases/</code> (测试层)</strong>：<strong>顾客</strong>。只写<strong>业务逻辑</strong>和<strong>断言</strong>。</li></ol><hr><h3 id="4-手把手代码实战"><a href="#4-手把手代码实战" class="headerlink" title="4. 手把手代码实战"></a>4. 手把手代码实战</h3><p>我们以 <strong>SauceDemo</strong> 登录为例。</p><h4 id="第一步：搭建项目结构"><a href="#第一步：搭建项目结构" class="headerlink" title="第一步：搭建项目结构"></a>第一步：搭建项目结构</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">AutoTestProject/<br>├── base/<br>│   └── base_page.py      # 封装底层 Selenium<br>├── pages/<br>│   └── login_page.py     # 登录页面的元素和操作<br>└── test_cases/<br>    └── test_login.py     # 具体的测试脚本<br></code></pre></td></tr></table></figure><h4 id="第二步：编写基类-base-base-page-py"><a href="#第二步：编写基类-base-base-page-py" class="headerlink" title="第二步：编写基类 (base/base_page.py)"></a>第二步：编写基类 (<code>base/base_page.py</code>)</h4><p>这一层的目的是：<strong>让页面层不需要直接接触 <code>driver</code> 的原生 API，而是用我们封装好的更稳定的方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, driver</span>):<br>        <span class="hljs-variable language_">self</span>.driver = driver<br><br>    <span class="hljs-comment"># 封装 find_element，加入显式等待，从此告别 NoSuchElementException</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-comment"># locator 比如是 (By.ID, &quot;user-name&quot;)</span><br>        <span class="hljs-keyword">return</span> WebDriverWait(<span class="hljs-variable language_">self</span>.driver, <span class="hljs-number">10</span>).until(<br>            EC.visibility_of_element_located(locator)<br>        )<br><br>    <span class="hljs-comment"># 封装输入</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_keys</span>(<span class="hljs-params">self, locator, text</span>):<br>        ele = <span class="hljs-variable language_">self</span>.find(locator)<br>        ele.clear() <span class="hljs-comment"># 输入前先清空，好习惯</span><br>        ele.send_keys(text)<br><br>    <span class="hljs-comment"># 封装点击</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-variable language_">self</span>.find(locator).click()<br>        <br>    <span class="hljs-comment"># 封装获取文本（用于断言）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_text</span>(<span class="hljs-params">self, locator</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.find(locator).text<br></code></pre></td></tr></table></figure><h4 id="第三步：编写页面层-pages-login-page-py"><a href="#第三步：编写页面层-pages-login-page-py" class="headerlink" title="第三步：编写页面层 (pages/login_page.py)"></a>第三步：编写页面层 (<code>pages/login_page.py</code>)</h4><p>这一层<strong>严禁出现断言（assert）</strong>，只负责描述页面长什么样、能干什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> base.base_page <span class="hljs-keyword">import</span> BasePage<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPage</span>(<span class="hljs-title class_ inherited__">BasePage</span>):<br>    <span class="hljs-comment"># --- 1. 核心：元素定位 (Locators) ---</span><br>    <span class="hljs-comment"># 把页面上用到的元素 ID 都写在这里，以后改 ID 只要改这里</span><br>    _USERNAME_INPUT = (By.ID, <span class="hljs-string">&quot;user-name&quot;</span>)<br>    _PASSWORD_INPUT = (By.ID, <span class="hljs-string">&quot;password&quot;</span>)<br>    _LOGIN_BTN = (By.ID, <span class="hljs-string">&quot;login-button&quot;</span>)<br>    _ERROR_MSG = (By.CSS_SELECTOR, <span class="hljs-string">&quot;h3[data-test=&#x27;error&#x27;]&quot;</span>)<br><br>    <span class="hljs-comment"># --- 2. 核心：页面操作 (Actions) ---</span><br>    <br>    <span class="hljs-comment"># 定义一个登录动作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, user, pwd</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在登录账号: <span class="hljs-subst">&#123;user&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 调用父类 BasePage 的方法，而不是直接用 driver</span><br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._USERNAME_INPUT, user)<br>        <span class="hljs-variable language_">self</span>.send_keys(<span class="hljs-variable language_">self</span>._PASSWORD_INPUT, pwd)<br>        <span class="hljs-variable language_">self</span>.click(<span class="hljs-variable language_">self</span>._LOGIN_BTN)<br><br>    <span class="hljs-comment"># 获取错误提示文字</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_error_msg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.get_text(<span class="hljs-variable language_">self</span>._ERROR_MSG)<br></code></pre></td></tr></table></figure><h4 id="第四步：编写测试层-test-cases-test-login-py"><a href="#第四步：编写测试层-test-cases-test-login-py" class="headerlink" title="第四步：编写测试层 (test_cases/test_login.py)"></a>第四步：编写测试层 (<code>test_cases/test_login.py</code>)</h4><p>这一层只能调用 Page 对象的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> pages.login_page <span class="hljs-keyword">import</span> LoginPage<br><br><span class="hljs-comment"># 模拟一个测试用例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_logic</span>():<br>    <span class="hljs-comment"># 1. 启动浏览器 (这一步以后会交给 Pytest fixture 做)</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 初始化页面对象</span><br>    <span class="hljs-comment"># 把 driver 传给 LoginPage，这样 LoginPage 才能操作浏览器</span><br>    login_page = LoginPage(driver)<br><br>    <span class="hljs-comment"># --- 用例 1: 登录成功 ---</span><br>    login_page.login(<span class="hljs-string">&quot;standard_user&quot;</span>, <span class="hljs-string">&quot;secret_sauce&quot;</span>)<br>    <br>    <span class="hljs-comment"># 断言：判断 URL 是否跳转</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;inventory.html&quot;</span> <span class="hljs-keyword">in</span> driver.current_url:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例1通过：登录成功&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 用例1失败&quot;</span>)<br><br>    <span class="hljs-comment"># --- 准备测下一个用例，先退出或重启浏览器 ---</span><br>    <span class="hljs-comment"># 这里为了演示简单，我们直接重启</span><br>    driver.quit()<br>    <br>    <span class="hljs-comment"># --- 用例 2: 登录失败 ---</span><br>    driver = webdriver.Chrome()<br>    driver.get(<span class="hljs-string">&quot;https://www.saucedemo.com/&quot;</span>)<br>    login_page = LoginPage(driver)<br>    <br>    login_page.login(<span class="hljs-string">&quot;locked_out_user&quot;</span>, <span class="hljs-string">&quot;wrong_password&quot;</span>)<br>    <br>    <span class="hljs-comment"># 获取页面上的错误提示</span><br>    error_text = login_page.get_error_msg()<br>    <br>    <span class="hljs-comment"># 断言</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Epic sadface&quot;</span> <span class="hljs-keyword">in</span> error_text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 用例2通过：错误提示正确&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 用例2失败，实际提示: <span class="hljs-subst">&#123;error_text&#125;</span>&quot;</span>)<br>        <br>    driver.quit()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    test_login_logic()<br></code></pre></td></tr></table></figure><hr><h3 id="5-PO-模式的“六大原则”-面试加分项"><a href="#5-PO-模式的“六大原则”-面试加分项" class="headerlink" title="5. PO 模式的“六大原则” (面试加分项)"></a>5. PO 模式的“六大原则” (面试加分项)</h3><p>你在设计 PO 模式时遵循什么原则？</p><ol><li><strong>公共方法封装在 BasePage</strong>：不要在每个 Page 里重复写显式等待。</li><li><strong>页面元素与测试数据分离</strong>：Page 类里不要写死 “standard_user”，数据要从 Test 层传进来。</li><li><strong>Page 层不写断言</strong>：Page 层只负责“做动作”和“返回结果”，断言（判断对错）是 Test 层的事。</li><li><strong>方法名要有业务含义</strong>：用 <code>login()</code> 而不是 <code>type_username_and_click()</code>。</li><li><strong>不要暴露内部元素</strong>：Test 层不应该能访问到 <code>By.ID</code>，只能调用方法。</li><li><strong>返回新页面对象 (进阶)</strong>：点击登录后，<code>login()</code> 方法最好返回一个 <code>InventoryPage</code> 对象（链式调用）。</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Web自动化测试</tag>
      
      <tag>selenium</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/2025/12/10/Python%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/12/10/Python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: 演示定义汽车类 及  使用类中的成员.</span><br><span class="hljs-string"></span><br><span class="hljs-string">面向对象核心概念:</span><br><span class="hljs-string">    类: 抽象的概念, 看不见, 摸不着, 是 属性(名词) 和 行为(动词)的集合.</span><br><span class="hljs-string">    对象: 类的具体体现, 实现.</span><br><span class="hljs-string">    属性(名词): 用来描述事物的外在特征的, 例如: 姓名, 年龄...</span><br><span class="hljs-string">        格式: 和以前定义变量一样.</span><br><span class="hljs-string">    行为(动词): 用来描述事物能够做什么的, 例如: 吃, 喝...</span><br><span class="hljs-string">        格式: 和以前定义函数一样.</span><br><span class="hljs-string"></span><br><span class="hljs-string">定义类的格式:</span><br><span class="hljs-string">    class 类名:</span><br><span class="hljs-string">        # 属性</span><br><span class="hljs-string">        # 行为</span><br><span class="hljs-string"></span><br><span class="hljs-string">如何访问类中的成员?</span><br><span class="hljs-string">    step1: 创建该类的对象.</span><br><span class="hljs-string">        对象名 = 类名()</span><br><span class="hljs-string">    step2: 通过 对象名. 的方式调用.</span><br><span class="hljs-string">        对象性.属性名</span><br><span class="hljs-string">        对象名.行为名()</span><br><span class="hljs-string"></span><br><span class="hljs-string">需求: 定义汽车类, 有跑的行为.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 1.定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:      <span class="hljs-comment"># 类名遵循 大驼峰命名法.</span><br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><br><span class="hljs-comment"># 3. 调用Car类的run()函数, 简写版: 调用Car#run()</span><br>c1.run()<br></code></pre></td></tr></table></figure><hr><h2 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: self关键字介绍.</span><br><span class="hljs-string"></span><br><span class="hljs-string">self介绍:</span><br><span class="hljs-string">    概述:</span><br><span class="hljs-string">        它是Python内置的关键字, 用于表示 本类当前对象的引用.</span><br><span class="hljs-string">    作用:</span><br><span class="hljs-string">        1个类是可以有多个对象的, 这多个对象都可以通过 对象名. 的方式访问类中的行为(函数)</span><br><span class="hljs-string">        函数默认有self属性, 函数通过self来区分到底是哪个对象调用的该函数.</span><br><span class="hljs-string">    大白话:</span><br><span class="hljs-string">        谁调用函数, self就代表哪个对象.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 需求: 定义汽车类, 创建多个该类的对象, 看看打印结果.</span><br><span class="hljs-comment"># 1. 定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为, 跑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是run函数, self的值是: <span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1对象: <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c1.run()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">34</span>)<br><br><span class="hljs-comment"># 3.继续创建汽车类的对象.</span><br>c2 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2对象: <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c2.run()<br></code></pre></td></tr></table></figure><hr><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/self.png" class="" title="self"><p>这张图非常生动地展示了 <strong>Python 面向对象编程（OOP）中的内存管理机制</strong>，特别是<strong>对象（Object）与引用（Reference）的关系，以及实例属性</strong>是如何存储的。</p><p>这张图主要分为三个部分：<strong>代码区（左侧）</strong>、<strong>内存结构示意图（右侧，包含栈、堆、方法区）</strong>。</p><p>我将为你详细拆解这张图背后的逻辑：</p><h3 id="1-核心概念：内存的三大区域"><a href="#1-核心概念：内存的三大区域" class="headerlink" title="1. 核心概念：内存的三大区域"></a>1. 核心概念：内存的三大区域</h3><ul><li><strong>栈 (Stack)</strong>：<ul><li>图中的左侧竖条。</li><li><strong>作用</strong>：存储局部变量（即变量名）。在这里存储的是 <code>c1</code> 和 <code>c2</code>。</li><li><strong>本质</strong>：它们只是**引用（Reference）**或者说是“标签”，它们本身不存数据，而是指向堆内存中的具体地址（如 <code>0x01</code> 和 <code>0x02</code>）。</li></ul></li><li><strong>堆 (Heap)</strong>：<ul><li>图中的右侧蓝色大框。</li><li><strong>作用</strong>：存储真正的<strong>对象实例</strong>。</li><li><strong>内容</strong>：这里有两个 <code>Car()</code> 对象。每个对象都有自己独立的内存空间（地址 <code>0x01</code> 和 <code>0x02</code>）。对象内部存储该对象的具体数据（属性）。</li></ul></li><li><strong>方法区 (Method Area)</strong>：<ul><li>图中的右下角红色框。</li><li><strong>作用</strong>：存储类的定义和方法的代码。</li><li><strong>关键点</strong>：<code>run(self)</code> 这个方法只有一份代码（地址 <code>0x03</code>）。无论你创建多少个 <code>Car</code> 对象，它们调用的 <code>run</code> 方法都是同一个，不需要为每个对象复制一份代码。</li></ul></li></ul><h3 id="2-代码执行流程与内存变化"><a href="#2-代码执行流程与内存变化" class="headerlink" title="2. 代码执行流程与内存变化"></a>2. 代码执行流程与内存变化</h3><p>让我们跟随左侧的代码，看看内存里发生了什么：</p><h4 id="第一步：创建-c1-对象"><a href="#第一步：创建-c1-对象" class="headerlink" title="第一步：创建 c1 对象"></a>第一步：创建 c1 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c1</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块空间（假设地址 <code>0x01</code>）生成一个 <code>Car</code> 对象。</li><li>在<strong>栈</strong>中创建一个变量 <code>c1</code>。</li><li>将 <code>c1</code> 指向 <code>0x01</code>（图中绿色的箭头）。</li></ol></li><li>此时，<code>c1</code> 对象内部包含一个指向方法区的指针 <code>0x03</code>，以便能调用 <code>run()</code> 方法。</li></ul><h4 id="第二步：给-c1-添加属性（动态属性）"><a href="#第二步：给-c1-添加属性（动态属性）" class="headerlink" title="第二步：给 c1 添加属性（动态属性）"></a>第二步：给 c1 添加属性（动态属性）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">c1.color</span> = <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-attr">c1.number</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ul><li>Python 是动态语言，允许在对象创建后随意添加属性。</li><li>图中的 <code>c1</code> 对象（<code>0x01</code> 盒子）里，现在多了两行数据：<code>color=&#39;红色&#39;</code> 和 <code>number=4</code>。</li><li><strong>注意</strong>：这些数据是<strong>独属于</strong> <code>c1</code> 这个对象的。</li></ul></li></ul><h4 id="第三步：创建-c2-对象"><a href="#第三步：创建-c2-对象" class="headerlink" title="第三步：创建 c2 对象"></a>第三步：创建 c2 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c2</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure><ul><li><strong>内存动作</strong>：<ol><li>在<strong>堆</strong>中开辟一块<strong>新的</strong>空间（地址 <code>0x02</code>）。</li><li>在<strong>栈</strong>中创建变量 <code>c2</code>。</li><li>将 <code>c2</code> 指向 <code>0x02</code>（图中深红色的箭头）。</li></ol></li><li><strong>关键区别</strong>：<code>c2</code> 是一个全新的对象。虽然它也是 <code>Car</code>，但因为它刚出生，还没有人给它赋值 <code>color</code> 和 <code>number</code>，所以图中的 <code>c2</code> 盒子（<code>0x02</code>）里是<strong>空的</strong>（只有指向方法的 <code>0x03</code>）。</li></ul><h4 id="第四步：代码中的注释细节-细节-3"><a href="#第四步：代码中的注释细节-细节-3" class="headerlink" title="第四步：代码中的注释细节 (细节 3)"></a>第四步：代码中的注释细节 (细节 3)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;颜色: &#123;c2.color&#125;...&#x27;</span>)</span><br></code></pre></td></tr></table></figure><ul><li>这行代码被注释掉了，因为如果运行它会<strong>报错</strong>（AttributeError）。</li><li><strong>原因</strong>：看堆内存图就很清楚，<code>c2</code> 指向的 <code>0x02</code> 盒子里并没有 <code>color</code> 和 <code>number</code> 数据。属性不会自动从 <code>c1</code> 传染给 <code>c2</code>。</li></ul><h3 id="3-图解总结-Key-Takeaways"><a href="#3-图解总结-Key-Takeaways" class="headerlink" title="3. 图解总结 (Key Takeaways)"></a>3. 图解总结 (Key Takeaways)</h3><ol><li><strong>同类不同命</strong>：<code>c1</code> 和 <code>c2</code> 虽然都是 <code>Car</code> 类造出来的，但它们是两个独立的个体。修改 <code>c1</code> 的属性不会影响 <code>c2</code>。</li><li><strong>方法共享，数据独享</strong>：<ul><li><strong>数据（属性）</strong>：存在<strong>堆</strong>里各自的对象中（<code>c1</code> 有颜色，<code>c2</code> 没有）。</li><li><strong>行为（方法）</strong>：存在<strong>方法区</strong>里，大家共用同一个（地址 <code>0x03</code>）。</li></ul></li><li><strong>引用传递</strong>：变量名（<code>c1</code>）只是一个遥控器，它通过内存地址控制真正的对象。</li></ol><hr><p>**问：**如果每个对象调用的方法都指向同一个地址，那假如这个方法中有修改对象属性的逻辑，那岂不是一个对象调用之后，别的对象的属性也被修改了？</p><p>答案是：<strong>完全不会。</strong></p><p>其中的关键就在于 Python 方法中的第一个参数 —— <strong><code>self</code></strong>。</p><p>虽然代码（指令）只有一份，存在方法区里（比如地址 <code>0x03</code>），但<strong>执行这份代码时操作的数据对象</strong>是不同的。</p><h3 id="核心机制：self-就是那个“定位器”"><a href="#核心机制：self-就是那个“定位器”" class="headerlink" title="核心机制：self 就是那个“定位器”"></a>核心机制：<code>self</code> 就是那个“定位器”</h3><p>你可以把方法区里的代码看作是一本**“公用操作手册”**。</p><p>假如 <code>run</code> 方法里有一句代码是修改颜色的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 修改属性</span><br></code></pre></td></tr></table></figure><p>当你调用方法时，Python 在后台做了一个**“隐式传递”**的操作：</p><h4 id="1-当-c1-调用时"><a href="#1-当-c1-调用时" class="headerlink" title="1. 当 c1 调用时"></a>1. 当 <code>c1</code> 调用时</h4><p>你写的是：c1.run()</p><p>Python 实际执行的是：Car.run(c1)  &lt;– 看这里！</p><ul><li>它把 <code>c1</code> 的地址（<code>0x01</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c1.color = &#39;黑色&#39;</code>。</li><li>于是，只有 <strong>堆内存中 0x01 号盒子</strong> 里的 <code>color</code> 变成了黑色。</li></ul><h4 id="2-当-c2-调用时"><a href="#2-当-c2-调用时" class="headerlink" title="2. 当 c2 调用时"></a>2. 当 <code>c2</code> 调用时</h4><p>你写的是：c2.run()</p><p>Python 实际执行的是：Car.run(c2)</p><ul><li>这次它把 <code>c2</code> 的地址（<code>0x02</code>）传给了 <code>self</code>。</li><li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c2.color = &#39;黑色&#39;</code>。</li><li>于是，是 <strong>堆内存中 0x02 号盒子</strong> 里的数据被修改了。</li></ul><hr><h2 id="魔术方法init"><a href="#魔术方法init" class="headerlink" title="魔术方法init"></a>魔术方法init</h2><p><strong>init</strong>()魔法方法, 在创建对象的时候, 会被自动调用, 一般用于给该类对象 的属性进行初始化.</p><p>无参版 init -&gt;  默认上的有底色, 你需要重新涂色(覆盖底色)<br>有参版 init -&gt;  默认没有涂色的石膏娃娃, 我们根据喜好自由涂色即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时不需要参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br>        <span class="hljs-variable language_">self</span>.number = <span class="hljs-number">3</span>      <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br><br><span class="hljs-comment"># 情况 A：c2 (保留默认)</span><br>c2 = Car()<br><span class="hljs-comment"># 此时内存里是：黑色, 3</span><br><br><span class="hljs-comment"># 情况 B：c1 (后期改装)</span><br>c1 = Car()          <br><span class="hljs-comment"># 1. 此时内存里也是：黑色, 3</span><br>c1.color = <span class="hljs-string">&#x27;红色&#x27;</span>   <br><span class="hljs-comment"># 2. 【覆盖动作】：找到内存里的&#x27;黑色&#x27;，把它擦掉，换成&#x27;红色&#x27;</span><br>c1.number = <span class="hljs-number">6</span>       <br><span class="hljs-comment"># 3. 【覆盖动作】：找到内存里的3，把它擦掉，换成6</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c2: <span class="hljs-subst">&#123;c2.color&#125;</span>, <span class="hljs-subst">&#123;c2.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：黑色, 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：红色, 6</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时，强制要求传入颜色和数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color    <span class="hljs-comment"># 直接赋值为传入的参数</span><br>        <span class="hljs-variable language_">self</span>.number = number<br><br><span class="hljs-comment"># 【内存动作】：</span><br><span class="hljs-comment"># 在堆内存创建对象时，直接写入 &#x27;红色&#x27; 和 6。</span><br><span class="hljs-comment"># 不需要先写入默认值再擦除。</span><br>c1 = Car(<span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-number">6</span>) <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：c1: 红色, 6</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法str"><a href="#魔术方法str" class="headerlink" title="魔术方法str"></a>魔术方法str</h2><p>当用print()函数 打印对象的时候, 会自动调用该对象(所在类)的 str魔法方法.该魔法方法默认打印的是对象的地址值, 无意义, 一般都会重写, 改为打印对象的各个属性值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-comment"># 输出结果类似：&lt;__main__.Car object at 0x000001&gt;  (看不懂，只知道是个Car对象)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br>        <span class="hljs-variable language_">self</span>.number = number<br><br>    <span class="hljs-comment"># 定义对象的字符串表现形式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 必须返回一个字符串！</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;【车辆信息】颜色：<span class="hljs-subst">&#123;self.color&#125;</span>，轮胎数：<span class="hljs-subst">&#123;self.number&#125;</span>&quot;</span><br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 此时 print 内部会自动调用 c1.__str__()</span><br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-comment"># 输出结果：【车辆信息】颜色：红色，轮胎数：4</span><br></code></pre></td></tr></table></figure><hr><h2 id="魔术方法del"><a href="#魔术方法del" class="headerlink" title="魔术方法del"></a>魔术方法del</h2><p>当.py文件执行结束, 或者 手动 del 释放对象资源, 会自动调用该函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【出生】<span class="hljs-subst">&#123;self.name&#125;</span> 被制造出来了！&quot;</span>)<br><br>    <span class="hljs-comment"># 定义对象销毁时要执行的逻辑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【消亡】<span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了，送去回收站。&quot;</span>)<br><br><span class="hljs-comment"># 1. 创建对象</span><br>c1 = Car(<span class="hljs-string">&quot;宝马&quot;</span>)<br><br><span class="hljs-comment"># 2. 模拟一些操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 正在开车中 ---&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 手动删除对象（或者当程序运行结束时，也会自动触发）</span><br><span class="hljs-keyword">del</span> c1 <br><span class="hljs-comment"># 此时，c1 的引用计数变为0，Python 自动调用 __del__ 【消亡】宝马 被销毁了，送去回收站。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="模数方法lt-le-eq"><a href="#模数方法lt-le-eq" class="headerlink" title="模数方法lt&#x2F;le&#x2F;eq"></a>模数方法lt&#x2F;le&#x2F;eq</h2><p>这三个魔术方法让你的对象可以使用 <strong>比较运算符</strong>（<code>&lt;</code>, <code>&lt;=</code>, <code>==</code>）进行 PK。如果不写这些方法，Python 不知道怎么比较两个自定义对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-comment"># __lt__ 对应 &lt; (Less Than)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt; other.score<br><br>    <span class="hljs-comment"># __le__ 对应 &lt;= (Less Than or Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt;= other.score<br><br>    <span class="hljs-comment"># __eq__ 对应 == (Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score == other.score<br><br><span class="hljs-comment"># 创建学生对象</span><br>s1 = Student(<span class="hljs-number">80</span>)<br>s2 = Student(<span class="hljs-number">90</span>)<br>s3 = Student(<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># Python 会自动调用对应的方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt; s2 : <span class="hljs-subst">&#123;s1 &lt; s2&#125;</span>&quot;</span>)   <span class="hljs-comment"># 调用 s1.__lt__(s2)，80 &lt; 90，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt;= s3: <span class="hljs-subst">&#123;s1 &lt;= s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__le__(s3)，80 &lt;= 80，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 == s3: <span class="hljs-subst">&#123;s1 == s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__eq__(s3)，80 == 80，结果 True</span><br><br><span class="hljs-comment"># 甚至可以直接用在列表中排序（主要依赖 __lt__）</span><br>students = [s2, s1]<br>students.sort() <span class="hljs-comment"># 此时 Python 知道按分数排</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一名分数: <span class="hljs-subst">&#123;students[-<span class="hljs-number">1</span>].score&#125;</span>&quot;</span>) <span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure><hr><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>是一种编程思想, 强调的是以 <strong>对象</strong> 为基础完成各种操作，其三大特性：</p><ul><li>封装：大白话：把属性和方法封装在一起，仅提供对外的方法让别人去访问。好处： 简化编程</li><li>继承：大白话：孩子可使用老爹的东西。好处：代码复用</li><li>多态：大白话：同样一个函数（消息）在不同场景下表现出不同形态。 好处：解耦合，可拓展</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装 (Encapsulation)</strong> 的核心思想是：<strong>把重要的数据锁在保险箱里，只留一个小窗口（方法）对外办事。</strong></p><p>这样做可以防止外部随意修改内部数据，保证数据的安全性。在 Python 中，在属性名前加 <strong>两个下划线 <code>__</code></strong>，就可以把它变成**私有（Private）**的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, money</span>):<br>        <span class="hljs-variable language_">self</span>.name = name          <span class="hljs-comment"># 公有属性：大家都能看</span><br>        <span class="hljs-variable language_">self</span>.__balance = money    <span class="hljs-comment"># 私有属性：加了__，只有自己能看/改</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来查看余额 (Getter)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_balance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;用户 <span class="hljs-subst">&#123;self.name&#125;</span> 当前余额：<span class="hljs-subst">&#123;self.__balance&#125;</span> 元&quot;</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来修改余额 (Setter)，可以在这里加安全判断</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_money</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.__balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功存入 <span class="hljs-subst">&#123;amount&#125;</span> 元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存钱金额必须大于0！&quot;</span>)<br><br>acc = Account(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 1. 正常操作：通过方法访问</span><br>acc.save_money(<span class="hljs-number">500</span>)<br><span class="hljs-built_in">print</span>(acc.check_balance())<br><br><span class="hljs-comment"># 2. 违规操作：尝试直接访问私有属性</span><br><span class="hljs-comment"># print(acc.__balance)  </span><br><span class="hljs-comment"># 报错：AttributeError（Python 会假装在这个对象里找不到 __balance）</span><br><br><span class="hljs-comment"># 3. 绕过封装（虽然不推荐，但原理要知道）</span><br><span class="hljs-comment"># Python 实际上是把名字改成了 _类名__属性名</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;强行偷看：<span class="hljs-subst">&#123;acc._Account__balance&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类可以继承父类的属性和行为</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大口干饭...&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义子类，括号里写父类的名字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-comment"># 3. 使用</span><br>wangcai = Dog()<br>wangcai.bark()  <span class="hljs-comment"># 调用自己的方法</span><br>wangcai.eat()   <span class="hljs-comment"># 【关键】调用父类的方法（虽然Dog里没写eat，但它继承下来了）</span><br></code></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会飞高高&quot;</span>)<br><br><span class="hljs-comment"># 父类 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会跑得快&quot;</span>)<br><br><span class="hljs-comment"># 子类：括号里写多个父类，用逗号隔开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Flyer, Mammal):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bite</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我还咬人！&quot;</span>)<br><br><span class="hljs-comment"># 使用</span><br>bianfu = Bat()<br>bianfu.fly()   <span class="hljs-comment"># 继承自 Flyer</span><br>bianfu.run()   <span class="hljs-comment"># 继承自 Mammal</span><br>bianfu.bite()  <span class="hljs-comment"># 自己的</span><br></code></pre></td></tr></table></figure><h3 id="子类重写父类的功能"><a href="#子类重写父类的功能" class="headerlink" title="子类重写父类的功能"></a>子类重写父类的功能</h3><p>有两种常见的重写方式：</p><ol><li><strong>完全覆盖</strong>：彻底抛弃父类的做法，另起炉灶。</li><li><strong>功能扩展</strong>：保留父类的核心逻辑（用 <code>super()</code>），然后增加新功能。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 父类：普通的狗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！(普通叫声)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;也就是个慢跑...&quot;</span>)<br><br><span class="hljs-comment"># 2. 子类A：哈士奇 (完全覆盖)</span><br><span class="hljs-comment"># 哈士奇不想“汪汪汪”，它想“嗷呜”，所以它彻底改写了 bark 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;嗷呜~~~~ (狼嚎)&quot;</span>)<br><br><span class="hljs-comment"># 3. 子类B：警犬 (功能扩展)</span><br><span class="hljs-comment"># 警犬也得先像普通狗一样叫，但叫完之后还得抓坏人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoliceDog</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 【关键步骤】super() 代表父类</span><br>        <span class="hljs-comment"># 先执行父类的 bark (输出“汪汪汪”)</span><br>        <span class="hljs-built_in">super</span>().bark() <br>        <span class="hljs-comment"># 然后再执行自己的特殊逻辑</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 发现坏人，猛扑上去！&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br>h = Husky()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 哈士奇 ---&quot;</span>)<br>h.bark() <br><span class="hljs-comment"># 输出：嗷呜~~~~ (父类的逻辑完全不见了)</span><br><br>p = PoliceDog()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 警犬 ---&quot;</span>)<br>p.bark()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 汪汪汪！(普通叫声)  &lt;-- 来自 super().bark()</span><br><span class="hljs-comment"># &gt;&gt;&gt; 发现坏人，猛扑上去！</span><br></code></pre></td></tr></table></figure><hr><h3 id="子类访问父类功能"><a href="#子类访问父类功能" class="headerlink" title="子类访问父类功能"></a>子类访问父类功能</h3><p>子类重写父类功能后, 继续访问父类功能 </p><ol><li>父类名.父类函数名(self)      精准访问, 想找哪个父类, 就调哪个父类.</li><li>super().父类函数名()        只能访问最近的那个父类, 有就用, 没有就往后继续查找.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👴 父亲的技能：编程 (Python)&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👩 母亲的技能：画画 (Painting)&quot;</span>)<br><br><span class="hljs-comment"># 注意继承顺序：Father 在前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Father, Mother):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是孩子，开始展示技能...&quot;</span>)<br><br>        <span class="hljs-comment"># --- 方式 1: super() (自动挡) ---</span><br>        <span class="hljs-comment"># 规则：只找 MRO 列表里的“下一个”。</span><br>        <span class="hljs-comment"># 因为 class Child(Father, Mother)，Father 排前面，</span><br>        <span class="hljs-comment"># 所以 super() 只能调到 Father，直接忽略了 Mother。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 1: super().skill()】&quot;</span>)<br>        <span class="hljs-built_in">super</span>().skill()<br><br>        <span class="hljs-comment"># --- 方式 2: 类名.方法(self) (手动挡) ---</span><br>        <span class="hljs-comment"># 规则：指哪打哪。</span><br>        <span class="hljs-comment"># 即使 Mother 排在后面，super() 够不着，</span><br>        <span class="hljs-comment"># 我依然可以通过“类名”强行调用她。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 2: Mother.skill(self)】&quot;</span>)<br>        Mother.skill(<span class="hljs-variable language_">self</span>)<br><br><span class="hljs-comment"># 运行测试</span><br>c = Child()<br>c.skill()<br><span class="hljs-comment"># 我是孩子，开始展示技能...</span><br><br><span class="hljs-comment"># 【方式 1: super().skill()】</span><br><span class="hljs-comment"># 👴 父亲的技能：编程 (Python)</span><br><br><span class="hljs-comment"># 【方式 2: Mother.skill(self)】</span><br><span class="hljs-comment"># 👩 母亲的技能：画画 (Painting)</span><br></code></pre></td></tr></table></figure><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个函数, 接收不同的参数, 有不同的效果。即同一个指令，不同的对象去做，会有不同的行为。</p><p>多态的一般前提条件:1.要有继承.2.有方法重写, 不然多态无意义.3.要有父类引用指向子类对象.但在 Python 中，多态更加灵活，归因于Python 动态语言灵活性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 必须有继承 (条件1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Charger</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-comment"># 2. 必须重写 (条件2)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 Type-C 充电...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lightning_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 苹果头 充电...&quot;</span>)<br><br><span class="hljs-comment"># 函数定义必须暗示接收父类类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">charger_obj: Charger</span>): <span class="hljs-comment"># 类型提示只是提示，不强制</span><br>    charger_obj.charge()<br><br><span class="hljs-comment"># 3. 父类引用指向子类 (在Python里变量没有类型，所以这一步是隐式的)</span><br>c1 = TypeC_Charger()<br>power_up(c1)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>:<br>    <span class="hljs-comment"># 没有继承任何父类！</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Type-C 充电中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span>:<br>    <span class="hljs-comment"># 这是一个汉堡，跟充电器没半毛钱关系</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是一个汉堡，但我居然也有 charge 方法！充能中（热量+100）&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-comment"># Python 不管你是什么类，只管你有没有 charge 方法</span><br>    obj.charge() <br><br>t = TypeC_Charger()<br>b = Burger()<br><br>power_up(t) <span class="hljs-comment"># 正常工作</span><br>power_up(b) <span class="hljs-comment"># 居然也正常工作！这就是鸭子类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类解释:<br>        抽象类一般充当父类, 用于指定行业规范, 准则, 具体的实现交由 子类 来完成.</p><h3 id="父类制定标准，子类去实现-思想"><a href="#父类制定标准，子类去实现-思想" class="headerlink" title="父类制定标准，子类去实现(思想)"></a>父类制定标准，子类去实现(思想)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义抽象类, 空调类, 设定: 空调的规则.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC</span>:<br>    <span class="hljs-comment"># 1.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 2. 定义子类(小米空调), 实现父类(空调类)中的所有抽象方法.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-comment"># 2.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制冷技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制热技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米空调 静音左右摆风 技术!&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 4.1 小米空调</span><br>    xm = XiaoMi()<br>    xm.cool_wind()<br>    xm.hot_wind()<br>    xm.swing_l_r()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><h3 id="引入-abc-模块（Abstract-Base-Class）-严谨"><a href="#引入-abc-模块（Abstract-Base-Class）-严谨" class="headerlink" title="引入 abc 模块（Abstract Base Class）(严谨)"></a>引入 <code>abc</code> 模块（Abstract Base Class）(严谨)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 1. 定义抽象类：必须继承 ABC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义抽象方法：加上装饰器 @abstractmethod</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 这里不写具体逻辑，因为不知道怎么付，只占个位</span><br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># ❌ 错误演示：尝试直接创建抽象类对象</span><br><span class="hljs-comment"># p = Payment() </span><br><span class="hljs-comment"># 报错：TypeError: Can&#x27;t instantiate abstract class Payment...</span><br><span class="hljs-comment"># (意思：Payment 是抽象的，是个半成品，不能直接用)</span><br><br><br><span class="hljs-comment"># ✅ 正确演示：子类继承并实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-comment"># 【必须重写】如果不写这个方法，AliPay 也会报错</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;支付宝支付中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;微信支付中...&quot;</span>)<br><br><span class="hljs-comment"># 3. 正常使用</span><br>ali = AliPay()<br>ali.pay()<br></code></pre></td></tr></table></figure><p>在python中，<strong>抽象类（ABC）和接口（Interface）在语法上是同一个东西</strong>。如果你把一个抽象类里的方法全写成空（只有定义没实现），它就是接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 用法 A：当作【接口】用 (全都是抽象方法，没有具体实现)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USBInterface</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 用法 B：当作【抽象类】用 (有一部分共用的代码)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭眼睡觉...&quot;</span>)  <span class="hljs-comment"># 这是一个具体功能</span><br>    <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><hr><h2 id="类属性和对象属性"><a href="#类属性和对象属性" class="headerlink" title="类属性和对象属性"></a>类属性和对象属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># --- 这里是【类属性】 ---</span><br>    <span class="hljs-comment"># 定义在方法外面，这是大家共享的</span><br>    school = <span class="hljs-string">&quot;霍格沃茨魔法学校&quot;</span><br>    count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用来记录一共招生了多少人</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># --- 这里是【实例属性】 ---</span><br>        <span class="hljs-comment"># 定义在 __init__ 里，绑定在 self 上，是个人的</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <br>        <span class="hljs-comment"># 每创建一个学生，班级总人数就 +1</span><br>        <span class="hljs-comment"># 注意：要修改类属性，最好用 类名.属性</span><br>        Student.count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 1. 创建两个学生</span><br>s1 = Student(<span class="hljs-string">&quot;哈利波特&quot;</span>, <span class="hljs-number">11</span>)<br>s2 = Student(<span class="hljs-string">&quot;罗恩&quot;</span>, <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 2. 访问实例属性 (每个人不一样) 只能通过对象访问</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的名字: <span class="hljs-subst">&#123;s1.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 哈利波特</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的名字: <span class="hljs-subst">&#123;s2.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 罗恩</span><br><br><span class="hljs-comment"># 3. 访问类属性 (大家都一样)</span><br><span class="hljs-comment"># 可以通过对象访问，也可以通过类名访问(推荐)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的学校: <span class="hljs-subst">&#123;s1.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的学校: <span class="hljs-subst">&#123;s2.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目前招生人数: <span class="hljs-subst">&#123;Student.count&#125;</span>&quot;</span>) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><hr><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>    属于类的方法, 可以通过类名. 还可以通过对象名. 的方式来调用.<br>    定义类方法的时候, 必须使用装饰器 @classmethod, 且第1个参数必须表示类对象.</p><p>静态方法:<br>    属于该类下所有对象所共享的方法, 可以通过类名. 还可以通过 对象名.的方式来调用.<br>    定义静态方法的时候, 必须使用装饰器 @staticmethod, 且参数传不传都可以.</p><p>区别:<br>       1. 类方法的第1个参数必须是类对象, 静态方法无参数的特殊要求<br>       2. 你可以理解为: 如果函数中要用类对象, 就定义成类方法, 否则定义成静态方法, 除此外并无任何区别.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义学生类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># 2. 定义类属性.</span><br>    school = <span class="hljs-string">&#x27;黑马程序员&#x27;</span><br><br>    <span class="hljs-comment"># 3. 定义类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show1</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cls: <span class="hljs-subst">&#123;cls&#125;</span>&#x27;</span>)        <span class="hljs-comment"># &lt;class &#x27;__main__.Student&#x27;&gt;</span><br>        <span class="hljs-built_in">print</span>(cls.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是类方法&#x27;</span>)<br><br>    <span class="hljs-comment"># 4. 定义静态方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show2</span>():<br>        <span class="hljs-built_in">print</span>(Student.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是静态方法&#x27;</span>)<br><br><span class="hljs-comment"># 5. 测试.</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s1 = Student()<br>    s1.show1()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br>    s1.show2()<br></code></pre></td></tr></table></figure><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包入门"><a href="#闭包入门" class="headerlink" title="闭包入门"></a>闭包入门</h2><p>通常情况下，函数内部的变量是“临时工”，函数执行完，变量就被销毁（内存释放）了。</p><p>但是<strong>闭包</strong>不同，它可以让一个函数<strong>把外部的变量“打包带走”</strong>。即使外部函数已经执行完了，内部函数依然能访问并使用那个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 外部函数 (工厂)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">config_greeting</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-comment"># msg 是外部函数的变量 (零件)</span><br>    <br>    <span class="hljs-comment"># 2. 内部函数 (工人)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-comment"># 3. 内部使用了外部变量 msg</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;msg&#125;</span>, <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 返回内部函数 (工人背着零件走了)</span><br>    <span class="hljs-keyword">return</span> printer<br><br><span class="hljs-comment"># --- 关键看这里 ---</span><br><br><span class="hljs-comment"># 创建一个闭包实例：配置为 &quot;Hello&quot;</span><br>say_hello = config_greeting(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-comment"># 此时，config_greeting 函数其实已经运行结束了！</span><br><span class="hljs-comment"># 按理说变量 &quot;Hello&quot; 应该从内存消失，但它被 printer 抓住了。</span><br><br><span class="hljs-comment"># 创建另一个闭包实例：配置为 &quot;你好&quot;</span><br>say_nihao = config_greeting(<span class="hljs-string">&quot;你好&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br>say_hello(<span class="hljs-string">&quot;张三&quot;</span>)  <span class="hljs-comment"># 输出：Hello, 张三</span><br>say_nihao(<span class="hljs-string">&quot;李四&quot;</span>)  <span class="hljs-comment"># 输出：你好, 李四</span><br></code></pre></td></tr></table></figure><h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><p><code>nonlocal</code> 的作用是：<strong>允许内部函数修改外部函数（闭包）中的变量</strong>。</p><p>Python 有一个保护机制：如果你在函数内部给一个变量赋值（比如 <code>a = 10</code>），Python 默认会认为这只是一个<strong>全新的局部变量</strong>，跟外面的那个 <code>a</code> 没关系。</p><p>这就导致了一个问题：如果想<strong>修改</strong>外面的变量，而不是<strong>新建</strong>一个，程序会报错或者不符合预期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>        <span class="hljs-comment"># 【关键】声明：我要修改外面的那个 count！</span><br>        <span class="hljs-keyword">nonlocal</span> count <br>        <br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前计数: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>        <br>    <span class="hljs-keyword">return</span> adder<br><br>c = make_counter()<br>c()  <span class="hljs-comment"># 输出：当前计数: 1</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 2</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 3</span><br></code></pre></td></tr></table></figure><p>问：<code>nonlocal</code> vs <code>global</code> 的区别？</p><p><strong><code>global</code></strong>：</p><ul><li>用于修改<strong>全局变量</strong>（整个模块级别的）。</li><li>它是去<strong>最外层</strong>找变量。</li></ul><p><strong><code>nonlocal</code></strong>：</p><ul><li>用于修改<strong>嵌套函数中的变量</strong>（闭包里的）。</li><li>它是去<strong>上一层（或上上层）函数找变量，但绝不</strong>去全局找。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全局变量</span><br>score = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_score</span>():<br>    <span class="hljs-comment"># 【声明】：我要用的这个 score 是全局那个！不是新建的！</span><br>    <span class="hljs-keyword">global</span> score<br>    <br>    score += <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;游戏得分！&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 0</span><br><br>add_score()<br>add_score()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 200 (真的被改掉了)</span><br></code></pre></td></tr></table></figure><hr><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><p><strong>装饰器本质上就是一个闭包，它的作用是在不修改原函数代码的前提下，给原函数“增加新功能”</strong></p><p><strong>核心原则：开放封闭原则 (Open-Closed Principle)</strong></p><ul><li><strong>封闭</strong>：对修改源代码封闭（不要动原来的代码）</li><li><strong>开放</strong>：对扩展功能开放（想加日志、想加权限验证，随便加）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 接收一个函数作为参数 (外部函数)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_gift</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义内部函数 (包装纸)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 🎁 正在包装礼物...&quot;</span>)<br>        <span class="hljs-comment"># 3. 调用原函数 (放入礼物)</span><br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; ✅ 礼物已发出！&quot;</span>)<br>        <br>    <span class="hljs-comment"># 4. 返回内部函数</span><br>    <span class="hljs-keyword">return</span> wrapper<br>    <br>    <br><span class="hljs-comment"># 写法 A：原函数</span><br><span class="hljs-meta">@add_gift  </span><span class="hljs-comment"># &lt;--- 这就是装饰器语法，相当于给 buy_shoe 穿了层衣服</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_shoe</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一双球鞋&quot;</span>)<br><br><span class="hljs-meta">@add_gift</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_phone</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一台手机&quot;</span>)<br><br><span class="hljs-comment"># --- 运行测试 ---</span><br><br><span class="hljs-comment"># 当你调用 buy_shoe 时，其实你运行的是 wrapper！</span><br>buy_shoe()<br></code></pre></td></tr></table></figure><h2 id="带参数和返回值"><a href="#带参数和返回值" class="headerlink" title="带参数和返回值"></a>带参数和返回值</h2><p>例子虽然简单，但有两个致命的缺陷：</p><ol><li><strong>传参限制</strong>：如果原函数需要参数（比如 <code>buy_shoe(&quot;耐克&quot;)</code>），之前的 <code>wrapper()</code> 没定义参数，一调就报错。</li><li><strong>吞噬返回值</strong>：如果原函数有 <code>return</code>，之前的 <code>wrapper()</code> 没有把结果返回出来，导致外界拿到的是 <code>None</code>。</li></ol><p><strong>装饰器的内部函数格式要和被装饰的原函数 保持一致,即: 原函数是无参无返回的, 则装饰器的内部函数也必须是无参无返回的.原函数有参有返回的, 则装饰器的内部函数也必须是有参有返回的.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-comment"># 1. 【万能参数】：*args, **kwargs</span><br>    <span class="hljs-comment"># 不管原函数传什么参数（一个、两个、关键字参数），我全都能接住</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 正在进行权限核对...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 2. 【调用原函数】并【接收返回值】</span><br>        <span class="hljs-comment"># 把刚才接住的参数，原封不动地传给原函数</span><br>        result = func(*args, **kwargs)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 核对完毕，放行。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 3. 【返回结果】</span><br>        <span class="hljs-comment"># 这一步如果不写，外界拿到的就是 None</span><br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 A：有参数，无返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">food, drink</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在吃<span class="hljs-subst">&#123;food&#125;</span>，喝<span class="hljs-subst">&#123;drink&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 场景 B：有参数，有返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_sum</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在努力计算中...&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 测试 eat (两个参数)</span><br>eat(<span class="hljs-string">&quot;火锅&quot;</span>, <span class="hljs-string">&quot;可乐&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在吃火锅，喝可乐</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 2. 测试 calculate_sum (有返回值)</span><br>res = calculate_sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在努力计算中...</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><span class="hljs-comment"># 计算结果是: 30  &lt;-- 如果 wrapper 没写 return，这里就是 None</span><br></code></pre></td></tr></table></figure><p><strong>args和kwargs<code>就像是一个弹性收纳袋，无论扔进来多少个参数，wrapper 都能收下，然后再原封不动地传递给</code>func</strong></p><p>万能公式 &#x3D; 闭包 + <code>*args/**kwargs</code> + <code>return</code></p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>要在装饰器里传参数，需要在原本的装饰器外面，<strong>再包一层函数</strong>。</p><ul><li><strong>第一层 (最外面)</strong>：负责接收<strong>装饰器的参数</strong>（比如 “ERROR”）。管它叫“装饰器工厂”。</li><li><strong>第二层 (中间层)</strong>：负责接收<strong>被修饰的函数</strong>（<code>func</code>）。这才是真正的装饰器。</li><li><strong>第三层 (最里面)</strong>：负责接收<strong>函数的参数</strong>（<code>*args</code>）。这是具体的干活逻辑（Wrapper）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># --- 第一层：工厂层 (负责接收 level 参数) ---</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">level</span>):<br>    <br>    <span class="hljs-comment"># --- 第二层：装饰器层 (负责接收 func) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <br>        <span class="hljs-comment"># --- 第三层：Wrapper层 (负责接收 func 的参数) ---</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 正在启动功能...&quot;</span>) <span class="hljs-comment"># 这里用到了第一层的变量</span><br>            <br>            <span class="hljs-comment"># 调用原函数</span><br>            result = func(*args, **kwargs)<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 执行结束。&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <br>        <span class="hljs-keyword">return</span> wrapper <span class="hljs-comment"># 返回第三层</span><br>    <br>    <span class="hljs-keyword">return</span> decorator <span class="hljs-comment"># 返回第二层</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 1：普通操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;INFO&quot;</span></span>) </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_page</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打开网页...&quot;</span>)<br><br><span class="hljs-comment"># 场景 2：危险操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;DANGER&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删库跑路...&quot;</span>)<br><br><span class="hljs-comment"># --- 运行 ---</span><br>open_page()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [INFO] 正在启动功能...</span><br><span class="hljs-comment"># 打开网页...</span><br><br>delete_db()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [DANGER] 正在启动功能...</span><br><span class="hljs-comment"># 删库跑路...</span><br></code></pre></td></tr></table></figure><p><strong>FastAPI</strong> 和 <strong>Django</strong> 中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)  </span><span class="hljs-comment"># 传了参数 &quot;/users&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(): ...<br></code></pre></td></tr></table></figure><p>这里 <code>@app.get</code> 就是一个带参数的装饰器，它记录了 URL 路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@permission_required(<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span></span>) </span><span class="hljs-comment"># 传了参数 &quot;admin&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(): ...<br></code></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>用了装饰器后，原函数的名字（<code>__name__</code>）会变成 <code>wrapper</code>，这在调试时很不方便</p><p>先看没有 <code>wraps</code> 时会发生什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 见证“身份被窃” ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 函数的名字是: wrapper   &lt;-- 糟糕！原本叫 login，现在变成 wrapper 了</span><br><span class="hljs-comment"># 函数的说明是: None      &lt;-- 糟糕！原本写的注释说明也没了</span><br></code></pre></td></tr></table></figure><p><strong>为什么会这样？</strong> 因为 <code>login = my_decorator(login)</code>，现在的 <code>login</code> 变量实际上指向的是那个内部函数 <code>wrapper</code>。所以你打印的自然是 <code>wrapper</code> 的名字。</p><p>Python 标准库提供了一个神器 <code>@functools.wraps</code>。它的作用是：<strong>自动把原函数（func）的元数据（名字、注释文档等）拷贝给 wrapper。</strong></p><p>这就是所谓的“伪装”：让 wrapper 看起来跟原函数一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools  <span class="hljs-comment"># 1. 导入模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 【关键】在定义 wrapper 之前，加上这行代码</span><br>    <span class="hljs-comment"># 意思是：把 func 的身份证信息贴到 wrapper 脑门上</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>) </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 再次查验身份 ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 函数的名字是: login</span><br><span class="hljs-comment"># 函数的说明是: 这是登录系统的核心函数</span><br></code></pre></td></tr></table></figure><p>为什么这很关键？</p><p>在简单的脚本里确实没关系，但在<strong>框架开发</strong>中这是致命的：</p><ol><li><strong>FastAPI &#x2F; Django 生成文档</strong>：<ul><li>FastAPI 会自动读取函数名和 docstring 来生成 Swagger 接口文档。</li><li>如果你用了装饰器但没加 <code>wraps</code>，FastAPI 看到的函数全叫 <code>wrapper</code>，文档里的接口说明也会全都变成空白。API 文档瞬间就废了。</li></ul></li><li><strong>自动化测试框架</strong>：<ul><li>在 Pytest 或 Unittest 中，测试报告通常会显示“正在执行 xxxx 用例”。</li><li>如果不加 <code>wraps</code>，测试报告里可能会显示“正在执行 wrapper”，根本不知道崩的是哪个用例。</li></ul></li></ol><hr><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h2><p>赋值操作（<code>=</code>）永远只是复制了对象的引用（内存地址），而没有复制对象本身,即仅仅是多了一个指向同一个内存地址的指针</p><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image2.png" class="" title="普通赋值"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="浅拷贝可变类型"><a href="#浅拷贝可变类型" class="headerlink" title="浅拷贝可变类型"></a>浅拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image3.png" class="" title="浅拷贝可变类型"><p>可以清晰地看出，浅拷贝拷贝可变类型，只拷贝第一层</p><h3 id="浅拷贝不可变类型"><a href="#浅拷贝不可变类型" class="headerlink" title="浅拷贝不可变类型"></a>浅拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image4.png" class="" title="浅拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），浅拷贝（copy）等同于赋值（&#x3D;），根本不会创建新对象！</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="深拷贝可变类型"><a href="#深拷贝可变类型" class="headerlink" title="深拷贝可变类型"></a>深拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image5.png" class="" title="深拷贝可变类型"><p>深拷贝拷贝可变类型，则会拷贝所有可变类型的层。</p><h3 id="深拷贝不可变类型"><a href="#深拷贝不可变类型" class="headerlink" title="深拷贝不可变类型"></a>深拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image6.png" class="" title="深拷贝不可变类型"><p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），深拷贝（deepcopy）等同于赋值（&#x3D;），根本不会创建新对象！</p><hr><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>简单来说，网络编程就是让<strong>两台计算机（或者同一台电脑上的两个程序）互相说话</strong>。网络编程其实就是：<strong>IP 定位电脑 + Port 定位程序 + TCP&#x2F;UDP 定位规则</strong>。</p><p>为了实现“说话”，必须解决三个核心问题：</p><ol><li><strong>找人</strong>：去哪里找对方？（IP 地址）</li><li><strong>找门</strong>：找到电脑后，跟哪个软件说话？（端口号 Port）</li><li><strong>怎么说</strong>：用什么规则交流？（协议 Protocol）</li></ol><hr><h3 id="1-找人：IP-地址-IP-Address"><a href="#1-找人：IP-地址-IP-Address" class="headerlink" title="1. 找人：IP 地址 (IP Address)"></a>1. 找人：IP 地址 (IP Address)</h3><p>IP 地址就是计算机在网络世界的**“门牌号”**。</p><ul><li><strong>公网 IP</strong>：比如百度的 IP，全世界都能访问。</li><li><strong>局域网 IP</strong>：比如 <code>192.168.1.5</code>，只有你家路由器下面的设备能互访。</li><li><strong>本机 IP</strong>：<code>127.0.0.1</code>（有个别名叫 <code>localhost</code>），特指“我自己”。做测试开发时先在本地部署服务，用的就是这个 IP。</li></ul><hr><h3 id="2-找门：端口号-Port"><a href="#2-找门：端口号-Port" class="headerlink" title="2. 找门：端口号 (Port)"></a>2. 找门：端口号 (Port)</h3><p>找到电脑（IP）后，电脑里运行着几十个程序（微信、QQ、浏览器、你的测试脚本）。消息发给谁呢？</p><p>这就需要端口号。它就像是这栋大楼里的**“房间号”**。</p><ul><li><strong>端口范围</strong>：0 - 65535。</li><li><strong>知名端口</strong>（不要去占用）：<ul><li><code>80</code>: 网页浏览 (HTTP)</li><li><code>443</code>: 加密网页 (HTTPS)</li><li><code>3306</code>: MySQL 数据库</li></ul></li><li><strong>动态端口</strong>：我们写程序时，一般使用 1024 之后的端口（比如 8000, 8080, 9999），避免和系统冲突。</li></ul><hr><h3 id="3-怎么说：通信协议-Protocol"><a href="#3-怎么说：通信协议-Protocol" class="headerlink" title="3. 怎么说：通信协议 (Protocol)"></a>3. 怎么说：通信协议 (Protocol)</h3><p>找到了人，也敲开了门，接下来怎么交流？</p><p>在传输层（Transport Layer），最著名的两位“大佬”是 TCP 和 UDP。它们的性格截然不同：</p><h4 id="A-TCP-协议-Transmission-Control-Protocol-——-“打电话”"><a href="#A-TCP-协议-Transmission-Control-Protocol-——-“打电话”" class="headerlink" title="A. TCP 协议 (Transmission Control Protocol) —— “打电话”"></a>A. TCP 协议 (Transmission Control Protocol) —— “打电话”</h4><ul><li><strong>性格</strong>：严谨、靠谱、慢热。</li><li><strong>特点</strong>：<strong>面向连接</strong>。<ul><li>在发数据前，必须先建立连接（著名的<strong>三次握手</strong>）。</li><li>发出去的数据，对方必须确认收到（ACK）。如果没收到，我会重发。</li><li>保证数据顺序不错乱。</li></ul></li><li><strong>应用</strong>：网页访问 (HTTP)、文件传输、邮件、接口自动化（绝大多数接口测试测的都是基于 TCP 的 HTTP）。</li></ul><h4 id="B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”"><a href="#B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”" class="headerlink" title="B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”"></a>B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”</h4><ul><li><strong>性格</strong>：豪爽、快、不负责任。</li><li><strong>特点</strong>：<strong>无连接</strong>。<ul><li>想发就发，不需要建立连接。</li><li>发出去就不管了，对方收没收到我不知道，也不重发。</li><li>可能会丢包，顺序可能会乱。</li></ul></li><li><strong>应用</strong>：视频会议、在线直播、王者荣耀（卡顿一下没关系，只要实时性高就行）。</li></ul><hr><h3 id="4-Python-的工具：socket"><a href="#4-Python-的工具：socket" class="headerlink" title="4. Python 的工具：socket"></a>4. Python 的工具：socket</h3><p>在 Python 中，实现网络编程主要靠 socket (套接字) 模块。</p><p>把 socket 想象成是一个**“电话机”**。</p><ul><li><strong>服务端 (Server)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>插上电话线，绑定号码 (bind IP &amp; Port)。</li><li>守在电话旁等铃声 (listen)。</li><li>接电话 (accept)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li><li><strong>客户端 (Client)</strong>：<ol><li>买个电话 (创建 socket)。</li><li>拨号 (connect IP &amp; Port)。</li><li>说话&#x2F;听话 (send&#x2F;recv)。</li></ol></li></ul><hr><h2 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image7.png" class="" title="网络编程"><p>这张图是 <strong>TCP 网络编程中最经典、最标准的核心流程图</strong>。</p><hr><h3 id="1-右侧：TCP-服务器-Server-——-“客服中心”"><a href="#1-右侧：TCP-服务器-Server-——-“客服中心”" class="headerlink" title="1. 右侧：TCP 服务器 (Server) —— “客服中心”"></a>1. 右侧：TCP 服务器 (Server) —— “客服中心”</h3><p>服务器必须先启动，坐在那儿等着被撩。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>首先需要有一个通信工具。在代码中就是创建一个套接字对象。</li></ul></li><li><strong>插卡&#x2F;定号码 (<code>bind(IP, 端口号)</code>)</strong><ul><li>手机买好了，你得告诉大家你的号码是多少（IP），以及大家打进来找哪个部门（端口号，比如 8080）。</li><li>如果不绑定，别人根本找不到你。</li></ul></li><li><strong>开机&#x2F;设置排队 (<code>listen(最大监听数)</code>)</strong><ul><li><strong>开机</strong>：让端口处于“监听状态”，准备接客。</li><li><strong>最大监听数</strong>：相当于客服系统的“排队上限”。如果同时有 100 个人打进来，但我设了 5，那第 6 个人就会听到“正在通话中”。</li></ul></li><li><strong>等待接听 (<code>accept()</code>) —— 关键步骤！</strong><ul><li>图中有个蓝字解释非常重要：<strong>“等待监听，会返回 1 个元组 (负责和客户端交互的 socket, 客户端信息)”</strong>。</li><li><strong>阻塞 (Blocking)</strong>：代码运行到这儿会<strong>停住</strong>（卡住），直到有电话打进来。</li><li><strong>分身术</strong>：这是新手最容易晕的地方。<code>accept</code> 收到请求后，会<strong>专门分配一个新的分身 socket</strong> 去跟这个客户一对一聊天。原来的主 socket 继续回到 <code>listen</code> 状态等下一个电话。</li></ul></li><li><strong>收发数据 (<code>recv() / send()</code>)</strong><ul><li>图中的箭头展示了数据的流向：服务器先接收请求，处理完后，再发送响应。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>聊完了，释放资源。</li></ul></li></ol><hr><h3 id="2-左侧：TCP-客户端-Client-——-“打电话的人”"><a href="#2-左侧：TCP-客户端-Client-——-“打电话的人”" class="headerlink" title="2. 左侧：TCP 客户端 (Client) —— “打电话的人”"></a>2. 左侧：TCP 客户端 (Client) —— “打电话的人”</h3><p>客户端就比较主动了。</p><ol><li><strong>买个手机 (<code>socket()</code>)</strong><ul><li>同样先创建一个 socket 对象。</li></ul></li><li><strong>拨号 (<code>connect(IP, 端口号)</code>)</strong><ul><li><strong>三次握手</strong>：也就是图中间写的“连接建立”。</li><li>这一步如果成功，就说明电话通了；如果失败（比如服务器没开），程序就会直接报错 <code>ConnectionRefusedError</code>。</li></ul></li><li><strong>发收数据 (<code>send() / recv()</code>)</strong><ul><li>注意箭头方向：客户端通常是<strong>先说话</strong>（发送请求 <code>send</code>），然后<strong>等着听</strong>（接收响应 <code>recv</code>）。</li></ul></li><li><strong>挂断 (<code>close()</code>)</strong><ul><li>打完收工。</li></ul></li></ol><hr><h3 id="3-图中的三个“隐藏细节”"><a href="#3-图中的三个“隐藏细节”" class="headerlink" title="3. 图中的三个“隐藏细节”"></a>3. 图中的三个“隐藏细节”</h3><p>这张图里有几行不起眼的小字，但这恰恰是写代码时最容易踩坑的地方：</p><ol><li><strong>“二进制传输” (绿色字)</strong><ul><li>网络不认识中文，也不认识字符串。</li><li><strong>潜台词</strong>：你在 Python 里 <code>send(&quot;你好&quot;)</code> 是会报错的！必须 <code>send(&quot;你好&quot;.encode(&quot;utf-8&quot;))</code>，把它变成 <code>bytes</code> 类型才能传。</li></ul></li><li><strong>“一直阻塞到客户连接到达”</strong><ul><li>这就是 <code>accept()</code> 的特性。如果没人连你，你的程序就会像死机一样停在那一行不动。</li></ul></li><li><strong>交互逻辑 (<code>send</code> 对 <code>recv</code>)</strong><ul><li>看图中间的横向箭头：<ul><li>客户端的 <code>send()</code> 数据流向 -&gt; 服务器的 <code>recv()</code>。</li><li>服务器的 <code>send()</code> 数据流向 -&gt; 客户端的 <code>recv()</code>。</li></ul></li><li>如果两边同时写 <code>recv()</code>，就会发生<strong>死锁</strong>（俩人都在等对方先说话，结果谁也不理谁）。</li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这张图就是 TCP 代码的<strong>骨架</strong>。</p><ul><li><strong>Server</strong>: <code>socket</code> -&gt; <code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code> (循环) -&gt; <code>recv/send</code> -&gt; <code>close</code></li><li><strong>Client</strong>: <code>socket</code> -&gt; <code>connect</code> -&gt; <code>send/recv</code> -&gt; <code>close</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机 (创建 socket 对象)</span><br><span class="hljs-comment"># AF_INET: 使用 IPv4</span><br><span class="hljs-comment"># SOCK_STREAM: 使用 TCP 协议</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 插卡 (绑定 IP 和 端口)</span><br><span class="hljs-comment"># &#x27;127.0.0.1&#x27; 代表本机</span><br>server_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 开机 (监听)</span><br>server_socket.listen(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 客服中心已启动，正在等待客户电话...&quot;</span>)<br><br><span class="hljs-comment"># 4. 等待接听 (accept) -- 程序会卡在这里直到有人连接</span><br><span class="hljs-comment"># client_sock: 专门负责跟这个客户聊天的分身 socket</span><br><span class="hljs-comment"># addr: 客户的 IP 地址</span><br>client_sock, addr = server_socket.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 电话通了！客户地址: <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 接收消息 (recv) -- 对应图中的第一对 send/recv</span><br><span class="hljs-comment"># 注意：网络传输必须用 bytes，所以要 decode 解码</span><br>data = client_sock.recv(<span class="hljs-number">1024</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客户消息: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 6. 发送回复 (send) -- 对应图中的第二对 send/recv</span><br>msg = <span class="hljs-string">&quot;你好，我是客服小冰，很高兴为您服务！&quot;</span><br>client_sock.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 必须 encode 转成二进制</span><br><br><span class="hljs-comment"># 7. 挂断</span><br>client_sock.close()<br>server_socket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 拨号 (连接服务器)</span><br><span class="hljs-comment"># 必须和服务器的 IP、端口一致</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 先说话 (send)</span><br>msg = <span class="hljs-string">&quot;你好，我要查余额&quot;</span><br>client_socket.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 4. 等回复 (recv)</span><br>data = client_socket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客服回复: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 挂断</span><br>client_socket.close()<br></code></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="1-核心概念：进程-vs-线程"><a href="#1-核心概念：进程-vs-线程" class="headerlink" title="1. 核心概念：进程 vs 线程"></a>1. 核心概念：进程 vs 线程</h3><ul><li><strong>进程 (Process)</strong>：<ul><li><strong>定义</strong>：资源分配的最小单位。</li><li><strong>比喻</strong>：一个独立运行的 <code>.exe</code> 程序，比如 QQ</li><li><strong>特点</strong>：每个进程都有自己独立的内存空间，互不干扰。QQ 崩了，不会影响微信。</li><li><strong>开销</strong>：创建和销毁都很慢，像盖工厂一样费劲。</li></ul></li><li><strong>线程 (Thread)</strong>：<ul><li><strong>定义</strong>：CPU 调度的最小单位。</li><li><strong>比喻</strong>：<strong>工厂里的工人</strong>。</li><li><strong>特点</strong>：<ul><li>一个进程（工厂）里至少有一个线程（老板自己干活），也可以有多个线程（雇了 10 个工人）。</li><li><strong>共享资源</strong>：所有线程都在同一个工厂里，共用同一个食堂、同一个厕所（共享内存）。这就带来了“争抢资源”的问题</li></ul></li><li><strong>开销</strong>：创建非常快，像招个临时工一样简单。</li></ul></li></ul><hr><h3 id="2-串行、并发、并行"><a href="#2-串行、并发、并行" class="headerlink" title="2. 串行、并发、并行"></a>2. 串行、并发、并行</h3><ul><li><strong>串行 (Serial)</strong>：<ul><li><strong>模式</strong>：一个一个来。</li><li><strong>例子</strong>：你去排队打饭，前一个人没打完，你只能干等。</li></ul></li><li><strong>并发 (Concurrency) —— Python 多线程主要属于这种</strong>：<ul><li><strong>模式</strong>：<strong>假装</strong>同时在做。其实是 CPU 切换得太快了，让你产生了错觉。</li><li><strong>例子</strong>：你一边吃饭一边回微信。其实你不能同时把饭送进嘴里又同时打字。你是“吃一口饭 -&gt; 放下筷子回两句 -&gt; 再吃一口”。因为切换速度极快，看起来像是同时进行的。</li></ul></li><li><strong>并行 (Parallelism)</strong>：<ul><li><strong>模式</strong>：<strong>真正</strong>同时在做。</li><li><strong>例子</strong>：你用左手拿勺子喝汤，你朋友坐在对面用右手拿筷子吃面。你俩互不干扰，真正的同时进行（这通常需要多核 CPU 支持）。</li></ul></li></ul><hr><h3 id="3-Python-多线程的“阿喀琉斯之踵”：GIL-锁"><a href="#3-Python-多线程的“阿喀琉斯之踵”：GIL-锁" class="headerlink" title="3. Python 多线程的“阿喀琉斯之踵”：GIL 锁"></a>3. Python 多线程的“阿喀琉斯之踵”：GIL 锁</h3><p>在 Python 中谈多线程，必须得提 <strong>GIL (Global Interpreter Lock，全局解释器锁)</strong>。</p><ul><li><strong>现象</strong>：因为有 GIL 的存在，Python 的多线程在<strong>同一时刻，只能有一个线程在 CPU 上运行</strong>。</li><li><strong>后果</strong>：<ul><li>Python 的多线程是 <strong>“伪多线程”</strong>（针对 CPU 密集型任务）。哪怕你是 8 核 CPU，Python 多线程也只能用 1 个核。</li></ul></li><li><strong>那多线程还有用吗？</strong><ul><li><strong>非常有用！</strong> 但要分场景：</li><li><strong>计算密集型（CPU Bound）</strong>：比如视频解码、科学计算。<strong>（Python 多线程没用，反而更慢，因为要频繁切换）</strong>。</li><li><strong>IO 密集型（IO Bound）</strong>：比如 <strong>爬虫、接口请求、读写文件</strong>。<strong>（Python 多线程神器！）</strong><ul><li><strong>原因</strong>：当线程 A 去请求网络（IO 操作）时，它处于“等待”状态（不占 CPU），Python 会立刻释放 GIL 锁，让线程 B 赶紧去干活。这样就利用了等待的时间。</li></ul></li></ul></li></ul><hr><h2 id="多线程示例"><a href="#多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image8.png" class="" title="多线程"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟网络延迟，耗时1秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_single</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 依次调用 5 次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        download(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>)<br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[单线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_single()<br>    <br>    <br><span class="hljs-comment"># 开始下载: 图片_1.jpg</span><br><span class="hljs-comment"># ... (等1秒)</span><br><span class="hljs-comment"># 下载完成: 图片_1.jpg</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># [单线程] 总耗时: 5.02 秒</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_multi</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 用来存放所有线程对象的列表</span><br>    threads = []<br>    <br>    <span class="hljs-comment"># 1. 创建并启动线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># target: 指定要干什么活 (函数名)</span><br>        <span class="hljs-comment"># args: 指定参数 (注意必须是元组，如果是1个参数后面要加逗号)</span><br>        t = threading.Thread(target=download, args=(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>,))<br>        <br>        <span class="hljs-comment"># 启动线程！(相当于告诉工人：开始干活！)</span><br>        t.start()<br>        <br>        <span class="hljs-comment"># 把工人的名字记下来</span><br>        threads.append(t)<br>        <br>    <span class="hljs-comment"># 2. 等待所有线程结束 (这一步至关重要！)</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join() <br>        <span class="hljs-comment"># join的意思是：主程序(老板)在这里等着，直到这个线程(工人)干完活才能往下走</span><br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[多线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_multi()<br>    <br><span class="hljs-string">&quot;&quot;&quot;   </span><br><span class="hljs-string">开始下载: 图片_1.jpg</span><br><span class="hljs-string">开始下载: 图片_2.jpg</span><br><span class="hljs-string"><span class="hljs-meta">... </span>(几乎同时打印)</span><br><span class="hljs-string">下载完成: 图片_1.jpg</span><br><span class="hljs-string">...</span><br><span class="hljs-string">[多线程] 总耗时: 1.01 秒</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="A-t-start-vs-t-run"><a href="#A-t-start-vs-t-run" class="headerlink" title="A. t.start() vs t.run()"></a>A. <code>t.start()</code> vs <code>t.run()</code></h4><ul><li><strong><code>start()</code></strong>: <strong>正确写法</strong>。它会向操作系统申请一个新的线程，并在新线程里执行代码（真正的并发）。</li><li><strong><code>run()</code></strong>: <strong>错误写法</strong>。它只是把函数当普通函数调用了一遍，还在主线程里跑，根本没有多线程效果。</li></ul><h4 id="B-t-join-为什么要写？"><a href="#B-t-join-为什么要写？" class="headerlink" title="B. t.join() 为什么要写？"></a>B. <code>t.join()</code> 为什么要写？</h4><p>如果把 <code>join</code> 那段循环删掉，会发现程序会在 <strong>0.00秒</strong> 就打印“总耗时”，然后才慢慢打印“下载完成”。</p><ul><li><strong>原因</strong>：Python 的主线程（老板）启动完子线程（工人）后，默认是<strong>不等的</strong>。工人还在下载，老板已经把最后一句 <code>print(总耗时)</code> 执行完了。</li><li><strong>作用</strong>：<code>join()</code> 就像是设了一个<strong>关卡</strong>：“所有人都得在这儿集合！谁没干完，主程序就不准结束！”</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>使用原始的 <code>threading</code> 模块有两个大麻烦：</p><ol><li><strong>管理麻烦</strong>：如果有 1000 个任务，你不能真的启动 1000 个线程（CPU 切换会累死，内存会爆）。你需要控制<strong>最大并发数</strong>（比如只允许同时有 5 个人干活，后面的人排队）。</li><li><strong>拿结果麻烦</strong>：<code>threading.Thread</code> 很难获取函数的<strong>返回值</strong>。你不知道工人干得怎么样，只能靠改全局变量或用队列，很丑陋。</li></ol><p><strong>线程池完美解决了这两个问题。 核心模块：<code>concurrent.futures</code></strong></p><h4 id="实战代码-1：最常用的-submit-方式（灵活控制）"><a href="#实战代码-1：最常用的-submit-方式（灵活控制）" class="headerlink" title="实战代码 1：最常用的 submit 方式（灵活控制）"></a>实战代码 1：最常用的 <code>submit</code> 方式（灵活控制）</h4><p>这种方式适合：任务参数各不相同，或者你需要实时处理每个完成的任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 模拟一个有返回值的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">name, seconds</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔴 [开始] <span class="hljs-subst">&#123;name&#125;</span> 需要 <span class="hljs-subst">&#123;seconds&#125;</span>秒&quot;</span>)<br>    time.sleep(seconds)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;name&#125;</span> 下载成功！&quot;</span>  <span class="hljs-comment"># 这里有返回值！</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># max_workers=3: 也就是虽然我有 5 个任务，但公司只有 3 个工位</span><br>    <span class="hljs-comment"># 剩下 2 个任务得在外面排队，等有人干完了才能进</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 1. 提交任务 (submit)</span><br>        <span class="hljs-comment"># 这里的 task1, task2 是 &quot;未来对象&quot; (Future)，代表一个将来的结果</span><br>        all_tasks = [<br>            pool.submit(download, <span class="hljs-string">&quot;电影A&quot;</span>, <span class="hljs-number">2</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;图片B&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;小说C&quot;</span>, <span class="hljs-number">3</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;音乐D&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;文件E&quot;</span>, <span class="hljs-number">2</span>)<br>        ]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 任务已全部提交，正在排队执行中...\n&quot;</span>)<br><br>        <span class="hljs-comment"># 2. 获取结果 (as_completed)</span><br>        <span class="hljs-comment"># 谁先干完，谁先返回。不用傻傻地按顺序等。</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(all_tasks):<br>            result = future.result() <span class="hljs-comment"># 【关键】获取函数的返回值</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="实战代码-2：极简的-map-方式（批量处理）"><a href="#实战代码-2：极简的-map-方式（批量处理）" class="headerlink" title="实战代码 2：极简的 map 方式（批量处理）"></a>实战代码 2：极简的 <code>map</code> 方式（批量处理）</h4><p>这种方式适合：任务逻辑完全一样，只是参数不同（比如给 100 个 URL 列表发请求）。它的写法跟 Python 自带的 <code>map</code> 一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_url</span>(<span class="hljs-params">url</span>):<br>    time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 模拟请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;url&#125;</span>] 状态码: 200&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_map</span>():<br>    urls = [<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-string">&quot;www.google.com&quot;</span>, <span class="hljs-string">&quot;www.python.org&quot;</span>]<br>    <br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 一行代码搞定批量提交 + 结果按顺序返回</span><br>        <span class="hljs-comment"># 注意：这里的结果是严格按照 urls 列表的顺序返回的</span><br>        results = pool.<span class="hljs-built_in">map</span>(check_url, urls)<br>        <br>        <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> results:<br>            <span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_map()<br></code></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul><li><strong>可迭代对象 (Iterable)</strong>：<ul><li><strong>含义</strong>：具有“被遍历能力”的数据。</li><li><strong>例子</strong>：<code>list</code>, <code>tuple</code>, <code>str</code>, <code>dict</code>。</li><li><strong>特征</strong>：内部实现了 <code>__iter__</code> 方法。它本身不记录位置，需要转化成迭代器才能用 <code>next()</code>。</li></ul></li><li><strong>迭代器 (Iterator)</strong>：<ul><li><strong>含义</strong>：正在执行遍历动作的那个“指针”。</li><li><strong>例子</strong>：<code>iter(list)</code> 后的结果。</li><li><strong>特征</strong>：同时实现了 <code>__iter__</code> 和 <strong><code>__next__</code></strong> 方法。</li></ul></li></ul><p><code>for x in [1, 2, 3]</code>，其实 Python 偷偷做了三件事：</p><ol><li>调用 <code>iter()</code> 把列表变成迭代器。</li><li>不断调用 <code>next()</code> 获取下一个值。</li><li>遇到 <code>StopIteration</code> 异常时，停止循环。</li></ol><p>手动模拟一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 这是一个可迭代对象 (Iterable)</span><br>my_list = [<span class="hljs-string">&quot;接口A&quot;</span>, <span class="hljs-string">&quot;接口B&quot;</span>, <span class="hljs-string">&quot;接口C&quot;</span>]<br><br><span class="hljs-comment"># ❌ 直接 next(my_list) 会报错，因为它还不是迭代器</span><br><br><span class="hljs-comment"># 2. 变成迭代器 (Iterator)</span><br><span class="hljs-comment"># 这一步相当于给薯片筒装上了弹簧，可以往外弹了</span><br>my_iterator = <span class="hljs-built_in">iter</span>(my_list)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;迭代器长这样: <span class="hljs-subst">&#123;my_iterator&#125;</span>&quot;</span>) <br><span class="hljs-comment"># &lt;list_iterator object at 0x...&gt;</span><br><br><span class="hljs-comment"># 3. 手动调用 next()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口A</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口B</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口C</span><br><br><span class="hljs-comment"># 4. 再拿一次？</span><br><span class="hljs-comment"># print(next(my_iterator)) </span><br><span class="hljs-comment"># 报错！StopIteration (薯片吃完了)</span><br></code></pre></td></tr></table></figure><p>要在 Python 中创建一个自定义的迭代器类，需要实现两个魔术方法：</p><ul><li><code>__iter__(self)</code>: 返回自己。</li><li><code>__next__(self)</code>: 返回下一个数据，或者抛出 <code>StopIteration</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_num</span>):<br>        <span class="hljs-variable language_">self</span>.max_num = max_num<br>        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 1. 必须有这个，表明我是可迭代的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-comment"># 2. 必须有这个，定义“下一次”返回什么</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 只要没超标，就返回新账号</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current &lt;= <span class="hljs-variable language_">self</span>.max_num:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;User_<span class="hljs-subst">&#123;self.current&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 超标了，通知 for 循环停下来</span><br>            <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># --- 使用 ---</span><br><br><span class="hljs-comment"># 创建一个能生成 3 个账号的迭代器</span><br>users = UserGenerator(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 像用列表一样用它</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users:<br>    <span class="hljs-built_in">print</span>(u)<br><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># User_1</span><br><span class="hljs-comment"># User_2</span><br><span class="hljs-comment"># User_3</span><br></code></pre></td></tr></table></figure><p>假设有一个 1GB 的 CSV 文件，里面存了 <strong>100 万条</strong> 真实的交易数据，你要用这些数据来跑测试。</p><ul><li><strong>如果不通过迭代器（用 List）</strong>： <code>data = open(&quot;big_data.csv&quot;).readlines()</code> 这会瞬间把 100 万行数据全部加载到内存里，电脑可能会卡死（MemoryError）。</li><li><strong>如果使用迭代器</strong>： 写一个迭代器，每次只从文件里<strong>读取一行</strong>，测试完这一行，扔掉，再读下一行。 <strong>结果</strong>：不管文件有几百 GB，程序只占几 KB 的内存。这叫 <strong>“惰性求值” (Lazy Evaluation)</strong>。</li></ul><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器 <strong>本质上就是一个迭代器</strong>。 但不需要写复杂的类，只需要写一个<strong>函数</strong>。</p><ul><li><strong>普通函数</strong>：用 <code>return</code> 返回结果。一旦 <code>return</code>，函数就结束了，内存也就释放了。</li><li><strong>生成器函数</strong>：用 <strong><code>yield</code></strong> 返回结果。<ul><li><strong>暂停</strong>：函数执行到 <code>yield</code> 时，会把结果交出去，然后<strong>暂停</strong>在这一行（像按了暂停键）。</li><li><strong>保留现场</strong>：函数内的变量、状态全都保留着，没死。</li><li><strong>恢复</strong>：下次你再调用 <code>next()</code> 时，它从刚才暂停的地方<strong>继续往下执行</strong>。</li></ul></li></ul><p>普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_list</span>():<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        result.append(<span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 必须全部做完才能返回</span><br><br><span class="hljs-comment"># 调用</span><br>plate = make_dumplings_list()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;端上来：<span class="hljs-subst">&#123;plate&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成器函数 (<code>yield</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        <span class="hljs-comment"># 【关键】把饺子交出去，然后在这个位置暂停！</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   (第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子被取走了...继续干活)&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br><span class="hljs-comment"># 注意：这一步并没有执行函数代码！只是创建了一个生成器对象</span><br>gen = make_dumplings_gen()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成器对象: <span class="hljs-subst">&#123;gen&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 开始吃 (手动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 我要吃第一个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师包第1个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 我要吃第二个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师从暂停处恢复 -&gt; 包第2个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-comment"># --- 或者直接用 for 循环 (自动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 剩下的我全包了&quot;</span>)<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(d)<br>    <br><span class="hljs-string">&quot;&quot;&quot;    </span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第一个</span><br><span class="hljs-string">👨‍🍳 正在包第 1 个饺子...</span><br><span class="hljs-string">饺子_1</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第二个</span><br><span class="hljs-string">   (第 1 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 2 个饺子...</span><br><span class="hljs-string">饺子_2</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>剩下的我全包了</span><br><span class="hljs-string">   (第 2 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 3 个饺子...</span><br><span class="hljs-string">饺子_3</span><br><span class="hljs-string">   (第 3 个饺子被取走了...继续干活)</span><br></code></pre></td></tr></table></figure><p>写法2-生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 列表推导式 (耗内存)</span><br>list_data = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(list_data) <br><span class="hljs-comment"># 输出: [0, 1, 4, 9, ..., 81] (内存里真的有10个数)</span><br><br><span class="hljs-comment"># 2. 生成器表达式 (省内存)</span><br>gen_data = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(gen_data)<br><span class="hljs-comment"># 输出: &lt;generator object ...&gt; (内存里只有一个公式，还没算呢)</span><br><br><span class="hljs-comment"># 想用的时候再算</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><hr><h1 id="Property属性"><a href="#Property属性" class="headerlink" title="Property属性"></a>Property属性</h1><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, birth_year</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.birth_year = birth_year<br><br>    <span class="hljs-comment"># 【关键】加上 @property</span><br>    <span class="hljs-comment"># 把这个方法变成一个 &quot;只读属性&quot;</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        current_year = datetime.datetime.now().year<br>        <span class="hljs-keyword">return</span> current_year - <span class="hljs-variable language_">self</span>.birth_year<br><br>s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment"># 1. 像访问变量一样访问 age（注意：后面没有括号！）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;今年年龄: <span class="hljs-subst">&#123;s1.age&#125;</span>&quot;</span>) <br><br><span class="hljs-comment"># 2. 尝试修改它（会报错）</span><br><span class="hljs-comment"># s1.age = 18 </span><br><span class="hljs-comment"># 报错：AttributeError: can&#x27;t set attribute (因为我们只定义了 getter，没定义 setter)</span><br></code></pre></td></tr></table></figure><h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这是一个私有变量，不对外公开</span><br>        <span class="hljs-variable language_">self</span>._score = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># --- 1. 定义 Getter (读) ---</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._score<br><br>    <span class="hljs-comment"># --- 2. 定义 Setter (写) ---</span><br>    <span class="hljs-comment"># 语法规则：@函数名.setter</span><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 错误：分数必须是整数！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 错误：分数 <span class="hljs-subst">&#123;value&#125;</span> 超出范围 (0-100)！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>            <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 分数 <span class="hljs-subst">&#123;value&#125;</span> 设置成功&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._score = value<br><br><span class="hljs-comment"># --- 测试 ---</span><br>s = Student()<br><br><span class="hljs-comment"># 正常赋值</span><br>s.score = <span class="hljs-number">90</span>  <span class="hljs-comment"># 自动触发 @score.setter 下的函数</span><br><span class="hljs-built_in">print</span>(s.score) <span class="hljs-comment"># 自动触发 @property 下的函数</span><br><br><span class="hljs-comment"># 异常赋值（会被 setter 里的逻辑拦截）</span><br>s.score = <span class="hljs-number">999</span> <br>s.score = <span class="hljs-string">&quot;不及格&quot;</span><br><br><span class="hljs-comment"># 再次查看，还是原来的 90，没被污染</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前真实分数: <span class="hljs-subst">&#123;s.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="基础语法速查表"><a href="#基础语法速查表" class="headerlink" title="基础语法速查表"></a>基础语法速查表</h3><p>认识几个“特殊符号”（元字符）：</p><h4 id="A-代表“字符”的符号"><a href="#A-代表“字符”的符号" class="headerlink" title="A. 代表“字符”的符号"></a>A. 代表“字符”的符号</h4><ul><li><strong><code>.</code> (点)</strong>：万能符。代表<strong>除了换行符以外的任意一个字符</strong>。</li><li><strong><code>\d</code></strong>：数字 (Digit)。等价于 <code>[0-9]</code>。</li><li><strong><code>\w</code></strong>：单词字符 (Word)。代表 <strong>数字、字母、下划线、中文</strong>（Python 3 中）。</li><li><strong><code>\s</code></strong>：空白符 (Space)。代表空格、Tab、换行。</li></ul><h4 id="B-代表“数量”的符号"><a href="#B-代表“数量”的符号" class="headerlink" title="B. 代表“数量”的符号"></a>B. 代表“数量”的符号</h4><ul><li><strong><code>*</code></strong>：0 次或多次（有没有都行，越多越好）。</li><li><strong><code>+</code></strong>：1 次或多次（至少得有一个）。</li><li><strong><code>?</code></strong>：0 次或 1 次（要么没有，要么有一个）。</li><li><strong><code>&#123;n&#125;</code></strong>：恰好 n 次。</li><li><strong><code>&#123;n, m&#125;</code></strong>：n 到 m 次。</li></ul><h4 id="C-代表“位置”的符号"><a href="#C-代表“位置”的符号" class="headerlink" title="C. 代表“位置”的符号"></a>C. 代表“位置”的符号</h4><ul><li><strong><code>^</code></strong>：必须以…开头。</li><li><strong><code>$</code></strong>：必须以…结尾。</li></ul><p>1：<code>re.findall()</code> —— 找到所有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;张三的电话是 13811112222，李四的电话是 15933334444，还有一个座机 010-123456。&quot;</span><br><br><span class="hljs-comment"># 规则：1开头，后面接10个数字</span><br><span class="hljs-comment"># r&#x27;&#x27; 表示原生字符串，防止转义字符捣乱，写正则建议都要加 r</span><br>pattern = <span class="hljs-string">r&quot;1\d&#123;10&#125;&quot;</span><br><br>phones = re.findall(pattern, text)<br><span class="hljs-built_in">print</span>(phones)<br><span class="hljs-comment"># 输出: [&#x27;13811112222&#x27;, &#x27;15933334444&#x27;]</span><br></code></pre></td></tr></table></figure><p>2：<code>re.search()</code> —— 找到第一个就收工 (最常用):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>html = <span class="hljs-string">&quot;&lt;div&gt;订单号: &lt;span id=&#x27;order&#x27;&gt;20231212001&lt;/span&gt;&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 规则：找数字，但我要更精确</span><br><span class="hljs-comment"># 使用括号 () 进行【分组提取】，这是做接口测试提取数据的核心！</span><br><span class="hljs-comment"># r&quot;(\d&#123;11&#125;)&quot; 意思是：找到11个数字，并把这11个数字单独拿出来</span><br>match_obj = re.search(<span class="hljs-string">r&quot;id=&#x27;order&#x27;&gt;(\d+)&lt;&quot;</span>, html)<br><br><span class="hljs-keyword">if</span> match_obj:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;匹配到的整体: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">0</span>)&#125;</span>&quot;</span>) <span class="hljs-comment"># id=&#x27;order&#x27;&gt;20231212001&lt;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取的目标: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)   <span class="hljs-comment"># 20231212001 (我们通常只要这个)</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没找到&quot;</span>)<br></code></pre></td></tr></table></figure><p>3：<code>re.sub()</code> —— 替换 (清洗数据):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;我给你转了￥100元，又转了$50元&quot;</span><br><br><span class="hljs-comment"># 把所有的货币符号去掉，只留数字</span><br><span class="hljs-comment"># [] 表示“其中任意一个”</span><br>new_text = re.sub(<span class="hljs-string">r&quot;[￥$元]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, text)<br><br><span class="hljs-built_in">print</span>(new_text) <br><span class="hljs-comment"># 输出: 我给你转了100，又转了50</span><br></code></pre></td></tr></table></figure><p>4:re.match()–只从字符串的第一个字符开始匹配:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello Python World&quot;</span><br>pattern = <span class="hljs-string">r&quot;Python&quot;</span><br><br><span class="hljs-comment"># --- 1. 使用 match (碰壁) ---</span><br><span class="hljs-comment"># match 看了看第一个单词 &quot;Hello&quot;，发现不是 &quot;Python&quot;，直接报错(返回None)</span><br>res_match = re.<span class="hljs-keyword">match</span>(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 结果: <span class="hljs-subst">&#123;res_match&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Match 结果: None</span><br><br><br><span class="hljs-comment"># --- 2. 使用 search (成功) ---</span><br><span class="hljs-comment"># search 很有耐心，跳过 Hello，在第 6 个位置找到了 Python</span><br>res_search = re.search(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Search 结果: <span class="hljs-subst">&#123;res_search&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Search 结果: &lt;re.Match object; span=(6, 12), match=&#x27;Python&#x27;&gt;</span><br><br><br><span class="hljs-comment"># --- 3. 只有一种情况 match 能成功 ---</span><br><span class="hljs-comment"># 必须让 Python 出现在开头</span><br>text_2 = <span class="hljs-string">&quot;Python is good&quot;</span><br>res_match_2 = re.<span class="hljs-keyword">match</span>(pattern, text_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 成功: <span class="hljs-subst">&#123;res_match_2&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: Match 成功: &lt;re.Match object...&gt;</span><br></code></pre></td></tr></table></figure><p>5:贪婪与非贪婪:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&quot;&lt;div&gt;第一个&lt;/div&gt;&lt;div&gt;第二个&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 1. 贪婪模式 (.*)</span><br><span class="hljs-comment"># 它会从第一个 &lt;div&gt; 一直吃到最后一个 &lt;/div&gt;，中间不管有多少闭合标签全吞了</span><br>res_greedy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;贪婪: <span class="hljs-subst">&#123;res_greedy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&lt;/div&gt;&lt;div&gt;第二个&#x27;]  &lt;-- 翻车了！</span><br><br><span class="hljs-comment"># 2. 非贪婪模式 (.*?)</span><br><span class="hljs-comment"># 遇到第一个 &lt;/div&gt; 它就觉得“够了”，停止匹配</span><br>res_lazy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*?)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;非贪婪: <span class="hljs-subst">&#123;res_lazy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&#x27;, &#x27;第二个&#x27;] &lt;-- 这才是我们要的</span><br></code></pre></td></tr></table></figure><hr><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Python 的 GC 机制是以【引用计数】为主，以【标记-清除】和【分代回收】为辅。</p><h2 id="引用计数-Reference-Counting"><a href="#引用计数-Reference-Counting" class="headerlink" title="引用计数 (Reference Counting)"></a>引用计数 (Reference Counting)</h2><p>这是 Python 内存管理最核心、最基础的机制。它像是一个**“计分器”**。</p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Python 中的每个对象（比如一个列表、一个数字）内部都有一个字段叫 <code>ob_refcnt</code>，记录着**“现在有多少个变量引用着我”**。</p><ul><li><strong>计数 +1 的情况</strong>：<ul><li>对象被创建：<code>a = [1, 2]</code> （计数&#x3D;1）</li><li>被赋值给别人：<code>b = a</code> （计数&#x3D;2）</li><li>作为参数传给函数：<code>func(a)</code> （计数+1，函数结束-1）</li><li>被放进容器里：<code>list_c = [a]</code> （计数+1）</li></ul></li><li><strong>计数 -1 的情况</strong>：<ul><li>变量被显式销毁：<code>del a</code></li><li>变量被赋予了新值：<code>a = &quot;hello&quot;</code> （原来的 <code>[1,2]</code> 计数-1）</li><li>离开作用域（函数运行结束）：局部变量会被自动销毁。</li></ul></li><li><strong>回收时刻</strong>：<ul><li>一旦某个对象的引用计数变成 <strong>0</strong>，Python 里的“收尸队”会<strong>立刻</strong>把它回收，释放内存。这是一种<strong>实时</strong>的回收机制。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 出生了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💀 <span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了 (内存释放)&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 创建对象（计数=1）</span><br>h1 = Hero(<span class="hljs-string">&quot;亚索&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 注意：sys.getrefcount() 会比实际多 1，因为它自己作为参数也引用了一次</span><br><br><span class="hljs-comment"># 2. 增加引用（计数+1）</span><br>h2 = h1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <span class="hljs-comment"># 现在有两个变量指着它</span><br><br><span class="hljs-comment"># 3. 删除其中一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h1...&quot;</span>)<br><span class="hljs-keyword">del</span> h1<br><span class="hljs-comment"># 此时 h2 还在，引用计数没归零，所以亚索还活着，不会打印 &quot;被销毁&quot;</span><br><br><span class="hljs-comment"># 4. 删除最后一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h2...&quot;</span>)<br><span class="hljs-keyword">del</span> h2<br><span class="hljs-comment"># 此时引用计数为 0，系统立刻触发回收，打印 &quot;被销毁&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 程序结束&quot;</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">✅ 亚索 出生了</span><br><span class="hljs-string">引用计数: 2</span><br><span class="hljs-string">引用计数: 3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h1...</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h2...</span><br><span class="hljs-string">💀 亚索 被销毁了 (内存释放)</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>程序结束</span><br></code></pre></td></tr></table></figure><h4 id="致命缺点：循环引用-Circular-Reference"><a href="#致命缺点：循环引用-Circular-Reference" class="headerlink" title="致命缺点：循环引用 (Circular Reference)"></a>致命缺点：循环引用 (Circular Reference)</h4><p>引用计数非常快，但有一个死穴。请看下面这个经典的“互为舔狗”场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>]<br>b = [<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 互相引用</span><br>a.append(b) <span class="hljs-comment"># a 引用 b</span><br>b.append(a) <span class="hljs-comment"># b 引用 a</span><br><br><span class="hljs-comment"># 删除外部引用</span><br><span class="hljs-keyword">del</span> a<br><span class="hljs-keyword">del</span> b<br></code></pre></td></tr></table></figure><p><strong>结果</strong>：</p><ul><li>执行 <code>del a</code> 后，<code>[1]</code> 的计数从 2 减为 1（因为 <code>b</code> 还在引用它）。</li><li>执行 <code>del b</code> 后，<code>[2]</code> 的计数从 2 减为 1（因为 <code>a</code> 还在引用它）。</li><li><strong>死锁</strong>：外界已经谁也找不到这两个列表了，但它俩在内存里互相抓着对方，计数器永远不为 0。这就造成了<strong>内存泄漏</strong>。</li></ul><p><strong>为了解决这个问题，Python 引入了后面两把辅助斧头。</strong></p><hr><h2 id="标记-清除-Mark-and-Sweep"><a href="#标记-清除-Mark-and-Sweep" class="headerlink" title="标记-清除 (Mark and Sweep)"></a>标记-清除 (Mark and Sweep)</h2><p>这把斧头专门用来解决<strong>循环引用</strong>的问题。</p><p>它不再盯着计数器看，而是从更高的视角看**“连通性”**。</p><h4 id="1-原理（图论思想）"><a href="#1-原理（图论思想）" class="headerlink" title="1. 原理（图论思想）"></a>1. 原理（图论思想）</h4><p>Python 会把所有的对象看作图的节点，引用看作边。</p><ul><li><strong>Root (根节点)</strong>：全局变量、调用栈里的变量、寄存器。这些是绝对不能回收的“大人物”。</li></ul><h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h4><ol><li><strong>标记 (Mark)</strong>：GC 算法从“根节点”出发，沿着引用链往下走。凡是能走到的对象，都打上“<strong>存活</strong>”的标签。</li><li><strong>清除 (Sweep)</strong>：遍历所有对象，凡是<strong>没有</strong>被打上“存活”标签的（也就是那些与外界彻底失联的“孤岛”，比如刚才互为舔狗的那俩），统统干掉。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 准备好了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;♻️ <span class="hljs-subst">&#123;self.name&#125;</span> 被 GC 回收了&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_cycle</span>():<br>    <span class="hljs-comment"># 1. 创建两个对象</span><br>    n1 = Node(<span class="hljs-string">&quot;节点A&quot;</span>)<br>    n2 = Node(<span class="hljs-string">&quot;节点B&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 制造循环引用 (互为舔狗)</span><br>    n1.partner = n2 <span class="hljs-comment"># Python 允许在对象创建后的任何时间，给它身上贴任何新的属性标签。</span><br>    n2.partner = n1<br><br>    <span class="hljs-comment"># 3. 删除外部引用</span><br>    <span class="hljs-comment"># 按理说，函数结束，n1 和 n2 应该被销毁。</span><br>    <span class="hljs-comment"># 但因为它们互相拉着对方，引用计数不为 0，所以默认无法回收！</span><br>    <span class="hljs-keyword">del</span> n1<br>    <span class="hljs-keyword">del</span> n2<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 函数运行结束，外部引用已断开&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 为了演示效果，我们先关闭自动 GC，模拟引用计数解决不了的场景</span><br>gc.disable()<br><br>create_cycle()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 等待片刻 ---&quot;</span>)<br><span class="hljs-comment"># 此时你会发现，并没有打印 &quot;被 GC 回收了&quot;，说明内存泄漏了！</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 手动触发 GC (标记-清除)...&quot;</span>)<br><span class="hljs-comment"># 手动召唤收尸队</span><br>collected_num = gc.collect()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;本次 GC 清理了 <span class="hljs-subst">&#123;collected_num&#125;</span> 个垃圾对象&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序彻底结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="分代回收-Generational-Collection"><a href="#分代回收-Generational-Collection" class="headerlink" title="分代回收 (Generational Collection)"></a>分代回收 (Generational Collection)</h2><p>标记-清除虽然能解决循环引用，但它要把所有对象扫描一遍，<strong>太慢了</strong>！ 为了不拖慢程序运行速度，Python 引入了**“分代回收”**（基于“空间换时间”的思想）。</p><h4 id="1-核心假设"><a href="#1-核心假设" class="headerlink" title="1. 核心假设"></a>1. 核心假设</h4><p><strong>“对象存活越久，它是垃圾的可能性越小。”</strong></p><ul><li>新创建的对象（比如循环里的临时变量）往往死得快。</li><li>老不死的对象（比如全局配置）往往会一直活下去。</li></ul><h4 id="2-三代人-0代-1代-2代"><a href="#2-三代人-0代-1代-2代" class="headerlink" title="2. 三代人 (0代, 1代, 2代)"></a>2. 三代人 (0代, 1代, 2代)</h4><p>Python 将所有的对象分为三代：</p><ul><li><strong>0代 (Generation 0)</strong>：新生代。所有新创建的对象都放这里。</li><li><strong>1代 (Generation 1)</strong>：中生代。</li><li><strong>2代 (Generation 2)</strong>：老年代。</li></ul><h4 id="3-回收逻辑"><a href="#3-回收逻辑" class="headerlink" title="3. 回收逻辑"></a>3. 回收逻辑</h4><ol><li><strong>扫描频率</strong>：0代扫描最勤快，1代次之，2代最懒。</li><li><strong>晋升机制</strong>：<ul><li>当 GC 扫描 0代列表时，发现有些对象居然还活着（没被回收），那就把它们<strong>移入 1代</strong>。</li><li>同理，如果在扫描 1代时对象还没死，就<strong>移入 2代</strong>。</li></ul></li><li><strong>触发阈值</strong>（了解即可）：<ul><li>当 0代对象数量达到一定阈值（默认 700 个），就会触发一次 0代 GC。</li><li>当 0代 GC 触发 10 次，才会触发一次 1代 GC。</li><li>当 1代 GC 触发 10 次，才会触发一次 2代 GC。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><span class="hljs-comment"># 获取当前的分代回收阈值</span><br>threshold = gc.get_threshold()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;700 表示：0代对象超过 700 个触发一次 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：0代 GC 触发 10 次，触发一次 1代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：1代 GC 触发 10 次，触发一次 2代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前阈值: <span class="hljs-subst">&#123;threshold&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前每一代的垃圾数量</span><br><span class="hljs-comment"># 结果类似 (count0, count1, count2)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前各代垃圾数量: <span class="hljs-subst">&#123;gc.get_count()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="数据结构原理"><a href="#数据结构原理" class="headerlink" title="数据结构原理"></a>数据结构原理</h1><h3 id="1-列表-List-vs-元组-Tuple"><a href="#1-列表-List-vs-元组-Tuple" class="headerlink" title="1. 列表 (List) vs 元组 (Tuple)"></a>1. 列表 (List) vs 元组 (Tuple)</h3><p><strong>面试题</strong>：“List 和 Tuple 有什么区别？为什么 Python 要设计两个看似一样的东西？”</p><h4 id="核心区别："><a href="#核心区别：" class="headerlink" title="核心区别："></a>核心区别：</h4><ol><li><strong>可变性 (Mutability)</strong>：<ul><li><strong>List (<code>[]</code>)</strong>：<strong>可变的（Mutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“背包”**。你可以随时往里塞东西、拿东西出来，甚至把里面的苹果换成香蕉。</li></ul></li><li><strong>Tuple (<code>()</code>)</strong>：<strong>不可变的（Immutable）</strong>。<ul><li><strong>比喻</strong>：它就像一个**“琥珀”<strong>或者</strong>“封死的快递箱”**。一旦出厂（创建），里面的东西就定死了。你想改？只能打碎了重新做一个。</li></ul></li></ul></li><li><strong>性能 (Performance)</strong>：<ul><li><strong>Tuple 比 List 快</strong>。</li><li><strong>原因</strong>：<ul><li>Python 对 Tuple 做了<strong>内存缓存机制</strong>。当你创建一个 tuple 时，Python 知道它不会变，所以可以放心大胆地分配一段固定的内存，不需要像 List 那样预留额外的空间（为了 append）。</li><li>如果你的数据只读不改（比如配置参数、数据库查出来的结果），请无脑用 Tuple。</li></ul></li></ul></li><li><strong>作为字典的 Key</strong>：<ul><li><strong>Tuple 可以</strong>做字典的 Key（只要里面装的也是不可变元素）。</li><li><strong>List 不行</strong>（因为它是可变的，不可哈希）。</li></ul></li></ol><hr><h3 id="2-字典-Dict-的底层原理-——-哈希表-Hash-Table"><a href="#2-字典-Dict-的底层原理-——-哈希表-Hash-Table" class="headerlink" title="2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)"></a>2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)</h3><p><strong>面试题</strong>：“字典为什么查找速度这么快？底层是怎么实现的？”</p><p>这是 Python 面试中<strong>含金量最高</strong>的问题。</p><h4 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h4><p>字典查找是 <strong>O(1)</strong> 的时间复杂度（也就是<strong>秒查</strong>，不管字典里有 1 万个数据还是 1 亿个，查找速度几乎一样快）。</p><p><strong>比喻：超市储物柜</strong></p><ul><li><strong>Hash 函数</strong>：就是<strong>条形码扫描枪</strong>。</li><li><strong>Key</strong>：你手里的<strong>小票</strong>。</li><li><strong>Value</strong>：柜子里的<strong>包</strong>。</li></ul><p>当你想存东西（<code>dict[&quot;name&quot;] = &quot;亚索&quot;</code>）：</p><ol><li>Python 拿着 “name” 这个 Key，通过 <strong>哈希函数 (hash function)</strong> 算出一个数字（比如 10086）。</li><li>这个数字直接对应内存里的<strong>地址索引</strong>。</li><li>Python 直接把 “亚索” 扔进 10086 号柜子。</li></ol><p>当你想取东西（<code>dict[&quot;name&quot;]</code>）：</p><ol><li>Python 拿着 “name” 再算一次哈希值，算出 10086。</li><li>直接去 10086 号柜子拿数据。</li><li><strong>完全不需要遍历！</strong> 不需要一个个柜子打开看。</li></ol><h4 id="追问：哈希冲突-Hash-Collision"><a href="#追问：哈希冲突-Hash-Collision" class="headerlink" title="追问：哈希冲突 (Hash Collision)"></a>追问：哈希冲突 (Hash Collision)</h4><p><strong>面试题</strong>：“如果两个不同的 Key，算出来的哈希值一样（都要抢 10086 号柜子）怎么办？”</p><ul><li><strong>Java (HashMap)</strong>：采用**“链地址法”**。如果你来了发现 10086 有人了，你在 10086 后面挂个钩子，吊在下面（形成链表）。</li><li><strong>Python (Dict)</strong>：采用**“开放寻址法” (Open Addressing)**。<ul><li><strong>逻辑</strong>：如果你来了发现 10086 被占了，Python 会说：“别急，往后看！”</li><li>它会按照某种规则（比如看 10087、10088…）去找<strong>下一个空的柜子</strong>存进去。</li><li><em>注：Python 3.6+ 之后对字典进行了大量优化（变得有序且更省内存），但核心依然是哈希表。</em></li></ul></li></ul><hr><h3 id="3-列表-List-的底层-——-动态数组"><a href="#3-列表-List-的底层-——-动态数组" class="headerlink" title="3. 列表 (List) 的底层 —— 动态数组"></a>3. 列表 (List) 的底层 —— 动态数组</h3><p><strong>面试题</strong>：“List 是怎么实现动态扩容的？为什么 append 很快，insert 很慢？”</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Python 的 List 不是链表，而是<strong>连续的内存空间（数组）</strong>，里面存的是<strong>指针</strong>（指向具体的对象）。</p><ol><li><strong>为什么 append (尾部插入) 快？</strong><ul><li>List 在初始化时，会<strong>偷偷多申请一点内存</strong>。</li><li>比如你存 3 个数，它实际申请了 4 个坑位。当你 <code>append</code> 第 4 个数时，直接放进去就行，不需要找操作系统要内存。</li></ul></li><li><strong>动态扩容 (Resizing)</strong>：<ul><li>如果你 append 第 5 个数，坑位不够了怎么办？</li><li>Python 会直接申请一个<strong>更大的内存条</strong>（通常是原来的 1.125 倍左右），然后把旧数据<strong>统统复制过去</strong>，再把旧内存扔掉。</li><li>这就是为什么偶尔一次 append 会变慢的原因。</li></ul></li><li><strong>为什么 insert (中间插入) 慢？</strong><ul><li>如果你在 index&#x3D;0 的位置插入一个数据。</li><li>Python 必须把后面所有的数据<strong>全体起立，向后挪一个位置</strong>，给新来的腾地儿。</li><li>数据越多，挪动越慢。所以 List 极其不适合做“队列”使用。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python进阶</tag>
      
      <tag>面向对象</tag>
      
      <tag>装饰器</tag>
      
      <tag>拷贝</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2025/12/09/Python%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-1-字面量"><a href="#1-1-字面量" class="headerlink" title="1.1 字面量"></a>1.1 字面量</h2><p>字面量：在代码中，被写下来的的固定的值，称之为字面量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;人生苦短_&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个变量</span><br>money = <span class="hljs-number">50</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br><br>money -= <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;钱包还有:&quot;</span>,money)<br></code></pre></td></tr></table></figure><hr><h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;小黎&quot;</span>)) <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)) <span class="hljs-comment"># &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">13.14</span>)) <span class="hljs-comment"># &lt;class &#x27;float&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int() 转换为整数类型</span><br>a = <span class="hljs-built_in">int</span>(<span class="hljs-number">99.6</span>) <span class="hljs-comment"># 99.6 转换为 99</span><br><span class="hljs-comment"># float() 转换为浮点类型</span><br>b = <span class="hljs-built_in">float</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 99.0</span><br><span class="hljs-comment"># str() 转换为字符串类型</span><br>c = <span class="hljs-built_in">str</span>(<span class="hljs-number">99</span>) <span class="hljs-comment"># 99 转换为 &quot;99&quot;</span><br><span class="hljs-comment"># bool() 转换为布尔类型</span><br>d = <span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 转换为 True</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-6-字符串拼接"><a href="#1-6-字符串拼接" class="headerlink" title="1.6 字符串拼接"></a>1.6 字符串拼接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span> + <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>)<br><span class="hljs-comment"># 用+拼接只适用于字符串 不适用与整数型或浮点型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-7-字符串格式化"><a href="#1-7-字符串格式化" class="headerlink" title="1.7 字符串格式化"></a>1.7 字符串格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;小黎&quot;</span><br>age = <span class="hljs-number">22</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-comment"># %s 即将内容转换为字符串放入占位位置</span><br>message1 = <span class="hljs-string">&quot;我的名字是%s&quot;</span> %name<br>message2 = <span class="hljs-string">&quot;我的名字是%s,年龄是%d&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message1) <span class="hljs-comment"># 我的名字是小黎</span><br><span class="hljs-built_in">print</span>(message2) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-comment"># 数字精度控制 (会做四舍五入)</span><br>message3 = <span class="hljs-string">&quot;我的名字是%s,年龄是%.2f&quot;</span> %(name,age)<br><span class="hljs-built_in">print</span>(message3) <span class="hljs-comment"># 我的名字是小黎,年龄是22.00</span><br><span class="hljs-comment"># 方式二 比较快捷 不关心精度控制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的名字是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的名字是小黎,年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是&quot;</span>,name,<span class="hljs-string">&quot;年龄是&quot;</span>,age) <span class="hljs-comment"># 我的名字是 小黎 年龄是 22</span><br>age = <span class="hljs-number">22.0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age)) <span class="hljs-comment"># 我的年龄是22.00</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-8-表达式格式化"><a href="#1-8-表达式格式化" class="headerlink" title="1.8 表达式格式化"></a>1.8 表达式格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的年龄是%s&quot;</span> %(<span class="hljs-number">11</span> + <span class="hljs-number">11</span>)) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的年龄是<span class="hljs-subst">&#123;<span class="hljs-number">11</span> + <span class="hljs-number">11</span>&#125;</span>&quot;</span>) <span class="hljs-comment"># 我的年龄是22</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字符串在python中的数据类型是%s&quot;</span> %(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;字符串&quot;</span>))) <span class="hljs-comment"># 字符串在python中的数据类型是&lt;class &#x27;str&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="2-1-布尔类型"><a href="#2-1-布尔类型" class="headerlink" title="2.1 布尔类型"></a>2.1 布尔类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-literal">True</span><br>b = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;a的内容是<span class="hljs-subst">&#123;a&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(a)&#125;</span>&quot;</span>) <span class="hljs-comment"># a的内容是True,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;b的内容是<span class="hljs-subst">&#123;b&#125;</span>,数据类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(b)&#125;</span>&quot;</span>) <span class="hljs-comment"># b的内容是False,数据类型是&lt;class &#x27;bool&#x27;&gt;</span><br><br>result = <span class="hljs-number">10</span> &gt; <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10 &gt; 5 的结果是<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>) <span class="hljs-comment"># 10 &gt; 5 的结果是True</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-2-判断语句"><a href="#2-2-判断语句" class="headerlink" title="2.2 判断语句"></a>2.2 判断语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 产生一个1-10之间的随机数字</span><br>num = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(num)</span><br>guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入您猜测的数:&quot;</span>))<br><span class="hljs-keyword">if</span> guess_num == num:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第一次就猜中了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> guess_num &gt; num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>    guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>    <span class="hljs-keyword">if</span> guess_num == num:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第二次猜中了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> guess_num &gt; num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜大了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜小了&quot;</span>)<br>        guess_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;再猜一次吧:&quot;</span>))<br>        <span class="hljs-keyword">if</span> guess_num == num:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜，第三次猜中了&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;很遗憾，三次你都没猜中&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="3-1-while循环"><a href="#3-1-while循环" class="headerlink" title="3.1 while循环"></a>3.1 while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">9</span>:<br>    j = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt;= i:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;j&#125;</span> * <span class="hljs-subst">&#123;i&#125;</span> = <span class="hljs-subst">&#123;j * i&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 不换行且对齐</span><br>        j += <span class="hljs-number">1</span><br>    i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 换行</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-2-for循环"><a href="#3-2-for循环" class="headerlink" title="3.2 for循环"></a>3.2 for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 统计字符串中有多少个a</span><br>name = <span class="hljs-string">&quot;xiaoli is a rapper&quot;</span><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> name:<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;a&quot;</span>:<br>        count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(count)<br></code></pre></td></tr></table></figure><hr><h2 id="3-3-range"><a href="#3-3-range" class="headerlink" title="3.3 range"></a>3.3 range</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># range的作用 获得一个数字序列</span><br>num1 = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num1:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;x&#125;</span>\t&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="4-1-传参方式"><a href="#4-1-传参方式" class="headerlink" title="4.1 传参方式"></a>4.1 传参方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示多种传参的形式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 位置传参</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是20,性别是男</span><br><br><span class="hljs-comment"># 关键字传参</span><br>user_info(name=<span class="hljs-string">&#x27;小王&#x27;</span>, age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小王,年龄是19,性别是女</span><br>user_info(age=<span class="hljs-number">19</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, name=<span class="hljs-string">&#x27;小黎&#x27;</span>)  <span class="hljs-comment"># 位置可随意</span><br><br><span class="hljs-comment"># 缺省参数(默认参数必须写在最后面)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender=<span class="hljs-string">&#x27;男&#x27;</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名是<span class="hljs-subst">&#123;name&#125;</span>,年龄是<span class="hljs-subst">&#123;age&#125;</span>,性别是<span class="hljs-subst">&#123;gender&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是男</span><br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">13</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>) <span class="hljs-comment"># 姓名是小明,年龄是13,性别是女</span><br><br><span class="hljs-comment"># 位置不定长 不定长定义的形式参数会作为元组存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;args&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(args)&#125;</span>&quot;</span>)<br><br>user_info(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;小黎&#x27;</span>, <span class="hljs-string">&#x27;男孩&#x27;</span>) <span class="hljs-comment"># args的内容是(1, 2, 3, &#x27;小黎&#x27;, &#x27;男孩&#x27;)，类型是&lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 关键字不定长 不定长定义的形式参数会作为字典存在，接受不定长数量的参数传入</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;args的内容是<span class="hljs-subst">&#123;kwargs&#125;</span>，类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(kwargs)&#125;</span>&quot;</span>)<br><br>user_info(name=<span class="hljs-string">&quot;小黎&quot;</span>, age=<span class="hljs-number">22</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>) <span class="hljs-comment"># args的内容是&#123;&#x27;name&#x27;: &#x27;小黎&#x27;, &#x27;age&#x27;: 22, &#x27;gender&#x27;: &#x27;男&#x27;&#125;，类型是&lt;class &#x27;dict&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-2-函数作为参数传递"><a href="#4-2-函数作为参数传递" class="headerlink" title="4.2 函数作为参数传递"></a>4.2 函数作为参数传递</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是<span class="hljs-subst">&#123;result&#125;</span>,参数类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(compute)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br>test_func(compute) <span class="hljs-comment"># 计算结果是3,参数类型是&lt;class &#x27;function&#x27;&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-3-lambda匿名函数"><a href="#4-3-lambda匿名函数" class="headerlink" title="4.3 lambda匿名函数"></a>4.3 lambda匿名函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute</span>):<br>    result = compute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果是:<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 将匿名函数作为参数传入</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x + y)<br></code></pre></td></tr></table></figure><hr><h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="5-1-列表"><a href="#5-1-列表" class="headerlink" title="5.1 列表"></a>5.1 列表</h2><h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><p>列表可以修改、支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>,<span class="hljs-number">666</span>,<span class="hljs-string">&quot;python&quot;</span>]<br><span class="hljs-comment"># 查找某元素的下标索引 若不存在会报错</span><br><span class="hljs-built_in">print</span>(mylist.index(<span class="hljs-string">&quot;python&quot;</span>))<br><span class="hljs-comment"># 修改目标索引对应元素的值</span><br>mylist[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;小黎&quot;</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在目标索引处插入元素</span><br>mylist.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加元素</span><br>mylist.append(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br>mylist += [<span class="hljs-string">&quot;人生苦短&quot;</span>]<br>mylist *= <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 在尾部追加一个数据容器中的元素</span><br>mylist2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>mylist.extend(mylist2)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除目标索引处的元素 两种方法 第一种方法可以得到返回值</span><br>element = mylist.pop(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-keyword">del</span> mylist[<span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 删除某元素在列表中的第一个匹配项</span><br>mylist.remove(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 统计某元素的个数</span><br><span class="hljs-built_in">print</span>(mylist.count(<span class="hljs-string">&quot;xiaoli&quot;</span>))<br><span class="hljs-comment"># 统计所有元素的个数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mylist))<br><span class="hljs-comment"># 清空列表</span><br>mylist.clear()<br><span class="hljs-built_in">print</span>(mylist)<br></code></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_while_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(mylist):<br>        <span class="hljs-built_in">print</span>(mylist[index])<br>        index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 使用for循环遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_for_func</span>():<br>    mylist = [<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-number">666</span>, <span class="hljs-string">&quot;最帅&quot;</span>, <span class="hljs-literal">True</span>]<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> mylist:<br>        <span class="hljs-built_in">print</span>(element)<br><br>list_while_func()<br>list_for_func()<br></code></pre></td></tr></table></figure><hr><h2 id="5-2-元组"><a href="#5-2-元组" class="headerlink" title="5.2 元组"></a>5.2 元组</h2><p>元组不可修改，支持重复元素且有序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义元组</span><br>t1 = (<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义空元祖</span><br>t2 = ()<br>t3 = <span class="hljs-built_in">tuple</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t1的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t1)&#125;</span>,内容是<span class="hljs-subst">&#123;t1&#125;</span>&quot;</span>) <span class="hljs-comment"># t1的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(2, &#x27;Hello&#x27;, True)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t2的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t2)&#125;</span>,内容是<span class="hljs-subst">&#123;t2&#125;</span>&quot;</span>) <span class="hljs-comment"># t2的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t3的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t3)&#125;</span>,内容是<span class="hljs-subst">&#123;t3&#125;</span>&quot;</span>) <span class="hljs-comment"># t3的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是()</span><br><span class="hljs-comment"># 定义单个元素的元组</span><br>t4 = (<span class="hljs-string">&quot;hello&quot;</span>)<br>t5 = (<span class="hljs-string">&quot;hello&quot;</span>,)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t4的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t4)&#125;</span>,内容是<span class="hljs-subst">&#123;t4&#125;</span>&quot;</span>) <span class="hljs-comment"># t4的类型是&lt;class &#x27;str&#x27;&gt;,内容是hello</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t5的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t5)&#125;</span>,内容是<span class="hljs-subst">&#123;t5&#125;</span>&quot;</span>) <span class="hljs-comment"># t5的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是(&#x27;hello&#x27;,)</span><br><span class="hljs-comment"># 元组的嵌套</span><br>t6 = ((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t6的类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(t6)&#125;</span>,内容是<span class="hljs-subst">&#123;t6&#125;</span>&quot;</span>) <span class="hljs-comment"># t6的类型是&lt;class &#x27;tuple&#x27;&gt;,内容是((1, 2, 3), (4, 5, 6))</span><br><span class="hljs-comment"># 取目标索引的值</span><br><span class="hljs-built_in">print</span>(t6[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) <span class="hljs-comment"># 6</span><br><span class="hljs-comment"># index</span><br><span class="hljs-built_in">print</span>(t1.index(<span class="hljs-string">&quot;Hello&quot;</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(t1.count(<span class="hljs-literal">True</span>)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(t1)) <span class="hljs-comment"># 3</span><br><span class="hljs-comment"># while遍历</span><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(t1):<br>    <span class="hljs-built_in">print</span>(t1[index])<br>    index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># for遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> t1:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 不可以直接修改元组中的元素 否则会报错</span><br><span class="hljs-comment"># 但是若元组中包含列表 则可以修改该列表中的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-3-集合"><a href="#5-3-集合" class="headerlink" title="5.3 集合"></a>5.3 集合</h2><p>集合中的元素不重复且内容无序 不支持按照索引访问元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;learn&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>&#125;<br>my_set_empty = <span class="hljs-built_in">set</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_set内容是<span class="hljs-subst">&#123;my_set_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_set_empty)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 添加新元素</span><br>my_set.add(<span class="hljs-string">&quot;人生苦短&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 移除元素</span><br>my_set.remove(<span class="hljs-string">&quot;learn&quot;</span>)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 随机取出一个元素</span><br>element = my_set.pop()<br><span class="hljs-built_in">print</span>(element)<br><span class="hljs-built_in">print</span>(my_set)<br><span class="hljs-comment"># 统计集合中元素的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_set))<br><span class="hljs-comment"># 遍历 由于不支持索引查找元素 所以不支持while循环遍历</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> my_set:<br>    <span class="hljs-built_in">print</span>(element)<br><span class="hljs-comment"># 清空集合</span><br>my_set.clear()<br><span class="hljs-built_in">print</span>(my_set)<br><br><span class="hljs-comment"># 集合的数学运算</span><br>set1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>set2 = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment"># 并集 &#123;1,2,3,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.union(set2))<br><span class="hljs-built_in">print</span>(set1 | set2)<br><span class="hljs-comment"># 交集 &#123;3&#125;</span><br><span class="hljs-built_in">print</span>(set1.intersection(set2))<br><span class="hljs-built_in">print</span>(set1 &amp; set2)<br><span class="hljs-comment"># 差集 &#123;1,2&#125;</span><br><span class="hljs-built_in">print</span>(set1.difference(set2))<br><span class="hljs-built_in">print</span>(set1 - set2)<br><span class="hljs-comment"># 对称差集 &#123;1,2,4,5&#125;</span><br><span class="hljs-built_in">print</span>(set1.symmetric_difference(set2))<br><span class="hljs-built_in">print</span>(set1 ^ set2)<br></code></pre></td></tr></table></figure><hr><h2 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h2><p>典存储的元素是键值对 key不允许重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;黎鸿翔&quot;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&quot;xiaoli&quot;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>: <span class="hljs-number">97</span>&#125;<br>my_dict_empty = &#123;&#125;  <span class="hljs-comment"># 空字典</span><br>my_dict_empty2 = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict的内容是<span class="hljs-subst">&#123;my_dict&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty的内容是<span class="hljs-subst">&#123;my_dict_empty&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;my_dict_empty2的内容是<span class="hljs-subst">&#123;my_dict_empty2&#125;</span>,类型是<span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(my_dict_empty2)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 通过key获取value</span><br>score = my_dict[<span class="hljs-string">&quot;xiaoli&quot;</span>]<br><span class="hljs-built_in">print</span>(score)<br><span class="hljs-comment"># 修改或新增</span><br>my_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>] = <span class="hljs-number">99.5</span>  <span class="hljs-comment"># key存在则修改value</span><br>my_dict[<span class="hljs-string">&quot;孙悟空&quot;</span>] = <span class="hljs-number">99.9</span>  <span class="hljs-comment"># 若key不存在则为新增</span><br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 删除</span><br>value = my_dict.pop(<span class="hljs-string">&quot;孙悟空&quot;</span>)<br><span class="hljs-built_in">print</span>(value)<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 获取全部的key</span><br>keys = my_dict.keys()<br><span class="hljs-built_in">print</span>(keys)<br><span class="hljs-comment"># 遍历字典</span><br><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------&#x27;</span>)<br><span class="hljs-comment">#     方式二:</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;my_dict[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 方式三: 通过items()方法获取key-value对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的key是<span class="hljs-subst">&#123;key&#125;</span>,value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取全部的value</span><br>values = my_dict.values()<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;字典的value是<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><span class="hljs-comment">#     长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_dict))<br><span class="hljs-comment"># 清空</span><br>my_dict.clear()<br><span class="hljs-built_in">print</span>(my_dict)<br><span class="hljs-comment"># 定义嵌套字典</span><br>stu_score_dict = &#123;<br>    <span class="hljs-string">&quot;黎鸿翔&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">97</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">110</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">107</span><br>    &#125;,<br>    <span class="hljs-string">&quot;xiaoli&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">92</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">140</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">137</span><br>    &#125;,<br>    <span class="hljs-string">&quot;Lil Pear&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;语文&quot;</span>: <span class="hljs-number">90</span>,<br>        <span class="hljs-string">&quot;数学&quot;</span>: <span class="hljs-number">120</span>,<br>        <span class="hljs-string">&quot;英语&quot;</span>: <span class="hljs-number">100</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(stu_score_dict)<br><span class="hljs-comment"># 取value</span><br><span class="hljs-built_in">print</span>(stu_score_dict[<span class="hljs-string">&quot;黎鸿翔&quot;</span>][<span class="hljs-string">&quot;数学&quot;</span>])<br></code></pre></td></tr></table></figure><hr><h2 id="5-5-字符串"><a href="#5-5-字符串" class="headerlink" title="5.5 字符串"></a>5.5 字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 小黎专属python固定模板</span><br><span class="hljs-comment"># 开发时间：2024/7/5 21:42</span><br><span class="hljs-comment"># 字符串不可修改，支持重复元素且有序</span><br>my_str = <span class="hljs-string">&quot;xiaoli is the best one&quot;</span><br><span class="hljs-built_in">print</span>(my_str)<br><span class="hljs-comment"># 通过索引取值</span><br><span class="hljs-built_in">print</span>(my_str[<span class="hljs-number">2</span>])<br><span class="hljs-comment"># index方法</span><br><span class="hljs-built_in">print</span>(my_str.index(<span class="hljs-string">&quot;is&quot;</span>))<br><span class="hljs-comment"># replace 替换</span><br>my_str2 = my_str.replace(<span class="hljs-string">&quot;xiaoli&quot;</span>, <span class="hljs-string">&quot;Lil Pear&quot;</span>)<br><span class="hljs-built_in">print</span>(my_str2)<br><span class="hljs-built_in">print</span>(my_str) <span class="hljs-comment">#不变</span><br><span class="hljs-comment"># split 字符串分割</span><br>mylist = my_str.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(mylist)<br><span class="hljs-comment"># 字符串规整</span><br>my_str3 = <span class="hljs-string">&quot;  xiaoli  &quot;</span><br>my_str4 = <span class="hljs-string">&quot;12xiaoli212&quot;</span><br><span class="hljs-built_in">print</span>(my_str3.strip())<br><span class="hljs-built_in">print</span>(my_str4.strip(<span class="hljs-string">&quot;12&quot;</span>))<br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(my_str.count(<span class="hljs-string">&quot;i&quot;</span>))<br><span class="hljs-comment"># len</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_str))<br></code></pre></td></tr></table></figure><hr><h2 id="5-6-序列切片"><a href="#5-6-序列切片" class="headerlink" title="5.6 序列切片"></a>5.6 序列切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">序列是指：内容连续、有序，可使用下标索引的一类数据容器</span><br><span class="hljs-string">列表、元组、字符串，均可以视为序列</span><br><span class="hljs-string">切片就是从一个序列中取出一个子序列</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>mytuple = (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>mystr = <span class="hljs-string">&quot;0123456&quot;</span><br><span class="hljs-comment"># 对列表进行切片，从1开始，4结束(不含索引4对应的元素)，步长为1(默认为1可不写)</span><br>mylist2 = mylist[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(mylist2)<br><span class="hljs-comment"># 对元组进行切片，从头开始到尾结束，步长为1</span><br>mytuple2 = mytuple[:]<br><span class="hljs-built_in">print</span>(mytuple2)<br><span class="hljs-comment"># 对字符串进行切片，从头开始到尾结束，步长为2</span><br>mystr2 = mystr[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(mystr):<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr2)<br><br><span class="hljs-comment"># 也可以反向取</span><br><span class="hljs-comment"># 对列表进行切片，从头开始到尾结束，步长为-1</span><br>mylist3 = mylist[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mylist3)<br><span class="hljs-comment"># 对元组进行切片，从3开始到1结束，步长为-1</span><br>mytuple3 = mytuple[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(mytuple3)<br><span class="hljs-comment"># 对字符串进行切片 从头开始到尾结束步长为-2</span><br>mystr3 = mystr[::-<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(mystr3)<br></code></pre></td></tr></table></figure><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="6-1-文件读取"><a href="#6-1-文件读取" class="headerlink" title="6.1 文件读取"></a>6.1 文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f))<br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-comment"># print(f.read(9))  # 读取9个字节的内容</span><br><span class="hljs-comment"># print(f.read())</span><br><span class="hljs-comment"># io_list = f.readlines()  # 读取文件的全部行并存到列表中</span><br><span class="hljs-comment"># print(io_list)</span><br><br><span class="hljs-comment"># for line in f.readlines():</span><br><span class="hljs-comment">#     print(line)</span><br><br><span class="hljs-comment"># 读取每行数据</span><br><span class="hljs-comment"># line1 = f.readline()</span><br><span class="hljs-comment"># line2 = f.readline()</span><br><span class="hljs-comment"># line3 = f.readline()</span><br><span class="hljs-comment"># print(line1)</span><br><span class="hljs-comment"># print(line2)</span><br><span class="hljs-comment"># print(line3)</span><br><br><span class="hljs-comment"># for循环读取文件行</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>    <span class="hljs-built_in">print</span>(line.split(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-comment"># print(io_list)</span><br><span class="hljs-comment"># 文件的关闭</span><br>f.close()<br></code></pre></td></tr></table></figure><hr><h2 id="6-2-文件写入"><a href="#6-2-文件写入" class="headerlink" title="6.2 文件写入"></a>6.2 文件写入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件不存在时会创建新文件并写入内容 若文件存在则清空原有的内容并写入新内容 若要追加 则调整为a模式</span><br>f1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/pycharm_workspace/01_PythonBasic-learn/08_文件操作/test.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>f1.write(<span class="hljs-string">&quot;你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f2.write(<span class="hljs-string">&quot;\n你知道的，Lil Pear会走起来的&quot;</span>)  <span class="hljs-comment"># 内容写入到内存中</span><br>f1.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f2.flush()  <span class="hljs-comment"># 将内存中的内容写入到文件中</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><br><span class="hljs-comment"># 捕获指定的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(name)<br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义的异常&quot;</span>)<br><br><span class="hljs-comment"># 捕获多个类型的异常:</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># print(name)</span><br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> (NameError,ZeroDivisionError) <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现了变量未定义或者除以0的异常&quot;</span>)<br><br><span class="hljs-comment"># finally 一定会执行的语句</span><br><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment">#     捕获全部异常的第二种写法</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在 出现异常了 改为w模式&quot;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\\pycharm_workspace\\01_PythonBasic-learn\\09_异常、模块、包\\test2.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;好高兴，无异常&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一定会执行finally中的语句&quot;</span>)<br>    f.close()<br></code></pre></td></tr></table></figure><hr><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用（导入模块去使用）</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/image1.png" class="" title="模块"><p>常用的组合形式如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 类、变量、方法等<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 别名<br><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能名 <span class="hljs-keyword">as</span> 别名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种写法</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br><br><span class="hljs-comment"># 第二种写法</span><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 睡眠5秒钟</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我好&quot;</span>)<br></code></pre></td></tr></table></figure><p>自定义模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a + b)<br><br><span class="hljs-comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> my_module1<br><br>my_module1.test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如，在my_module1.py文件中添加测试代码test(1,1).此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>test</code>函数的调用</p><p>注意事项：当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能</p><p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素</p><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>从物理上看，包就是一个文件夹，在该文件夹下包含了一个 <strong>init</strong>.py 文件，该文件夹可用于包含多个模块文件</p><p>从逻辑上看，包的本质依然是模块</p><p>当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块</p><img src="/2025/12/09/Python%E5%9F%BA%E7%A1%80/package.png" class="" title="包"><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-keyword">import</span> 包名.模块名</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">包名.模块名.目标</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础</title>
    <link href="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">目标：学会使用注释</span><br><span class="hljs-comment">     这是程序的讲解注释</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoteDemo</span>&#123;<br>    <span class="hljs-comment">//这是程序的主方法，是程序的入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我开始学习Java程序，好嗨皮~~&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        窗前明月光</span><br><span class="hljs-comment">        疑是地上霜</span><br><span class="hljs-comment">        举头望明月</span><br><span class="hljs-comment">        低头思故乡</span><br><span class="hljs-comment">        */</span><br>        System.out.println(<span class="hljs-string">&quot;播仔&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;deli&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-2-字面量"><a href="#1-2-字面量" class="headerlink" title="1.2 字面量"></a>1.2 字面量</h2><p>字面量其实就是告诉程序员数据在程序中的书写格式。下面是常用的数据在程序中的书写格式</p><img src="/2025/12/09/Java-SE%E5%9F%BA%E7%A1%80/image1.png" class="" title="字面量"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">目标：需要同学们掌握常见数据在程序中的书写格式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiteralDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.整数</span><br>        System.out.println(<span class="hljs-number">666</span>);<br>        <br>        <span class="hljs-comment">//2.小数</span><br>        System.out.println(<span class="hljs-number">3.66</span>);<br>        <br>        <span class="hljs-comment">//3.字符: 字符必须用单引号引起来</span><br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27;中&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//空格也算字符</span><br>        <span class="hljs-comment">//特殊字符：\t表示制表符 \n表示换行</span><br>        System.out.println(<span class="hljs-string">&#x27;\t&#x27;</span>); <span class="hljs-comment">//这相当于一个tab键，专业叫做制表符</span><br>        System.out.println(<span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">//这是换行的意思</span><br>        <br>        <span class="hljs-comment">//4.字符串：字符串是双引号引起来的</span><br>        System.out.println(<span class="hljs-string">&quot;我爱你中国abc&quot;</span>);<br>        <br>        <span class="hljs-comment">//5.布尔值：只有两个值true和false</span><br>        System.out.println(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>变量是用来记录程序中的数据的。其本质上是内存中的一块区域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p>当执行<code>int age = 18;</code> 这句代码时，JVM会在内存中申请一块区域，在这个区域中存储了一个整数18，给这个区域取的名字叫age； 相当于在盒子中存了一个数据18，这个盒子的名字是age，当我们打印age时，就是从盒子中把盒子中的数据取出来再打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>变量定义在哪个&#123;&#125;范围内，就只在哪个大括号内有效。变量的有效范围称之为变量的作用域<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>System.out.println(a); <span class="hljs-comment">//这是是对的</span><br>&#125;<br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">2.</span>在同一个作用域内，不能有两个同名的变量<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">//这里会出错</span><br>&#125;<br><br><span class="hljs-number">3.</span>变量没有初始化只，不能直接使用<br><span class="hljs-type">int</span> a; <span class="hljs-comment">//仅仅定义了变量，但是没有初始值</span><br>System.out.println(a); <span class="hljs-comment">//这里会出错</span><br><br><span class="hljs-number">4.</span>变量可以定义在同一行<br>如：<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>; <span class="hljs-comment">//a和b都是int类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="1-4-关键字"><a href="#1-4-关键字" class="headerlink" title="1.4 关键字"></a>1.4 关键字</h2><p>关键字是java语言中有特殊含义的单词。比如用int表示整数，用double表示小数，等等</p><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><hr><h2 id="1-5-标识符"><a href="#1-5-标识符" class="headerlink" title="1.5 标识符"></a>1.5 标识符</h2><p>标志符其实就是我们自己取的名字。像前面我们取的类名，变量名其实都是标志符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">强制要求：必须遵守，不遵守就会报错<br><span class="hljs-number">1.</span>最好是字母、数字、下划线、$组成<br><span class="hljs-number">2.</span>不能以数字开头<br><span class="hljs-number">3.</span>不能是Java的关键字<br><br>建议遵守：按照下面的方式取名字会显得更加专业<br><span class="hljs-number">1.</span>所有的名字要见名知意，便于自己和别人阅读<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125; <span class="hljs-comment">//一看这个类就知道表示一个学生</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span><span class="hljs-number">10</span>;    <span class="hljs-comment">//一看这个变量就知道表示年龄</span><br><br><span class="hljs-number">2.</span>类名：首字母大写（大驼峰命名）<br>举例： <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br><br><span class="hljs-number">3.</span>变量名：第二个单词开始首字母大写（小驼峰命名）<br>举例： <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.88</span>;  <br>  <span class="hljs-type">double</span> <span class="hljs-variable">applePrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">7.5</span>; <br></code></pre></td></tr></table></figure><hr><h1 id="类型转换、运算符"><a href="#类型转换、运算符" class="headerlink" title="类型转换、运算符"></a>类型转换、运算符</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java SE</tag>
      
      <tag>流程控制</tag>
      
      <tag>数组</tag>
      
      <tag>方法</tag>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试基础</title>
    <link href="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试理论基础"><a href="#软件测试理论基础" class="headerlink" title="软件测试理论基础"></a>软件测试理论基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>标准定义：</strong> 在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</li><li><strong>核心目的 ：</strong><ol><li><strong>发现缺陷：</strong> 尽可能早地找出软件中的Bug。</li><li><strong>评估质量：</strong> 告诉开发和产品经理，现在的软件能不能上线，风险大不大。</li><li><strong>预防风险：</strong> 通过测试反馈，帮助开发改进流程，预防同类Bug再次出现。</li></ol></li></ul><blockquote><p><strong>💡 测开视角：</strong> 作为测开，目标不仅仅是“点点点”找错，而是要**“保障交付质量”**。有时候需要开发工具来提高测试效率，这也是为了这个目标服务。</p></blockquote><h2 id="测试的“七大原则”-ISTQB-标准"><a href="#测试的“七大原则”-ISTQB-标准" class="headerlink" title="测试的“七大原则” (ISTQB 标准)"></a>测试的“七大原则” (ISTQB 标准)</h2><p>国际软件测试认证委员会 (ISTQB) 总结的原则：</p><ol><li><strong>测试显示缺陷的存在 (Testing shows the presence of defects)：</strong> 测试只能证明软件<strong>有</strong>错，不能证明软件<strong>没</strong>错。</li><li><strong>穷尽测试是不可能的 (Exhaustive testing is impossible)：</strong> 输入组合是无穷无尽的，不可能测完所有情况。所以需要<strong>设计</strong>测试用例。</li><li><strong>测试尽早介入 (Early testing)：</strong> Bug 发现得越早，修复成本越低。</li><li><strong>缺陷集群性 (Defect clustering)：</strong> 80% 的错误通常集中在 20% 的核心模块里。（二八原则，找到一个Bug的地方，通常还有更多Bug）。</li><li><strong>杀虫剂悖论 (Pesticide paradox)：</strong> 同样的测试用例如果重复运行很多次，就找不出新Bug了。需要不断更新用例，或者开发自动化脚本来应对。</li></ol><h2 id="软件开发与测试模型-V模型）"><a href="#软件开发与测试模型-V模型）" class="headerlink" title="软件开发与测试模型 (V模型）"></a>软件开发与测试模型 (V模型）</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image1.jpg" class="" title="V模型"><p><strong>V模型</strong>展示了开发阶段和测试阶段的对应关系：</p><ul><li><strong>左边是开发过程：</strong><ol><li><strong>需求分析</strong> (弄清要做什么)</li><li><strong>概要设计</strong> (系统架构设计)</li><li><strong>详细设计</strong> (具体模块&#x2F;函数设计)</li><li><strong>编码</strong> (写代码)</li></ol></li><li><strong>右边是测试过程：</strong><ol><li><strong>单元测试 (Unit Testing)：</strong> 对应<strong>编码</strong>。测最小的函数或类。通常由开发做，或者测开写单测代码。</li><li><strong>集成测试 (Integration Testing)：</strong> 对应<strong>详细设计</strong>。测模块与模块之间的接口（比如 订单模块 调 支付模块 通不通）。</li><li><strong>系统测试 (System Testing)：</strong> 对应<strong>概要设计</strong>。把软件看成一个整体来测（我们常说的功能测试、性能测试都在这）。</li><li><strong>验收测试 (Acceptance Testing)：</strong> 对应<strong>需求分析</strong>。由用户或产品经理来测，确认是否满足了最初的需求。</li></ol></li></ul><h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><h4 id="A-代码可见度划分"><a href="#A-代码可见度划分" class="headerlink" title="A. 代码可见度划分"></a>A. 代码可见度划分</h4><ul><li><strong>黑盒测试 (Black-box)：</strong> 把软件当成一个黑盒子，不看内部代码，只关心输入变成输出对不对。<ul><li><em>应用：</em> 功能测试、用户体验测试。</li></ul></li><li><strong>白盒测试 (White-box)：</strong> 打开盒子，研究里面的代码逻辑、循环、分支是否正确。<ul><li><em>应用：</em> 单元测试、代码审计。</li></ul></li><li><strong>灰盒测试 (Grey-box)：</strong> 介于两者之间，关注接口的输入输出，也关注部分内部逻辑（如数据库状态）。<ul><li><em>应用：</em> <strong>接口测试</strong></li></ul></li></ul><h4 id="B-按是否运行程序分"><a href="#B-按是否运行程序分" class="headerlink" title="B. 按是否运行程序分"></a>B. 按是否运行程序分</h4><ul><li><strong>静态测试：</strong> 不运行程序。比如：检查文档、Review代码（代码走查）。</li><li><strong>动态测试：</strong> 运行程序，看实际结果。平时做的绝大多数测试都是动态的。</li></ul><h4 id="C-按测试属性分-专项测试"><a href="#C-按测试属性分-专项测试" class="headerlink" title="C. 按测试属性分 (专项测试)"></a>C. 按测试属性分 (专项测试)</h4><ul><li><strong>功能测试：</strong> 点点点，验证功能对不对。</li><li><strong>性能测试：</strong> 测快不快（响应时间）、能不能抗住（并发量）。</li><li><strong>安全测试：</strong> 测有没有漏洞（SQL注入、XSS攻击）。</li><li><strong>兼容性测试：</strong> 安卓&#x2F;iOS能不能用，Chrome&#x2F;Edge能不能用。</li></ul><h2 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image2.png" class="" title="质量模型"><h4 id="1-功能性-Functional-Suitability-——-软件是否具备某方面的能力"><a href="#1-功能性-Functional-Suitability-——-软件是否具备某方面的能力" class="headerlink" title="1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力"></a>1. 功能性 (Functional Suitability) —— 软件是否具备某方面的能力</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image3.png" class="" title="功能性"><h4 id="2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）"><a href="#2-性能效率-Performance-Efficiency-——-多用户同时使用能否满足要求（时间、资源）" class="headerlink" title="2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）"></a>2. 性能效率 (Performance Efficiency) —— 多用户同时使用能否满足要求（时间、资源）</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image4.png" class="" title="性能效率"><h4 id="3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用"><a href="#3-兼容性-Compatibility-——-在不同的设备-平台上能否正常使用" class="headerlink" title="3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用"></a>3. 兼容性 (Compatibility) —— 在不同的设备&#x2F;平台上能否正常使用</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image5.png" class="" title="兼容性"><h4 id="4-易用性-Usability-——-易学、易用、用户粘性好"><a href="#4-易用性-Usability-——-易学、易用、用户粘性好" class="headerlink" title="4. 易用性 (Usability) —— 易学、易用、用户粘性好"></a>4. 易用性 (Usability) —— 易学、易用、用户粘性好</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image6.png" class="" title="易容性"><h4 id="5-可靠性-Reliability-——-长时间运行稳定，不出现异常"><a href="#5-可靠性-Reliability-——-长时间运行稳定，不出现异常" class="headerlink" title="5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常"></a>5. 可靠性 (Reliability) —— 长时间运行稳定，不出现异常</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image7.png" class="" title="可靠性"><h4 id="6-安全性-Security-——-敏感数据存储-传输安全"><a href="#6-安全性-Security-——-敏感数据存储-传输安全" class="headerlink" title="6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全"></a>6. 安全性 (Security) —— 敏感数据存储&#x2F;传输安全</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image8.png" class="" title="安全性"><h4 id="7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便"><a href="#7-可维护性-Maintainability-——-运行过程出现问题维护操作是否方便" class="headerlink" title="7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便"></a>7. 可维护性 (Maintainability) —— 运行过程出现问题维护操作是否方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image9.png" class="" title="可维护性"><h4 id="8-可移植性-Portability-——-应用系统升级-数据迁移方便"><a href="#8-可移植性-Portability-——-应用系统升级-数据迁移方便" class="headerlink" title="8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便"></a>8. 可移植性 (Portability) —— 应用系统升级&#x2F;数据迁移方便</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image10.png" class="" title="可移植性"><p>以微信为例</p><p>1.功能性：与需求数量一致，功能正确 2. 性能：响应快、占用资源少 3. 兼容性：不同设备平台正常使用 4. 易用性：用户体验好 5. 安全性：敏感信息无泄密存储有保障 6. 可靠性：持久运行无异常 7. 可移植性：升级迁移数据不丢失 8. 可维护性：出现异常恢复简单、可扩展功能、升级更新便捷</p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image11.png" class="" title="测试流程"><hr><h1 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h1><h2 id="1-什么是测试用例-Test-Case-？"><a href="#1-什么是测试用例-Test-Case-？" class="headerlink" title="1. 什么是测试用例 (Test Case)？"></a>1. 什么是测试用例 (Test Case)？</h2><p>测试用例就是一个<strong>文档化的“操作剧本”</strong>。它的核心作用是：让任何一个人拿着这份文档，都能按步骤执行，并判断系统是对是错。</p><h4 id="🧪-一个标准测试用例的解剖图"><a href="#🧪-一个标准测试用例的解剖图" class="headerlink" title="🧪 一个标准测试用例的解剖图"></a>🧪 一个标准测试用例的解剖图</h4><p>不同公司的模板（Excel&#x2F;Jira&#x2F;飞书）长相不同，但核心要素万变不离其宗：</p><ol><li><strong>用例编号 (ID):</strong> 唯一标识 (如 <code>LOGIN_001</code>)。</li><li><strong>用例标题 (Title):</strong> 一句话概括测什么 (如：<code>验证输入正确账号密码能成功登录</code>)。</li><li><strong>项目&#x2F;模块</strong></li><li><strong>预置条件 (Precondition):</strong> 执行前需要满足的环境 (如：<code>已注册账号，且网络正常</code>)。</li><li><strong>测试步骤 (Steps):</strong>  第一步做什么，第二步做什么。</li><li><strong>测试数据</strong></li><li><strong>预期结果 (Expected Result):</strong> 也是判断Bug的标准。必须明确！不能写“登录成功”，要写“跳转至首页，右上角显示用户名”。</li><li><strong>实际结果 (Actual Result):</strong> 执行测试时填写的。</li><li><strong>优先级 (Priority):</strong> P0(冒烟&#x2F;核心) &gt; P1 &gt; P2。</li></ol><blockquote><p>👨‍💻 测开视角 Pro Tip：为什么写好用例对“测开”特别重要？</p><p>因为自动化测试脚本其实就是把这些步骤翻译成代码（Python&#x2F;Java）。如果用例逻辑不通，代码根本写不出来。</p></blockquote><hr><h2 id="2-为什么需要设计方法？"><a href="#2-为什么需要设计方法？" class="headerlink" title="2. 为什么需要设计方法？"></a>2. 为什么需要设计方法？</h2><p>穷尽测试是不可能的。比如一个输入框要求输入 <code>1~100</code> 的整数：</p><ul><li>如果测 1, 2, 3…一直测到 100，那是<strong>蛮力</strong>，效率极低。</li><li>如果只测 50，那是<strong>碰运气</strong>。</li></ul><p>所以需要科学的方法，用<strong>最少的用例，覆盖最多的Bug</strong>。即黑盒测试的<strong>五大核心设计方法</strong>。</p><h3 id="（1）等价类划分法"><a href="#（1）等价类划分法" class="headerlink" title="（1）等价类划分法"></a>（1）等价类划分法</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image12.png" class="" title="等价类划分法"><p>它的逻辑基础是：<strong>如果在这个类别中选取的一个数据通过了测试，那么这个类别中的其他数据也一定能通过</strong></p><p>在划分时，必须把数据分为两类：</p><ol><li><strong>有效等价类 (Valid Equivalence Class):</strong><ul><li>完全符合需求规格说明的数据。</li><li><strong>目的：</strong> 验证软件**“做了它该做的事情”**。</li></ul></li><li><strong>无效等价类 (Invalid Equivalence Class):</strong><ul><li>不符合需求的数据（比如格式错、范围错、类型错）。</li><li><strong>目的：</strong> 验证软件**“有错误处理能力”**（比如提示“输入错误”，而不是直接崩溃或乱码）。找Bug通常是在这里找到的！</li></ul></li></ol><p>三步走：</p><p><strong>分析需求：</strong> 找到输入条件（长度、类型、规则）。</p><p><strong>划分集合：</strong> 针对每个条件，列出“有效”和“无效”的情况。</p><p><strong>设计用例：</strong> 从每个集合中挑选 <strong>1个</strong> 代表性数据作为测试数据。设计无效用例时，每次只能破坏一个规则，保证其他规则是正确的</p><hr><p>案例:某电商网站的“修改密码”功能，新密码长度限制为 <strong>8 到 16 位</strong> 的字符,并且必须包含 <strong>大写字母</strong> + <strong>小写字母</strong> + <strong>数字</strong></p><h4 id="1-划分等价类表"><a href="#1-划分等价类表" class="headerlink" title="1. 划分等价类表"></a>1. 划分等价类表</h4><table><thead><tr><th><strong>输入条件</strong></th><th><strong>有效等价类 (合法 - 预期成功)</strong></th><th><strong>无效等价类 (非法 - 预期失败&#x2F;提示)</strong></th></tr></thead><tbody><tr><td><strong>长度 (8~16)</strong></td><td>1. 长度在 8~16 之间   <em>(例如选个中间值：10位)</em></td><td>2. 长度 &lt; 8   *(例如：5位)*   3. 长度 &gt; 16   <em>(例如：20位)</em></td></tr><tr><td><strong>规则 (组合)</strong></td><td>4. 同时包含大写+小写+数字</td><td>5. 缺少大写字母   6. 缺少小写字母   7. 缺少数字   8. 为空   9. 包含非法字符(如汉字&#x2F;空格)</td></tr></tbody></table><h4 id="2-挑选测试用例-Sample"><a href="#2-挑选测试用例-Sample" class="headerlink" title="2. 挑选测试用例 (Sample)"></a>2. 挑选测试用例 (Sample)</h4><p>挑选最具代表性的数据：</p><ul><li><strong>【这条必须过】(有效长度+有效规则):</strong><ul><li><code>Netease163</code> (10位，含大写N、小写、数字) -&gt; <strong>预期：通过</strong></li></ul></li><li><strong>【测长度无效】:</strong><ul><li><code>Test1</code> (5位，长度过短) -&gt; <strong>预期：报错“密码长度不足”</strong></li><li><code>Netease123456789000</code> (20位，长度过长) -&gt; <strong>预期：报错“密码过长”</strong></li></ul></li><li><strong>【测规则无效 - 控制变量法】:</strong><ul><li><code>netease163</code> (缺大写) -&gt; <strong>预期：报错“需包含大写字母”</strong></li><li><code>NETEASE163</code> (缺小写) -&gt; <strong>预期：报错“需包含小写字母”</strong></li><li><code>NeteaseTest</code> (缺数字) -&gt; <strong>预期：报错“需包含数字”</strong></li><li>空字符</li><li>非法字符</li></ul></li></ul><hr><h3 id="（2）边界值分析法"><a href="#（2）边界值分析法" class="headerlink" title="（2）边界值分析法"></a>（2）边界值分析法</h3><p>如果代码不小心写成 <code>if (length &gt; 8 &amp;&amp; length &lt; 16)</code>，那么输入 8 和 16 都会报错，这时候只用等价类划分可能无法发现这个错误</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image13.png" class="" title="边界值分析法"><p><strong>边界值分析法</strong>就是专门针对输入范围的<strong>边缘</strong>进行测试的方法</p><h4 id="关键概念：上点、离点、内点"><a href="#关键概念：上点、离点、内点" class="headerlink" title="关键概念：上点、离点、内点"></a>关键概念：上点、离点、内点</h4><p>假设需求是输入范围：<strong>[1, 100]</strong> （包含1和100）。</p><ol><li><strong>上点 (On Point)：</strong> 边界上的点。<ul><li>也就是 <strong>1</strong> 和 <strong>100</strong>。</li><li><em>(在此例中，它们是<strong>有效</strong>的)</em></li></ul></li><li><strong>离点 (Off Point)：</strong> 离边界最近的那个点。<ul><li>也就是 <strong>0</strong> 和 <strong>101</strong>。</li><li><em>(在此例中，它们是<strong>无效</strong>的)</em></li></ul></li><li><strong>内点 (Interior Point)：</strong> 范围内的任意一点。<ul><li>比如 <strong>50</strong>。</li></ul></li></ol><p><strong>等价类</strong>和<strong>边界值</strong>一般都是<strong>同时使用</strong>的</p><hr><p>以上述的案例为例：</p><p>这种方法在方案一的基础上，对“长度”这个条件进行了<strong>极致的精确打击</strong>。因为程序员最容易把 <code>&gt;8</code> 写成 <code>&gt;=8</code>，或者把 <code>16</code> 写成 <code>15</code>。</p><h4 id="1-确定边界点"><a href="#1-确定边界点" class="headerlink" title="1. 确定边界点"></a>1. 确定边界点</h4><ul><li><strong>有效范围：</strong> [8, 16]</li><li><strong>上点 (有效边界)：</strong> 8, 16</li><li><strong>离点 (无效边界)：</strong> 7, 17</li><li><strong>内点 (有效中间)：</strong> 10 (或任意8-16之间的数)</li></ul><h4 id="2-设计测试用例-高能部分"><a href="#2-设计测试用例-高能部分" class="headerlink" title="2. 设计测试用例 (高能部分)"></a>2. 设计测试用例 (高能部分)</h4><p>在设计边界值用例时，<strong>内容规则必须是正确的（大写+小写+数字）</strong>，这样才能确保报错唯一原因是“长度不对”。</p><p><strong>针对“长度”的边界测试：</strong></p><ol><li><strong>【最小无效边界 - 7位】 (关键):</strong><ul><li>输入：<code>Abcdef1</code></li><li>说明：7位，规则满足。</li><li><strong>预期：失败</strong> (刚好不够长)</li></ul></li><li><strong>【最小有效边界 - 8位】 (关键):</strong><ul><li>输入：<code>Abcdefg1</code></li><li>说明：8位，规则满足。</li><li><strong>预期：成功</strong> (刚好够长，测是否写了<code>&gt;8</code>导致8失败)</li></ul></li><li><strong>【中间任意值】:</strong><ul><li>输入：<code>Abcdefg123</code></li><li>说明：10位。</li><li><strong>预期：成功</strong> (日常功能验证)</li></ul></li><li><strong>【最大有效边界 - 16位】 (关键):</strong><ul><li>输入：<code>Abcdefghij123456</code></li><li>说明：16位，规则满足。</li><li><strong>预期：成功</strong></li></ul></li><li><strong>【最大无效边界 - 17位】 (关键):</strong><ul><li>输入：<code>Abcdefghij1234567</code></li><li>说明：17位，规则满足。</li><li><strong>预期：失败</strong> (刚好溢出)</li></ul></li></ol><p><strong>针对“规则”的等价类测试 (同方案一，补充测试):</strong></p><ol><li><strong>【缺大写】:</strong> <code>abcdefg1</code> (8位，满足长度，破坏规则) -&gt; <strong>失败</strong></li><li><strong>【缺小写】:</strong> <code>ABCDEFG1</code> -&gt; <strong>失败</strong></li><li><strong>【缺数字】:</strong> <code>Abcdefgh</code> -&gt; <strong>失败</strong></li><li><strong>【其他非法】:</strong> 空值、空格、中文等。</li></ol><hr><h3 id="（3）判定表法"><a href="#（3）判定表法" class="headerlink" title="（3）判定表法"></a>（3）判定表法</h3><p>判定表法是专门用来处理<strong>多条件组合逻辑</strong>的工具。它能帮你把所有可能的“条件组合”都列出来，确保每一种逻辑分支（True&#x2F;False 组合）都被测到。</p><ul><li><strong>条件桩 (Condition Stub):</strong> 列出问题的所有<strong>输入条件</strong>（例如：是否VIP、金额是否&gt;100）。</li><li><strong>动作桩 (Action Stub):</strong> 列出可能采取的所有<strong>操作&#x2F;结果</strong>（例如：打8折、不打折、包邮）。</li><li><strong>条件项 (Condition Entry):</strong> 填入真假值（True&#x2F;False 或 Yes&#x2F;No），列出所有可能的<strong>组合</strong>。</li><li><strong>动作项 (Action Entry):</strong> 根据每一列的条件组合，勾选出对应的<strong>结果</strong>。</li></ul><p><strong>需求场景：</strong> 某电商网站规定：如果订单金额 <strong>大于 99 元</strong>，<strong>或者</strong> 用户是 <strong>VIP会员</strong>，则享受 <strong>“免运费”</strong> 服务；否则需要 <strong>“支付运费”</strong>。</p><table><thead><tr><th align="center"><strong>组成部分</strong></th><th align="center"><strong>规则 1</strong></th><th align="center"><strong>规则 2</strong></th><th align="center"><strong>规则 3</strong></th><th align="center"><strong>规则 4</strong></th></tr></thead><tbody><tr><td align="center"><strong>【条件桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">C1: 金额 &gt; 99元</td><td align="center"><strong>Y</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center">C2: 是 VIP</td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td><td align="center"><strong>Y</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center"><strong>【动作桩】</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">A1: 免运费</td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"><strong>✔</strong></td><td align="center"></td></tr><tr><td align="center">A2: 支付运费</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><strong>✔</strong></td></tr></tbody></table><p>根据上面的表格，直接就能写出 4 条测试用例：</p><ol><li><strong>用例1:</strong> 购买 200元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例2:</strong> 购买 200元，非 VIP -&gt; 预期：免运费。</li><li><strong>用例3:</strong> 购买 50元，且是 VIP -&gt; 预期：免运费。</li><li><strong>用例4:</strong> 购买 50元，非 VIP -&gt; 预期：支付运费。</li></ol><h3 id="（4）场景图"><a href="#（4）场景图" class="headerlink" title="（4）场景图"></a>（4）场景图</h3><p>把软件运行想象成用户在走一条路。</p><ul><li><strong>基本流 (Basic Flow):</strong> 也叫“快乐路径” (Happy Path)。一切顺利，没有任何报错，用户最想走的那个流程。</li><li><strong>备选流 (Alternative Flow):</strong> 也就是异常流程。走到半路出了岔子（密码错了、没钱了、网断了），程序怎么处理？</li></ul><p>练习流程图工具：visio、processon</p><h4 id="案例-ATM"><a href="#案例-ATM" class="headerlink" title="案例-ATM"></a>案例-ATM</h4><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image14.png" class="" title="ATM流程图"><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image15.png" class="" title="路径"><h5 id="1-基本流-The-Happy-Path"><a href="#1-基本流-The-Happy-Path" class="headerlink" title="1. 基本流 (The Happy Path)"></a>1. 基本流 (The Happy Path)</h5><p>这是最顺畅的一条路，也就是图中中间那一列直直往下走的路。</p><ul><li><strong>路径：</strong> 插入银行卡 -&gt; 验证成功 -&gt; 输入密码 -&gt; 验证正确 -&gt; 选择取款 -&gt; 验证账户余额(足) -&gt; 验证取款金额(对) -&gt; 验证ATM余额(足) -&gt; 出钞 -&gt; <strong>[结束]</strong>。</li><li><strong>对应图中下方的文字：</strong> <code>6、开始-&gt;验证银行卡成功-&gt;...-&gt;取款成功-&gt;结束</code>。</li><li><strong>意义：</strong> 证明ATM机“能用”。</li></ul><h5 id="2-备选流-The-Sad-Paths"><a href="#2-备选流-The-Sad-Paths" class="headerlink" title="2. 备选流 (The Sad Paths)"></a>2. 备选流 (The Sad Paths)</h5><p>这是你在每一个“菱形判断框”遇到红灯（No&#x2F;False）时拐弯走的路。顺着图一个一个找：</p><ul><li><strong>拐弯点 1 (验证银行卡):</strong> 验证不成功 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>1</code>。</li></ul></li><li><strong>拐弯点 2 (验证密码):</strong> 这是一个特殊的<strong>循环结构</strong>。<ul><li>不正确 -&gt; 提示错误 -&gt; 判断到3次了吗？</li><li><strong>没有到3次</strong> -&gt; 箭头指回“输入密码” (让用户重输)。</li><li><strong>到了3次</strong> -&gt; 吞卡 -&gt; <strong>[结束]</strong>。</li><li>这就是路径 <code>2</code>。</li></ul></li><li><strong>拐弯点 3 (验证账户余额):</strong> 不满足 -&gt; 提示错误、退卡 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>3</code>。</li></ul></li><li><strong>拐弯点 4 (验证取款金额):</strong> 不满足 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>4</code>。</li></ul></li><li><strong>拐弯点 5 (验证ATM余额):</strong> 不够用 -&gt; 提示错误 -&gt; <strong>[结束]</strong>。<ul><li>这就是路径 <code>5</code>。</li></ul></li></ul><p><strong>总结：</strong> 通过对着这张图“顺藤摸瓜”，一共摸出了 <strong>6条</strong> 唯一的路径（1条成功 + 5条失败）。</p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image16.png" class="" title="ATM测试用例"><hr><h3 id="（5）错误猜测法"><a href="#（5）错误猜测法" class="headerlink" title="（5）错误猜测法"></a>（5）错误猜测法</h3><p>基于你以前见过的 Bug，去“猜”这个程序哪里可能坏掉。通常作为最后一步的<strong>补充测试</strong></p><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image17.png" class="" title="错误猜测法"><hr><p>在实际工作中，不要割裂使用，要像打组合拳一样：</p><ol><li>拿到功能，先用 <strong>场景法</strong> 搞清楚业务流程（基本流+备选流）。</li><li>针对流程中的每一个输入框（比如金额、密码），用 <strong>等价类</strong> + <strong>边界值</strong> 设计具体数据。</li><li>如果有复杂的逻辑判断（比如满减、VIP），用 <strong>判定表</strong> 理清逻辑。</li><li>最后，用 <strong>错误猜测法</strong> 搞点破坏，查漏补缺。</li></ol><hr><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>$$<br>Bug &#x3D; 实际结果 (Actual Result) \neq 预期结果 (Expected Result)<br>$$</p><p>软件中存在的各种问题，都为缺陷，简称bug；</p><h2 id="Bug的生命周期"><a href="#Bug的生命周期" class="headerlink" title="Bug的生命周期"></a>Bug的生命周期</h2><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image18.png" class="" title="Bug的生命周期"><p>Bug 的生命周期，就是**“从被发现，到最终被消灭”<strong>的全过程。这中间会经历不同的</strong>状态 (Status)**。</p><h3 id="🔄-标准流程（Happy-Path）"><a href="#🔄-标准流程（Happy-Path）" class="headerlink" title="🔄 标准流程（Happy Path）"></a>🔄 标准流程（Happy Path）</h3><p>这是最顺利的情况，Bug 被发现并成功修复。</p><ol><li><strong>New (新建):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 你发现了Bug，提交到系统里。</li><li><strong>含义：</strong> “嘿，我发现了个问题，待认领。”</li></ul></li><li><strong>Open (打开&#x2F;确认):</strong><ul><li><strong>谁做：</strong> 开发人员（老王）或 测试组长。</li><li><strong>动作：</strong> 开发看到了单子，确认这确实是个Bug，准备开始修。</li><li><strong>含义：</strong> “收到，确实是问题，我开始干活了。”</li></ul></li><li><strong>Fixed &#x2F; Resolved (已修复&#x2F;已解决):</strong><ul><li><strong>谁做：</strong> 开发人员。</li><li><strong>动作：</strong> 代码改好了，开发在系统上点“已修复”。</li><li><strong>含义：</strong> “我改完了，你（测试）去验证一下吧。”</li></ul></li><li><strong>Verified (已验证):</strong><ul><li><strong>谁做：</strong> 测试人员（你）。</li><li><strong>动作：</strong> 你拿到新版本，重新测了一遍，发现真的修好了。</li><li><strong>含义：</strong> “验货通过，没问题了。”</li><li><em>(注：有的公司会跳过这个状态直接Closed，但在严谨流程中，验证是独立动作)</em></li></ul></li><li><strong>Closed (关闭):</strong><ul><li><strong>谁做：</strong> 测试人员。</li><li><strong>动作：</strong> 关闭这个Bug单。</li><li><strong>含义：</strong> “此案终结，归档。”</li></ul></li></ol><hr><h4 id="⚠️-异常流程（扯皮与返工）"><a href="#⚠️-异常流程（扯皮与返工）" class="headerlink" title="⚠️ 异常流程（扯皮与返工）"></a>⚠️ 异常流程（扯皮与返工）</h4><ol><li><strong>Reopen (重新打开):</strong><ul><li><strong>场景：</strong> 开发说“修好了” (Fixed)，结果你去验证 (Verify) 发现<strong>还是没好</strong>，或者<strong>引发了新Bug</strong>。</li><li><strong>动作：</strong> 你把状态从 Fixed 改为 Reopen，打回给开发。</li><li><strong>含义：</strong> “老王，你没修好啊，重来！”</li></ul></li><li><strong>Rejected (拒绝):</strong><ul><li><strong>场景：</strong> 开发觉得这不是Bug（比如是你环境配错了，或者需求理解不一致，或者就是“特性不是Bug”）。</li><li><strong>含义：</strong> “这不是我的锅，驳回。”</li><li><em>应对：这时需要找产品经理（PM）来做裁判。</em></li></ul></li><li><strong>Duplicate (重复):</strong><ul><li><strong>场景：</strong> 你提的Bug，别的测试同事昨天已经提过了。</li><li><strong>含义：</strong> “重复单子，关掉其中一个。”</li></ul></li><li><strong>Deferred &#x2F; Postponed (延期):</strong><ul><li><strong>场景：</strong> Bug确实存在，但上线时间紧，这个Bug影响不大（比如一个像素的偏差），决定放到下一个版本再修。</li><li><strong>含义：</strong> “承认问题，但暂不修复，下期再说。”</li></ul></li></ol><hr><h2 id="Bug的管理"><a href="#Bug的管理" class="headerlink" title="Bug的管理"></a>Bug的管理</h2><h3 id="Bug-的核心要素"><a href="#Bug-的核心要素" class="headerlink" title="Bug 的核心要素"></a>Bug 的核心要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image19.png" class="" title="Bug的核心要素"><h3 id="Bug-的提交要素"><a href="#Bug-的提交要素" class="headerlink" title="Bug 的提交要素"></a>Bug 的提交要素</h3><img src="/2025/12/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image20.png" class="" title="Bug的提交要素"><h3 id="常用管理工具"><a href="#常用管理工具" class="headerlink" title="常用管理工具"></a>常用管理工具</h3><ul><li><strong>Jira:</strong> 全球最通用的项目管理工具，大厂常用。</li><li><strong>禅道 (ZenTao):</strong> 国内中小厂非常流行，集成了用例管理和Bug管理。</li><li><strong>Tapd:</strong> 腾讯出的，很多互联网公司也在用。</li><li><strong>Excel:</strong> 虽然原始，但有些小项目确实还在用 Excel 记 Bug。</li></ul><h3 id="Bug-的等级：严重程度-vs-优先级"><a href="#Bug-的等级：严重程度-vs-优先级" class="headerlink" title="Bug 的等级：严重程度 vs 优先级"></a>Bug 的等级：严重程度 vs 优先级</h3><p><strong>“严重程度高的Bug，优先级一定高吗？”</strong></p><h4 id="A-严重程度-Severity-——-技术视角"><a href="#A-严重程度-Severity-——-技术视角" class="headerlink" title="A. 严重程度 (Severity) —— 技术视角"></a>A. 严重程度 (Severity) —— 技术视角</h4><p>代表这个 Bug 对软件功能的破坏程度。</p><ul><li><strong>S1 (致命):</strong> 系统崩溃、数据丢失、核心功能瘫痪（如无法支付）。</li><li><strong>S2 (严重):</strong> 主要功能出错（如算错钱、逻辑错误），但系统没崩。</li><li><strong>S3 (一般):</strong> 次要功能错误（如提示语模糊、界面布局微调）。</li><li><strong>S4 (轻微):</strong> 建议性问题（如字体不好看、个别错别字）。</li></ul><h4 id="B-优先级-Priority-——-业务视角"><a href="#B-优先级-Priority-——-业务视角" class="headerlink" title="B. 优先级 (Priority) —— 业务视角"></a>B. 优先级 (Priority) —— 业务视角</h4><p>代表开发需要<strong>多快</strong>去修这个 Bug。</p><ul><li><strong>P0 (立即):</strong> 现在、马上、停下手头所有事去修（通常针对阻碍测试进行的Bug）。</li><li><strong>P1 (高):</strong> 下个版本发布前必须修好。</li><li><strong>P2 (中):</strong> 发布前最好修好，修不完可以延期。</li><li><strong>P3 (低):</strong> 有空再修，或者不修。</li></ul><p><strong>问：</strong> “有没有 <strong>严重程度很高</strong>，但 <strong>优先级很低</strong> 的情况？或者反过来？” <strong>答：</strong> 有！</p><ol><li><strong>高严重 + 低优先级：</strong><ul><li><em>例子：</em> 一个会让APP崩溃的Bug，但它只发生在 <strong>iPhone 6 (很久远的机型)</strong> 上，而公司决定下个月就停止支持 iPhone 6 了。虽然崩溃很严重，但修它的优先级很低。</li></ul></li><li><strong>低严重 + 高优先级：</strong><ul><li><em>例子：</em> 公司首页的 Logo 颜色配错了（甚至带了竞争对手的颜色），或者有一句骂人的文案。</li><li><em>分析：</em> 技术上这只是换张图、改个字，完全不影响功能使用（严重度极低）。但这对公司形象影响巨大，必须立刻、马上修好（优先级极高）。</li></ul></li></ol><hr><h1 id="补充-白盒测试方法"><a href="#补充-白盒测试方法" class="headerlink" title="补充-白盒测试方法"></a>补充-白盒测试方法</h1><p>白盒测试的核心思想是：穷尽代码内部的逻辑路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 案例：电商打折逻辑</span><br><span class="hljs-comment"># 如果 消费金额 &gt; 1000 并且 是VIP用户，那么打8折</span><br><span class="hljs-comment"># 如果 消费金额 &gt; 500  或者 是老用户，那么打9折</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_discount</span>(<span class="hljs-params">amount, is_vip, is_old_user</span>):<br>    <span class="hljs-comment"># 判定 A</span><br>    <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">1000</span> <span class="hljs-keyword">and</span> is_vip:<br>        discount = <span class="hljs-number">0.8</span><br>    <span class="hljs-comment"># 判定 B</span><br>    <span class="hljs-keyword">elif</span> amount &gt; <span class="hljs-number">500</span> <span class="hljs-keyword">or</span> is_old_user:<br>        discount = <span class="hljs-number">0.9</span><br>    <span class="hljs-keyword">else</span>:<br>        discount = <span class="hljs-number">1.0</span><br>    <br>    <span class="hljs-keyword">return</span> discount<br></code></pre></td></tr></table></figure><hr><h3 id="1-语句覆盖-Statement-Coverage-——-最弱-🥉"><a href="#1-语句覆盖-Statement-Coverage-——-最弱-🥉" class="headerlink" title="1. 语句覆盖 (Statement Coverage) —— 最弱 🥉"></a>1. 语句覆盖 (Statement Coverage) —— 最弱 🥉</h3><ul><li><strong>定义：</strong> 设计足够多的用例，保证<strong>每一行代码都至少被执行一次</strong>。</li><li><strong>如何做：</strong><ul><li>用例 1：<code>amount=2000, is_vip=True</code> (走到 0.8 折，覆盖了 line 6-7)</li><li>用例 2：<code>amount=600, is_vip=False</code> (走到 0.9 折，覆盖了 line 9-10)</li><li>用例 3：<code>amount=100, is_vip=False, is_old_user=False</code> (走到无折扣，覆盖 line 12)</li></ul></li><li><strong>缺点：</strong> 它的覆盖度最低。比如第一个判断 <code>amount &gt; 1000 and is_vip</code>，如果代码逻辑错写成了 <code>or</code>，语句覆盖也能通过，根本发现不了逻辑错误。</li></ul><h3 id="2-判定覆盖-分支覆盖-Decision-Branch-Coverage-——-标准-🥈"><a href="#2-判定覆盖-分支覆盖-Decision-Branch-Coverage-——-标准-🥈" class="headerlink" title="2. 判定覆盖 &#x2F; 分支覆盖 (Decision&#x2F;Branch Coverage) —— 标准 🥈"></a>2. 判定覆盖 &#x2F; 分支覆盖 (Decision&#x2F;Branch Coverage) —— 标准 🥈</h3><ul><li><strong>定义：</strong> 保证每个 <strong><code>if</code></strong> 语句的 <strong>True</strong> 和 <strong>False</strong> 两个分支都至少被执行一次。</li><li><strong>关注点：</strong> 不关心 <code>if</code> 里面的条件细节，只关心 <code>if</code> 整体的结果是真还是假。</li><li><strong>针对判定 A (<code>amount &gt; 1000 and is_vip</code>)：</strong><ul><li>需要一个 <code>True</code> 的用例（比如：2000, True）。</li><li>需要一个 <code>False</code> 的用例（比如：200, True）。</li></ul></li><li><strong>缺点：</strong> 它把 <code>and</code> 里面的条件当成一个整体。如果 <code>amount &gt; 1000</code> 这个子条件写错了，只要整体结果凑巧对了，测试也就过了。</li></ul><h3 id="3-条件覆盖-Condition-Coverage-——-细节"><a href="#3-条件覆盖-Condition-Coverage-——-细节" class="headerlink" title="3. 条件覆盖 (Condition Coverage) —— 细节"></a>3. 条件覆盖 (Condition Coverage) —— 细节</h3><ul><li><strong>定义：</strong> 不管 <code>if</code> 整体怎么样，我要保证每个<strong>原子条件</strong>（Atomic Condition）的真假都被测到。</li><li><strong>拆解原子条件：</strong><ol><li><code>amount &gt; 1000</code> (取真、取假)</li><li><code>is_vip</code> (取真、取假)</li><li><code>amount &gt; 500</code> (取真、取假)</li><li><code>is_old_user</code> (取真、取假)</li></ol></li><li><strong>如何做：</strong> 设计用例，让上面 4 个小条件分别出现 True 和 False。</li><li><strong>缺点：</strong> 有时候你覆盖了所有小条件的真假，但可能凑不出 <code>if</code> 整体为 True 的情况（虽然概率小，但逻辑上存在）。</li></ul><h3 id="4-路径覆盖-Path-Coverage-——-最强-🥇"><a href="#4-路径覆盖-Path-Coverage-——-最强-🥇" class="headerlink" title="4. 路径覆盖 (Path Coverage) —— 最强 🥇"></a>4. 路径覆盖 (Path Coverage) —— 最强 🥇</h3><ul><li><strong>定义：</strong> 覆盖程序中<strong>所有可能的执行路径</strong>。这是最彻底的测试。</li><li><strong>如何做：</strong> 我们需要画出<strong>控制流图 (Control Flow Graph)</strong>，找出从“开始”到“结束”的所有路线。</li><li><strong>针对案例的路径：</strong><ol><li>路径 1：判定A(真)-&gt;结束</li><li>路径 2：判定A(假)-&gt;判定B(真-&gt;结束</li><li>路径 3：判定A(假) -&gt; 判定B(假) -&gt; 结束</li></ol></li><li><strong>现实中的大坑：</strong> 如果代码里有 <strong>循环 (Loop)</strong>（比如 <code>while</code> 循环 1000 次），路径数量就是天文数字（无穷多），根本测不完。所以通常把循环简化为“执行0次、1次、N次”。</li></ul><hr><h3 id="5-圈复杂度-Cyclomatic-Complexity"><a href="#5-圈复杂度-Cyclomatic-Complexity" class="headerlink" title="5. 圈复杂度 (Cyclomatic Complexity)"></a>5. 圈复杂度 (Cyclomatic Complexity)</h3><p>问：“你怎么判断这段代码难不难测？”</p><p>答：“我会看它的圈复杂度。”</p><ul><li><p><strong>定义：</strong> 衡量代码逻辑复杂程度的一个指标。</p></li><li><p>简单计算公式：</p><p>判定节点数 + 1</p><p>(通俗点说：代码里有多少个 if, while, case, &amp;&amp;, ||，加起来再加 1)</p></li><li><p><strong>意义：</strong></p><ul><li>圈复杂度越高，Bug 可能性越大。</li><li><strong>黄金标准：</strong> 如果一个函数的圈复杂度 <strong>&gt; 10</strong>，说明代码写得太复杂，建议开发重构，或者需要极其严格的测试。</li></ul></li></ul><hr><p>问：“你平时用白盒测试吗？” 答：</p><blockquote><p>“虽然单元测试主要由开发同学完成，但在我的测试工作中，我会大量运用<strong>白盒思维</strong>：</p><ol><li>在设计用例时，对于复杂逻辑，我会<strong>阅读核心代码</strong>（Code Review）来确保没有遗漏特定的逻辑分支（比如特殊的 if&#x2F;else 组合）。</li><li>执行自动化测试后，我会关注<strong>代码覆盖率</strong>，利用白盒工具发现漏测的代码块。</li><li>在定位 Bug 时，我会通过查看<strong>代码和日志</strong>来精准定位问题根源，而不仅仅是停留在 UI 报错层面。”</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>软件测试理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/08/hello-world/"/>
    <url>/2025/12/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
