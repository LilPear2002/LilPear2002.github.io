

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="测开求职者">
  <meta name="keywords" content="">
  
    <meta name="description" content="Python 进阶知识，包括面向对象、装饰器、深浅拷贝、多线程、网络编程等">
<meta property="og:type" content="article">
<meta property="og:title" content="Python进阶">
<meta property="og:url" content="https://lilpear2002.github.io/2025/12/10/Python%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="测开学习之路">
<meta property="og:description" content="Python 进阶知识，包括面向对象、装饰器、深浅拷贝、多线程、网络编程等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lilpear2002.github.io/img/python.png">
<meta property="article:published_time" content="2025-12-10T02:18:48.000Z">
<meta property="article:modified_time" content="2025-12-10T14:41:34.305Z">
<meta property="article:author" content="测开求职者">
<meta property="article:tag" content="Python进阶">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="拷贝">
<meta property="article:tag" content="装饰器">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lilpear2002.github.io/img/python.png">
  
  
  
  <title>Python进阶 - 测开学习之路</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lilpear2002.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/Java/" target="_self">
                <i class="iconfont icon-code-fill"></i>
                <span>Java基础</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/Python/" target="_self">
                <i class="iconfont icon-code-fill"></i>
                <span>Python基础</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/Testing/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>测试基础</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/Java%E9%A1%B9%E7%9B%AE/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>Java项目</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E6%B5%8B%E5%BC%80%E9%A1%B9%E7%9B%AE/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>测开项目</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E7%A7%91%E7%A0%94%E7%BB%8F%E5%8E%86/" target="_self">
                <i class="iconfont icon-lab-fill"></i>
                <span>科研经历</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/LLM/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>大模型</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Python进阶"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-10 10:18" pubdate>
          2025年12月10日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          136 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Python进阶</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: 演示定义汽车类 及  使用类中的成员.</span><br><span class="hljs-string"></span><br><span class="hljs-string">面向对象核心概念:</span><br><span class="hljs-string">    类: 抽象的概念, 看不见, 摸不着, 是 属性(名词) 和 行为(动词)的集合.</span><br><span class="hljs-string">    对象: 类的具体体现, 实现.</span><br><span class="hljs-string">    属性(名词): 用来描述事物的外在特征的, 例如: 姓名, 年龄...</span><br><span class="hljs-string">        格式: 和以前定义变量一样.</span><br><span class="hljs-string">    行为(动词): 用来描述事物能够做什么的, 例如: 吃, 喝...</span><br><span class="hljs-string">        格式: 和以前定义函数一样.</span><br><span class="hljs-string"></span><br><span class="hljs-string">定义类的格式:</span><br><span class="hljs-string">    class 类名:</span><br><span class="hljs-string">        # 属性</span><br><span class="hljs-string">        # 行为</span><br><span class="hljs-string"></span><br><span class="hljs-string">如何访问类中的成员?</span><br><span class="hljs-string">    step1: 创建该类的对象.</span><br><span class="hljs-string">        对象名 = 类名()</span><br><span class="hljs-string">    step2: 通过 对象名. 的方式调用.</span><br><span class="hljs-string">        对象性.属性名</span><br><span class="hljs-string">        对象名.行为名()</span><br><span class="hljs-string"></span><br><span class="hljs-string">需求: 定义汽车类, 有跑的行为.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 1.定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:      <span class="hljs-comment"># 类名遵循 大驼峰命名法.</span><br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><br><span class="hljs-comment"># 3. 调用Car类的run()函数, 简写版: 调用Car#run()</span><br>c1.run()<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">案例: self关键字介绍.</span><br><span class="hljs-string"></span><br><span class="hljs-string">self介绍:</span><br><span class="hljs-string">    概述:</span><br><span class="hljs-string">        它是Python内置的关键字, 用于表示 本类当前对象的引用.</span><br><span class="hljs-string">    作用:</span><br><span class="hljs-string">        1个类是可以有多个对象的, 这多个对象都可以通过 对象名. 的方式访问类中的行为(函数)</span><br><span class="hljs-string">        函数默认有self属性, 函数通过self来区分到底是哪个对象调用的该函数.</span><br><span class="hljs-string">    大白话:</span><br><span class="hljs-string">        谁调用函数, self就代表哪个对象.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 需求: 定义汽车类, 创建多个该类的对象, 看看打印结果.</span><br><span class="hljs-comment"># 1. 定义汽车类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 属性</span><br><br>    <span class="hljs-comment"># 行为, 跑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;汽车会跑!...&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是run函数, self的值是: <span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 2.创建汽车类的对象.</span><br>c1 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1对象: <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c1.run()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">34</span>)<br><br><span class="hljs-comment"># 3.继续创建汽车类的对象.</span><br>c2 = Car()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2对象: <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 通过 对象名. 的形式, 调用Car#run()</span><br>c2.run()<br></code></pre></td></tr></table></figure>

<hr>
<img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/self.png" srcset="/img/loading.gif" lazyload class="" title="self">

<p>这张图非常生动地展示了 <strong>Python 面向对象编程（OOP）中的内存管理机制</strong>，特别是<strong>对象（Object）与引用（Reference）的关系，以及实例属性</strong>是如何存储的。</p>
<p>这张图主要分为三个部分：<strong>代码区（左侧）</strong>、<strong>内存结构示意图（右侧，包含栈、堆、方法区）</strong>。</p>
<p>我将为你详细拆解这张图背后的逻辑：</p>
<h3 id="1-核心概念：内存的三大区域"><a href="#1-核心概念：内存的三大区域" class="headerlink" title="1. 核心概念：内存的三大区域"></a>1. 核心概念：内存的三大区域</h3><ul>
<li><strong>栈 (Stack)</strong>：<ul>
<li>图中的左侧竖条。</li>
<li><strong>作用</strong>：存储局部变量（即变量名）。在这里存储的是 <code>c1</code> 和 <code>c2</code>。</li>
<li><strong>本质</strong>：它们只是**引用（Reference）**或者说是“标签”，它们本身不存数据，而是指向堆内存中的具体地址（如 <code>0x01</code> 和 <code>0x02</code>）。</li>
</ul>
</li>
<li><strong>堆 (Heap)</strong>：<ul>
<li>图中的右侧蓝色大框。</li>
<li><strong>作用</strong>：存储真正的<strong>对象实例</strong>。</li>
<li><strong>内容</strong>：这里有两个 <code>Car()</code> 对象。每个对象都有自己独立的内存空间（地址 <code>0x01</code> 和 <code>0x02</code>）。对象内部存储该对象的具体数据（属性）。</li>
</ul>
</li>
<li><strong>方法区 (Method Area)</strong>：<ul>
<li>图中的右下角红色框。</li>
<li><strong>作用</strong>：存储类的定义和方法的代码。</li>
<li><strong>关键点</strong>：<code>run(self)</code> 这个方法只有一份代码（地址 <code>0x03</code>）。无论你创建多少个 <code>Car</code> 对象，它们调用的 <code>run</code> 方法都是同一个，不需要为每个对象复制一份代码。</li>
</ul>
</li>
</ul>
<h3 id="2-代码执行流程与内存变化"><a href="#2-代码执行流程与内存变化" class="headerlink" title="2. 代码执行流程与内存变化"></a>2. 代码执行流程与内存变化</h3><p>让我们跟随左侧的代码，看看内存里发生了什么：</p>
<h4 id="第一步：创建-c1-对象"><a href="#第一步：创建-c1-对象" class="headerlink" title="第一步：创建 c1 对象"></a>第一步：创建 c1 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c1</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>内存动作</strong>：<ol>
<li>在<strong>堆</strong>中开辟一块空间（假设地址 <code>0x01</code>）生成一个 <code>Car</code> 对象。</li>
<li>在<strong>栈</strong>中创建一个变量 <code>c1</code>。</li>
<li>将 <code>c1</code> 指向 <code>0x01</code>（图中绿色的箭头）。</li>
</ol>
</li>
<li>此时，<code>c1</code> 对象内部包含一个指向方法区的指针 <code>0x03</code>，以便能调用 <code>run()</code> 方法。</li>
</ul>
<h4 id="第二步：给-c1-添加属性（动态属性）"><a href="#第二步：给-c1-添加属性（动态属性）" class="headerlink" title="第二步：给 c1 添加属性（动态属性）"></a>第二步：给 c1 添加属性（动态属性）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">c1.color</span> = <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-attr">c1.number</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>内存动作</strong>：<ul>
<li>Python 是动态语言，允许在对象创建后随意添加属性。</li>
<li>图中的 <code>c1</code> 对象（<code>0x01</code> 盒子）里，现在多了两行数据：<code>color=&#39;红色&#39;</code> 和 <code>number=4</code>。</li>
<li><strong>注意</strong>：这些数据是<strong>独属于</strong> <code>c1</code> 这个对象的。</li>
</ul>
</li>
</ul>
<h4 id="第三步：创建-c2-对象"><a href="#第三步：创建-c2-对象" class="headerlink" title="第三步：创建 c2 对象"></a>第三步：创建 c2 对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c2</span> <span class="hljs-operator">=</span> Car()<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>内存动作</strong>：<ol>
<li>在<strong>堆</strong>中开辟一块<strong>新的</strong>空间（地址 <code>0x02</code>）。</li>
<li>在<strong>栈</strong>中创建变量 <code>c2</code>。</li>
<li>将 <code>c2</code> 指向 <code>0x02</code>（图中深红色的箭头）。</li>
</ol>
</li>
<li><strong>关键区别</strong>：<code>c2</code> 是一个全新的对象。虽然它也是 <code>Car</code>，但因为它刚出生，还没有人给它赋值 <code>color</code> 和 <code>number</code>，所以图中的 <code>c2</code> 盒子（<code>0x02</code>）里是<strong>空的</strong>（只有指向方法的 <code>0x03</code>）。</li>
</ul>
<h4 id="第四步：代码中的注释细节-细节-3"><a href="#第四步：代码中的注释细节-细节-3" class="headerlink" title="第四步：代码中的注释细节 (细节 3)"></a>第四步：代码中的注释细节 (细节 3)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(f<span class="hljs-string">&#x27;颜色: &#123;c2.color&#125;...&#x27;</span>)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这行代码被注释掉了，因为如果运行它会<strong>报错</strong>（AttributeError）。</li>
<li><strong>原因</strong>：看堆内存图就很清楚，<code>c2</code> 指向的 <code>0x02</code> 盒子里并没有 <code>color</code> 和 <code>number</code> 数据。属性不会自动从 <code>c1</code> 传染给 <code>c2</code>。</li>
</ul>
<h3 id="3-图解总结-Key-Takeaways"><a href="#3-图解总结-Key-Takeaways" class="headerlink" title="3. 图解总结 (Key Takeaways)"></a>3. 图解总结 (Key Takeaways)</h3><ol>
<li><strong>同类不同命</strong>：<code>c1</code> 和 <code>c2</code> 虽然都是 <code>Car</code> 类造出来的，但它们是两个独立的个体。修改 <code>c1</code> 的属性不会影响 <code>c2</code>。</li>
<li><strong>方法共享，数据独享</strong>：<ul>
<li><strong>数据（属性）</strong>：存在<strong>堆</strong>里各自的对象中（<code>c1</code> 有颜色，<code>c2</code> 没有）。</li>
<li><strong>行为（方法）</strong>：存在<strong>方法区</strong>里，大家共用同一个（地址 <code>0x03</code>）。</li>
</ul>
</li>
<li><strong>引用传递</strong>：变量名（<code>c1</code>）只是一个遥控器，它通过内存地址控制真正的对象。</li>
</ol>
<hr>
<p>**问：**如果每个对象调用的方法都指向同一个地址，那假如这个方法中有修改对象属性的逻辑，那岂不是一个对象调用之后，别的对象的属性也被修改了？</p>
<p>答案是：<strong>完全不会。</strong></p>
<p>其中的关键就在于 Python 方法中的第一个参数 —— <strong><code>self</code></strong>。</p>
<p>虽然代码（指令）只有一份，存在方法区里（比如地址 <code>0x03</code>），但<strong>执行这份代码时操作的数据对象</strong>是不同的。</p>
<h3 id="核心机制：self-就是那个“定位器”"><a href="#核心机制：self-就是那个“定位器”" class="headerlink" title="核心机制：self 就是那个“定位器”"></a>核心机制：<code>self</code> 就是那个“定位器”</h3><p>你可以把方法区里的代码看作是一本**“公用操作手册”**。</p>
<p>假如 <code>run</code> 方法里有一句代码是修改颜色的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 修改属性</span><br></code></pre></td></tr></table></figure>

<p>当你调用方法时，Python 在后台做了一个**“隐式传递”**的操作：</p>
<h4 id="1-当-c1-调用时"><a href="#1-当-c1-调用时" class="headerlink" title="1. 当 c1 调用时"></a>1. 当 <code>c1</code> 调用时</h4><p>你写的是：c1.run()</p>
<p>Python 实际执行的是：Car.run(c1)  &lt;– 看这里！</p>
<ul>
<li>它把 <code>c1</code> 的地址（<code>0x01</code>）传给了 <code>self</code>。</li>
<li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c1.color = &#39;黑色&#39;</code>。</li>
<li>于是，只有 <strong>堆内存中 0x01 号盒子</strong> 里的 <code>color</code> 变成了黑色。</li>
</ul>
<h4 id="2-当-c2-调用时"><a href="#2-当-c2-调用时" class="headerlink" title="2. 当 c2 调用时"></a>2. 当 <code>c2</code> 调用时</h4><p>你写的是：c2.run()</p>
<p>Python 实际执行的是：Car.run(c2)</p>
<ul>
<li>这次它把 <code>c2</code> 的地址（<code>0x02</code>）传给了 <code>self</code>。</li>
<li>方法里的代码 <code>self.color = &#39;黑色&#39;</code> 就变成了 <code>c2.color = &#39;黑色&#39;</code>。</li>
<li>于是，是 <strong>堆内存中 0x02 号盒子</strong> 里的数据被修改了。</li>
</ul>
<hr>
<h2 id="魔术方法init"><a href="#魔术方法init" class="headerlink" title="魔术方法init"></a>魔术方法init</h2><p><strong>init</strong>()魔法方法, 在创建对象的时候, 会被自动调用, 一般用于给该类对象 的属性进行初始化.</p>
<p>无参版 init -&gt;  默认上的有底色, 你需要重新涂色(覆盖底色)<br>有参版 init -&gt;  默认没有涂色的石膏娃娃, 我们根据喜好自由涂色即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时不需要参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.color = <span class="hljs-string">&#x27;黑色&#x27;</span>  <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br>        <span class="hljs-variable language_">self</span>.number = <span class="hljs-number">3</span>      <span class="hljs-comment"># 【出厂设置】先写入默认值</span><br><br><span class="hljs-comment"># 情况 A：c2 (保留默认)</span><br>c2 = Car()<br><span class="hljs-comment"># 此时内存里是：黑色, 3</span><br><br><span class="hljs-comment"># 情况 B：c1 (后期改装)</span><br>c1 = Car()          <br><span class="hljs-comment"># 1. 此时内存里也是：黑色, 3</span><br>c1.color = <span class="hljs-string">&#x27;红色&#x27;</span>   <br><span class="hljs-comment"># 2. 【覆盖动作】：找到内存里的&#x27;黑色&#x27;，把它擦掉，换成&#x27;红色&#x27;</span><br>c1.number = <span class="hljs-number">6</span>       <br><span class="hljs-comment"># 3. 【覆盖动作】：找到内存里的3，把它擦掉，换成6</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c2: <span class="hljs-subst">&#123;c2.color&#125;</span>, <span class="hljs-subst">&#123;c2.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：黑色, 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>) <span class="hljs-comment"># 输出：红色, 6</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-comment"># 初始化时，强制要求传入颜色和数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color    <span class="hljs-comment"># 直接赋值为传入的参数</span><br>        <span class="hljs-variable language_">self</span>.number = number<br><br><span class="hljs-comment"># 【内存动作】：</span><br><span class="hljs-comment"># 在堆内存创建对象时，直接写入 &#x27;红色&#x27; 和 6。</span><br><span class="hljs-comment"># 不需要先写入默认值再擦除。</span><br>c1 = Car(<span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-number">6</span>) <br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c1: <span class="hljs-subst">&#123;c1.color&#125;</span>, <span class="hljs-subst">&#123;c1.number&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：c1: 红色, 6</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="魔术方法str"><a href="#魔术方法str" class="headerlink" title="魔术方法str"></a>魔术方法str</h2><p>当用print()函数 打印对象的时候, 会自动调用该对象(所在类)的 str魔法方法.该魔法方法默认打印的是对象的地址值, 无意义, 一般都会重写, 改为打印对象的各个属性值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-comment"># 输出结果类似：&lt;__main__.Car object at 0x000001&gt;  (看不懂，只知道是个Car对象)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, color, number</span>):<br>        <span class="hljs-variable language_">self</span>.color = color<br>        <span class="hljs-variable language_">self</span>.number = number<br><br>    <span class="hljs-comment"># 定义对象的字符串表现形式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 必须返回一个字符串！</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;【车辆信息】颜色：<span class="hljs-subst">&#123;self.color&#125;</span>，轮胎数：<span class="hljs-subst">&#123;self.number&#125;</span>&quot;</span><br><br>c1 = Car(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 此时 print 内部会自动调用 c1.__str__()</span><br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-comment"># 输出结果：【车辆信息】颜色：红色，轮胎数：4</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="魔术方法del"><a href="#魔术方法del" class="headerlink" title="魔术方法del"></a>魔术方法del</h2><p>当.py文件执行结束, 或者 手动 del 释放对象资源, 会自动调用该函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【出生】<span class="hljs-subst">&#123;self.name&#125;</span> 被制造出来了！&quot;</span>)<br><br>    <span class="hljs-comment"># 定义对象销毁时要执行的逻辑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;【消亡】<span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了，送去回收站。&quot;</span>)<br><br><span class="hljs-comment"># 1. 创建对象</span><br>c1 = Car(<span class="hljs-string">&quot;宝马&quot;</span>)<br><br><span class="hljs-comment"># 2. 模拟一些操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 正在开车中 ---&quot;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 3. 手动删除对象（或者当程序运行结束时，也会自动触发）</span><br><span class="hljs-keyword">del</span> c1 <br><span class="hljs-comment"># 此时，c1 的引用计数变为0，Python 自动调用 __del__ 【消亡】宝马 被销毁了，送去回收站。</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="模数方法lt-le-eq"><a href="#模数方法lt-le-eq" class="headerlink" title="模数方法lt&#x2F;le&#x2F;eq"></a>模数方法lt&#x2F;le&#x2F;eq</h2><p>这三个魔术方法让你的对象可以使用 <strong>比较运算符</strong>（<code>&lt;</code>, <code>&lt;=</code>, <code>==</code>）进行 PK。如果不写这些方法，Python 不知道怎么比较两个自定义对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-comment"># __lt__ 对应 &lt; (Less Than)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt; other.score<br><br>    <span class="hljs-comment"># __le__ 对应 &lt;= (Less Than or Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score &lt;= other.score<br><br>    <span class="hljs-comment"># __eq__ 对应 == (Equal)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.score == other.score<br><br><span class="hljs-comment"># 创建学生对象</span><br>s1 = Student(<span class="hljs-number">80</span>)<br>s2 = Student(<span class="hljs-number">90</span>)<br>s3 = Student(<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># Python 会自动调用对应的方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt; s2 : <span class="hljs-subst">&#123;s1 &lt; s2&#125;</span>&quot;</span>)   <span class="hljs-comment"># 调用 s1.__lt__(s2)，80 &lt; 90，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 &lt;= s3: <span class="hljs-subst">&#123;s1 &lt;= s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__le__(s3)，80 &lt;= 80，结果 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1 == s3: <span class="hljs-subst">&#123;s1 == s3&#125;</span>&quot;</span>)  <span class="hljs-comment"># 调用 s1.__eq__(s3)，80 == 80，结果 True</span><br><br><span class="hljs-comment"># 甚至可以直接用在列表中排序（主要依赖 __lt__）</span><br>students = [s2, s1]<br>students.sort() <span class="hljs-comment"># 此时 Python 知道按分数排</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一名分数: <span class="hljs-subst">&#123;students[-<span class="hljs-number">1</span>].score&#125;</span>&quot;</span>) <span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>是一种编程思想, 强调的是以 <strong>对象</strong> 为基础完成各种操作，其三大特性：</p>
<ul>
<li>封装：大白话：把属性和方法封装在一起，仅提供对外的方法让别人去访问。好处： 简化编程</li>
<li>继承：大白话：孩子可使用老爹的东西。好处：代码复用</li>
<li>多态：大白话：同样一个函数（消息）在不同场景下表现出不同形态。 好处：解耦合，可拓展</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装 (Encapsulation)</strong> 的核心思想是：<strong>把重要的数据锁在保险箱里，只留一个小窗口（方法）对外办事。</strong></p>
<p>这样做可以防止外部随意修改内部数据，保证数据的安全性。在 Python 中，在属性名前加 <strong>两个下划线 <code>__</code></strong>，就可以把它变成**私有（Private）**的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, money</span>):<br>        <span class="hljs-variable language_">self</span>.name = name          <span class="hljs-comment"># 公有属性：大家都能看</span><br>        <span class="hljs-variable language_">self</span>.__balance = money    <span class="hljs-comment"># 私有属性：加了__，只有自己能看/改</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来查看余额 (Getter)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_balance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;用户 <span class="hljs-subst">&#123;self.name&#125;</span> 当前余额：<span class="hljs-subst">&#123;self.__balance&#125;</span> 元&quot;</span><br><br>    <span class="hljs-comment"># 提供一个公开的方法来修改余额 (Setter)，可以在这里加安全判断</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_money</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.__balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功存入 <span class="hljs-subst">&#123;amount&#125;</span> 元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存钱金额必须大于0！&quot;</span>)<br><br>acc = Account(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 1. 正常操作：通过方法访问</span><br>acc.save_money(<span class="hljs-number">500</span>)<br><span class="hljs-built_in">print</span>(acc.check_balance())<br><br><span class="hljs-comment"># 2. 违规操作：尝试直接访问私有属性</span><br><span class="hljs-comment"># print(acc.__balance)  </span><br><span class="hljs-comment"># 报错：AttributeError（Python 会假装在这个对象里找不到 __balance）</span><br><br><span class="hljs-comment"># 3. 绕过封装（虽然不推荐，但原理要知道）</span><br><span class="hljs-comment"># Python 实际上是把名字改成了 _类名__属性名</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;强行偷看：<span class="hljs-subst">&#123;acc._Account__balance&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类可以继承父类的属性和行为</p>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大口干饭...&quot;</span>)<br><br><span class="hljs-comment"># 2. 定义子类，括号里写父类的名字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-comment"># 3. 使用</span><br>wangcai = Dog()<br>wangcai.bark()  <span class="hljs-comment"># 调用自己的方法</span><br>wangcai.eat()   <span class="hljs-comment"># 【关键】调用父类的方法（虽然Dog里没写eat，但它继承下来了）</span><br></code></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会飞高高&quot;</span>)<br><br><span class="hljs-comment"># 父类 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我会跑得快&quot;</span>)<br><br><span class="hljs-comment"># 子类：括号里写多个父类，用逗号隔开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Flyer, Mammal):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bite</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我还咬人！&quot;</span>)<br><br><span class="hljs-comment"># 使用</span><br>bianfu = Bat()<br>bianfu.fly()   <span class="hljs-comment"># 继承自 Flyer</span><br>bianfu.run()   <span class="hljs-comment"># 继承自 Mammal</span><br>bianfu.bite()  <span class="hljs-comment"># 自己的</span><br></code></pre></td></tr></table></figure>

<h3 id="子类重写父类的功能"><a href="#子类重写父类的功能" class="headerlink" title="子类重写父类的功能"></a>子类重写父类的功能</h3><p>有两种常见的重写方式：</p>
<ol>
<li><strong>完全覆盖</strong>：彻底抛弃父类的做法，另起炉灶。</li>
<li><strong>功能扩展</strong>：保留父类的核心逻辑（用 <code>super()</code>），然后增加新功能。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 父类：普通的狗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;汪汪汪！(普通叫声)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;也就是个慢跑...&quot;</span>)<br><br><span class="hljs-comment"># 2. 子类A：哈士奇 (完全覆盖)</span><br><span class="hljs-comment"># 哈士奇不想“汪汪汪”，它想“嗷呜”，所以它彻底改写了 bark 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;嗷呜~~~~ (狼嚎)&quot;</span>)<br><br><span class="hljs-comment"># 3. 子类B：警犬 (功能扩展)</span><br><span class="hljs-comment"># 警犬也得先像普通狗一样叫，但叫完之后还得抓坏人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoliceDog</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 【关键步骤】super() 代表父类</span><br>        <span class="hljs-comment"># 先执行父类的 bark (输出“汪汪汪”)</span><br>        <span class="hljs-built_in">super</span>().bark() <br>        <span class="hljs-comment"># 然后再执行自己的特殊逻辑</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 发现坏人，猛扑上去！&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br>h = Husky()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 哈士奇 ---&quot;</span>)<br>h.bark() <br><span class="hljs-comment"># 输出：嗷呜~~~~ (父类的逻辑完全不见了)</span><br><br>p = PoliceDog()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 警犬 ---&quot;</span>)<br>p.bark()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 汪汪汪！(普通叫声)  &lt;-- 来自 super().bark()</span><br><span class="hljs-comment"># &gt;&gt;&gt; 发现坏人，猛扑上去！</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="子类访问父类功能"><a href="#子类访问父类功能" class="headerlink" title="子类访问父类功能"></a>子类访问父类功能</h3><p>子类重写父类功能后, 继续访问父类功能 </p>
<ol>
<li>父类名.父类函数名(self)      精准访问, 想找哪个父类, 就调哪个父类.</li>
<li>super().父类函数名()        只能访问最近的那个父类, 有就用, 没有就往后继续查找.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👴 父亲的技能：编程 (Python)&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;👩 母亲的技能：画画 (Painting)&quot;</span>)<br><br><span class="hljs-comment"># 注意继承顺序：Father 在前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Father, Mother):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">skill</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是孩子，开始展示技能...&quot;</span>)<br><br>        <span class="hljs-comment"># --- 方式 1: super() (自动挡) ---</span><br>        <span class="hljs-comment"># 规则：只找 MRO 列表里的“下一个”。</span><br>        <span class="hljs-comment"># 因为 class Child(Father, Mother)，Father 排前面，</span><br>        <span class="hljs-comment"># 所以 super() 只能调到 Father，直接忽略了 Mother。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 1: super().skill()】&quot;</span>)<br>        <span class="hljs-built_in">super</span>().skill()<br><br>        <span class="hljs-comment"># --- 方式 2: 类名.方法(self) (手动挡) ---</span><br>        <span class="hljs-comment"># 规则：指哪打哪。</span><br>        <span class="hljs-comment"># 即使 Mother 排在后面，super() 够不着，</span><br>        <span class="hljs-comment"># 我依然可以通过“类名”强行调用她。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n【方式 2: Mother.skill(self)】&quot;</span>)<br>        Mother.skill(<span class="hljs-variable language_">self</span>)<br><br><span class="hljs-comment"># 运行测试</span><br>c = Child()<br>c.skill()<br><span class="hljs-comment"># 我是孩子，开始展示技能...</span><br><br><span class="hljs-comment"># 【方式 1: super().skill()】</span><br><span class="hljs-comment"># 👴 父亲的技能：编程 (Python)</span><br><br><span class="hljs-comment"># 【方式 2: Mother.skill(self)】</span><br><span class="hljs-comment"># 👩 母亲的技能：画画 (Painting)</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个函数, 接收不同的参数, 有不同的效果。即同一个指令，不同的对象去做，会有不同的行为。</p>
<p>多态的一般前提条件:1.要有继承.2.有方法重写, 不然多态无意义.3.要有父类引用指向子类对象.但在 Python 中，多态更加灵活，归因于Python 动态语言灵活性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 必须有继承 (条件1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Charger</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-comment"># 2. 必须重写 (条件2)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 Type-C 充电...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lightning_Charger</span>(<span class="hljs-title class_ inherited__">Charger</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在用 苹果头 充电...&quot;</span>)<br><br><span class="hljs-comment"># 函数定义必须暗示接收父类类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">charger_obj: Charger</span>): <span class="hljs-comment"># 类型提示只是提示，不强制</span><br>    charger_obj.charge()<br><br><span class="hljs-comment"># 3. 父类引用指向子类 (在Python里变量没有类型，所以这一步是隐式的)</span><br>c1 = TypeC_Charger()<br>power_up(c1)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC_Charger</span>:<br>    <span class="hljs-comment"># 没有继承任何父类！</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Type-C 充电中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span>:<br>    <span class="hljs-comment"># 这是一个汉堡，跟充电器没半毛钱关系</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是一个汉堡，但我居然也有 charge 方法！充能中（热量+100）&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">power_up</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-comment"># Python 不管你是什么类，只管你有没有 charge 方法</span><br>    obj.charge() <br><br>t = TypeC_Charger()<br>b = Burger()<br><br>power_up(t) <span class="hljs-comment"># 正常工作</span><br>power_up(b) <span class="hljs-comment"># 居然也正常工作！这就是鸭子类型</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类解释:<br>        抽象类一般充当父类, 用于指定行业规范, 准则, 具体的实现交由 子类 来完成.</p>
<h3 id="父类制定标准，子类去实现-思想"><a href="#父类制定标准，子类去实现-思想" class="headerlink" title="父类制定标准，子类去实现(思想)"></a>父类制定标准，子类去实现(思想)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义抽象类, 空调类, 设定: 空调的规则.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC</span>:<br>    <span class="hljs-comment"># 1.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 1.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 2. 定义子类(小米空调), 实现父类(空调类)中的所有抽象方法.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-comment"># 2.1 制冷</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制冷技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.2 制热</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米 核心 制热技术!&#x27;</span>)<br><br>    <span class="hljs-comment"># 2.3 左右摆风</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小米空调 静音左右摆风 技术!&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 4.1 小米空调</span><br>    xm = XiaoMi()<br>    xm.cool_wind()<br>    xm.hot_wind()<br>    xm.swing_l_r()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure>

<h3 id="引入-abc-模块（Abstract-Base-Class）-严谨"><a href="#引入-abc-模块（Abstract-Base-Class）-严谨" class="headerlink" title="引入 abc 模块（Abstract Base Class）(严谨)"></a>引入 <code>abc</code> 模块（Abstract Base Class）(严谨)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 1. 定义抽象类：必须继承 ABC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义抽象方法：加上装饰器 @abstractmethod</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 这里不写具体逻辑，因为不知道怎么付，只占个位</span><br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># ❌ 错误演示：尝试直接创建抽象类对象</span><br><span class="hljs-comment"># p = Payment() </span><br><span class="hljs-comment"># 报错：TypeError: Can&#x27;t instantiate abstract class Payment...</span><br><span class="hljs-comment"># (意思：Payment 是抽象的，是个半成品，不能直接用)</span><br><br><br><span class="hljs-comment"># ✅ 正确演示：子类继承并实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-comment"># 【必须重写】如果不写这个方法，AliPay 也会报错</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;支付宝支付中...&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;微信支付中...&quot;</span>)<br><br><span class="hljs-comment"># 3. 正常使用</span><br>ali = AliPay()<br>ali.pay()<br></code></pre></td></tr></table></figure>

<p>在python中，<strong>抽象类（ABC）和接口（Interface）在语法上是同一个东西</strong>。如果你把一个抽象类里的方法全写成空（只有定义没实现），它就是接口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 用法 A：当作【接口】用 (全都是抽象方法，没有具体实现)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USBInterface</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 用法 B：当作【抽象类】用 (有一部分共用的代码)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;闭眼睡觉...&quot;</span>)  <span class="hljs-comment"># 这是一个具体功能</span><br>    <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="类属性和对象属性"><a href="#类属性和对象属性" class="headerlink" title="类属性和对象属性"></a>类属性和对象属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># --- 这里是【类属性】 ---</span><br>    <span class="hljs-comment"># 定义在方法外面，这是大家共享的</span><br>    school = <span class="hljs-string">&quot;霍格沃茨魔法学校&quot;</span><br>    count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用来记录一共招生了多少人</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># --- 这里是【实例属性】 ---</span><br>        <span class="hljs-comment"># 定义在 __init__ 里，绑定在 self 上，是个人的</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <br>        <span class="hljs-comment"># 每创建一个学生，班级总人数就 +1</span><br>        <span class="hljs-comment"># 注意：要修改类属性，最好用 类名.属性</span><br>        Student.count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 1. 创建两个学生</span><br>s1 = Student(<span class="hljs-string">&quot;哈利波特&quot;</span>, <span class="hljs-number">11</span>)<br>s2 = Student(<span class="hljs-string">&quot;罗恩&quot;</span>, <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 2. 访问实例属性 (每个人不一样) 只能通过对象访问</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的名字: <span class="hljs-subst">&#123;s1.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 哈利波特</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的名字: <span class="hljs-subst">&#123;s2.name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 罗恩</span><br><br><span class="hljs-comment"># 3. 访问类属性 (大家都一样)</span><br><span class="hljs-comment"># 可以通过对象访问，也可以通过类名访问(推荐)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s1的学校: <span class="hljs-subst">&#123;s1.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s2的学校: <span class="hljs-subst">&#123;s2.school&#125;</span>&quot;</span>)      <span class="hljs-comment"># 霍格沃茨</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目前招生人数: <span class="hljs-subst">&#123;Student.count&#125;</span>&quot;</span>) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>    属于类的方法, 可以通过类名. 还可以通过对象名. 的方式来调用.<br>    定义类方法的时候, 必须使用装饰器 @classmethod, 且第1个参数必须表示类对象.</p>
<p>静态方法:<br>    属于该类下所有对象所共享的方法, 可以通过类名. 还可以通过 对象名.的方式来调用.<br>    定义静态方法的时候, 必须使用装饰器 @staticmethod, 且参数传不传都可以.</p>
<p>区别:<br>       1. 类方法的第1个参数必须是类对象, 静态方法无参数的特殊要求<br>       2. 你可以理解为: 如果函数中要用类对象, 就定义成类方法, 否则定义成静态方法, 除此外并无任何区别.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 定义学生类.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># 2. 定义类属性.</span><br>    school = <span class="hljs-string">&#x27;黑马程序员&#x27;</span><br><br>    <span class="hljs-comment"># 3. 定义类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show1</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cls: <span class="hljs-subst">&#123;cls&#125;</span>&#x27;</span>)        <span class="hljs-comment"># &lt;class &#x27;__main__.Student&#x27;&gt;</span><br>        <span class="hljs-built_in">print</span>(cls.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是类方法&#x27;</span>)<br><br>    <span class="hljs-comment"># 4. 定义静态方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show2</span>():<br>        <span class="hljs-built_in">print</span>(Student.school)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是静态方法&#x27;</span>)<br><br><span class="hljs-comment"># 5. 测试.</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s1 = Student()<br>    s1.show1()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">23</span>)<br>    s1.show2()<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包入门"><a href="#闭包入门" class="headerlink" title="闭包入门"></a>闭包入门</h2><p>通常情况下，函数内部的变量是“临时工”，函数执行完，变量就被销毁（内存释放）了。</p>
<p>但是<strong>闭包</strong>不同，它可以让一个函数<strong>把外部的变量“打包带走”</strong>。即使外部函数已经执行完了，内部函数依然能访问并使用那个变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 外部函数 (工厂)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">config_greeting</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-comment"># msg 是外部函数的变量 (零件)</span><br>    <br>    <span class="hljs-comment"># 2. 内部函数 (工人)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-comment"># 3. 内部使用了外部变量 msg</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;msg&#125;</span>, <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 4. 返回内部函数 (工人背着零件走了)</span><br>    <span class="hljs-keyword">return</span> printer<br><br><span class="hljs-comment"># --- 关键看这里 ---</span><br><br><span class="hljs-comment"># 创建一个闭包实例：配置为 &quot;Hello&quot;</span><br>say_hello = config_greeting(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-comment"># 此时，config_greeting 函数其实已经运行结束了！</span><br><span class="hljs-comment"># 按理说变量 &quot;Hello&quot; 应该从内存消失，但它被 printer 抓住了。</span><br><br><span class="hljs-comment"># 创建另一个闭包实例：配置为 &quot;你好&quot;</span><br>say_nihao = config_greeting(<span class="hljs-string">&quot;你好&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br>say_hello(<span class="hljs-string">&quot;张三&quot;</span>)  <span class="hljs-comment"># 输出：Hello, 张三</span><br>say_nihao(<span class="hljs-string">&quot;李四&quot;</span>)  <span class="hljs-comment"># 输出：你好, 李四</span><br></code></pre></td></tr></table></figure>

<h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><p><code>nonlocal</code> 的作用是：<strong>允许内部函数修改外部函数（闭包）中的变量</strong>。</p>
<p>Python 有一个保护机制：如果你在函数内部给一个变量赋值（比如 <code>a = 10</code>），Python 默认会认为这只是一个<strong>全新的局部变量</strong>，跟外面的那个 <code>a</code> 没关系。</p>
<p>这就导致了一个问题：如果想<strong>修改</strong>外面的变量，而不是<strong>新建</strong>一个，程序会报错或者不符合预期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>():<br>        <span class="hljs-comment"># 【关键】声明：我要修改外面的那个 count！</span><br>        <span class="hljs-keyword">nonlocal</span> count <br>        <br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前计数: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>        <br>    <span class="hljs-keyword">return</span> adder<br><br>c = make_counter()<br>c()  <span class="hljs-comment"># 输出：当前计数: 1</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 2</span><br>c()  <span class="hljs-comment"># 输出：当前计数: 3</span><br></code></pre></td></tr></table></figure>

<p>问：<code>nonlocal</code> vs <code>global</code> 的区别？</p>
<p><strong><code>global</code></strong>：</p>
<ul>
<li>用于修改<strong>全局变量</strong>（整个模块级别的）。</li>
<li>它是去<strong>最外层</strong>找变量。</li>
</ul>
<p><strong><code>nonlocal</code></strong>：</p>
<ul>
<li>用于修改<strong>嵌套函数中的变量</strong>（闭包里的）。</li>
<li>它是去<strong>上一层（或上上层）函数找变量，但绝不</strong>去全局找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全局变量</span><br>score = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_score</span>():<br>    <span class="hljs-comment"># 【声明】：我要用的这个 score 是全局那个！不是新建的！</span><br>    <span class="hljs-keyword">global</span> score<br>    <br>    score += <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;游戏得分！&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 0</span><br><br>add_score()<br>add_score()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终分数: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)  <span class="hljs-comment"># 200 (真的被改掉了)</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><p><strong>装饰器本质上就是一个闭包，它的作用是在不修改原函数代码的前提下，给原函数“增加新功能”</strong></p>
<p><strong>核心原则：开放封闭原则 (Open-Closed Principle)</strong></p>
<ul>
<li><strong>封闭</strong>：对修改源代码封闭（不要动原来的代码）</li>
<li><strong>开放</strong>：对扩展功能开放（想加日志、想加权限验证，随便加）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 接收一个函数作为参数 (外部函数)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_gift</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 定义内部函数 (包装纸)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 🎁 正在包装礼物...&quot;</span>)<br>        <span class="hljs-comment"># 3. 调用原函数 (放入礼物)</span><br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; ✅ 礼物已发出！&quot;</span>)<br>        <br>    <span class="hljs-comment"># 4. 返回内部函数</span><br>    <span class="hljs-keyword">return</span> wrapper<br>    <br>    <br><span class="hljs-comment"># 写法 A：原函数</span><br><span class="hljs-meta">@add_gift  </span><span class="hljs-comment"># &lt;--- 这就是装饰器语法，相当于给 buy_shoe 穿了层衣服</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_shoe</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一双球鞋&quot;</span>)<br><br><span class="hljs-meta">@add_gift</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_phone</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一台手机&quot;</span>)<br><br><span class="hljs-comment"># --- 运行测试 ---</span><br><br><span class="hljs-comment"># 当你调用 buy_shoe 时，其实你运行的是 wrapper！</span><br>buy_shoe()<br></code></pre></td></tr></table></figure>

<h2 id="带参数和返回值"><a href="#带参数和返回值" class="headerlink" title="带参数和返回值"></a>带参数和返回值</h2><p>例子虽然简单，但有两个致命的缺陷：</p>
<ol>
<li><strong>传参限制</strong>：如果原函数需要参数（比如 <code>buy_shoe(&quot;耐克&quot;)</code>），之前的 <code>wrapper()</code> 没定义参数，一调就报错。</li>
<li><strong>吞噬返回值</strong>：如果原函数有 <code>return</code>，之前的 <code>wrapper()</code> 没有把结果返回出来，导致外界拿到的是 <code>None</code>。</li>
</ol>
<p><strong>装饰器的内部函数格式要和被装饰的原函数 保持一致,即: 原函数是无参无返回的, 则装饰器的内部函数也必须是无参无返回的.原函数有参有返回的, 则装饰器的内部函数也必须是有参有返回的.</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-comment"># 1. 【万能参数】：*args, **kwargs</span><br>    <span class="hljs-comment"># 不管原函数传什么参数（一个、两个、关键字参数），我全都能接住</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 正在进行权限核对...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 2. 【调用原函数】并【接收返回值】</span><br>        <span class="hljs-comment"># 把刚才接住的参数，原封不动地传给原函数</span><br>        result = func(*args, **kwargs)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; [装饰器] 核对完毕，放行。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 3. 【返回结果】</span><br>        <span class="hljs-comment"># 这一步如果不写，外界拿到的就是 None</span><br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 A：有参数，无返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">food, drink</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在吃<span class="hljs-subst">&#123;food&#125;</span>，喝<span class="hljs-subst">&#123;drink&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 场景 B：有参数，有返回值</span><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_sum</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在努力计算中...&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 测试 eat (两个参数)</span><br>eat(<span class="hljs-string">&quot;火锅&quot;</span>, <span class="hljs-string">&quot;可乐&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在吃火锅，喝可乐</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 2. 测试 calculate_sum (有返回值)</span><br>res = calculate_sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算结果是: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 正在进行权限核对...</span><br><span class="hljs-comment"># 正在努力计算中...</span><br><span class="hljs-comment"># &gt;&gt;&gt; [装饰器] 核对完毕，放行。</span><br><span class="hljs-comment"># 计算结果是: 30  &lt;-- 如果 wrapper 没写 return，这里就是 None</span><br></code></pre></td></tr></table></figure>

<p><strong>args和kwargs<code>就像是一个弹性收纳袋，无论扔进来多少个参数，wrapper 都能收下，然后再原封不动地传递给</code>func</strong></p>
<p>万能公式 &#x3D; 闭包 + <code>*args/**kwargs</code> + <code>return</code></p>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>要在装饰器里传参数，需要在原本的装饰器外面，<strong>再包一层函数</strong>。</p>
<ul>
<li><strong>第一层 (最外面)</strong>：负责接收<strong>装饰器的参数</strong>（比如 “ERROR”）。管它叫“装饰器工厂”。</li>
<li><strong>第二层 (中间层)</strong>：负责接收<strong>被修饰的函数</strong>（<code>func</code>）。这才是真正的装饰器。</li>
<li><strong>第三层 (最里面)</strong>：负责接收<strong>函数的参数</strong>（<code>*args</code>）。这是具体的干活逻辑（Wrapper）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># --- 第一层：工厂层 (负责接收 level 参数) ---</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">level</span>):<br>    <br>    <span class="hljs-comment"># --- 第二层：装饰器层 (负责接收 func) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <br>        <span class="hljs-comment"># --- 第三层：Wrapper层 (负责接收 func 的参数) ---</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 正在启动功能...&quot;</span>) <span class="hljs-comment"># 这里用到了第一层的变量</span><br>            <br>            <span class="hljs-comment"># 调用原函数</span><br>            result = func(*args, **kwargs)<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;level&#125;</span>] 执行结束。&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <br>        <span class="hljs-keyword">return</span> wrapper <span class="hljs-comment"># 返回第三层</span><br>    <br>    <span class="hljs-keyword">return</span> decorator <span class="hljs-comment"># 返回第二层</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 场景 1：普通操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;INFO&quot;</span></span>) </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_page</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打开网页...&quot;</span>)<br><br><span class="hljs-comment"># 场景 2：危险操作</span><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&quot;DANGER&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删库跑路...&quot;</span>)<br><br><span class="hljs-comment"># --- 运行 ---</span><br>open_page()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [INFO] 正在启动功能...</span><br><span class="hljs-comment"># 打开网页...</span><br><br>delete_db()<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [DANGER] 正在启动功能...</span><br><span class="hljs-comment"># 删库跑路...</span><br></code></pre></td></tr></table></figure>

<p><strong>FastAPI</strong> 和 <strong>Django</strong> 中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)  </span><span class="hljs-comment"># 传了参数 &quot;/users&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(): ...<br></code></pre></td></tr></table></figure>

<p>这里 <code>@app.get</code> 就是一个带参数的装饰器，它记录了 URL 路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@permission_required(<span class="hljs-params"><span class="hljs-string">&quot;admin&quot;</span></span>) </span><span class="hljs-comment"># 传了参数 &quot;admin&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(): ...<br></code></pre></td></tr></table></figure>

<h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>用了装饰器后，原函数的名字（<code>__name__</code>）会变成 <code>wrapper</code>，这在调试时很不方便</p>
<p>先看没有 <code>wraps</code> 时会发生什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 见证“身份被窃” ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 函数的名字是: wrapper   &lt;-- 糟糕！原本叫 login，现在变成 wrapper 了</span><br><span class="hljs-comment"># 函数的说明是: None      &lt;-- 糟糕！原本写的注释说明也没了</span><br></code></pre></td></tr></table></figure>

<p><strong>为什么会这样？</strong> 因为 <code>login = my_decorator(login)</code>，现在的 <code>login</code> 变量实际上指向的是那个内部函数 <code>wrapper</code>。所以你打印的自然是 <code>wrapper</code> 的名字。</p>
<p>Python 标准库提供了一个神器 <code>@functools.wraps</code>。它的作用是：<strong>自动把原函数（func）的元数据（名字、注释文档等）拷贝给 wrapper。</strong></p>
<p>这就是所谓的“伪装”：让 wrapper 看起来跟原函数一模一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools  <span class="hljs-comment"># 1. 导入模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <br>    <span class="hljs-comment"># 2. 【关键】在定义 wrapper 之前，加上这行代码</span><br>    <span class="hljs-comment"># 意思是：把 func 的身份证信息贴到 wrapper 脑门上</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>) </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行装饰逻辑...&quot;</span>)<br>        func()<br>        <br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;这是登录系统的核心函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功！&quot;</span>)<br><br><span class="hljs-comment"># --- 再次查验身份 ---</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名字是: <span class="hljs-subst">&#123;login.__name__&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的说明是: <span class="hljs-subst">&#123;login.__doc__&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 函数的名字是: login</span><br><span class="hljs-comment"># 函数的说明是: 这是登录系统的核心函数</span><br></code></pre></td></tr></table></figure>

<p>为什么这很关键？</p>
<p>在简单的脚本里确实没关系，但在<strong>框架开发</strong>中这是致命的：</p>
<ol>
<li><strong>FastAPI &#x2F; Django 生成文档</strong>：<ul>
<li>FastAPI 会自动读取函数名和 docstring 来生成 Swagger 接口文档。</li>
<li>如果你用了装饰器但没加 <code>wraps</code>，FastAPI 看到的函数全叫 <code>wrapper</code>，文档里的接口说明也会全都变成空白。API 文档瞬间就废了。</li>
</ul>
</li>
<li><strong>自动化测试框架</strong>：<ul>
<li>在 Pytest 或 Unittest 中，测试报告通常会显示“正在执行 xxxx 用例”。</li>
<li>如果不加 <code>wraps</code>，测试报告里可能会显示“正在执行 wrapper”，根本不知道崩的是哪个用例。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h2><p>赋值操作（<code>=</code>）永远只是复制了对象的引用（内存地址），而没有复制对象本身,即仅仅是多了一个指向同一个内存地址的指针</p>
<img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image2.png" srcset="/img/loading.gif" lazyload class="" title="普通赋值">

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="浅拷贝可变类型"><a href="#浅拷贝可变类型" class="headerlink" title="浅拷贝可变类型"></a>浅拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image3.png" srcset="/img/loading.gif" lazyload class="" title="浅拷贝可变类型">

<p>可以清晰地看出，浅拷贝拷贝可变类型，只拷贝第一层</p>
<h3 id="浅拷贝不可变类型"><a href="#浅拷贝不可变类型" class="headerlink" title="浅拷贝不可变类型"></a>浅拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image4.png" srcset="/img/loading.gif" lazyload class="" title="浅拷贝不可变类型">

<p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），浅拷贝（copy）等同于赋值（&#x3D;），根本不会创建新对象！</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="深拷贝可变类型"><a href="#深拷贝可变类型" class="headerlink" title="深拷贝可变类型"></a>深拷贝可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image5.png" srcset="/img/loading.gif" lazyload class="" title="深拷贝可变类型">

<p>深拷贝拷贝可变类型，则会拷贝所有可变类型的层。</p>
<h3 id="深拷贝不可变类型"><a href="#深拷贝不可变类型" class="headerlink" title="深拷贝不可变类型"></a>深拷贝不可变类型</h3><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image6.png" srcset="/img/loading.gif" lazyload class="" title="深拷贝不可变类型">

<p>对于“不可变类型”（如元组 tuple、字符串 string、数字 number），深拷贝（deepcopy）等同于赋值（&#x3D;），根本不会创建新对象！</p>
<hr>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>简单来说，网络编程就是让<strong>两台计算机（或者同一台电脑上的两个程序）互相说话</strong>。网络编程其实就是：<strong>IP 定位电脑 + Port 定位程序 + TCP&#x2F;UDP 定位规则</strong>。</p>
<p>为了实现“说话”，必须解决三个核心问题：</p>
<ol>
<li><strong>找人</strong>：去哪里找对方？（IP 地址）</li>
<li><strong>找门</strong>：找到电脑后，跟哪个软件说话？（端口号 Port）</li>
<li><strong>怎么说</strong>：用什么规则交流？（协议 Protocol）</li>
</ol>
<hr>
<h3 id="1-找人：IP-地址-IP-Address"><a href="#1-找人：IP-地址-IP-Address" class="headerlink" title="1. 找人：IP 地址 (IP Address)"></a>1. 找人：IP 地址 (IP Address)</h3><p>IP 地址就是计算机在网络世界的**“门牌号”**。</p>
<ul>
<li><strong>公网 IP</strong>：比如百度的 IP，全世界都能访问。</li>
<li><strong>局域网 IP</strong>：比如 <code>192.168.1.5</code>，只有你家路由器下面的设备能互访。</li>
<li><strong>本机 IP</strong>：<code>127.0.0.1</code>（有个别名叫 <code>localhost</code>），特指“我自己”。做测试开发时先在本地部署服务，用的就是这个 IP。</li>
</ul>
<hr>
<h3 id="2-找门：端口号-Port"><a href="#2-找门：端口号-Port" class="headerlink" title="2. 找门：端口号 (Port)"></a>2. 找门：端口号 (Port)</h3><p>找到电脑（IP）后，电脑里运行着几十个程序（微信、QQ、浏览器、你的测试脚本）。消息发给谁呢？</p>
<p>这就需要端口号。它就像是这栋大楼里的**“房间号”**。</p>
<ul>
<li><strong>端口范围</strong>：0 - 65535。</li>
<li><strong>知名端口</strong>（不要去占用）：<ul>
<li><code>80</code>: 网页浏览 (HTTP)</li>
<li><code>443</code>: 加密网页 (HTTPS)</li>
<li><code>3306</code>: MySQL 数据库</li>
</ul>
</li>
<li><strong>动态端口</strong>：我们写程序时，一般使用 1024 之后的端口（比如 8000, 8080, 9999），避免和系统冲突。</li>
</ul>
<hr>
<h3 id="3-怎么说：通信协议-Protocol"><a href="#3-怎么说：通信协议-Protocol" class="headerlink" title="3. 怎么说：通信协议 (Protocol)"></a>3. 怎么说：通信协议 (Protocol)</h3><p>找到了人，也敲开了门，接下来怎么交流？</p>
<p>在传输层（Transport Layer），最著名的两位“大佬”是 TCP 和 UDP。它们的性格截然不同：</p>
<h4 id="A-TCP-协议-Transmission-Control-Protocol-——-“打电话”"><a href="#A-TCP-协议-Transmission-Control-Protocol-——-“打电话”" class="headerlink" title="A. TCP 协议 (Transmission Control Protocol) —— “打电话”"></a>A. TCP 协议 (Transmission Control Protocol) —— “打电话”</h4><ul>
<li><strong>性格</strong>：严谨、靠谱、慢热。</li>
<li><strong>特点</strong>：<strong>面向连接</strong>。<ul>
<li>在发数据前，必须先建立连接（著名的<strong>三次握手</strong>）。</li>
<li>发出去的数据，对方必须确认收到（ACK）。如果没收到，我会重发。</li>
<li>保证数据顺序不错乱。</li>
</ul>
</li>
<li><strong>应用</strong>：网页访问 (HTTP)、文件传输、邮件、接口自动化（绝大多数接口测试测的都是基于 TCP 的 HTTP）。</li>
</ul>
<h4 id="B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”"><a href="#B-UDP-协议-User-Datagram-Protocol-——-“发广播-寄信”" class="headerlink" title="B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”"></a>B. UDP 协议 (User Datagram Protocol) —— “发广播&#x2F;寄信”</h4><ul>
<li><strong>性格</strong>：豪爽、快、不负责任。</li>
<li><strong>特点</strong>：<strong>无连接</strong>。<ul>
<li>想发就发，不需要建立连接。</li>
<li>发出去就不管了，对方收没收到我不知道，也不重发。</li>
<li>可能会丢包，顺序可能会乱。</li>
</ul>
</li>
<li><strong>应用</strong>：视频会议、在线直播、王者荣耀（卡顿一下没关系，只要实时性高就行）。</li>
</ul>
<hr>
<h3 id="4-Python-的工具：socket"><a href="#4-Python-的工具：socket" class="headerlink" title="4. Python 的工具：socket"></a>4. Python 的工具：socket</h3><p>在 Python 中，实现网络编程主要靠 socket (套接字) 模块。</p>
<p>把 socket 想象成是一个**“电话机”**。</p>
<ul>
<li><strong>服务端 (Server)</strong>：<ol>
<li>买个电话 (创建 socket)。</li>
<li>插上电话线，绑定号码 (bind IP &amp; Port)。</li>
<li>守在电话旁等铃声 (listen)。</li>
<li>接电话 (accept)。</li>
<li>说话&#x2F;听话 (send&#x2F;recv)。</li>
</ol>
</li>
<li><strong>客户端 (Client)</strong>：<ol>
<li>买个电话 (创建 socket)。</li>
<li>拨号 (connect IP &amp; Port)。</li>
<li>说话&#x2F;听话 (send&#x2F;recv)。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image7.png" srcset="/img/loading.gif" lazyload class="" title="网络编程">

<p>这张图是 <strong>TCP 网络编程中最经典、最标准的核心流程图</strong>。</p>
<hr>
<h3 id="1-右侧：TCP-服务器-Server-——-“客服中心”"><a href="#1-右侧：TCP-服务器-Server-——-“客服中心”" class="headerlink" title="1. 右侧：TCP 服务器 (Server) —— “客服中心”"></a>1. 右侧：TCP 服务器 (Server) —— “客服中心”</h3><p>服务器必须先启动，坐在那儿等着被撩。</p>
<ol>
<li><strong>买个手机 (<code>socket()</code>)</strong><ul>
<li>首先需要有一个通信工具。在代码中就是创建一个套接字对象。</li>
</ul>
</li>
<li><strong>插卡&#x2F;定号码 (<code>bind(IP, 端口号)</code>)</strong><ul>
<li>手机买好了，你得告诉大家你的号码是多少（IP），以及大家打进来找哪个部门（端口号，比如 8080）。</li>
<li>如果不绑定，别人根本找不到你。</li>
</ul>
</li>
<li><strong>开机&#x2F;设置排队 (<code>listen(最大监听数)</code>)</strong><ul>
<li><strong>开机</strong>：让端口处于“监听状态”，准备接客。</li>
<li><strong>最大监听数</strong>：相当于客服系统的“排队上限”。如果同时有 100 个人打进来，但我设了 5，那第 6 个人就会听到“正在通话中”。</li>
</ul>
</li>
<li><strong>等待接听 (<code>accept()</code>) —— 关键步骤！</strong><ul>
<li>图中有个蓝字解释非常重要：<strong>“等待监听，会返回 1 个元组 (负责和客户端交互的 socket, 客户端信息)”</strong>。</li>
<li><strong>阻塞 (Blocking)</strong>：代码运行到这儿会<strong>停住</strong>（卡住），直到有电话打进来。</li>
<li><strong>分身术</strong>：这是新手最容易晕的地方。<code>accept</code> 收到请求后，会<strong>专门分配一个新的分身 socket</strong> 去跟这个客户一对一聊天。原来的主 socket 继续回到 <code>listen</code> 状态等下一个电话。</li>
</ul>
</li>
<li><strong>收发数据 (<code>recv() / send()</code>)</strong><ul>
<li>图中的箭头展示了数据的流向：服务器先接收请求，处理完后，再发送响应。</li>
</ul>
</li>
<li><strong>挂断 (<code>close()</code>)</strong><ul>
<li>聊完了，释放资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-左侧：TCP-客户端-Client-——-“打电话的人”"><a href="#2-左侧：TCP-客户端-Client-——-“打电话的人”" class="headerlink" title="2. 左侧：TCP 客户端 (Client) —— “打电话的人”"></a>2. 左侧：TCP 客户端 (Client) —— “打电话的人”</h3><p>客户端就比较主动了。</p>
<ol>
<li><strong>买个手机 (<code>socket()</code>)</strong><ul>
<li>同样先创建一个 socket 对象。</li>
</ul>
</li>
<li><strong>拨号 (<code>connect(IP, 端口号)</code>)</strong><ul>
<li><strong>三次握手</strong>：也就是图中间写的“连接建立”。</li>
<li>这一步如果成功，就说明电话通了；如果失败（比如服务器没开），程序就会直接报错 <code>ConnectionRefusedError</code>。</li>
</ul>
</li>
<li><strong>发收数据 (<code>send() / recv()</code>)</strong><ul>
<li>注意箭头方向：客户端通常是<strong>先说话</strong>（发送请求 <code>send</code>），然后<strong>等着听</strong>（接收响应 <code>recv</code>）。</li>
</ul>
</li>
<li><strong>挂断 (<code>close()</code>)</strong><ul>
<li>打完收工。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-图中的三个“隐藏细节”"><a href="#3-图中的三个“隐藏细节”" class="headerlink" title="3. 图中的三个“隐藏细节”"></a>3. 图中的三个“隐藏细节”</h3><p>这张图里有几行不起眼的小字，但这恰恰是写代码时最容易踩坑的地方：</p>
<ol>
<li><strong>“二进制传输” (绿色字)</strong><ul>
<li>网络不认识中文，也不认识字符串。</li>
<li><strong>潜台词</strong>：你在 Python 里 <code>send(&quot;你好&quot;)</code> 是会报错的！必须 <code>send(&quot;你好&quot;.encode(&quot;utf-8&quot;))</code>，把它变成 <code>bytes</code> 类型才能传。</li>
</ul>
</li>
<li><strong>“一直阻塞到客户连接到达”</strong><ul>
<li>这就是 <code>accept()</code> 的特性。如果没人连你，你的程序就会像死机一样停在那一行不动。</li>
</ul>
</li>
<li><strong>交互逻辑 (<code>send</code> 对 <code>recv</code>)</strong><ul>
<li>看图中间的横向箭头：<ul>
<li>客户端的 <code>send()</code> 数据流向 -&gt; 服务器的 <code>recv()</code>。</li>
<li>服务器的 <code>send()</code> 数据流向 -&gt; 客户端的 <code>recv()</code>。</li>
</ul>
</li>
<li>如果两边同时写 <code>recv()</code>，就会发生<strong>死锁</strong>（俩人都在等对方先说话，结果谁也不理谁）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这张图就是 TCP 代码的<strong>骨架</strong>。</p>
<ul>
<li><strong>Server</strong>: <code>socket</code> -&gt; <code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code> (循环) -&gt; <code>recv/send</code> -&gt; <code>close</code></li>
<li><strong>Client</strong>: <code>socket</code> -&gt; <code>connect</code> -&gt; <code>send/recv</code> -&gt; <code>close</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机 (创建 socket 对象)</span><br><span class="hljs-comment"># AF_INET: 使用 IPv4</span><br><span class="hljs-comment"># SOCK_STREAM: 使用 TCP 协议</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 插卡 (绑定 IP 和 端口)</span><br><span class="hljs-comment"># &#x27;127.0.0.1&#x27; 代表本机</span><br>server_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 开机 (监听)</span><br>server_socket.listen(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 客服中心已启动，正在等待客户电话...&quot;</span>)<br><br><span class="hljs-comment"># 4. 等待接听 (accept) -- 程序会卡在这里直到有人连接</span><br><span class="hljs-comment"># client_sock: 专门负责跟这个客户聊天的分身 socket</span><br><span class="hljs-comment"># addr: 客户的 IP 地址</span><br>client_sock, addr = server_socket.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&gt;&gt;&gt; 电话通了！客户地址: <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 接收消息 (recv) -- 对应图中的第一对 send/recv</span><br><span class="hljs-comment"># 注意：网络传输必须用 bytes，所以要 decode 解码</span><br>data = client_sock.recv(<span class="hljs-number">1024</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客户消息: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 6. 发送回复 (send) -- 对应图中的第二对 send/recv</span><br>msg = <span class="hljs-string">&quot;你好，我是客服小冰，很高兴为您服务！&quot;</span><br>client_sock.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 必须 encode 转成二进制</span><br><br><span class="hljs-comment"># 7. 挂断</span><br>client_sock.close()<br>server_socket.close()<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1. 买个手机</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2. 拨号 (连接服务器)</span><br><span class="hljs-comment"># 必须和服务器的 IP、端口一致</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>))<br><br><span class="hljs-comment"># 3. 先说话 (send)</span><br>msg = <span class="hljs-string">&quot;你好，我要查余额&quot;</span><br>client_socket.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment"># 4. 等回复 (recv)</span><br>data = client_socket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到客服回复: <span class="hljs-subst">&#123;data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 挂断</span><br>client_socket.close()<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="1-核心概念：进程-vs-线程"><a href="#1-核心概念：进程-vs-线程" class="headerlink" title="1. 核心概念：进程 vs 线程"></a>1. 核心概念：进程 vs 线程</h3><ul>
<li><strong>进程 (Process)</strong>：<ul>
<li><strong>定义</strong>：资源分配的最小单位。</li>
<li><strong>比喻</strong>：一个独立运行的 <code>.exe</code> 程序，比如 QQ</li>
<li><strong>特点</strong>：每个进程都有自己独立的内存空间，互不干扰。QQ 崩了，不会影响微信。</li>
<li><strong>开销</strong>：创建和销毁都很慢，像盖工厂一样费劲。</li>
</ul>
</li>
<li><strong>线程 (Thread)</strong>：<ul>
<li><strong>定义</strong>：CPU 调度的最小单位。</li>
<li><strong>比喻</strong>：<strong>工厂里的工人</strong>。</li>
<li><strong>特点</strong>：<ul>
<li>一个进程（工厂）里至少有一个线程（老板自己干活），也可以有多个线程（雇了 10 个工人）。</li>
<li><strong>共享资源</strong>：所有线程都在同一个工厂里，共用同一个食堂、同一个厕所（共享内存）。这就带来了“争抢资源”的问题</li>
</ul>
</li>
<li><strong>开销</strong>：创建非常快，像招个临时工一样简单。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-串行、并发、并行"><a href="#2-串行、并发、并行" class="headerlink" title="2. 串行、并发、并行"></a>2. 串行、并发、并行</h3><ul>
<li><strong>串行 (Serial)</strong>：<ul>
<li><strong>模式</strong>：一个一个来。</li>
<li><strong>例子</strong>：你去排队打饭，前一个人没打完，你只能干等。</li>
</ul>
</li>
<li><strong>并发 (Concurrency) —— Python 多线程主要属于这种</strong>：<ul>
<li><strong>模式</strong>：<strong>假装</strong>同时在做。其实是 CPU 切换得太快了，让你产生了错觉。</li>
<li><strong>例子</strong>：你一边吃饭一边回微信。其实你不能同时把饭送进嘴里又同时打字。你是“吃一口饭 -&gt; 放下筷子回两句 -&gt; 再吃一口”。因为切换速度极快，看起来像是同时进行的。</li>
</ul>
</li>
<li><strong>并行 (Parallelism)</strong>：<ul>
<li><strong>模式</strong>：<strong>真正</strong>同时在做。</li>
<li><strong>例子</strong>：你用左手拿勺子喝汤，你朋友坐在对面用右手拿筷子吃面。你俩互不干扰，真正的同时进行（这通常需要多核 CPU 支持）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Python-多线程的“阿喀琉斯之踵”：GIL-锁"><a href="#3-Python-多线程的“阿喀琉斯之踵”：GIL-锁" class="headerlink" title="3. Python 多线程的“阿喀琉斯之踵”：GIL 锁"></a>3. Python 多线程的“阿喀琉斯之踵”：GIL 锁</h3><p>在 Python 中谈多线程，必须得提 <strong>GIL (Global Interpreter Lock，全局解释器锁)</strong>。</p>
<ul>
<li><strong>现象</strong>：因为有 GIL 的存在，Python 的多线程在<strong>同一时刻，只能有一个线程在 CPU 上运行</strong>。</li>
<li><strong>后果</strong>：<ul>
<li>Python 的多线程是 <strong>“伪多线程”</strong>（针对 CPU 密集型任务）。哪怕你是 8 核 CPU，Python 多线程也只能用 1 个核。</li>
</ul>
</li>
<li><strong>那多线程还有用吗？</strong><ul>
<li><strong>非常有用！</strong> 但要分场景：</li>
<li><strong>计算密集型（CPU Bound）</strong>：比如视频解码、科学计算。<strong>（Python 多线程没用，反而更慢，因为要频繁切换）</strong>。</li>
<li><strong>IO 密集型（IO Bound）</strong>：比如 <strong>爬虫、接口请求、读写文件</strong>。<strong>（Python 多线程神器！）</strong><ul>
<li><strong>原因</strong>：当线程 A 去请求网络（IO 操作）时，它处于“等待”状态（不占 CPU），Python 会立刻释放 GIL 锁，让线程 B 赶紧去干活。这样就利用了等待的时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="多线程示例"><a href="#多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h2><img src="/2025/12/10/Python%E8%BF%9B%E9%98%B6/image8.png" srcset="/img/loading.gif" lazyload class="" title="多线程">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟网络延迟，耗时1秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_single</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 依次调用 5 次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        download(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>)<br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[单线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_single()<br>    <br>    <br><span class="hljs-comment"># 开始下载: 图片_1.jpg</span><br><span class="hljs-comment"># ... (等1秒)</span><br><span class="hljs-comment"># 下载完成: 图片_1.jpg</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># [单线程] 总耗时: 5.02 秒</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载完成: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_multi</span>():<br>    start_time = time.time()<br>    <br>    <span class="hljs-comment"># 用来存放所有线程对象的列表</span><br>    threads = []<br>    <br>    <span class="hljs-comment"># 1. 创建并启动线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># target: 指定要干什么活 (函数名)</span><br>        <span class="hljs-comment"># args: 指定参数 (注意必须是元组，如果是1个参数后面要加逗号)</span><br>        t = threading.Thread(target=download, args=(<span class="hljs-string">f&quot;图片_<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.jpg&quot;</span>,))<br>        <br>        <span class="hljs-comment"># 启动线程！(相当于告诉工人：开始干活！)</span><br>        t.start()<br>        <br>        <span class="hljs-comment"># 把工人的名字记下来</span><br>        threads.append(t)<br>        <br>    <span class="hljs-comment"># 2. 等待所有线程结束 (这一步至关重要！)</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join() <br>        <span class="hljs-comment"># join的意思是：主程序(老板)在这里等着，直到这个线程(工人)干完活才能往下走</span><br>        <br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[多线程] 总耗时: <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_multi()<br>    <br><span class="hljs-string">&quot;&quot;&quot;   </span><br><span class="hljs-string">开始下载: 图片_1.jpg</span><br><span class="hljs-string">开始下载: 图片_2.jpg</span><br><span class="hljs-string"><span class="hljs-meta">... </span>(几乎同时打印)</span><br><span class="hljs-string">下载完成: 图片_1.jpg</span><br><span class="hljs-string">...</span><br><span class="hljs-string">[多线程] 总耗时: 1.01 秒</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="A-t-start-vs-t-run"><a href="#A-t-start-vs-t-run" class="headerlink" title="A. t.start() vs t.run()"></a>A. <code>t.start()</code> vs <code>t.run()</code></h4><ul>
<li><strong><code>start()</code></strong>: <strong>正确写法</strong>。它会向操作系统申请一个新的线程，并在新线程里执行代码（真正的并发）。</li>
<li><strong><code>run()</code></strong>: <strong>错误写法</strong>。它只是把函数当普通函数调用了一遍，还在主线程里跑，根本没有多线程效果。</li>
</ul>
<h4 id="B-t-join-为什么要写？"><a href="#B-t-join-为什么要写？" class="headerlink" title="B. t.join() 为什么要写？"></a>B. <code>t.join()</code> 为什么要写？</h4><p>如果把 <code>join</code> 那段循环删掉，会发现程序会在 <strong>0.00秒</strong> 就打印“总耗时”，然后才慢慢打印“下载完成”。</p>
<ul>
<li><strong>原因</strong>：Python 的主线程（老板）启动完子线程（工人）后，默认是<strong>不等的</strong>。工人还在下载，老板已经把最后一句 <code>print(总耗时)</code> 执行完了。</li>
<li><strong>作用</strong>：<code>join()</code> 就像是设了一个<strong>关卡</strong>：“所有人都得在这儿集合！谁没干完，主程序就不准结束！”</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>使用原始的 <code>threading</code> 模块有两个大麻烦：</p>
<ol>
<li><strong>管理麻烦</strong>：如果有 1000 个任务，你不能真的启动 1000 个线程（CPU 切换会累死，内存会爆）。你需要控制<strong>最大并发数</strong>（比如只允许同时有 5 个人干活，后面的人排队）。</li>
<li><strong>拿结果麻烦</strong>：<code>threading.Thread</code> 很难获取函数的<strong>返回值</strong>。你不知道工人干得怎么样，只能靠改全局变量或用队列，很丑陋。</li>
</ol>
<p><strong>线程池完美解决了这两个问题。 核心模块：<code>concurrent.futures</code></strong></p>
<h4 id="实战代码-1：最常用的-submit-方式（灵活控制）"><a href="#实战代码-1：最常用的-submit-方式（灵活控制）" class="headerlink" title="实战代码 1：最常用的 submit 方式（灵活控制）"></a>实战代码 1：最常用的 <code>submit</code> 方式（灵活控制）</h4><p>这种方式适合：任务参数各不相同，或者你需要实时处理每个完成的任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 模拟一个有返回值的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">name, seconds</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;🔴 [开始] <span class="hljs-subst">&#123;name&#125;</span> 需要 <span class="hljs-subst">&#123;seconds&#125;</span>秒&quot;</span>)<br>    time.sleep(seconds)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;name&#125;</span> 下载成功！&quot;</span>  <span class="hljs-comment"># 这里有返回值！</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># max_workers=3: 也就是虽然我有 5 个任务，但公司只有 3 个工位</span><br>    <span class="hljs-comment"># 剩下 2 个任务得在外面排队，等有人干完了才能进</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 1. 提交任务 (submit)</span><br>        <span class="hljs-comment"># 这里的 task1, task2 是 &quot;未来对象&quot; (Future)，代表一个将来的结果</span><br>        all_tasks = [<br>            pool.submit(download, <span class="hljs-string">&quot;电影A&quot;</span>, <span class="hljs-number">2</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;图片B&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;小说C&quot;</span>, <span class="hljs-number">3</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;音乐D&quot;</span>, <span class="hljs-number">1</span>),<br>            pool.submit(download, <span class="hljs-string">&quot;文件E&quot;</span>, <span class="hljs-number">2</span>)<br>        ]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 任务已全部提交，正在排队执行中...\n&quot;</span>)<br><br>        <span class="hljs-comment"># 2. 获取结果 (as_completed)</span><br>        <span class="hljs-comment"># 谁先干完，谁先返回。不用傻傻地按顺序等。</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(all_tasks):<br>            result = future.result() <span class="hljs-comment"># 【关键】获取函数的返回值</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;收到结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>

<h4 id="实战代码-2：极简的-map-方式（批量处理）"><a href="#实战代码-2：极简的-map-方式（批量处理）" class="headerlink" title="实战代码 2：极简的 map 方式（批量处理）"></a>实战代码 2：极简的 <code>map</code> 方式（批量处理）</h4><p>这种方式适合：任务逻辑完全一样，只是参数不同（比如给 100 个 URL 列表发请求）。它的写法跟 Python 自带的 <code>map</code> 一模一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_url</span>(<span class="hljs-params">url</span>):<br>    time.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 模拟请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;url&#125;</span>] 状态码: 200&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main_map</span>():<br>    urls = [<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-string">&quot;www.google.com&quot;</span>, <span class="hljs-string">&quot;www.python.org&quot;</span>]<br>    <br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 一行代码搞定批量提交 + 结果按顺序返回</span><br>        <span class="hljs-comment"># 注意：这里的结果是严格按照 urls 列表的顺序返回的</span><br>        results = pool.<span class="hljs-built_in">map</span>(check_url, urls)<br>        <br>        <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> results:<br>            <span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main_map()<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul>
<li><strong>可迭代对象 (Iterable)</strong>：<ul>
<li><strong>含义</strong>：具有“被遍历能力”的数据。</li>
<li><strong>例子</strong>：<code>list</code>, <code>tuple</code>, <code>str</code>, <code>dict</code>。</li>
<li><strong>特征</strong>：内部实现了 <code>__iter__</code> 方法。它本身不记录位置，需要转化成迭代器才能用 <code>next()</code>。</li>
</ul>
</li>
<li><strong>迭代器 (Iterator)</strong>：<ul>
<li><strong>含义</strong>：正在执行遍历动作的那个“指针”。</li>
<li><strong>例子</strong>：<code>iter(list)</code> 后的结果。</li>
<li><strong>特征</strong>：同时实现了 <code>__iter__</code> 和 <strong><code>__next__</code></strong> 方法。</li>
</ul>
</li>
</ul>
<p><code>for x in [1, 2, 3]</code>，其实 Python 偷偷做了三件事：</p>
<ol>
<li>调用 <code>iter()</code> 把列表变成迭代器。</li>
<li>不断调用 <code>next()</code> 获取下一个值。</li>
<li>遇到 <code>StopIteration</code> 异常时，停止循环。</li>
</ol>
<p>手动模拟一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 这是一个可迭代对象 (Iterable)</span><br>my_list = [<span class="hljs-string">&quot;接口A&quot;</span>, <span class="hljs-string">&quot;接口B&quot;</span>, <span class="hljs-string">&quot;接口C&quot;</span>]<br><br><span class="hljs-comment"># ❌ 直接 next(my_list) 会报错，因为它还不是迭代器</span><br><br><span class="hljs-comment"># 2. 变成迭代器 (Iterator)</span><br><span class="hljs-comment"># 这一步相当于给薯片筒装上了弹簧，可以往外弹了</span><br>my_iterator = <span class="hljs-built_in">iter</span>(my_list)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;迭代器长这样: <span class="hljs-subst">&#123;my_iterator&#125;</span>&quot;</span>) <br><span class="hljs-comment"># &lt;list_iterator object at 0x...&gt;</span><br><br><span class="hljs-comment"># 3. 手动调用 next()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口A</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口B</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># 输出: 接口C</span><br><br><span class="hljs-comment"># 4. 再拿一次？</span><br><span class="hljs-comment"># print(next(my_iterator)) </span><br><span class="hljs-comment"># 报错！StopIteration (薯片吃完了)</span><br></code></pre></td></tr></table></figure>

<p>要在 Python 中创建一个自定义的迭代器类，需要实现两个魔术方法：</p>
<ul>
<li><code>__iter__(self)</code>: 返回自己。</li>
<li><code>__next__(self)</code>: 返回下一个数据，或者抛出 <code>StopIteration</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_num</span>):<br>        <span class="hljs-variable language_">self</span>.max_num = max_num<br>        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 1. 必须有这个，表明我是可迭代的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-comment"># 2. 必须有这个，定义“下一次”返回什么</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 只要没超标，就返回新账号</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current &lt;= <span class="hljs-variable language_">self</span>.max_num:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;User_<span class="hljs-subst">&#123;self.current&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 超标了，通知 for 循环停下来</span><br>            <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># --- 使用 ---</span><br><br><span class="hljs-comment"># 创建一个能生成 3 个账号的迭代器</span><br>users = UserGenerator(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 像用列表一样用它</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users:<br>    <span class="hljs-built_in">print</span>(u)<br><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># User_1</span><br><span class="hljs-comment"># User_2</span><br><span class="hljs-comment"># User_3</span><br></code></pre></td></tr></table></figure>

<p>假设有一个 1GB 的 CSV 文件，里面存了 <strong>100 万条</strong> 真实的交易数据，你要用这些数据来跑测试。</p>
<ul>
<li><strong>如果不通过迭代器（用 List）</strong>： <code>data = open(&quot;big_data.csv&quot;).readlines()</code> 这会瞬间把 100 万行数据全部加载到内存里，电脑可能会卡死（MemoryError）。</li>
<li><strong>如果使用迭代器</strong>： 写一个迭代器，每次只从文件里<strong>读取一行</strong>，测试完这一行，扔掉，再读下一行。 <strong>结果</strong>：不管文件有几百 GB，程序只占几 KB 的内存。这叫 <strong>“惰性求值” (Lazy Evaluation)</strong>。</li>
</ul>
<hr>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器 <strong>本质上就是一个迭代器</strong>。 但不需要写复杂的类，只需要写一个<strong>函数</strong>。</p>
<ul>
<li><strong>普通函数</strong>：用 <code>return</code> 返回结果。一旦 <code>return</code>，函数就结束了，内存也就释放了。</li>
<li><strong>生成器函数</strong>：用 <strong><code>yield</code></strong> 返回结果。<ul>
<li><strong>暂停</strong>：函数执行到 <code>yield</code> 时，会把结果交出去，然后<strong>暂停</strong>在这一行（像按了暂停键）。</li>
<li><strong>保留现场</strong>：函数内的变量、状态全都保留着，没死。</li>
<li><strong>恢复</strong>：下次你再调用 <code>next()</code> 时，它从刚才暂停的地方<strong>继续往下执行</strong>。</li>
</ul>
</li>
</ul>
<p>普通函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_list</span>():<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        result.append(<span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 必须全部做完才能返回</span><br><br><span class="hljs-comment"># 调用</span><br>plate = make_dumplings_list()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;端上来：<span class="hljs-subst">&#123;plate&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>生成器函数 (<code>yield</code>)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dumplings_gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;👨‍🍳 正在包第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子...&quot;</span>)<br>        <span class="hljs-comment"># 【关键】把饺子交出去，然后在这个位置暂停！</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">f&quot;饺子_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;   (第 <span class="hljs-subst">&#123;i&#125;</span> 个饺子被取走了...继续干活)&quot;</span>)<br><br><span class="hljs-comment"># 调用</span><br><span class="hljs-comment"># 注意：这一步并没有执行函数代码！只是创建了一个生成器对象</span><br>gen = make_dumplings_gen()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成器对象: <span class="hljs-subst">&#123;gen&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 开始吃 (手动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 我要吃第一个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师包第1个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 我要吃第二个&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 厨师从暂停处恢复 -&gt; 包第2个 -&gt; yield -&gt; 暂停</span><br><br><span class="hljs-comment"># --- 或者直接用 for 循环 (自动驱动) ---</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&gt;&gt;&gt; 剩下的我全包了&quot;</span>)<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(d)<br>    <br><span class="hljs-string">&quot;&quot;&quot;    </span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第一个</span><br><span class="hljs-string">👨‍🍳 正在包第 1 个饺子...</span><br><span class="hljs-string">饺子_1</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>我要吃第二个</span><br><span class="hljs-string">   (第 1 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 2 个饺子...</span><br><span class="hljs-string">饺子_2</span><br><span class="hljs-string"></span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>剩下的我全包了</span><br><span class="hljs-string">   (第 2 个饺子被取走了...继续干活)</span><br><span class="hljs-string">👨‍🍳 正在包第 3 个饺子...</span><br><span class="hljs-string">饺子_3</span><br><span class="hljs-string">   (第 3 个饺子被取走了...继续干活)</span><br></code></pre></td></tr></table></figure>

<p>写法2-生成器表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 列表推导式 (耗内存)</span><br>list_data = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(list_data) <br><span class="hljs-comment"># 输出: [0, 1, 4, 9, ..., 81] (内存里真的有10个数)</span><br><br><span class="hljs-comment"># 2. 生成器表达式 (省内存)</span><br>gen_data = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(gen_data)<br><span class="hljs-comment"># 输出: &lt;generator object ...&gt; (内存里只有一个公式，还没算呢)</span><br><br><span class="hljs-comment"># 想用的时候再算</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen_data)) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Property属性"><a href="#Property属性" class="headerlink" title="Property属性"></a>Property属性</h1><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, birth_year</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.birth_year = birth_year<br><br>    <span class="hljs-comment"># 【关键】加上 @property</span><br>    <span class="hljs-comment"># 把这个方法变成一个 &quot;只读属性&quot;</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        current_year = datetime.datetime.now().year<br>        <span class="hljs-keyword">return</span> current_year - <span class="hljs-variable language_">self</span>.birth_year<br><br>s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment"># 1. 像访问变量一样访问 age（注意：后面没有括号！）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;今年年龄: <span class="hljs-subst">&#123;s1.age&#125;</span>&quot;</span>) <br><br><span class="hljs-comment"># 2. 尝试修改它（会报错）</span><br><span class="hljs-comment"># s1.age = 18 </span><br><span class="hljs-comment"># 报错：AttributeError: can&#x27;t set attribute (因为我们只定义了 getter，没定义 setter)</span><br></code></pre></td></tr></table></figure>

<h2 id="读写控制"><a href="#读写控制" class="headerlink" title="读写控制"></a>读写控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这是一个私有变量，不对外公开</span><br>        <span class="hljs-variable language_">self</span>._score = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># --- 1. 定义 Getter (读) ---</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._score<br><br>    <span class="hljs-comment"># --- 2. 定义 Setter (写) ---</span><br>    <span class="hljs-comment"># 语法规则：@函数名.setter</span><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;❌ 错误：分数必须是整数！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 错误：分数 <span class="hljs-subst">&#123;value&#125;</span> 超出范围 (0-100)！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>            <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 分数 <span class="hljs-subst">&#123;value&#125;</span> 设置成功&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._score = value<br><br><span class="hljs-comment"># --- 测试 ---</span><br>s = Student()<br><br><span class="hljs-comment"># 正常赋值</span><br>s.score = <span class="hljs-number">90</span>  <span class="hljs-comment"># 自动触发 @score.setter 下的函数</span><br><span class="hljs-built_in">print</span>(s.score) <span class="hljs-comment"># 自动触发 @property 下的函数</span><br><br><span class="hljs-comment"># 异常赋值（会被 setter 里的逻辑拦截）</span><br>s.score = <span class="hljs-number">999</span> <br>s.score = <span class="hljs-string">&quot;不及格&quot;</span><br><br><span class="hljs-comment"># 再次查看，还是原来的 90，没被污染</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前真实分数: <span class="hljs-subst">&#123;s.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="基础语法速查表"><a href="#基础语法速查表" class="headerlink" title="基础语法速查表"></a>基础语法速查表</h3><p>认识几个“特殊符号”（元字符）：</p>
<h4 id="A-代表“字符”的符号"><a href="#A-代表“字符”的符号" class="headerlink" title="A. 代表“字符”的符号"></a>A. 代表“字符”的符号</h4><ul>
<li><strong><code>.</code> (点)</strong>：万能符。代表<strong>除了换行符以外的任意一个字符</strong>。</li>
<li><strong><code>\d</code></strong>：数字 (Digit)。等价于 <code>[0-9]</code>。</li>
<li><strong><code>\w</code></strong>：单词字符 (Word)。代表 <strong>数字、字母、下划线、中文</strong>（Python 3 中）。</li>
<li><strong><code>\s</code></strong>：空白符 (Space)。代表空格、Tab、换行。</li>
</ul>
<h4 id="B-代表“数量”的符号"><a href="#B-代表“数量”的符号" class="headerlink" title="B. 代表“数量”的符号"></a>B. 代表“数量”的符号</h4><ul>
<li><strong><code>*</code></strong>：0 次或多次（有没有都行，越多越好）。</li>
<li><strong><code>+</code></strong>：1 次或多次（至少得有一个）。</li>
<li><strong><code>?</code></strong>：0 次或 1 次（要么没有，要么有一个）。</li>
<li><strong><code>&#123;n&#125;</code></strong>：恰好 n 次。</li>
<li><strong><code>&#123;n, m&#125;</code></strong>：n 到 m 次。</li>
</ul>
<h4 id="C-代表“位置”的符号"><a href="#C-代表“位置”的符号" class="headerlink" title="C. 代表“位置”的符号"></a>C. 代表“位置”的符号</h4><ul>
<li><strong><code>^</code></strong>：必须以…开头。</li>
<li><strong><code>$</code></strong>：必须以…结尾。</li>
</ul>
<p>1：<code>re.findall()</code> —— 找到所有:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;张三的电话是 13811112222，李四的电话是 15933334444，还有一个座机 010-123456。&quot;</span><br><br><span class="hljs-comment"># 规则：1开头，后面接10个数字</span><br><span class="hljs-comment"># r&#x27;&#x27; 表示原生字符串，防止转义字符捣乱，写正则建议都要加 r</span><br>pattern = <span class="hljs-string">r&quot;1\d&#123;10&#125;&quot;</span><br><br>phones = re.findall(pattern, text)<br><span class="hljs-built_in">print</span>(phones)<br><span class="hljs-comment"># 输出: [&#x27;13811112222&#x27;, &#x27;15933334444&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>2：<code>re.search()</code> —— 找到第一个就收工 (最常用):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>html = <span class="hljs-string">&quot;&lt;div&gt;订单号: &lt;span id=&#x27;order&#x27;&gt;20231212001&lt;/span&gt;&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 规则：找数字，但我要更精确</span><br><span class="hljs-comment"># 使用括号 () 进行【分组提取】，这是做接口测试提取数据的核心！</span><br><span class="hljs-comment"># r&quot;(\d&#123;11&#125;)&quot; 意思是：找到11个数字，并把这11个数字单独拿出来</span><br>match_obj = re.search(<span class="hljs-string">r&quot;id=&#x27;order&#x27;&gt;(\d+)&lt;&quot;</span>, html)<br><br><span class="hljs-keyword">if</span> match_obj:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;匹配到的整体: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">0</span>)&#125;</span>&quot;</span>) <span class="hljs-comment"># id=&#x27;order&#x27;&gt;20231212001&lt;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取的目标: <span class="hljs-subst">&#123;match_obj.group(<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)   <span class="hljs-comment"># 20231212001 (我们通常只要这个)</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没找到&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>3：<code>re.sub()</code> —— 替换 (清洗数据):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;我给你转了￥100元，又转了$50元&quot;</span><br><br><span class="hljs-comment"># 把所有的货币符号去掉，只留数字</span><br><span class="hljs-comment"># [] 表示“其中任意一个”</span><br>new_text = re.sub(<span class="hljs-string">r&quot;[￥$元]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, text)<br><br><span class="hljs-built_in">print</span>(new_text) <br><span class="hljs-comment"># 输出: 我给你转了100，又转了50</span><br></code></pre></td></tr></table></figure>

<p>4:re.match()–只从字符串的第一个字符开始匹配:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello Python World&quot;</span><br>pattern = <span class="hljs-string">r&quot;Python&quot;</span><br><br><span class="hljs-comment"># --- 1. 使用 match (碰壁) ---</span><br><span class="hljs-comment"># match 看了看第一个单词 &quot;Hello&quot;，发现不是 &quot;Python&quot;，直接报错(返回None)</span><br>res_match = re.<span class="hljs-keyword">match</span>(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 结果: <span class="hljs-subst">&#123;res_match&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Match 结果: None</span><br><br><br><span class="hljs-comment"># --- 2. 使用 search (成功) ---</span><br><span class="hljs-comment"># search 很有耐心，跳过 Hello，在第 6 个位置找到了 Python</span><br>res_search = re.search(pattern, text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Search 结果: <span class="hljs-subst">&#123;res_search&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 输出: Search 结果: &lt;re.Match object; span=(6, 12), match=&#x27;Python&#x27;&gt;</span><br><br><br><span class="hljs-comment"># --- 3. 只有一种情况 match 能成功 ---</span><br><span class="hljs-comment"># 必须让 Python 出现在开头</span><br>text_2 = <span class="hljs-string">&quot;Python is good&quot;</span><br>res_match_2 = re.<span class="hljs-keyword">match</span>(pattern, text_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match 成功: <span class="hljs-subst">&#123;res_match_2&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: Match 成功: &lt;re.Match object...&gt;</span><br></code></pre></td></tr></table></figure>

<p>5:贪婪与非贪婪:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&quot;&lt;div&gt;第一个&lt;/div&gt;&lt;div&gt;第二个&lt;/div&gt;&quot;</span><br><br><span class="hljs-comment"># 1. 贪婪模式 (.*)</span><br><span class="hljs-comment"># 它会从第一个 &lt;div&gt; 一直吃到最后一个 &lt;/div&gt;，中间不管有多少闭合标签全吞了</span><br>res_greedy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;贪婪: <span class="hljs-subst">&#123;res_greedy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&lt;/div&gt;&lt;div&gt;第二个&#x27;]  &lt;-- 翻车了！</span><br><br><span class="hljs-comment"># 2. 非贪婪模式 (.*?)</span><br><span class="hljs-comment"># 遇到第一个 &lt;/div&gt; 它就觉得“够了”，停止匹配</span><br>res_lazy = re.findall(<span class="hljs-string">r&quot;&lt;div&gt;(.*?)&lt;/div&gt;&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;非贪婪: <span class="hljs-subst">&#123;res_lazy&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出: [&#x27;第一个&#x27;, &#x27;第二个&#x27;] &lt;-- 这才是我们要的</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Python 的 GC 机制是以【引用计数】为主，以【标记-清除】和【分代回收】为辅。</p>
<h2 id="引用计数-Reference-Counting"><a href="#引用计数-Reference-Counting" class="headerlink" title="引用计数 (Reference Counting)"></a>引用计数 (Reference Counting)</h2><p>这是 Python 内存管理最核心、最基础的机制。它像是一个**“计分器”**。</p>
<h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Python 中的每个对象（比如一个列表、一个数字）内部都有一个字段叫 <code>ob_refcnt</code>，记录着**“现在有多少个变量引用着我”**。</p>
<ul>
<li><strong>计数 +1 的情况</strong>：<ul>
<li>对象被创建：<code>a = [1, 2]</code> （计数&#x3D;1）</li>
<li>被赋值给别人：<code>b = a</code> （计数&#x3D;2）</li>
<li>作为参数传给函数：<code>func(a)</code> （计数+1，函数结束-1）</li>
<li>被放进容器里：<code>list_c = [a]</code> （计数+1）</li>
</ul>
</li>
<li><strong>计数 -1 的情况</strong>：<ul>
<li>变量被显式销毁：<code>del a</code></li>
<li>变量被赋予了新值：<code>a = &quot;hello&quot;</code> （原来的 <code>[1,2]</code> 计数-1）</li>
<li>离开作用域（函数运行结束）：局部变量会被自动销毁。</li>
</ul>
</li>
<li><strong>回收时刻</strong>：<ul>
<li>一旦某个对象的引用计数变成 <strong>0</strong>，Python 里的“收尸队”会<strong>立刻</strong>把它回收，释放内存。这是一种<strong>实时</strong>的回收机制。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 出生了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💀 <span class="hljs-subst">&#123;self.name&#125;</span> 被销毁了 (内存释放)&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 1. 创建对象（计数=1）</span><br>h1 = Hero(<span class="hljs-string">&quot;亚索&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <br><span class="hljs-comment"># 注意：sys.getrefcount() 会比实际多 1，因为它自己作为参数也引用了一次</span><br><br><span class="hljs-comment"># 2. 增加引用（计数+1）</span><br>h2 = h1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;引用计数: <span class="hljs-subst">&#123;sys.getrefcount(h1)&#125;</span>&quot;</span>) <span class="hljs-comment"># 现在有两个变量指着它</span><br><br><span class="hljs-comment"># 3. 删除其中一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h1...&quot;</span>)<br><span class="hljs-keyword">del</span> h1<br><span class="hljs-comment"># 此时 h2 还在，引用计数没归零，所以亚索还活着，不会打印 &quot;被销毁&quot;</span><br><br><span class="hljs-comment"># 4. 删除最后一个引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 删除 h2...&quot;</span>)<br><span class="hljs-keyword">del</span> h2<br><span class="hljs-comment"># 此时引用计数为 0，系统立刻触发回收，打印 &quot;被销毁&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 程序结束&quot;</span>)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">✅ 亚索 出生了</span><br><span class="hljs-string">引用计数: 2</span><br><span class="hljs-string">引用计数: 3</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h1...</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>删除 h2...</span><br><span class="hljs-string">💀 亚索 被销毁了 (内存释放)</span><br><span class="hljs-string"><span class="hljs-meta">&gt;&gt;&gt; </span>程序结束</span><br></code></pre></td></tr></table></figure>

<h4 id="致命缺点：循环引用-Circular-Reference"><a href="#致命缺点：循环引用-Circular-Reference" class="headerlink" title="致命缺点：循环引用 (Circular Reference)"></a>致命缺点：循环引用 (Circular Reference)</h4><p>引用计数非常快，但有一个死穴。请看下面这个经典的“互为舔狗”场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>]<br>b = [<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 互相引用</span><br>a.append(b) <span class="hljs-comment"># a 引用 b</span><br>b.append(a) <span class="hljs-comment"># b 引用 a</span><br><br><span class="hljs-comment"># 删除外部引用</span><br><span class="hljs-keyword">del</span> a<br><span class="hljs-keyword">del</span> b<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<ul>
<li>执行 <code>del a</code> 后，<code>[1]</code> 的计数从 2 减为 1（因为 <code>b</code> 还在引用它）。</li>
<li>执行 <code>del b</code> 后，<code>[2]</code> 的计数从 2 减为 1（因为 <code>a</code> 还在引用它）。</li>
<li><strong>死锁</strong>：外界已经谁也找不到这两个列表了，但它俩在内存里互相抓着对方，计数器永远不为 0。这就造成了<strong>内存泄漏</strong>。</li>
</ul>
<p><strong>为了解决这个问题，Python 引入了后面两把辅助斧头。</strong></p>
<hr>
<h2 id="标记-清除-Mark-and-Sweep"><a href="#标记-清除-Mark-and-Sweep" class="headerlink" title="标记-清除 (Mark and Sweep)"></a>标记-清除 (Mark and Sweep)</h2><p>这把斧头专门用来解决<strong>循环引用</strong>的问题。</p>
<p>它不再盯着计数器看，而是从更高的视角看**“连通性”**。</p>
<h4 id="1-原理（图论思想）"><a href="#1-原理（图论思想）" class="headerlink" title="1. 原理（图论思想）"></a>1. 原理（图论思想）</h4><p>Python 会把所有的对象看作图的节点，引用看作边。</p>
<ul>
<li><strong>Root (根节点)</strong>：全局变量、调用栈里的变量、寄存器。这些是绝对不能回收的“大人物”。</li>
</ul>
<h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h4><ol>
<li><strong>标记 (Mark)</strong>：GC 算法从“根节点”出发，沿着引用链往下走。凡是能走到的对象，都打上“<strong>存活</strong>”的标签。</li>
<li><strong>清除 (Sweep)</strong>：遍历所有对象，凡是<strong>没有</strong>被打上“存活”标签的（也就是那些与外界彻底失联的“孤岛”，比如刚才互为舔狗的那俩），统统干掉。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ <span class="hljs-subst">&#123;self.name&#125;</span> 准备好了&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;♻️ <span class="hljs-subst">&#123;self.name&#125;</span> 被 GC 回收了&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_cycle</span>():<br>    <span class="hljs-comment"># 1. 创建两个对象</span><br>    n1 = Node(<span class="hljs-string">&quot;节点A&quot;</span>)<br>    n2 = Node(<span class="hljs-string">&quot;节点B&quot;</span>)<br><br>    <span class="hljs-comment"># 2. 制造循环引用 (互为舔狗)</span><br>    n1.partner = n2 <span class="hljs-comment"># Python 允许在对象创建后的任何时间，给它身上贴任何新的属性标签。</span><br>    n2.partner = n1<br><br>    <span class="hljs-comment"># 3. 删除外部引用</span><br>    <span class="hljs-comment"># 按理说，函数结束，n1 和 n2 应该被销毁。</span><br>    <span class="hljs-comment"># 但因为它们互相拉着对方，引用计数不为 0，所以默认无法回收！</span><br>    <span class="hljs-keyword">del</span> n1<br>    <span class="hljs-keyword">del</span> n2<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 函数运行结束，外部引用已断开&quot;</span>)<br><br><span class="hljs-comment"># --- 测试 ---</span><br><br><span class="hljs-comment"># 为了演示效果，我们先关闭自动 GC，模拟引用计数解决不了的场景</span><br>gc.disable()<br><br>create_cycle()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 等待片刻 ---&quot;</span>)<br><span class="hljs-comment"># 此时你会发现，并没有打印 &quot;被 GC 回收了&quot;，说明内存泄漏了！</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; 手动触发 GC (标记-清除)...&quot;</span>)<br><span class="hljs-comment"># 手动召唤收尸队</span><br>collected_num = gc.collect()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;本次 GC 清理了 <span class="hljs-subst">&#123;collected_num&#125;</span> 个垃圾对象&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 程序彻底结束 ---&quot;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="分代回收-Generational-Collection"><a href="#分代回收-Generational-Collection" class="headerlink" title="分代回收 (Generational Collection)"></a>分代回收 (Generational Collection)</h2><p>标记-清除虽然能解决循环引用，但它要把所有对象扫描一遍，<strong>太慢了</strong>！ 为了不拖慢程序运行速度，Python 引入了**“分代回收”**（基于“空间换时间”的思想）。</p>
<h4 id="1-核心假设"><a href="#1-核心假设" class="headerlink" title="1. 核心假设"></a>1. 核心假设</h4><p><strong>“对象存活越久，它是垃圾的可能性越小。”</strong></p>
<ul>
<li>新创建的对象（比如循环里的临时变量）往往死得快。</li>
<li>老不死的对象（比如全局配置）往往会一直活下去。</li>
</ul>
<h4 id="2-三代人-0代-1代-2代"><a href="#2-三代人-0代-1代-2代" class="headerlink" title="2. 三代人 (0代, 1代, 2代)"></a>2. 三代人 (0代, 1代, 2代)</h4><p>Python 将所有的对象分为三代：</p>
<ul>
<li><strong>0代 (Generation 0)</strong>：新生代。所有新创建的对象都放这里。</li>
<li><strong>1代 (Generation 1)</strong>：中生代。</li>
<li><strong>2代 (Generation 2)</strong>：老年代。</li>
</ul>
<h4 id="3-回收逻辑"><a href="#3-回收逻辑" class="headerlink" title="3. 回收逻辑"></a>3. 回收逻辑</h4><ol>
<li><strong>扫描频率</strong>：0代扫描最勤快，1代次之，2代最懒。</li>
<li><strong>晋升机制</strong>：<ul>
<li>当 GC 扫描 0代列表时，发现有些对象居然还活着（没被回收），那就把它们<strong>移入 1代</strong>。</li>
<li>同理，如果在扫描 1代时对象还没死，就<strong>移入 2代</strong>。</li>
</ul>
</li>
<li><strong>触发阈值</strong>（了解即可）：<ul>
<li>当 0代对象数量达到一定阈值（默认 700 个），就会触发一次 0代 GC。</li>
<li>当 0代 GC 触发 10 次，才会触发一次 1代 GC。</li>
<li>当 1代 GC 触发 10 次，才会触发一次 2代 GC。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><span class="hljs-comment"># 获取当前的分代回收阈值</span><br>threshold = gc.get_threshold()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;700 表示：0代对象超过 700 个触发一次 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：0代 GC 触发 10 次，触发一次 1代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;10  表示：1代 GC 触发 10 次，触发一次 2代 GC&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前阈值: <span class="hljs-subst">&#123;threshold&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取当前每一代的垃圾数量</span><br><span class="hljs-comment"># 结果类似 (count0, count1, count2)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前各代垃圾数量: <span class="hljs-subst">&#123;gc.get_count()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="数据结构原理"><a href="#数据结构原理" class="headerlink" title="数据结构原理"></a>数据结构原理</h1><h3 id="1-列表-List-vs-元组-Tuple"><a href="#1-列表-List-vs-元组-Tuple" class="headerlink" title="1. 列表 (List) vs 元组 (Tuple)"></a>1. 列表 (List) vs 元组 (Tuple)</h3><p><strong>面试题</strong>：“List 和 Tuple 有什么区别？为什么 Python 要设计两个看似一样的东西？”</p>
<h4 id="核心区别："><a href="#核心区别：" class="headerlink" title="核心区别："></a>核心区别：</h4><ol>
<li><strong>可变性 (Mutability)</strong>：<ul>
<li><strong>List (<code>[]</code>)</strong>：<strong>可变的（Mutable）</strong>。<ul>
<li><strong>比喻</strong>：它就像一个**“背包”**。你可以随时往里塞东西、拿东西出来，甚至把里面的苹果换成香蕉。</li>
</ul>
</li>
<li><strong>Tuple (<code>()</code>)</strong>：<strong>不可变的（Immutable）</strong>。<ul>
<li><strong>比喻</strong>：它就像一个**“琥珀”<strong>或者</strong>“封死的快递箱”**。一旦出厂（创建），里面的东西就定死了。你想改？只能打碎了重新做一个。</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能 (Performance)</strong>：<ul>
<li><strong>Tuple 比 List 快</strong>。</li>
<li><strong>原因</strong>：<ul>
<li>Python 对 Tuple 做了<strong>内存缓存机制</strong>。当你创建一个 tuple 时，Python 知道它不会变，所以可以放心大胆地分配一段固定的内存，不需要像 List 那样预留额外的空间（为了 append）。</li>
<li>如果你的数据只读不改（比如配置参数、数据库查出来的结果），请无脑用 Tuple。</li>
</ul>
</li>
</ul>
</li>
<li><strong>作为字典的 Key</strong>：<ul>
<li><strong>Tuple 可以</strong>做字典的 Key（只要里面装的也是不可变元素）。</li>
<li><strong>List 不行</strong>（因为它是可变的，不可哈希）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-字典-Dict-的底层原理-——-哈希表-Hash-Table"><a href="#2-字典-Dict-的底层原理-——-哈希表-Hash-Table" class="headerlink" title="2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)"></a>2. 字典 (Dict) 的底层原理 —— 哈希表 (Hash Table)</h3><p><strong>面试题</strong>：“字典为什么查找速度这么快？底层是怎么实现的？”</p>
<p>这是 Python 面试中<strong>含金量最高</strong>的问题。</p>
<h4 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h4><p>字典查找是 <strong>O(1)</strong> 的时间复杂度（也就是<strong>秒查</strong>，不管字典里有 1 万个数据还是 1 亿个，查找速度几乎一样快）。</p>
<p><strong>比喻：超市储物柜</strong></p>
<ul>
<li><strong>Hash 函数</strong>：就是<strong>条形码扫描枪</strong>。</li>
<li><strong>Key</strong>：你手里的<strong>小票</strong>。</li>
<li><strong>Value</strong>：柜子里的<strong>包</strong>。</li>
</ul>
<p>当你想存东西（<code>dict[&quot;name&quot;] = &quot;亚索&quot;</code>）：</p>
<ol>
<li>Python 拿着 “name” 这个 Key，通过 <strong>哈希函数 (hash function)</strong> 算出一个数字（比如 10086）。</li>
<li>这个数字直接对应内存里的<strong>地址索引</strong>。</li>
<li>Python 直接把 “亚索” 扔进 10086 号柜子。</li>
</ol>
<p>当你想取东西（<code>dict[&quot;name&quot;]</code>）：</p>
<ol>
<li>Python 拿着 “name” 再算一次哈希值，算出 10086。</li>
<li>直接去 10086 号柜子拿数据。</li>
<li><strong>完全不需要遍历！</strong> 不需要一个个柜子打开看。</li>
</ol>
<h4 id="追问：哈希冲突-Hash-Collision"><a href="#追问：哈希冲突-Hash-Collision" class="headerlink" title="追问：哈希冲突 (Hash Collision)"></a>追问：哈希冲突 (Hash Collision)</h4><p><strong>面试题</strong>：“如果两个不同的 Key，算出来的哈希值一样（都要抢 10086 号柜子）怎么办？”</p>
<ul>
<li><strong>Java (HashMap)</strong>：采用**“链地址法”**。如果你来了发现 10086 有人了，你在 10086 后面挂个钩子，吊在下面（形成链表）。</li>
<li><strong>Python (Dict)</strong>：采用**“开放寻址法” (Open Addressing)**。<ul>
<li><strong>逻辑</strong>：如果你来了发现 10086 被占了，Python 会说：“别急，往后看！”</li>
<li>它会按照某种规则（比如看 10087、10088…）去找<strong>下一个空的柜子</strong>存进去。</li>
<li><em>注：Python 3.6+ 之后对字典进行了大量优化（变得有序且更省内存），但核心依然是哈希表。</em></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-列表-List-的底层-——-动态数组"><a href="#3-列表-List-的底层-——-动态数组" class="headerlink" title="3. 列表 (List) 的底层 —— 动态数组"></a>3. 列表 (List) 的底层 —— 动态数组</h3><p><strong>面试题</strong>：“List 是怎么实现动态扩容的？为什么 append 很快，insert 很慢？”</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Python 的 List 不是链表，而是<strong>连续的内存空间（数组）</strong>，里面存的是<strong>指针</strong>（指向具体的对象）。</p>
<ol>
<li><strong>为什么 append (尾部插入) 快？</strong><ul>
<li>List 在初始化时，会<strong>偷偷多申请一点内存</strong>。</li>
<li>比如你存 3 个数，它实际申请了 4 个坑位。当你 <code>append</code> 第 4 个数时，直接放进去就行，不需要找操作系统要内存。</li>
</ul>
</li>
<li><strong>动态扩容 (Resizing)</strong>：<ul>
<li>如果你 append 第 5 个数，坑位不够了怎么办？</li>
<li>Python 会直接申请一个<strong>更大的内存条</strong>（通常是原来的 1.125 倍左右），然后把旧数据<strong>统统复制过去</strong>，再把旧内存扔掉。</li>
<li>这就是为什么偶尔一次 append 会变慢的原因。</li>
</ul>
</li>
<li><strong>为什么 insert (中间插入) 慢？</strong><ul>
<li>如果你在 index&#x3D;0 的位置插入一个数据。</li>
<li>Python 必须把后面所有的数据<strong>全体起立，向后挪一个位置</strong>，给新来的腾地儿。</li>
<li>数据越多，挪动越慢。所以 List 极其不适合做“队列”使用。</li>
</ul>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Python/" class="category-chain-item">Python</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Python%E8%BF%9B%E9%98%B6/" class="print-no-link">#Python进阶</a>
      
        <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="print-no-link">#面向对象</a>
      
        <a href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/" class="print-no-link">#装饰器</a>
      
        <a href="/tags/%E6%8B%B7%E8%B4%9D/" class="print-no-link">#拷贝</a>
      
        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="print-no-link">#多线程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Python进阶</div>
      <div>https://lilpear2002.github.io/2025/12/10/Python进阶/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>测开求职者</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/10/selenium%E5%AD%A6%E4%B9%A0/" title="selenium学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">selenium学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/09/Python%E5%9F%BA%E7%A1%80/" title="Python基础">
                        <span class="hidden-mobile">Python基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
